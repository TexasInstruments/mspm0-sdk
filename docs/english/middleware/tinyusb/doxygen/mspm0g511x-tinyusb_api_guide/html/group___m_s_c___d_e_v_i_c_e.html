<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>MSPM0G511xTinyUSBLibrary: MSC_DEVICE</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MSPM0G511xTinyUSBLibrary
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MSC_DEVICE</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa8ea50e85f41afdbb7f5922e49c249cc"><td class="memItemLeft" align="right" valign="top"><a id="gaa8ea50e85f41afdbb7f5922e49c249cc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___d_e_v_i_c_e.html#gaa8ea50e85f41afdbb7f5922e49c249cc">TU_VERIFY_STATIC</a> (CFG_TUD_MSC_EP_BUFSIZE&lt; UINT16_MAX, &quot;Size is not correct&quot;)</td></tr>
<tr class="memdesc:gaa8ea50e85f41afdbb7f5922e49c249cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to confirm MSC EP buffer size is smaller than UINT16_MAX. <br /></td></tr>
<tr class="separator:gaa8ea50e85f41afdbb7f5922e49c249cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fe9764da024511a8593a3eeb957d1cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___d_e_v_i_c_e.html#ga4fe9764da024511a8593a3eeb957d1cb">tud_msc_set_sense</a> (uint8_t lun, uint8_t sense_key, uint8_t add_sense_code, uint8_t add_sense_qualifier)</td></tr>
<tr class="memdesc:ga4fe9764da024511a8593a3eeb957d1cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set SCSI sense data for error reporting.  <a href="#ga4fe9764da024511a8593a3eeb957d1cb">More...</a><br /></td></tr>
<tr class="separator:ga4fe9764da024511a8593a3eeb957d1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga148e0153ce23f6ffd6305fb0e0fc4dfd"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___d_e_v_i_c_e.html#ga148e0153ce23f6ffd6305fb0e0fc4dfd">tud_msc_read10_cb</a> (uint8_t lun, uint32_t lba, uint32_t offset, void *buffer, uint32_t bufsize)</td></tr>
<tr class="memdesc:ga148e0153ce23f6ffd6305fb0e0fc4dfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function for handling SCSI READ10 commands.  <a href="#ga148e0153ce23f6ffd6305fb0e0fc4dfd">More...</a><br /></td></tr>
<tr class="separator:ga148e0153ce23f6ffd6305fb0e0fc4dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga375a5cc4f5760603edf955765eca41a8"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___d_e_v_i_c_e.html#ga375a5cc4f5760603edf955765eca41a8">tud_msc_write10_cb</a> (uint8_t lun, uint32_t lba, uint32_t offset, uint8_t *buffer, uint32_t bufsize)</td></tr>
<tr class="memdesc:ga375a5cc4f5760603edf955765eca41a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function for handling SCSI WRITE10 commands.  <a href="#ga375a5cc4f5760603edf955765eca41a8">More...</a><br /></td></tr>
<tr class="separator:ga375a5cc4f5760603edf955765eca41a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2aefd1e5c3d470f440cd8f07dce9991"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___d_e_v_i_c_e.html#gae2aefd1e5c3d470f440cd8f07dce9991">tud_msc_inquiry_cb</a> (uint8_t lun, uint8_t vendor_id[8], uint8_t product_id[16], uint8_t product_rev[4])</td></tr>
<tr class="memdesc:gae2aefd1e5c3d470f440cd8f07dce9991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function for handling SCSI INQUIRY commands.  <a href="#gae2aefd1e5c3d470f440cd8f07dce9991">More...</a><br /></td></tr>
<tr class="separator:gae2aefd1e5c3d470f440cd8f07dce9991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbb293c273679cadfae2b360ccd5e437"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___d_e_v_i_c_e.html#gabbb293c273679cadfae2b360ccd5e437">tud_msc_test_unit_ready_cb</a> (uint8_t lun)</td></tr>
<tr class="memdesc:gabbb293c273679cadfae2b360ccd5e437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function for handling SCSI TEST UNIT READY commands.  <a href="#gabbb293c273679cadfae2b360ccd5e437">More...</a><br /></td></tr>
<tr class="separator:gabbb293c273679cadfae2b360ccd5e437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac721126f20ec8c7358cc89ba971f6065"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___d_e_v_i_c_e.html#gac721126f20ec8c7358cc89ba971f6065">tud_msc_capacity_cb</a> (uint8_t lun, uint32_t *block_count, uint16_t *block_size)</td></tr>
<tr class="memdesc:gac721126f20ec8c7358cc89ba971f6065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function for determining disk capacity.  <a href="#gac721126f20ec8c7358cc89ba971f6065">More...</a><br /></td></tr>
<tr class="separator:gac721126f20ec8c7358cc89ba971f6065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f5dcb9aacaba9e9932f2c941d4639e3"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___d_e_v_i_c_e.html#ga8f5dcb9aacaba9e9932f2c941d4639e3">tud_msc_scsi_cb</a> (uint8_t lun, uint8_t const scsi_cmd[16], void *buffer, uint16_t bufsize)</td></tr>
<tr class="memdesc:ga8f5dcb9aacaba9e9932f2c941d4639e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked when received an SCSI command not in built-in list below.  <a href="#ga8f5dcb9aacaba9e9932f2c941d4639e3">More...</a><br /></td></tr>
<tr class="separator:ga8f5dcb9aacaba9e9932f2c941d4639e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab35b143912036b41c18fa29c486e0c3a"><td class="memItemLeft" align="right" valign="top">TU_ATTR_WEAK uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___d_e_v_i_c_e.html#gab35b143912036b41c18fa29c486e0c3a">tud_msc_get_maxlun_cb</a> (void)</td></tr>
<tr class="memdesc:gab35b143912036b41c18fa29c486e0c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function to get the maximum logical unit number (LUN)  <a href="#gab35b143912036b41c18fa29c486e0c3a">More...</a><br /></td></tr>
<tr class="separator:gab35b143912036b41c18fa29c486e0c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadcddfc7c9e78af14d9350829d53e07a"><td class="memItemLeft" align="right" valign="top">TU_ATTR_WEAK bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___d_e_v_i_c_e.html#gaadcddfc7c9e78af14d9350829d53e07a">tud_msc_start_stop_cb</a> (uint8_t lun, uint8_t power_condition, bool start, bool load_eject)</td></tr>
<tr class="memdesc:gaadcddfc7c9e78af14d9350829d53e07a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function for handling SCSI START STOP UNIT command.  <a href="#gaadcddfc7c9e78af14d9350829d53e07a">More...</a><br /></td></tr>
<tr class="separator:gaadcddfc7c9e78af14d9350829d53e07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9f0192d756de6c450756db9ac9edb8d"><td class="memItemLeft" align="right" valign="top">TU_ATTR_WEAK bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___d_e_v_i_c_e.html#gae9f0192d756de6c450756db9ac9edb8d">tud_msc_prevent_allow_medium_removal_cb</a> (uint8_t lun, uint8_t prohibit_removal, uint8_t control)</td></tr>
<tr class="memdesc:gae9f0192d756de6c450756db9ac9edb8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function for handling SCSI PREVENT ALLOW MEDIUM REMOVAL command.  <a href="#gae9f0192d756de6c450756db9ac9edb8d">More...</a><br /></td></tr>
<tr class="separator:gae9f0192d756de6c450756db9ac9edb8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga751b530ef36a86aca1267ea5210c9bf1"><td class="memItemLeft" align="right" valign="top">TU_ATTR_WEAK int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___d_e_v_i_c_e.html#ga751b530ef36a86aca1267ea5210c9bf1">tud_msc_request_sense_cb</a> (uint8_t lun, void *buffer, uint16_t bufsize)</td></tr>
<tr class="memdesc:ga751b530ef36a86aca1267ea5210c9bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function for handling SCSI REQUEST SENSE command.  <a href="#ga751b530ef36a86aca1267ea5210c9bf1">More...</a><br /></td></tr>
<tr class="separator:ga751b530ef36a86aca1267ea5210c9bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga605c7bc2eb5598adb94926142bf82886"><td class="memItemLeft" align="right" valign="top">TU_ATTR_WEAK void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___d_e_v_i_c_e.html#ga605c7bc2eb5598adb94926142bf82886">tud_msc_read10_complete_cb</a> (uint8_t lun)</td></tr>
<tr class="memdesc:ga605c7bc2eb5598adb94926142bf82886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function invoked when a SCSI READ10 command is complete.  <a href="#ga605c7bc2eb5598adb94926142bf82886">More...</a><br /></td></tr>
<tr class="separator:ga605c7bc2eb5598adb94926142bf82886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa447be8f95fca29834f797bdf65ad1e"><td class="memItemLeft" align="right" valign="top">TU_ATTR_WEAK void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___d_e_v_i_c_e.html#gaaa447be8f95fca29834f797bdf65ad1e">tud_msc_write10_complete_cb</a> (uint8_t lun)</td></tr>
<tr class="memdesc:gaaa447be8f95fca29834f797bdf65ad1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function invoked when a SCSI WRITE10 command is complete.  <a href="#gaaa447be8f95fca29834f797bdf65ad1e">More...</a><br /></td></tr>
<tr class="separator:gaaa447be8f95fca29834f797bdf65ad1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb76cc0118eeb65b5582d81401ebade6"><td class="memItemLeft" align="right" valign="top">TU_ATTR_WEAK void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___d_e_v_i_c_e.html#gacb76cc0118eeb65b5582d81401ebade6">tud_msc_scsi_complete_cb</a> (uint8_t lun, uint8_t const scsi_cmd[16])</td></tr>
<tr class="memdesc:gacb76cc0118eeb65b5582d81401ebade6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function invoked when a SCSI command has completed processing.  <a href="#gacb76cc0118eeb65b5582d81401ebade6">More...</a><br /></td></tr>
<tr class="separator:gacb76cc0118eeb65b5582d81401ebade6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59855b3113a2cb20b9f0b0d9cc2ca7d1"><td class="memItemLeft" align="right" valign="top">TU_ATTR_WEAK bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___d_e_v_i_c_e.html#ga59855b3113a2cb20b9f0b0d9cc2ca7d1">tud_msc_is_writable_cb</a> (uint8_t lun)</td></tr>
<tr class="memdesc:ga59855b3113a2cb20b9f0b0d9cc2ca7d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function to determine if the storage device is writable.  <a href="#ga59855b3113a2cb20b9f0b0d9cc2ca7d1">More...</a><br /></td></tr>
<tr class="separator:ga59855b3113a2cb20b9f0b0d9cc2ca7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf4981315a4d70a7057edd4064fd90ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___d_e_v_i_c_e.html#gaaf4981315a4d70a7057edd4064fd90ce">mscd_init</a> (void)</td></tr>
<tr class="memdesc:gaaf4981315a4d70a7057edd4064fd90ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the Mass Storage Class Device driver.  <a href="#gaaf4981315a4d70a7057edd4064fd90ce">More...</a><br /></td></tr>
<tr class="separator:gaaf4981315a4d70a7057edd4064fd90ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70d56238db44bce4d77c8297211e7e27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___d_e_v_i_c_e.html#ga70d56238db44bce4d77c8297211e7e27">mscd_deinit</a> (void)</td></tr>
<tr class="memdesc:ga70d56238db44bce4d77c8297211e7e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinitialize the Mass Storage Class Device driver.  <a href="#ga70d56238db44bce4d77c8297211e7e27">More...</a><br /></td></tr>
<tr class="separator:ga70d56238db44bce4d77c8297211e7e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b8d7cd18e5e49f3378e1f5bdd7bf196"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___d_e_v_i_c_e.html#ga2b8d7cd18e5e49f3378e1f5bdd7bf196">mscd_reset</a> (uint8_t rhport)</td></tr>
<tr class="memdesc:ga2b8d7cd18e5e49f3378e1f5bdd7bf196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the Mass Storage Class Device driver state.  <a href="#ga2b8d7cd18e5e49f3378e1f5bdd7bf196">More...</a><br /></td></tr>
<tr class="separator:ga2b8d7cd18e5e49f3378e1f5bdd7bf196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88c3deff8b6784aa3c5b273c3f34deb0"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___d_e_v_i_c_e.html#ga88c3deff8b6784aa3c5b273c3f34deb0">mscd_open</a> (uint8_t rhport, tusb_desc_interface_t const *itf_desc, uint16_t max_len)</td></tr>
<tr class="memdesc:ga88c3deff8b6784aa3c5b273c3f34deb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a Mass Storage Class interface.  <a href="#ga88c3deff8b6784aa3c5b273c3f34deb0">More...</a><br /></td></tr>
<tr class="separator:ga88c3deff8b6784aa3c5b273c3f34deb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc18d9c97fcbd636c71dab72302fa6b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___d_e_v_i_c_e.html#gadc18d9c97fcbd636c71dab72302fa6b3">mscd_control_xfer_cb</a> (uint8_t rhport, uint8_t stage, tusb_control_request_t const *p_request)</td></tr>
<tr class="memdesc:gadc18d9c97fcbd636c71dab72302fa6b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process control transfers for Mass Storage Class.  <a href="#gadc18d9c97fcbd636c71dab72302fa6b3">More...</a><br /></td></tr>
<tr class="separator:gadc18d9c97fcbd636c71dab72302fa6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a30469f504fc9d9add41321908d4988"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___d_e_v_i_c_e.html#ga0a30469f504fc9d9add41321908d4988">mscd_xfer_cb</a> (uint8_t rhport, uint8_t ep_addr, xfer_result_t event, uint32_t xferred_bytes)</td></tr>
<tr class="memdesc:ga0a30469f504fc9d9add41321908d4988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer callback for Mass Storage Class device.  <a href="#ga0a30469f504fc9d9add41321908d4988">More...</a><br /></td></tr>
<tr class="separator:ga0a30469f504fc9d9add41321908d4988"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga4fe9764da024511a8593a3eeb957d1cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fe9764da024511a8593a3eeb957d1cb">&sect;&nbsp;</a></span>tud_msc_set_sense()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tud_msc_set_sense </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>lun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sense_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>add_sense_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>add_sense_qualifier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set SCSI sense data for error reporting. </p>
<p>This function sets the SCSI sense data that will be returned to the host when a REQUEST SENSE command is received. It should be called by the application when an error occurs during command processing to provide detailed error information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lun</td><td>Logical Unit Number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sense_key</td><td>SCSI sense key (e.g., SCSI_SENSE_NOT_READY, SCSI_SENSE_ILLEGAL_REQUEST) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">add_sense_code</td><td>Additional sense code providing more specific error information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">add_sense_qualifier</td><td>Additional sense code qualifier for even more specific error information</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true (always succeeds) </dd></dl>

</div>
</div>
<a id="ga148e0153ce23f6ffd6305fb0e0fc4dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga148e0153ce23f6ffd6305fb0e0fc4dfd">&sect;&nbsp;</a></span>tud_msc_read10_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t tud_msc_read10_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>lun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bufsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function for handling SCSI READ10 commands. </p>
<p>This function is invoked when a SCSI READ10 command is received from the host. The application should fill the provided buffer with data from the specified address (LBA + offset) and return the number of bytes read.</p>
<p>The address is calculated as: lba * BLOCK_SIZE + offset Note that offset is only needed if CFG_TUD_MSC_EP_BUFSIZE is smaller than BLOCK_SIZE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lun</td><td>Logical Unit Number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lba</td><td>Logical Block Address to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Byte offset into the block </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>Buffer to fill with read data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufsize</td><td>Size of the buffer in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes read into the buffer (positive), 0 if application is not ready (callback will be invoked again), negative value if error occurred (request will be stalled) </dd></dl>

</div>
</div>
<a id="ga375a5cc4f5760603edf955765eca41a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga375a5cc4f5760603edf955765eca41a8">&sect;&nbsp;</a></span>tud_msc_write10_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t tud_msc_write10_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>lun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bufsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function for handling SCSI WRITE10 commands. </p>
<p>This function is invoked when a SCSI WRITE10 command is received from the host. The application should write the data from the provided buffer to the specified address (LBA + offset) and return the number of bytes written.</p>
<p>The address is calculated as: lba * BLOCK_SIZE + offset Note that offset is only needed if CFG_TUD_MSC_EP_BUFSIZE is smaller than BLOCK_SIZE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lun</td><td>Logical Unit Number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lba</td><td>Logical Block Address to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Byte offset into the block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Buffer containing data to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufsize</td><td>Size of the buffer in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes written (positive), 0 if application is not ready (callback will be invoked again), negative value if error occurred (request will be STALLed) </dd></dl>

</div>
</div>
<a id="gae2aefd1e5c3d470f440cd8f07dce9991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2aefd1e5c3d470f440cd8f07dce9991">&sect;&nbsp;</a></span>tud_msc_inquiry_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tud_msc_inquiry_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>lun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>vendor_id</em>[8], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>product_id</em>[16], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>product_rev</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function for handling SCSI INQUIRY commands. </p>
<p>This function is invoked when a SCSI INQUIRY command is received from the host. The application should fill the vendor ID, product ID, and product revision arrays with appropriate identification strings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lun</td><td>Logical Unit Number </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vendor_id</td><td>Buffer to fill with vendor identification (up to 8 characters) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">product_id</td><td>Buffer to fill with product identification (up to 16 characters) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">product_rev</td><td>Buffer to fill with product revision (up to 4 characters) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabbb293c273679cadfae2b360ccd5e437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbb293c273679cadfae2b360ccd5e437">&sect;&nbsp;</a></span>tud_msc_test_unit_ready_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tud_msc_test_unit_ready_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>lun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function for handling SCSI TEST UNIT READY commands. </p>
<p>This function is invoked when a SCSI TEST UNIT READY command is received from the host. The application should check if the device is ready to accept read/write commands.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lun</td><td>Logical Unit Number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the device is ready </dd>
<dd>
false If the device is not ready (will lead to a SCSI sense with "Not Ready") </dd></dl>

</div>
</div>
<a id="gac721126f20ec8c7358cc89ba971f6065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac721126f20ec8c7358cc89ba971f6065">&sect;&nbsp;</a></span>tud_msc_capacity_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tud_msc_capacity_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>lun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>block_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>block_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function for determining disk capacity. </p>
<p>This function is invoked when a SCSI_CMD_READ_CAPACITY_10 or SCSI_CMD_READ_FORMAT_CAPACITY command is received from the host. The application should update the block count and block size parameters to reflect the storage device's capacity.</p>
<p>For example, in an SD card implementation, this would return the total number of blocks and the block size (typically 512 bytes) of the SD card.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lun</td><td>Logical Unit Number </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">block_count</td><td>Pointer to store the total number of addressable blocks </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">block_size</td><td>Pointer to store the size of each block in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8f5dcb9aacaba9e9932f2c941d4639e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f5dcb9aacaba9e9932f2c941d4639e3">&sect;&nbsp;</a></span>tud_msc_scsi_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t tud_msc_scsi_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>lun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const&#160;</td>
          <td class="paramname"><em>scsi_cmd</em>[16], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>bufsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoked when received an SCSI command not in built-in list below. </p>
<ul>
<li>READ_CAPACITY10, READ_FORMAT_CAPACITY, INQUIRY, TEST_UNIT_READY, START_STOP_UNIT, MODE_SENSE6, REQUEST_SENSE</li>
<li>READ10 and WRITE10 has their own callbacks</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lun</td><td>Logical unit number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scsi_cmd</td><td>SCSI command contents which application must examine to response accordingly </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>Buffer for SCSI Data Stage.<ul>
<li>For INPUT: application must fill this with response.</li>
<li>For OUTPUT it holds the Data from host </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufsize</td><td>Buffer's length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Actual bytes processed, can be zero for no-data command. </dd>
<dd>
negative Indicate error e.g unsupported command, tinyusb will <b>STALL</b> the corresponding endpoint and return failed status in command status wrapper phase. </dd></dl>

</div>
</div>
<a id="gab35b143912036b41c18fa29c486e0c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab35b143912036b41c18fa29c486e0c3a">&sect;&nbsp;</a></span>tud_msc_get_maxlun_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TU_ATTR_WEAK uint8_t tud_msc_get_maxlun_cb </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function to get the maximum logical unit number (LUN) </p>
<p>This function is invoked during MSC enumeration to determine the number of logical units supported by the device. For example, a device with multiple storage partitions or multiple physical storage devices (like SD cards) might expose each as a separate LUN.</p>
<p>Most implementations with a single storage device will return 0.</p>
<dl class="section return"><dt>Returns</dt><dd>The maximum LUN value (number of LUNs - 1) </dd></dl>

</div>
</div>
<a id="gaadcddfc7c9e78af14d9350829d53e07a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadcddfc7c9e78af14d9350829d53e07a">&sect;&nbsp;</a></span>tud_msc_start_stop_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TU_ATTR_WEAK bool tud_msc_start_stop_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>lun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>power_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>load_eject</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function for handling SCSI START STOP UNIT command. </p>
<p>This function is invoked when a SCSI START STOP UNIT command is received from the host. The command is used to spin up/down the media or eject/load the media.</p>
<p>In an SD card implementation, this could be used to safely unmount the file system when the host requests media ejection, preventing data corruption.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lun</td><td>Logical Unit Number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">power_condition</td><td>Power condition field from the command </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>Start bit (1 = start, 0 = stop) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">load_eject</td><td>Load/Eject operation (1 = load, 0 = eject)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the command is handled successfully </dd>
<dd>
false If the command failed </dd></dl>

</div>
</div>
<a id="gae9f0192d756de6c450756db9ac9edb8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9f0192d756de6c450756db9ac9edb8d">&sect;&nbsp;</a></span>tud_msc_prevent_allow_medium_removal_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TU_ATTR_WEAK bool tud_msc_prevent_allow_medium_removal_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>lun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>prohibit_removal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>control</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function for handling SCSI PREVENT ALLOW MEDIUM REMOVAL command. </p>
<p>This function is invoked when a SCSI PREVENT ALLOW MEDIUM REMOVAL command is received from the host. The command is used to mechanically lock/unlock the storage media to prevent or allow its removal.</p>
<p>In an SD card implementation, this could be used to indicate to the application whether it should allow the user to physically remove the SD card. Some applications might use an LED indicator or other mechanism to signal when it's safe to remove the media.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lun</td><td>Logical Unit Number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prohibit_removal</td><td>Prohibit removal flag (1 = prevent removal, 0 = allow removal) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">control</td><td>Control field from the SCSI command</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the command is handled successfully </dd>
<dd>
false If the command failed </dd></dl>

</div>
</div>
<a id="ga751b530ef36a86aca1267ea5210c9bf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga751b530ef36a86aca1267ea5210c9bf1">&sect;&nbsp;</a></span>tud_msc_request_sense_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TU_ATTR_WEAK int32_t tud_msc_request_sense_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>lun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>bufsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function for handling SCSI REQUEST SENSE command. </p>
<p>This function is invoked when a SCSI REQUEST SENSE command is received from the host. It allows the application to provide detailed error information when a previous command has failed. The application should fill the provided buffer with appropriate sense data.</p>
<p>In an SD card implementation, this could provide specific information about card access errors, write protection status, or other media-specific issues.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lun</td><td>Logical Unit Number </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>Buffer to fill with sense data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufsize</td><td>Maximum size of the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes written to the buffer (positive), or negative value to indicate error </dd></dl>

</div>
</div>
<a id="ga605c7bc2eb5598adb94926142bf82886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga605c7bc2eb5598adb94926142bf82886">&sect;&nbsp;</a></span>tud_msc_read10_complete_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TU_ATTR_WEAK void tud_msc_read10_complete_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>lun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function invoked when a SCSI READ10 command is complete. </p>
<p>This function is called after a READ10 operation has completed successfully. It can be used to perform post-read operations such as updating internal state, releasing resources, or performing additional processing after data has been transferred to the host.</p>
<p>In an SD card implementation, this could be used to update access statistics, manage power states after read operations, or prepare for subsequent operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lun</td><td>Logical Unit Number that completed the read operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaa447be8f95fca29834f797bdf65ad1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa447be8f95fca29834f797bdf65ad1e">&sect;&nbsp;</a></span>tud_msc_write10_complete_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TU_ATTR_WEAK void tud_msc_write10_complete_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>lun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function invoked when a SCSI WRITE10 command is complete. </p>
<p>This function is called after a WRITE10 operation has completed successfully. It can be used to perform post-write operations such as flushing cached data, updating internal state, or performing additional processing after data has been received from the host.</p>
<p>In an SD card or flash memory implementation, this is particularly useful for flushing write caches, completing deferred writes, or updating file system structures after data has been written to storage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lun</td><td>Logical Unit Number that completed the write operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacb76cc0118eeb65b5582d81401ebade6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb76cc0118eeb65b5582d81401ebade6">&sect;&nbsp;</a></span>tud_msc_scsi_complete_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TU_ATTR_WEAK void tud_msc_scsi_complete_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>lun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const&#160;</td>
          <td class="paramname"><em>scsi_cmd</em>[16]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function invoked when a SCSI command has completed processing. </p>
<p>This function is called after a SCSI command processed in <a class="el" href="group___m_s_c___d_e_v_i_c_e.html#ga8f5dcb9aacaba9e9932f2c941d4639e3" title="Invoked when received an SCSI command not in built-in list below. ">tud_msc_scsi_cb()</a> has completed execution. It provides an opportunity to perform post-command operations such as resource cleanup, state updates, or additional processing based on the completed command.</p>
<p>Unlike the read10_complete_cb and write10_complete_cb callbacks which are specific to those operations, this callback handles completion of all other SCSI commands that were processed through the <a class="el" href="group___m_s_c___d_e_v_i_c_e.html#ga8f5dcb9aacaba9e9932f2c941d4639e3" title="Invoked when received an SCSI command not in built-in list below. ">tud_msc_scsi_cb()</a> function.</p>
<p>This can be useful for:</p><ul>
<li>Tracking command history</li>
<li>Performing cleanup after complex commands</li>
<li>Implementing state machines that depend on command completion</li>
<li>Logging or monitoring SCSI command execution</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lun</td><td>Logical Unit Number that the command was directed to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scsi_cmd</td><td>The 16-byte SCSI command that was completed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga59855b3113a2cb20b9f0b0d9cc2ca7d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59855b3113a2cb20b9f0b0d9cc2ca7d1">&sect;&nbsp;</a></span>tud_msc_is_writable_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TU_ATTR_WEAK bool tud_msc_is_writable_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>lun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function to determine if the storage device is writable. </p>
<p>This function is invoked as part of processing SCSI WRITE10 commands to check if the storage device is currently in a writable state. The application should return whether the specified logical unit accepts write operations.</p>
<p>This can be used to implement:</p><ul>
<li>Write protection mechanisms</li>
<li>Read-only mode for certain operations</li>
<li>Dynamic write permission based on device state</li>
<li>Write protection for specific logical units</li>
</ul>
<p>If this function returns false, the MSC device will respond to WRITE10 commands with a "Write Protected" sense key, informing the host that writing is not allowed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lun</td><td>Logical Unit Number to check for write permission</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the specified logical unit accepts write operations </dd>
<dd>
false If the specified logical unit is write-protected </dd></dl>

</div>
</div>
<a id="gaaf4981315a4d70a7057edd4064fd90ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf4981315a4d70a7057edd4064fd90ce">&sect;&nbsp;</a></span>mscd_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mscd_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the Mass Storage Class Device driver. </p>
<p>This function initializes the MSC device driver's internal state. It is called during the TinyUSB device stack initialization process. The function clears the MSC interface structure (_mscd_itf) to set all values to their default state.</p>
<p>This function is part of the internal class driver API and should not be called directly by applications. It is automatically invoked by the TinyUSB device stack during initialization. </p>

</div>
</div>
<a id="ga70d56238db44bce4d77c8297211e7e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70d56238db44bce4d77c8297211e7e27">&sect;&nbsp;</a></span>mscd_deinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mscd_deinit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deinitialize the Mass Storage Class Device driver. </p>
<p>This function deinitializes the MSC device driver, releasing any resources and returning the driver to an uninitialized state. It's called during the TinyUSB device stack deinitialization process.</p>
<p>Currently, the implementation simply returns true as there are no specific resources to release for the MSC device class.</p>
<p>This function is part of the internal class driver API and should not be called directly by applications. It is automatically invoked by the TinyUSB device stack during deinitialization.</p>
<dl class="section return"><dt>Returns</dt><dd>bool Always returns true indicating successful deinitialization </dd></dl>

</div>
</div>
<a id="ga2b8d7cd18e5e49f3378e1f5bdd7bf196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b8d7cd18e5e49f3378e1f5bdd7bf196">&sect;&nbsp;</a></span>mscd_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mscd_reset </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rhport</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the Mass Storage Class Device driver state. </p>
<p>This function resets the MSC device driver to its initial state. It is called when a USB reset event occurs or when the host sends a Bulk-Only Mass Storage Reset class-specific request. The function clears the MSC interface structure (_mscd_itf) to set all values to their default state.</p>
<p>According to the USB Mass Storage Class specification, this reset operation prepares the device for the next Command Block Wrapper (CBW) from the host.</p>
<p>This function is part of the internal class driver API and should not be called directly by applications. It is automatically invoked by the TinyUSB device stack during reset events.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhport</td><td>Root Hub Port number the device is connected to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga88c3deff8b6784aa3c5b273c3f34deb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88c3deff8b6784aa3c5b273c3f34deb0">&sect;&nbsp;</a></span>mscd_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t mscd_open </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rhport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tusb_desc_interface_t const *&#160;</td>
          <td class="paramname"><em>itf_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a Mass Storage Class interface. </p>
<p>This function initializes an MSC interface when the host configures the device. It validates that the interface descriptor is for a Mass Storage Class with SCSI subclass using the BOT (Bulk-Only Transport) protocol. If valid, it initializes the interface structure, opens the required bulk IN and OUT endpoints, and prepares for the first Command Block Wrapper (CBW).</p>
<p>This function is part of the internal class driver API and is automatically invoked by the TinyUSB device stack during the enumeration process. It should not be called directly by applications.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhport</td><td>Root Hub Port number the device is connected to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">itf_desc</td><td>Pointer to the interface descriptor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_len</td><td>Maximum length of the descriptor set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of the descriptor set processed, or 0 if the interface is not supported or an error occurred </dd></dl>

</div>
</div>
<a id="gadc18d9c97fcbd636c71dab72302fa6b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc18d9c97fcbd636c71dab72302fa6b3">&sect;&nbsp;</a></span>mscd_control_xfer_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mscd_control_xfer_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rhport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tusb_control_request_t const *&#160;</td>
          <td class="paramname"><em>p_request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process control transfers for Mass Storage Class. </p>
<p>This function handles control transfers directed to the MSC interface. It processes class-specific requests such as MSC_REQ_RESET (Bulk-Only Mass Storage Reset) and standard requests like CLEAR_FEATURE for endpoint stall conditions during error recovery.</p>
<p>When a stall condition is cleared, this function will:</p><ul>
<li>Continue to stall if the device is in NEED_RESET state</li>
<li>Resume sending CSW if previously in STATUS stage</li>
<li>Prepare for new CBW reception if in CMD stage</li>
</ul>
<p>The function is called by the USB device stack during different stages of a control transfer (setup, data, acknowledgment) and must handle each stage appropriately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhport</td><td>Root Hub Port number the device is connected to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stage</td><td>The current stage of the control transfer (setup, data, ack) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_request</td><td>Pointer to the setup packet containing the control request</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if the request is handled, false to stall the control endpoint </dd></dl>

</div>
</div>
<a id="ga0a30469f504fc9d9add41321908d4988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a30469f504fc9d9add41321908d4988">&sect;&nbsp;</a></span>mscd_xfer_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mscd_xfer_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rhport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ep_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xfer_result_t&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xferred_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer callback for Mass Storage Class device. </p>
<p>This function handles USB transfer completion events for the MSC interface. It processes different stages of the Bulk-Only Transport (BOT) protocol:</p><ul>
<li>Command stage: Processes received Command Block Wrapper (CBW)</li>
<li>Data stage: Handles data transfers (both IN and OUT)</li>
<li>Status stage: Manages Command Status Wrapper (CSW) transmission</li>
</ul>
<p>The function implements the state machine for BOT protocol, handling transitions between states and managing error conditions such as stalls and resets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhport</td><td>Root Hub Port number the device is connected to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep_addr</td><td>Endpoint address that generated the transfer event </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Transfer result (success, failed, stalled) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xferred_bytes</td><td>Number of bytes transferred</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the event is handled successfully </dd>
<dd>
false If the event is not recognized or cannot be handled </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="https://www.ti.com/corp/docs/legal/copyright.shtml"> Copyright 1995-2025</a>, Texas Instruments Incorporated. All rights reserved. <br/>
  <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
