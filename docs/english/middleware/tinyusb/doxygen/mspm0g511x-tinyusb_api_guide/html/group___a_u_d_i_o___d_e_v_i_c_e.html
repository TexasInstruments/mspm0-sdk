<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>MSPM0G511xTinyUSBLibrary: AUDIO_DEVICE</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MSPM0G511xTinyUSBLibrary
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">AUDIO_DEVICE</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaad48dcebe54ca31fb03add291ce36731"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#gaad48dcebe54ca31fb03add291ce36731">CFG_TUD_AUDIO_ENABLE_EP_IN</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gaad48dcebe54ca31fb03add291ce36731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable Audio IN endpoint (device-to-host audio streaming)  <a href="#gaad48dcebe54ca31fb03add291ce36731">More...</a><br /></td></tr>
<tr class="separator:gaad48dcebe54ca31fb03add291ce36731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b299e012d39b1aa4659690c4f198b57"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga0b299e012d39b1aa4659690c4f198b57">CFG_TUD_AUDIO_ENABLE_EP_OUT</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga0b299e012d39b1aa4659690c4f198b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable Audio OUT endpoint (host-to-device audio streaming)  <a href="#ga0b299e012d39b1aa4659690c4f198b57">More...</a><br /></td></tr>
<tr class="separator:ga0b299e012d39b1aa4659690c4f198b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f44e968494e29ffba870fde3e635609"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga2f44e968494e29ffba870fde3e635609">CFG_TUD_AUDIO_FUNC_1_EP_IN_SW_BUF_SZ</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga2f44e968494e29ffba870fde3e635609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Software buffer size for Audio function 1's IN endpoint (host ← device)  <a href="#ga2f44e968494e29ffba870fde3e635609">More...</a><br /></td></tr>
<tr class="separator:ga2f44e968494e29ffba870fde3e635609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga458e1c77977f19e2a5441ad98ea2abd8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga458e1c77977f19e2a5441ad98ea2abd8">CFG_TUD_AUDIO_FUNC_2_EP_IN_SW_BUF_SZ</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga458e1c77977f19e2a5441ad98ea2abd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Software buffer size for Audio function 2's IN endpoint (host ← device)  <a href="#ga458e1c77977f19e2a5441ad98ea2abd8">More...</a><br /></td></tr>
<tr class="separator:ga458e1c77977f19e2a5441ad98ea2abd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga021ef0b1e066c451d9183a758b730079"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga021ef0b1e066c451d9183a758b730079">CFG_TUD_AUDIO_FUNC_3_EP_IN_SW_BUF_SZ</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga021ef0b1e066c451d9183a758b730079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Software buffer size for Audio function 3's IN endpoint (host ← device)  <a href="#ga021ef0b1e066c451d9183a758b730079">More...</a><br /></td></tr>
<tr class="separator:ga021ef0b1e066c451d9183a758b730079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13be1f904bc346b715d91bd8c380750d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga13be1f904bc346b715d91bd8c380750d">CFG_TUD_AUDIO_FUNC_1_EP_OUT_SW_BUF_SZ</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga13be1f904bc346b715d91bd8c380750d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Software buffer size for Audio function 1's OUT endpoint (host → device)  <a href="#ga13be1f904bc346b715d91bd8c380750d">More...</a><br /></td></tr>
<tr class="separator:ga13be1f904bc346b715d91bd8c380750d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9743864181784be224e907790a3f96da"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga9743864181784be224e907790a3f96da">CFG_TUD_AUDIO_FUNC_2_EP_OUT_SW_BUF_SZ</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga9743864181784be224e907790a3f96da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Software buffer size for Audio function 2's OUT endpoint (host → device)  <a href="#ga9743864181784be224e907790a3f96da">More...</a><br /></td></tr>
<tr class="separator:ga9743864181784be224e907790a3f96da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5a66296830b1e32b77492da9d3dcd11"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#gaf5a66296830b1e32b77492da9d3dcd11">CFG_TUD_AUDIO_FUNC_3_EP_OUT_SW_BUF_SZ</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gaf5a66296830b1e32b77492da9d3dcd11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Software buffer size for Audio function 3's OUT endpoint (host → device)  <a href="#gaf5a66296830b1e32b77492da9d3dcd11">More...</a><br /></td></tr>
<tr class="separator:gaf5a66296830b1e32b77492da9d3dcd11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6b289f06098ab06d472852fb3f87d77"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#gaa6b289f06098ab06d472852fb3f87d77">CFG_TUD_AUDIO_EP_IN_FLOW_CONTROL</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gaa6b289f06098ab06d472852fb3f87d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls flow control behavior for Audio IN endpoint (host ← device)  <a href="#gaa6b289f06098ab06d472852fb3f87d77">More...</a><br /></td></tr>
<tr class="separator:gaa6b289f06098ab06d472852fb3f87d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9985d21ce2aa7edd5fc40278556a05b1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga9985d21ce2aa7edd5fc40278556a05b1">CFG_TUD_AUDIO_ENABLE_FEEDBACK_EP</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga9985d21ce2aa7edd5fc40278556a05b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the Audio feedback endpoint.  <a href="#ga9985d21ce2aa7edd5fc40278556a05b1">More...</a><br /></td></tr>
<tr class="separator:ga9985d21ce2aa7edd5fc40278556a05b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf686eba1eb0a0142d93379a2957f3357"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#gaf686eba1eb0a0142d93379a2957f3357">CFG_TUD_AUDIO_ENABLE_FEEDBACK_FORMAT_CORRECTION</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gaf686eba1eb0a0142d93379a2957f3357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables automatic feedback format correction.  <a href="#gaf686eba1eb0a0142d93379a2957f3357">More...</a><br /></td></tr>
<tr class="separator:gaf686eba1eb0a0142d93379a2957f3357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f5314a1fb0352ae2fca2e469b5932a9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga1f5314a1fb0352ae2fca2e469b5932a9">CFG_TUD_AUDIO_ENABLE_INTERRUPT_EP</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga1f5314a1fb0352ae2fca2e469b5932a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the Audio interrupt endpoint.  <a href="#ga1f5314a1fb0352ae2fca2e469b5932a9">More...</a><br /></td></tr>
<tr class="separator:ga1f5314a1fb0352ae2fca2e469b5932a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf649943f3bcea0032998cb80fabae7a6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#gaf649943f3bcea0032998cb80fabae7a6">CFG_TUD_AUDIO_INTERRUPT_EP_SZ</a>&#160;&#160;&#160;6</td></tr>
<tr class="memdesc:gaf649943f3bcea0032998cb80fabae7a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the Audio interrupt endpoint.  <a href="#gaf649943f3bcea0032998cb80fabae7a6">More...</a><br /></td></tr>
<tr class="separator:gaf649943f3bcea0032998cb80fabae7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc990ca0921d19627b9f9eea584d2ba5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#gafc990ca0921d19627b9f9eea584d2ba5">CFG_TUD_AUDIO_ENABLE_ENCODING</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gafc990ca0921d19627b9f9eea584d2ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables audio encoding/decoding support.  <a href="#gafc990ca0921d19627b9f9eea584d2ba5">More...</a><br /></td></tr>
<tr class="separator:gafc990ca0921d19627b9f9eea584d2ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1dc07afd4a6ce0d4fbf39fb5afff6f0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#gad1dc07afd4a6ce0d4fbf39fb5afff6f0">CFG_TUD_AUDIO_ENABLE_DECODING</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gad1dc07afd4a6ce0d4fbf39fb5afff6f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables audio decoding support.  <a href="#gad1dc07afd4a6ce0d4fbf39fb5afff6f0">More...</a><br /></td></tr>
<tr class="separator:gad1dc07afd4a6ce0d4fbf39fb5afff6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7ec46708fc4ad1d5676f4d59ef7900d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#gad7ec46708fc4ad1d5676f4d59ef7900d">CFG_TUD_AUDIO_ENABLE_TYPE_I_ENCODING</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gad7ec46708fc4ad1d5676f4d59ef7900d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables Type I audio encoding support.  <a href="#gad7ec46708fc4ad1d5676f4d59ef7900d">More...</a><br /></td></tr>
<tr class="separator:gad7ec46708fc4ad1d5676f4d59ef7900d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga511945393fd0ad1d2484d147230e3766"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga511945393fd0ad1d2484d147230e3766">CFG_TUD_AUDIO_ENABLE_TYPE_I_DECODING</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga511945393fd0ad1d2484d147230e3766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables Type I audio decoding support.  <a href="#ga511945393fd0ad1d2484d147230e3766">More...</a><br /></td></tr>
<tr class="separator:ga511945393fd0ad1d2484d147230e3766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3337b0b976b2862df666121bb214678c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga3337b0b976b2862df666121bb214678c">CFG_TUD_AUDIO_FUNC_1_N_TX_SUPP_SW_FIFO</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga3337b0b976b2862df666121bb214678c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of supported software FIFOs for TX (device → host) for Audio function 1.  <a href="#ga3337b0b976b2862df666121bb214678c">More...</a><br /></td></tr>
<tr class="separator:ga3337b0b976b2862df666121bb214678c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga264996bd10e8366693a100a520f8d222"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga264996bd10e8366693a100a520f8d222">CFG_TUD_AUDIO_FUNC_2_N_TX_SUPP_SW_FIFO</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga264996bd10e8366693a100a520f8d222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of supported software FIFOs for TX (device → host) for Audio function 2.  <a href="#ga264996bd10e8366693a100a520f8d222">More...</a><br /></td></tr>
<tr class="separator:ga264996bd10e8366693a100a520f8d222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fd781a32deb7cb1abf1c6a968714b99"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga0fd781a32deb7cb1abf1c6a968714b99">CFG_TUD_AUDIO_FUNC_3_N_TX_SUPP_SW_FIFO</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga0fd781a32deb7cb1abf1c6a968714b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of supported software FIFOs for TX (device → host) for Audio function 3.  <a href="#ga0fd781a32deb7cb1abf1c6a968714b99">More...</a><br /></td></tr>
<tr class="separator:ga0fd781a32deb7cb1abf1c6a968714b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cd83111ab0cea4e4371ae7c6aa00443"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga7cd83111ab0cea4e4371ae7c6aa00443">CFG_TUD_AUDIO_FUNC_1_N_RX_SUPP_SW_FIFO</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga7cd83111ab0cea4e4371ae7c6aa00443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of supported software FIFOs for RX (host → device) for Audio function 1.  <a href="#ga7cd83111ab0cea4e4371ae7c6aa00443">More...</a><br /></td></tr>
<tr class="separator:ga7cd83111ab0cea4e4371ae7c6aa00443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30d4aaf9c69492efd5ef967bf7a5ca23"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga30d4aaf9c69492efd5ef967bf7a5ca23">CFG_TUD_AUDIO_FUNC_2_N_RX_SUPP_SW_FIFO</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga30d4aaf9c69492efd5ef967bf7a5ca23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of supported software FIFOs for RX (host → device) for Audio function 2.  <a href="#ga30d4aaf9c69492efd5ef967bf7a5ca23">More...</a><br /></td></tr>
<tr class="separator:ga30d4aaf9c69492efd5ef967bf7a5ca23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba1a2511c2b574e4384ad8a750898fc2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#gaba1a2511c2b574e4384ad8a750898fc2">CFG_TUD_AUDIO_FUNC_3_N_RX_SUPP_SW_FIFO</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gaba1a2511c2b574e4384ad8a750898fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of supported software FIFOs for RX (host → device) for Audio function 3.  <a href="#gaba1a2511c2b574e4384ad8a750898fc2">More...</a><br /></td></tr>
<tr class="separator:gaba1a2511c2b574e4384ad8a750898fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31479858f794649f804e8a16b2887afe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga31479858f794649f804e8a16b2887afe">CFG_TUD_AUDIO_FUNC_1_TX_SUPP_SW_FIFO_SZ</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga31479858f794649f804e8a16b2887afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of supported software FIFOs for RX (host → device) for Audio function 1.  <a href="#ga31479858f794649f804e8a16b2887afe">More...</a><br /></td></tr>
<tr class="separator:ga31479858f794649f804e8a16b2887afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9898eb0dd2f0f5116ddbbcdd938b9003"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga9898eb0dd2f0f5116ddbbcdd938b9003">CFG_TUD_AUDIO_FUNC_2_TX_SUPP_SW_FIFO_SZ</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga9898eb0dd2f0f5116ddbbcdd938b9003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of supported software FIFOs for RX (host → device) for Audio function 2.  <a href="#ga9898eb0dd2f0f5116ddbbcdd938b9003">More...</a><br /></td></tr>
<tr class="separator:ga9898eb0dd2f0f5116ddbbcdd938b9003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga239e23c79fb707110d0dbe5ad5f4589d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga239e23c79fb707110d0dbe5ad5f4589d">CFG_TUD_AUDIO_FUNC_3_TX_SUPP_SW_FIFO_SZ</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga239e23c79fb707110d0dbe5ad5f4589d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of supported software FIFOs for RX (host → device) for Audio function 3.  <a href="#ga239e23c79fb707110d0dbe5ad5f4589d">More...</a><br /></td></tr>
<tr class="separator:ga239e23c79fb707110d0dbe5ad5f4589d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3767031a5654e9319c241d7a3846f2e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#gad3767031a5654e9319c241d7a3846f2e">CFG_TUD_AUDIO_FUNC_1_RX_SUPP_SW_FIFO_SZ</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gad3767031a5654e9319c241d7a3846f2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of each software FIFO for RX (host → device) for Audio function 1.  <a href="#gad3767031a5654e9319c241d7a3846f2e">More...</a><br /></td></tr>
<tr class="separator:gad3767031a5654e9319c241d7a3846f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32281dd7ddbcdd0146e27a6cf3756607"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga32281dd7ddbcdd0146e27a6cf3756607">CFG_TUD_AUDIO_FUNC_2_RX_SUPP_SW_FIFO_SZ</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga32281dd7ddbcdd0146e27a6cf3756607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of each software FIFO for RX (host → device) for Audio function 2.  <a href="#ga32281dd7ddbcdd0146e27a6cf3756607">More...</a><br /></td></tr>
<tr class="separator:ga32281dd7ddbcdd0146e27a6cf3756607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac83c890e673d2ad80ea21919ae913a36"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#gac83c890e673d2ad80ea21919ae913a36">CFG_TUD_AUDIO_FUNC_3_RX_SUPP_SW_FIFO_SZ</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gac83c890e673d2ad80ea21919ae913a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of each software FIFO for RX (host → device) for Audio function 3.  <a href="#gac83c890e673d2ad80ea21919ae913a36">More...</a><br /></td></tr>
<tr class="separator:gac83c890e673d2ad80ea21919ae913a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaeaf1722e90fbc7604cc92bdd681410fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#gaeaf1722e90fbc7604cc92bdd681410fd">tud_audio_n_mounted</a> (uint8_t func_id)</td></tr>
<tr class="memdesc:gaeaf1722e90fbc7604cc92bdd681410fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified audio function is mounted by the host.  <a href="#gaeaf1722e90fbc7604cc92bdd681410fd">More...</a><br /></td></tr>
<tr class="separator:gaeaf1722e90fbc7604cc92bdd681410fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga873bcba48292e5301b6f84ab9a9ae3c4"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga873bcba48292e5301b6f84ab9a9ae3c4">tud_audio_mounted</a> (void)</td></tr>
<tr class="memdesc:ga873bcba48292e5301b6f84ab9a9ae3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the default audio function is mounted by the host.  <a href="#ga873bcba48292e5301b6f84ab9a9ae3c4">More...</a><br /></td></tr>
<tr class="separator:ga873bcba48292e5301b6f84ab9a9ae3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga174b50cfb8892143b096a48c3c2f1b80"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga174b50cfb8892143b096a48c3c2f1b80">tud_audio_buffer_and_schedule_control_xfer</a> (uint8_t rhport, tusb_control_request_t const *p_request, void *data, uint16_t len)</td></tr>
<tr class="memdesc:ga174b50cfb8892143b096a48c3c2f1b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer control endpoint data and schedule a transmit.  <a href="#ga174b50cfb8892143b096a48c3c2f1b80">More...</a><br /></td></tr>
<tr class="separator:ga174b50cfb8892143b096a48c3c2f1b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae247fc7bb1effb1be9d40e0a911f1872"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#gae247fc7bb1effb1be9d40e0a911f1872">tud_audio_set_itf_cb</a> (uint8_t rhport, tusb_control_request_t const *p_request)</td></tr>
<tr class="memdesc:gae247fc7bb1effb1be9d40e0a911f1872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback when audio set interface request is received.  <a href="#gae247fc7bb1effb1be9d40e0a911f1872">More...</a><br /></td></tr>
<tr class="separator:gae247fc7bb1effb1be9d40e0a911f1872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6b28715bb6164b878aa3cc7443f1427"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#gae6b28715bb6164b878aa3cc7443f1427">tud_audio_set_itf_close_EP_cb</a> (uint8_t rhport, tusb_control_request_t const *p_request)</td></tr>
<tr class="memdesc:gae6b28715bb6164b878aa3cc7443f1427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback when audio set interface request is received that closes an endpoint.  <a href="#gae6b28715bb6164b878aa3cc7443f1427">More...</a><br /></td></tr>
<tr class="separator:gae6b28715bb6164b878aa3cc7443f1427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb68567b1d7debb5868c26b864b3e2b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#gacb68567b1d7debb5868c26b864b3e2b6">tud_audio_set_req_ep_cb</a> (uint8_t rhport, tusb_control_request_t const *p_request, uint8_t *pBuff)</td></tr>
<tr class="memdesc:gacb68567b1d7debb5868c26b864b3e2b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback when audio class specific set request is received for an endpoint.  <a href="#gacb68567b1d7debb5868c26b864b3e2b6">More...</a><br /></td></tr>
<tr class="separator:gacb68567b1d7debb5868c26b864b3e2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa56d5c9c8813afa52b387dda84f311f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#gafa56d5c9c8813afa52b387dda84f311f">tud_audio_set_req_itf_cb</a> (uint8_t rhport, tusb_control_request_t const *p_request, uint8_t *pBuff)</td></tr>
<tr class="memdesc:gafa56d5c9c8813afa52b387dda84f311f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback when audio class specific set request is received for an interface.  <a href="#gafa56d5c9c8813afa52b387dda84f311f">More...</a><br /></td></tr>
<tr class="separator:gafa56d5c9c8813afa52b387dda84f311f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf00be9e83cf49eccbd81945bf2a5688d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#gaf00be9e83cf49eccbd81945bf2a5688d">tud_audio_set_req_entity_cb</a> (uint8_t rhport, tusb_control_request_t const *p_request, uint8_t *pBuff)</td></tr>
<tr class="memdesc:gaf00be9e83cf49eccbd81945bf2a5688d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback when audio class specific set request is received for an entity.  <a href="#gaf00be9e83cf49eccbd81945bf2a5688d">More...</a><br /></td></tr>
<tr class="separator:gaf00be9e83cf49eccbd81945bf2a5688d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b9f2fd3de305ed9003cfa10509fc39a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga5b9f2fd3de305ed9003cfa10509fc39a">tud_audio_get_req_ep_cb</a> (uint8_t rhport, tusb_control_request_t const *p_request)</td></tr>
<tr class="memdesc:ga5b9f2fd3de305ed9003cfa10509fc39a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback when audio class specific get request is received for an endpoint.  <a href="#ga5b9f2fd3de305ed9003cfa10509fc39a">More...</a><br /></td></tr>
<tr class="separator:ga5b9f2fd3de305ed9003cfa10509fc39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga220604dba0d21db143eb8122dae57e6d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga220604dba0d21db143eb8122dae57e6d">tud_audio_get_req_itf_cb</a> (uint8_t rhport, tusb_control_request_t const *p_request)</td></tr>
<tr class="memdesc:ga220604dba0d21db143eb8122dae57e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback when audio class specific get request is received for an interface.  <a href="#ga220604dba0d21db143eb8122dae57e6d">More...</a><br /></td></tr>
<tr class="separator:ga220604dba0d21db143eb8122dae57e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac02b051352214ff36b6071c45a42d2ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#gac02b051352214ff36b6071c45a42d2ba">tud_audio_get_req_entity_cb</a> (uint8_t rhport, tusb_control_request_t const *p_request)</td></tr>
<tr class="memdesc:gac02b051352214ff36b6071c45a42d2ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback when audio class specific get request is received for an entity.  <a href="#gac02b051352214ff36b6071c45a42d2ba">More...</a><br /></td></tr>
<tr class="separator:gac02b051352214ff36b6071c45a42d2ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fa6dd742c1d1fd387767079876c8f19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga4fa6dd742c1d1fd387767079876c8f19">audiod_init</a> (void)</td></tr>
<tr class="memdesc:ga4fa6dd742c1d1fd387767079876c8f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the Audio Device driver.  <a href="#ga4fa6dd742c1d1fd387767079876c8f19">More...</a><br /></td></tr>
<tr class="separator:ga4fa6dd742c1d1fd387767079876c8f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b1f479dddacbab1d2b2c7f050e358d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga6b1f479dddacbab1d2b2c7f050e358d9">audiod_deinit</a> (void)</td></tr>
<tr class="memdesc:ga6b1f479dddacbab1d2b2c7f050e358d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-initialize the Audio Device driver.  <a href="#ga6b1f479dddacbab1d2b2c7f050e358d9">More...</a><br /></td></tr>
<tr class="separator:ga6b1f479dddacbab1d2b2c7f050e358d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94447dfe41f27fdde46871973a236886"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga94447dfe41f27fdde46871973a236886">audiod_reset</a> (uint8_t rhport)</td></tr>
<tr class="memdesc:ga94447dfe41f27fdde46871973a236886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the Audio Device driver state.  <a href="#ga94447dfe41f27fdde46871973a236886">More...</a><br /></td></tr>
<tr class="separator:ga94447dfe41f27fdde46871973a236886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05dc4cf6537e042cceacbc9fddcf5bd4"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga05dc4cf6537e042cceacbc9fddcf5bd4">audiod_open</a> (uint8_t rhport, tusb_desc_interface_t const *itf_desc, uint16_t max_len)</td></tr>
<tr class="memdesc:ga05dc4cf6537e042cceacbc9fddcf5bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an audio function when its interface descriptor is processed.  <a href="#ga05dc4cf6537e042cceacbc9fddcf5bd4">More...</a><br /></td></tr>
<tr class="separator:ga05dc4cf6537e042cceacbc9fddcf5bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga203ac09097d03c0e5669883120698746"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga203ac09097d03c0e5669883120698746">audiod_control_xfer_cb</a> (uint8_t rhport, uint8_t stage, tusb_control_request_t const *request)</td></tr>
<tr class="memdesc:ga203ac09097d03c0e5669883120698746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for handling control transfers to the Audio Class interface.  <a href="#ga203ac09097d03c0e5669883120698746">More...</a><br /></td></tr>
<tr class="separator:ga203ac09097d03c0e5669883120698746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga267968271f1e5533c5a529a4bb452fe9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga267968271f1e5533c5a529a4bb452fe9">audiod_xfer_cb</a> (uint8_t rhport, uint8_t edpt_addr, xfer_result_t result, uint32_t xferred_bytes)</td></tr>
<tr class="memdesc:ga267968271f1e5533c5a529a4bb452fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for handling audio data transfers.  <a href="#ga267968271f1e5533c5a529a4bb452fe9">More...</a><br /></td></tr>
<tr class="separator:ga267968271f1e5533c5a529a4bb452fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11bf9129dfada6cf2d4b82b70cee49e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga11bf9129dfada6cf2d4b82b70cee49e1">audiod_sof_isr</a> (uint8_t rhport, uint32_t frame_count)</td></tr>
<tr class="memdesc:ga11bf9129dfada6cf2d4b82b70cee49e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process Start of Frame (SOF) interrupt for audio feedback.  <a href="#ga11bf9129dfada6cf2d4b82b70cee49e1">More...</a><br /></td></tr>
<tr class="separator:ga11bf9129dfada6cf2d4b82b70cee49e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaad48dcebe54ca31fb03add291ce36731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad48dcebe54ca31fb03add291ce36731">&sect;&nbsp;</a></span>CFG_TUD_AUDIO_ENABLE_EP_IN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_TUD_AUDIO_ENABLE_EP_IN&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable Audio IN endpoint (device-to-host audio streaming) </p>
<p>When set to 1, this configuration enables the Audio IN endpoint functionality, allowing the device to transmit audio data to the host. This is used for microphone or audio source functionality. The endpoint sizes are specified in bytes, with maximum limits of 1023 bytes for Full Speed and 1024 bytes for High Speed.</p>
<p>If set to 0, the Audio IN endpoint is disabled, and related code for audio transmission to host will not be compiled. </p>

</div>
</div>
<a id="ga0b299e012d39b1aa4659690c4f198b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b299e012d39b1aa4659690c4f198b57">&sect;&nbsp;</a></span>CFG_TUD_AUDIO_ENABLE_EP_OUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_TUD_AUDIO_ENABLE_EP_OUT&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable Audio OUT endpoint (host-to-device audio streaming) </p>
<p>When set to 1, this configuration enables the Audio OUT endpoint functionality, allowing the device to receive audio data from the host. This is used for speaker or audio sink functionality. The endpoint sizes are specified in bytes, with maximum limits of 1023 bytes for Full Speed and 1024 bytes for High Speed.</p>
<p>If set to 0, the Audio OUT endpoint is disabled, and related code for audio reception from host will not be compiled. </p>

</div>
</div>
<a id="ga2f44e968494e29ffba870fde3e635609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f44e968494e29ffba870fde3e635609">&sect;&nbsp;</a></span>CFG_TUD_AUDIO_FUNC_1_EP_IN_SW_BUF_SZ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_TUD_AUDIO_FUNC_1_EP_IN_SW_BUF_SZ&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Software buffer size for Audio function 1's IN endpoint (host ← device) </p>
<p>Defines the size of the software FIFO buffer used for the audio IN endpoint of the first audio function. This buffer stores audio data before transmission to the host.</p>
<p>The buffer size MUST be greater than or equal to the maximum endpoint size (CFG_TUD_AUDIO_FUNC_1_EP_IN_SZ_MAX). This is required to ensure proper data handling without buffer overflows. </p>

</div>
</div>
<a id="ga458e1c77977f19e2a5441ad98ea2abd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga458e1c77977f19e2a5441ad98ea2abd8">&sect;&nbsp;</a></span>CFG_TUD_AUDIO_FUNC_2_EP_IN_SW_BUF_SZ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_TUD_AUDIO_FUNC_2_EP_IN_SW_BUF_SZ&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Software buffer size for Audio function 2's IN endpoint (host ← device) </p>
<p>Defines the size of the software FIFO buffer used for the audio IN endpoint of the first audio function. This buffer stores audio data before transmission to the host.</p>
<p>The buffer size MUST be greater than or equal to the maximum endpoint size (CFG_TUD_AUDIO_FUNC_2_EP_IN_SZ_MAX). This is required to ensure proper data handling without buffer overflows. </p>

</div>
</div>
<a id="ga021ef0b1e066c451d9183a758b730079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga021ef0b1e066c451d9183a758b730079">&sect;&nbsp;</a></span>CFG_TUD_AUDIO_FUNC_3_EP_IN_SW_BUF_SZ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_TUD_AUDIO_FUNC_3_EP_IN_SW_BUF_SZ&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Software buffer size for Audio function 3's IN endpoint (host ← device) </p>
<p>Defines the size of the software FIFO buffer used for the audio IN endpoint of the first audio function. This buffer stores audio data before transmission to the host.</p>
<p>The buffer size MUST be greater than or equal to the maximum endpoint size (CFG_TUD_AUDIO_FUNC_3_EP_IN_SZ_MAX). This is required to ensure proper data handling without buffer overflows. </p>

</div>
</div>
<a id="ga13be1f904bc346b715d91bd8c380750d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13be1f904bc346b715d91bd8c380750d">&sect;&nbsp;</a></span>CFG_TUD_AUDIO_FUNC_1_EP_OUT_SW_BUF_SZ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_TUD_AUDIO_FUNC_1_EP_OUT_SW_BUF_SZ&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Software buffer size for Audio function 1's OUT endpoint (host → device) </p>
<p>Defines the size of the software FIFO buffer used for the audio OUT endpoint of the first audio function. This buffer stores audio data received from the host.</p>
<p>The buffer size MUST be greater than or equal to the maximum endpoint size (CFG_TUD_AUDIO_FUNC_1_EP_OUT_SZ_MAX). This is required to ensure proper data handling without buffer overflows. </p>

</div>
</div>
<a id="ga9743864181784be224e907790a3f96da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9743864181784be224e907790a3f96da">&sect;&nbsp;</a></span>CFG_TUD_AUDIO_FUNC_2_EP_OUT_SW_BUF_SZ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_TUD_AUDIO_FUNC_2_EP_OUT_SW_BUF_SZ&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Software buffer size for Audio function 2's OUT endpoint (host → device) </p>
<p>Defines the size of the software FIFO buffer used for the audio OUT endpoint of the first audio function. This buffer stores audio data received from the host.</p>
<p>The buffer size MUST be greater than or equal to the maximum endpoint size (CFG_TUD_AUDIO_FUNC_2_EP_OUT_SZ_MAX). This is required to ensure proper data handling without buffer overflows. </p>

</div>
</div>
<a id="gaf5a66296830b1e32b77492da9d3dcd11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5a66296830b1e32b77492da9d3dcd11">&sect;&nbsp;</a></span>CFG_TUD_AUDIO_FUNC_3_EP_OUT_SW_BUF_SZ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_TUD_AUDIO_FUNC_3_EP_OUT_SW_BUF_SZ&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Software buffer size for Audio function 3's OUT endpoint (host → device) </p>
<p>Defines the size of the software FIFO buffer used for the audio OUT endpoint of the first audio function. This buffer stores audio data received from the host.</p>
<p>The buffer size MUST be greater than or equal to the maximum endpoint size (CFG_TUD_AUDIO_FUNC_3_EP_OUT_SZ_MAX). This is required to ensure proper data handling without buffer overflows. </p>

</div>
</div>
<a id="gaa6b289f06098ab06d472852fb3f87d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6b289f06098ab06d472852fb3f87d77">&sect;&nbsp;</a></span>CFG_TUD_AUDIO_EP_IN_FLOW_CONTROL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_TUD_AUDIO_EP_IN_FLOW_CONTROL&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Controls flow control behavior for Audio IN endpoint (host ← device) </p>
<p>This configuration option determines how flow control is handled for the Audio IN endpoint (data flowing from device to host).</p>
<p>When enabled (1), the stack will automatically manage flow control by:</p><ul>
<li>Detecting buffer overflow/underflow conditions</li>
<li>Adjusting the data rate to maintain synchronization with the host</li>
<li>Handling feedback data from the host to ensure proper isochronous transfers</li>
</ul>
<p>When disabled (0), the application is responsible for handling flow control and maintaining proper data flow to avoid buffer issues. </p>

</div>
</div>
<a id="ga9985d21ce2aa7edd5fc40278556a05b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9985d21ce2aa7edd5fc40278556a05b1">&sect;&nbsp;</a></span>CFG_TUD_AUDIO_ENABLE_FEEDBACK_EP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_TUD_AUDIO_ENABLE_FEEDBACK_EP&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the Audio feedback endpoint. </p>
<p>This configuration option controls whether the Audio class driver enables a dedicated feedback endpoint for isochronous adaptive or asynchronous audio streaming.</p>
<p>When enabled (1):</p><ul>
<li>The stack will create and manage an additional feedback endpoint</li>
<li>This endpoint allows the device to communicate timing information to the host</li>
<li>Helps maintain synchronization between host and device clocks</li>
<li>Required for adaptive and asynchronous isochronous transfers</li>
</ul>
<p>When disabled (0):</p><ul>
<li>No feedback endpoint is created</li>
<li>Only synchronous isochronous transfers are supported</li>
<li>The device and host must share the same clock or use other synchronization methods </li>
</ul>

</div>
</div>
<a id="gaf686eba1eb0a0142d93379a2957f3357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf686eba1eb0a0142d93379a2957f3357">&sect;&nbsp;</a></span>CFG_TUD_AUDIO_ENABLE_FEEDBACK_FORMAT_CORRECTION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_TUD_AUDIO_ENABLE_FEEDBACK_FORMAT_CORRECTION&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables automatic feedback format correction. </p>
<p>This configuration option controls whether the Audio class driver automatically corrects the format of feedback data sent to the host.</p>
<p>When enabled (1):</p><ul>
<li>The stack will automatically convert feedback values to the proper format required by the USB Audio Class specification</li>
<li>Ensures that feedback data is correctly formatted as 10.14 or 16.16 fixed-point values depending on the speed mode</li>
<li>Handles endianness conversion and bit-precision adjustments</li>
<li>Simplifies application development by abstracting format details</li>
</ul>
<p>When disabled (0):</p><ul>
<li>The application must provide correctly formatted feedback values</li>
<li>The application is responsible for ensuring compliance with USB Audio format requirements </li>
</ul>

</div>
</div>
<a id="ga1f5314a1fb0352ae2fca2e469b5932a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f5314a1fb0352ae2fca2e469b5932a9">&sect;&nbsp;</a></span>CFG_TUD_AUDIO_ENABLE_INTERRUPT_EP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_TUD_AUDIO_ENABLE_INTERRUPT_EP&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the Audio interrupt endpoint. </p>
<p>This configuration option controls whether the Audio class driver creates and manages an interrupt endpoint for control and status information.</p>
<p>When enabled (1):</p><ul>
<li>The stack will create and manage an interrupt endpoint</li>
<li>This endpoint allows the device to send status information and notifications to the host</li>
<li>Enables reporting of volume changes, mute status updates, and other control events</li>
<li>Supports features like hardware button presses on audio devices</li>
</ul>
<p>When disabled (0):</p><ul>
<li>No interrupt endpoint is created</li>
<li>Status changes can only be discovered by the host through polling control requests</li>
<li>Reduces endpoint usage but limits notification capabilities </li>
</ul>

</div>
</div>
<a id="gaf649943f3bcea0032998cb80fabae7a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf649943f3bcea0032998cb80fabae7a6">&sect;&nbsp;</a></span>CFG_TUD_AUDIO_INTERRUPT_EP_SZ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_TUD_AUDIO_INTERRUPT_EP_SZ&#160;&#160;&#160;6</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of the Audio interrupt endpoint. </p>
<p>Defines the maximum packet size for the interrupt endpoint used by the Audio class driver for sending status and control information to the host.</p>
<p>This value determines how much status data can be sent in a single interrupt transfer. For most audio control applications, a small size (2-8 bytes) is sufficient as interrupt transfers typically contain minimal control information such as volume changes, mute status, or button presses.</p>
<p>The USB specification limits interrupt endpoint sizes to:</p><ul>
<li>Full-speed: 64 bytes maximum</li>
<li>High-speed: 1024 bytes maximum </li>
</ul>

</div>
</div>
<a id="gafc990ca0921d19627b9f9eea584d2ba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc990ca0921d19627b9f9eea584d2ba5">&sect;&nbsp;</a></span>CFG_TUD_AUDIO_ENABLE_ENCODING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_TUD_AUDIO_ENABLE_ENCODING&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables audio encoding/decoding support. </p>
<p>This configuration option controls whether the Audio class driver includes support for encoding and decoding audio data formats.</p>
<p>When enabled (1):</p><ul>
<li>The stack includes code for processing different audio encodings</li>
<li>Supports conversion between encoded formats and PCM</li>
<li>Allows the device to handle compressed audio formats</li>
<li>Enables features like on-device encoding/decoding of audio streams</li>
</ul>
<p>When disabled (0):</p><ul>
<li>Only raw audio data transfer is supported</li>
<li>Reduces code size by excluding encoding/decoding functionality</li>
<li>The application must handle any format conversions externally </li>
</ul>

</div>
</div>
<a id="gad1dc07afd4a6ce0d4fbf39fb5afff6f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1dc07afd4a6ce0d4fbf39fb5afff6f0">&sect;&nbsp;</a></span>CFG_TUD_AUDIO_ENABLE_DECODING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_TUD_AUDIO_ENABLE_DECODING&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables audio decoding support. </p>
<p>This configuration option controls whether the Audio class driver includes support for decoding audio data from various formats to PCM.</p>
<p>When enabled (1):</p><ul>
<li>The stack includes code for decoding compressed or encoded audio formats</li>
<li>Supports conversion from encoded formats (like MP3, AAC, etc.) to PCM</li>
<li>Allows the device to receive compressed audio and process it natively</li>
<li>Enables features like on-device playback of compressed audio streams</li>
</ul>
<p>When disabled (0):</p><ul>
<li>Only raw audio data handling is supported</li>
<li>Reduces code size by excluding decoding functionality</li>
<li>The application must handle any format decoding externally </li>
</ul>

</div>
</div>
<a id="gad7ec46708fc4ad1d5676f4d59ef7900d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7ec46708fc4ad1d5676f4d59ef7900d">&sect;&nbsp;</a></span>CFG_TUD_AUDIO_ENABLE_TYPE_I_ENCODING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_TUD_AUDIO_ENABLE_TYPE_I_ENCODING&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables Type I audio encoding support. </p>
<p>This configuration option controls whether the Audio class driver includes support for Type I audio encoding as defined in the USB Audio Class specification. </p>

</div>
</div>
<a id="ga511945393fd0ad1d2484d147230e3766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga511945393fd0ad1d2484d147230e3766">&sect;&nbsp;</a></span>CFG_TUD_AUDIO_ENABLE_TYPE_I_DECODING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_TUD_AUDIO_ENABLE_TYPE_I_DECODING&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables Type I audio decoding support. </p>
<p>This configuration option controls whether the Audio class driver includes support for Type I audio decoding as defined in the USB Audio Class specification. </p>

</div>
</div>
<a id="ga3337b0b976b2862df666121bb214678c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3337b0b976b2862df666121bb214678c">&sect;&nbsp;</a></span>CFG_TUD_AUDIO_FUNC_1_N_TX_SUPP_SW_FIFO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_TUD_AUDIO_FUNC_1_N_TX_SUPP_SW_FIFO&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of supported software FIFOs for TX (device → host) for Audio function 1. </p>
<p>Defines how many software FIFO buffers are supported for transmitting audio data from the device to the host for Audio function 1.</p>
<p>Each FIFO represents a separate audio data channel or stream that can be transmitted independently. Multiple FIFOs are useful for:</p><ul>
<li>Stereo or multi-channel audio (e.g., one FIFO per audio channel)</li>
<li>Supporting multiple sample rates or bit depths simultaneously</li>
<li>Handling different audio formats in parallel </li>
</ul>

</div>
</div>
<a id="ga264996bd10e8366693a100a520f8d222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga264996bd10e8366693a100a520f8d222">&sect;&nbsp;</a></span>CFG_TUD_AUDIO_FUNC_2_N_TX_SUPP_SW_FIFO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_TUD_AUDIO_FUNC_2_N_TX_SUPP_SW_FIFO&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of supported software FIFOs for TX (device → host) for Audio function 2. </p>
<p>Defines how many software FIFO buffers are supported for transmitting audio data from the device to the host for Audio function 2.</p>
<p>Each FIFO represents a separate audio data channel or stream that can be transmitted independently. Multiple FIFOs are useful for:</p><ul>
<li>Stereo or multi-channel audio (e.g., one FIFO per audio channel)</li>
<li>Supporting multiple sample rates or bit depths simultaneously</li>
<li>Handling different audio formats in parallel </li>
</ul>

</div>
</div>
<a id="ga0fd781a32deb7cb1abf1c6a968714b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fd781a32deb7cb1abf1c6a968714b99">&sect;&nbsp;</a></span>CFG_TUD_AUDIO_FUNC_3_N_TX_SUPP_SW_FIFO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_TUD_AUDIO_FUNC_3_N_TX_SUPP_SW_FIFO&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of supported software FIFOs for TX (device → host) for Audio function 3. </p>
<p>Defines how many software FIFO buffers are supported for transmitting audio data from the device to the host for Audio function 3.</p>
<p>Each FIFO represents a separate audio data channel or stream that can be transmitted independently. Multiple FIFOs are useful for:</p><ul>
<li>Stereo or multi-channel audio (e.g., one FIFO per audio channel)</li>
<li>Supporting multiple sample rates or bit depths simultaneously</li>
<li>Handling different audio formats in parallel </li>
</ul>

</div>
</div>
<a id="ga7cd83111ab0cea4e4371ae7c6aa00443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cd83111ab0cea4e4371ae7c6aa00443">&sect;&nbsp;</a></span>CFG_TUD_AUDIO_FUNC_1_N_RX_SUPP_SW_FIFO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_TUD_AUDIO_FUNC_1_N_RX_SUPP_SW_FIFO&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of supported software FIFOs for RX (host → device) for Audio function 1. </p>
<p>Defines how many software FIFO buffers are supported for receiving audio data from the host to the device for Audio function 1.</p>
<p>Each FIFO represents a separate audio data channel or stream that can be received independently. Multiple FIFOs are useful for:</p><ul>
<li>Stereo or multi-channel audio (e.g., one FIFO per audio channel)</li>
<li>Supporting multiple sample rates or bit depths simultaneously</li>
<li>Handling different audio formats in parallel </li>
</ul>

</div>
</div>
<a id="ga30d4aaf9c69492efd5ef967bf7a5ca23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30d4aaf9c69492efd5ef967bf7a5ca23">&sect;&nbsp;</a></span>CFG_TUD_AUDIO_FUNC_2_N_RX_SUPP_SW_FIFO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_TUD_AUDIO_FUNC_2_N_RX_SUPP_SW_FIFO&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of supported software FIFOs for RX (host → device) for Audio function 2. </p>
<p>Defines how many software FIFO buffers are supported for receiving audio data from the host to the device for Audio function 2.</p>
<p>Each FIFO represents a separate audio data channel or stream that can be received independently. Multiple FIFOs are useful for:</p><ul>
<li>Stereo or multi-channel audio (e.g., one FIFO per audio channel)</li>
<li>Supporting multiple sample rates or bit depths simultaneously</li>
<li>Handling different audio formats in parallel </li>
</ul>

</div>
</div>
<a id="gaba1a2511c2b574e4384ad8a750898fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba1a2511c2b574e4384ad8a750898fc2">&sect;&nbsp;</a></span>CFG_TUD_AUDIO_FUNC_3_N_RX_SUPP_SW_FIFO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_TUD_AUDIO_FUNC_3_N_RX_SUPP_SW_FIFO&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of supported software FIFOs for RX (host → device) for Audio function 3. </p>
<p>Defines how many software FIFO buffers are supported for receiving audio data from the host to the device for Audio function 3.</p>
<p>Each FIFO represents a separate audio data channel or stream that can be received independently. Multiple FIFOs are useful for:</p><ul>
<li>Stereo or multi-channel audio (e.g., one FIFO per audio channel)</li>
<li>Supporting multiple sample rates or bit depths simultaneously</li>
<li>Handling different audio formats in parallel </li>
</ul>

</div>
</div>
<a id="ga31479858f794649f804e8a16b2887afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31479858f794649f804e8a16b2887afe">&sect;&nbsp;</a></span>CFG_TUD_AUDIO_FUNC_1_TX_SUPP_SW_FIFO_SZ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_TUD_AUDIO_FUNC_1_TX_SUPP_SW_FIFO_SZ&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of supported software FIFOs for RX (host → device) for Audio function 1. </p>
<p>Defines how many software FIFO buffers are supported for receiving audio data from the host to the device for Audio function 1.</p>
<p>Each FIFO represents a separate audio data channel or stream that can be received independently. Multiple FIFOs are useful for:</p><ul>
<li>Stereo or multi-channel audio (e.g., one FIFO per audio channel)</li>
<li>Supporting multiple sample rates or bit depths simultaneously</li>
<li>Handling different audio formats in parallel </li>
</ul>

</div>
</div>
<a id="ga9898eb0dd2f0f5116ddbbcdd938b9003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9898eb0dd2f0f5116ddbbcdd938b9003">&sect;&nbsp;</a></span>CFG_TUD_AUDIO_FUNC_2_TX_SUPP_SW_FIFO_SZ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_TUD_AUDIO_FUNC_2_TX_SUPP_SW_FIFO_SZ&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of supported software FIFOs for RX (host → device) for Audio function 2. </p>
<p>Defines how many software FIFO buffers are supported for receiving audio data from the host to the device for Audio function 2.</p>
<p>Each FIFO represents a separate audio data channel or stream that can be received independently. Multiple FIFOs are useful for:</p><ul>
<li>Stereo or multi-channel audio (e.g., one FIFO per audio channel)</li>
<li>Supporting multiple sample rates or bit depths simultaneously</li>
<li>Handling different audio formats in parallel </li>
</ul>

</div>
</div>
<a id="ga239e23c79fb707110d0dbe5ad5f4589d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga239e23c79fb707110d0dbe5ad5f4589d">&sect;&nbsp;</a></span>CFG_TUD_AUDIO_FUNC_3_TX_SUPP_SW_FIFO_SZ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_TUD_AUDIO_FUNC_3_TX_SUPP_SW_FIFO_SZ&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of supported software FIFOs for RX (host → device) for Audio function 3. </p>
<p>Defines how many software FIFO buffers are supported for receiving audio data from the host to the device for Audio function 3.</p>
<p>Each FIFO represents a separate audio data channel or stream that can be received independently. Multiple FIFOs are useful for:</p><ul>
<li>Stereo or multi-channel audio (e.g., one FIFO per audio channel)</li>
<li>Supporting multiple sample rates or bit depths simultaneously</li>
<li>Handling different audio formats in parallel </li>
</ul>

</div>
</div>
<a id="gad3767031a5654e9319c241d7a3846f2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3767031a5654e9319c241d7a3846f2e">&sect;&nbsp;</a></span>CFG_TUD_AUDIO_FUNC_1_RX_SUPP_SW_FIFO_SZ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_TUD_AUDIO_FUNC_1_RX_SUPP_SW_FIFO_SZ&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of each software FIFO for RX (host → device) for Audio function 1. </p>
<p>Defines the size in bytes of each software FIFO buffer used for receiving audio data from the host to the device for Audio function 1. </p>

</div>
</div>
<a id="ga32281dd7ddbcdd0146e27a6cf3756607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32281dd7ddbcdd0146e27a6cf3756607">&sect;&nbsp;</a></span>CFG_TUD_AUDIO_FUNC_2_RX_SUPP_SW_FIFO_SZ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_TUD_AUDIO_FUNC_2_RX_SUPP_SW_FIFO_SZ&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of each software FIFO for RX (host → device) for Audio function 2. </p>
<p>Defines the size in bytes of each software FIFO buffer used for receiving audio data from the host to the device for Audio function 2. </p>

</div>
</div>
<a id="gac83c890e673d2ad80ea21919ae913a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac83c890e673d2ad80ea21919ae913a36">&sect;&nbsp;</a></span>CFG_TUD_AUDIO_FUNC_3_RX_SUPP_SW_FIFO_SZ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_TUD_AUDIO_FUNC_3_RX_SUPP_SW_FIFO_SZ&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of each software FIFO for RX (host → device) for Audio function 3. </p>
<p>Defines the size in bytes of each software FIFO buffer used for receiving audio data from the host to the device for Audio function 3. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaeaf1722e90fbc7604cc92bdd681410fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeaf1722e90fbc7604cc92bdd681410fd">&sect;&nbsp;</a></span>tud_audio_n_mounted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tud_audio_n_mounted </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>func_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the specified audio function is mounted by the host. </p>
<p>This function checks if the specified audio function has been configured and mounted by the USB host. An audio function is considered mounted when the host has completed device configuration and the interface is ready for use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func_id</td><td>Audio function ID (zero-based index, less than CFG_TUD_AUDIO)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the audio function is mounted and ready for use </dd>
<dd>
false if the audio function is not mounted or the func_id is invalid </dd></dl>

<p>Referenced by <a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga873bcba48292e5301b6f84ab9a9ae3c4">tud_audio_mounted()</a>.</p>

</div>
</div>
<a id="ga873bcba48292e5301b6f84ab9a9ae3c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga873bcba48292e5301b6f84ab9a9ae3c4">&sect;&nbsp;</a></span>tud_audio_mounted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool tud_audio_mounted </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the default audio function is mounted by the host. </p>
<p>This function checks if the first audio function (function ID 0) has been configured and mounted by the USB host. An audio function is considered mounted when the host has completed device configuration and the interface is ready for use.</p>
<p>This is a convenience wrapper around tud_audio_n_mounted(0).</p>
<dl class="section return"><dt>Returns</dt><dd>true if the default audio function is mounted and ready for use </dd>
<dd>
false if the default audio function is not mounted</dd></dl>
<p>This function checks if the first audio function (function ID 0) has been configured and mounted by the USB host. An audio function is considered mounted when the host has completed device configuration and the interface is ready for use.</p>
<p>This is a convenience wrapper around tud_audio_n_mounted(0).</p>
<p>The mounted state indicates that the device is properly enumerated and the audio interface is ready to transfer data. Applications should check this before attempting to use audio functions.</p>
<dl class="section return"><dt>Returns</dt><dd>true If the default audio function is mounted and ready for use </dd>
<dd>
false If the default audio function is not mounted </dd></dl>

<p>References <a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga203ac09097d03c0e5669883120698746">audiod_control_xfer_cb()</a>, <a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga6b1f479dddacbab1d2b2c7f050e358d9">audiod_deinit()</a>, <a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga4fa6dd742c1d1fd387767079876c8f19">audiod_init()</a>, <a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga05dc4cf6537e042cceacbc9fddcf5bd4">audiod_open()</a>, <a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga94447dfe41f27fdde46871973a236886">audiod_reset()</a>, <a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga11bf9129dfada6cf2d4b82b70cee49e1">audiod_sof_isr()</a>, <a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga267968271f1e5533c5a529a4bb452fe9">audiod_xfer_cb()</a>, and <a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#gaeaf1722e90fbc7604cc92bdd681410fd">tud_audio_n_mounted()</a>.</p>

</div>
</div>
<a id="ga174b50cfb8892143b096a48c3c2f1b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga174b50cfb8892143b096a48c3c2f1b80">&sect;&nbsp;</a></span>tud_audio_buffer_and_schedule_control_xfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tud_audio_buffer_and_schedule_control_xfer </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rhport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tusb_control_request_t const *&#160;</td>
          <td class="paramname"><em>p_request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Buffer control endpoint data and schedule a transmit. </p>
<p>This function is intended to be used when responding to control requests without a persistent buffer. It copies the provided data into the control buffer of the corresponding audio driver and schedules a transmit to send the response.</p>
<p>Since transmission is triggered via interrupts, a persistent memory location is required for the buffer pointer. If you already have such a persistent buffer available, you may directly use 'tud_control_xfer(...)' instead. This avoids the additional data copy into the internal buffer and saves processing time.</p>
<p>This function handles only control requests with IN direction (device to host). If the request's wLength is zero, a status packet is sent instead of data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhport</td><td>USB port number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_request</td><td>Pointer to the setup request </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the response data to be sent to host </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the response data in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the operation was successful </dd>
<dd>
false If the operation failed (invalid parameters or OUT direction) </dd></dl>

</div>
</div>
<a id="gae247fc7bb1effb1be9d40e0a911f1872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae247fc7bb1effb1be9d40e0a911f1872">&sect;&nbsp;</a></span>tud_audio_set_itf_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tud_audio_set_itf_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rhport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tusb_control_request_t const *&#160;</td>
          <td class="paramname"><em>p_request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback when audio set interface request is received. </p>
<p>This callback is invoked when the host sends a Set Interface request to an audio interface. It is commonly used to handle audio streaming format changes or to start/stop audio streaming. The alternate setting value indicates the specific format to be used, or 0 for no streaming.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhport</td><td>USB port number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_request</td><td>Pointer to the setup request containing interface and alternate setting</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the request is accepted </dd>
<dd>
false If the request is rejected, will cause a STALL response </dd></dl>

</div>
</div>
<a id="gae6b28715bb6164b878aa3cc7443f1427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6b28715bb6164b878aa3cc7443f1427">&sect;&nbsp;</a></span>tud_audio_set_itf_close_EP_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tud_audio_set_itf_close_EP_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rhport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tusb_control_request_t const *&#160;</td>
          <td class="paramname"><em>p_request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback when audio set interface request is received that closes an endpoint. </p>
<p>This callback is invoked when the host sends a Set Interface request that would close an audio endpoint, typically when switching to alternate setting 0 (no streaming). This gives the application a chance to perform any necessary cleanup or state changes when audio streaming is stopped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhport</td><td>USB port number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_request</td><td>Pointer to the setup request containing interface and alternate setting</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the request is accepted </dd>
<dd>
false If the request is rejected, will cause a STALL response </dd></dl>

</div>
</div>
<a id="gacb68567b1d7debb5868c26b864b3e2b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb68567b1d7debb5868c26b864b3e2b6">&sect;&nbsp;</a></span>tud_audio_set_req_ep_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tud_audio_set_req_ep_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rhport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tusb_control_request_t const *&#160;</td>
          <td class="paramname"><em>p_request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pBuff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback when audio class specific set request is received for an endpoint. </p>
<p>This callback is invoked when the host sends an audio class-specific control request targeted at an endpoint. These requests are used to configure various endpoint-specific audio parameters such as:</p><ul>
<li>Sampling frequency</li>
<li>Pitch control</li>
<li>Data overrun/underrun control</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhport</td><td>USB port number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_request</td><td>Pointer to the setup request </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pBuff</td><td>Buffer containing data for SET requests or to be filled for GET requests</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the request is handled successfully </dd>
<dd>
false If the request is rejected, will cause a STALL response </dd></dl>

</div>
</div>
<a id="gafa56d5c9c8813afa52b387dda84f311f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa56d5c9c8813afa52b387dda84f311f">&sect;&nbsp;</a></span>tud_audio_set_req_itf_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tud_audio_set_req_itf_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rhport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tusb_control_request_t const *&#160;</td>
          <td class="paramname"><em>p_request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pBuff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback when audio class specific set request is received for an interface. </p>
<p>This callback is invoked when the host sends an audio class-specific control request targeted at an interface. These requests are used to configure various interface-specific audio parameters such as:</p><ul>
<li>Volume control</li>
<li>Mute control</li>
<li>Tone control (bass, mid, treble)</li>
<li>Graphic equalizer</li>
<li>Automatic gain control</li>
<li>Delay control</li>
<li>Bass boost</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhport</td><td>USB port number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_request</td><td>Pointer to the setup request </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pBuff</td><td>Buffer containing data for SET requests or to be filled for GET requests</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the request is handled successfully </dd>
<dd>
false If the request is rejected, will cause a STALL response </dd></dl>

</div>
</div>
<a id="gaf00be9e83cf49eccbd81945bf2a5688d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf00be9e83cf49eccbd81945bf2a5688d">&sect;&nbsp;</a></span>tud_audio_set_req_entity_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tud_audio_set_req_entity_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rhport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tusb_control_request_t const *&#160;</td>
          <td class="paramname"><em>p_request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pBuff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback when audio class specific set request is received for an entity. </p>
<p>This callback is invoked when the host sends an audio class-specific control request targeted at an audio entity. Audio entities include feature units, mixers, selectors, clock sources, and other audio processing blocks defined in the USB Audio Class specification.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhport</td><td>USB port number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_request</td><td>Pointer to the setup request </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pBuff</td><td>Buffer containing data for SET requests</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the request is handled successfully </dd>
<dd>
false If the request is rejected, will cause a STALL response </dd></dl>

</div>
</div>
<a id="ga5b9f2fd3de305ed9003cfa10509fc39a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b9f2fd3de305ed9003cfa10509fc39a">&sect;&nbsp;</a></span>tud_audio_get_req_ep_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tud_audio_get_req_ep_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rhport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tusb_control_request_t const *&#160;</td>
          <td class="paramname"><em>p_request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback when audio class specific get request is received for an endpoint. </p>
<p>This callback is invoked when the host sends an audio class-specific get request targeted at an endpoint. These requests are used to query various endpoint-specific audio parameters such as:</p><ul>
<li>Sampling frequency</li>
<li>Pitch control</li>
<li>Data overrun/underrun control</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhport</td><td>USB port number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_request</td><td>Pointer to the setup request</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the request is handled successfully </dd>
<dd>
false If the request is rejected, will cause a STALL response </dd></dl>

</div>
</div>
<a id="ga220604dba0d21db143eb8122dae57e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga220604dba0d21db143eb8122dae57e6d">&sect;&nbsp;</a></span>tud_audio_get_req_itf_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tud_audio_get_req_itf_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rhport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tusb_control_request_t const *&#160;</td>
          <td class="paramname"><em>p_request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback when audio class specific get request is received for an interface. </p>
<p>This callback is invoked when the host sends an audio class-specific get request targeted at an interface. These requests are used to query various interface-specific audio parameters such as:</p><ul>
<li>Volume control</li>
<li>Mute control</li>
<li>Tone control (bass, mid, treble)</li>
<li>Graphic equalizer</li>
<li>Automatic gain control</li>
<li>Delay control</li>
<li>Bass boost</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhport</td><td>USB port number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_request</td><td>Pointer to the setup request</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the request is handled successfully </dd>
<dd>
false If the request is rejected, will cause a STALL response </dd></dl>

</div>
</div>
<a id="gac02b051352214ff36b6071c45a42d2ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac02b051352214ff36b6071c45a42d2ba">&sect;&nbsp;</a></span>tud_audio_get_req_entity_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tud_audio_get_req_entity_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rhport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tusb_control_request_t const *&#160;</td>
          <td class="paramname"><em>p_request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback when audio class specific get request is received for an entity. </p>
<p>This callback is invoked when the host sends an audio class-specific get request targeted at an audio entity. Audio entities include feature units, mixers, selectors, clock sources, and other audio processing blocks defined in the USB Audio Class specification.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhport</td><td>USB port number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_request</td><td>Pointer to the setup request</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the request is handled successfully </dd>
<dd>
false If the request is rejected, will cause a STALL response </dd></dl>

</div>
</div>
<a id="ga4fa6dd742c1d1fd387767079876c8f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fa6dd742c1d1fd387767079876c8f19">&sect;&nbsp;</a></span>audiod_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void audiod_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the Audio Device driver. </p>
<p>This function initializes the internal state of the Audio Device driver. It is called during the USB device stack initialization and performs the following tasks:</p>
<ul>
<li>Clears the internal audio function structures</li>
<li>Sets up control buffers for each audio function</li>
<li>Initializes alternate interface settings</li>
<li>Configures FIFOs for audio data transfer (based on compile-time configuration)</li>
<li>Sets up any required linear buffers </li>
</ul>

<p>Referenced by <a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga873bcba48292e5301b6f84ab9a9ae3c4">tud_audio_mounted()</a>.</p>

</div>
</div>
<a id="ga6b1f479dddacbab1d2b2c7f050e358d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b1f479dddacbab1d2b2c7f050e358d9">&sect;&nbsp;</a></span>audiod_deinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool audiod_deinit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-initialize the Audio Device driver. </p>
<p>This function is intended to clean up resources used by the Audio Device driver when the USB device is disconnected or when the audio functions need to be reset.</p>
<p>When properly implemented, this function would be expected to:</p><ul>
<li>Free any dynamically allocated resources</li>
<li>Close any open audio endpoints</li>
<li>Reset internal state variables</li>
<li>Potentially notify the application layer that audio is no longer available</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>bool Currently always returns false indicating the operation is not implemented </dd></dl>

<p>Referenced by <a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga873bcba48292e5301b6f84ab9a9ae3c4">tud_audio_mounted()</a>.</p>

</div>
</div>
<a id="ga94447dfe41f27fdde46871973a236886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94447dfe41f27fdde46871973a236886">&sect;&nbsp;</a></span>audiod_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void audiod_reset </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rhport</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the Audio Device driver state. </p>
<p>This function resets the internal state of the Audio Device driver when a USB bus reset occurs or when the device needs to return to a known state. It performs the following operations:</p>
<ul>
<li>Clears the audio function structures (up to ITF_MEM_RESET_SIZE bytes)</li>
<li>Resets all FIFOs associated with audio endpoints</li>
<li>Clears transmit and receive support FIFOs if enabled</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhport</td><td>USB port number (currently unused in the function) </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga873bcba48292e5301b6f84ab9a9ae3c4">tud_audio_mounted()</a>.</p>

</div>
</div>
<a id="ga05dc4cf6537e042cceacbc9fddcf5bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05dc4cf6537e042cceacbc9fddcf5bd4">&sect;&nbsp;</a></span>audiod_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t audiod_open </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rhport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tusb_desc_interface_t const *&#160;</td>
          <td class="paramname"><em>itf_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize an audio function when its interface descriptor is processed. </p>
<p>This function is called by the USB stack when it encounters an Audio Class Control Interface descriptor during device enumeration. It initializes the audio function with the appropriate settings from the descriptor.</p>
<p>The function performs the following operations:</p><ul>
<li>Verifies the interface is an Audio Class Control Interface</li>
<li>Verifies protocol version and alternate setting</li>
<li>Finds an available audio driver interface slot</li>
<li>Stores descriptor information and configures function parameters</li>
<li>Allocates and configures endpoints if necessary</li>
<li>Sets up audio streaming interfaces and their alternate settings</li>
<li>Initializes FIFOs for audio data transfer</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhport</td><td>USB port number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">itf_desc</td><td>Pointer to the interface descriptor being processed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_len</td><td>Maximum length of the descriptor in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint16_t The number of bytes processed from the descriptor, or 0 if an error occurred during processing </dd></dl>

<p>Referenced by <a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga873bcba48292e5301b6f84ab9a9ae3c4">tud_audio_mounted()</a>.</p>

</div>
</div>
<a id="ga203ac09097d03c0e5669883120698746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga203ac09097d03c0e5669883120698746">&sect;&nbsp;</a></span>audiod_control_xfer_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool audiod_control_xfer_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rhport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tusb_control_request_t const *&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback for handling control transfers to the Audio Class interface. </p>
<p>This function is called by the USB device stack during control transfers targeted at the Audio Class interface. It handles both the SETUP and DATA stages of control transfers.</p>
<p>The function operates as follows:</p><ul>
<li>For CONTROL_STAGE_SETUP: Calls audiod_control_request() to process the setup packet</li>
<li>For CONTROL_STAGE_DATA: Calls audiod_control_complete() to finalize the request</li>
<li>For other stages (ACK): Returns true to indicate successful completion</li>
</ul>
<p>This callback is registered with the USB device stack and is invoked automatically when control transfers are directed to the Audio Class interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhport</td><td>USB port number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stage</td><td>Current stage of the control transfer (SETUP, DATA, or ACK) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>Pointer to the control request structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the stage was processed successfully </dd>
<dd>
false If an error occurred during processing </dd></dl>

<p>Referenced by <a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga873bcba48292e5301b6f84ab9a9ae3c4">tud_audio_mounted()</a>.</p>

</div>
</div>
<a id="ga267968271f1e5533c5a529a4bb452fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga267968271f1e5533c5a529a4bb452fe9">&sect;&nbsp;</a></span>audiod_xfer_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool audiod_xfer_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rhport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>edpt_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xfer_result_t&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xferred_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback for handling audio data transfers. </p>
<p>This function is called by the USB device stack when a data transfer completes on an audio endpoint. It handles transfers for both IN (device to host) and OUT (host to device) endpoints, as well as interrupt endpoints.</p>
<p>The function operates as follows:</p><ul>
<li>Searches for the audio function associated with the endpoint address</li>
<li>For interrupt endpoints: Calls tud_audio_int_done_cb() to notify the application</li>
<li>For IN endpoints (device to host):<ul>
<li>Handles isochronous transfers according to USB 2.0 specification</li>
<li>Prepares the next packet for transmission</li>
<li>Calls tud_audio_tx_done_pre_load_cb() to allow application processing</li>
<li>Handles audio encoding if enabled</li>
</ul>
</li>
<li>For OUT endpoints (host to device):<ul>
<li>Processes received audio data</li>
<li>Calls tud_audio_rx_done_pre_read_cb() to allow application processing</li>
<li>Handles audio decoding if enabled</li>
<li>Prepares for the next reception</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhport</td><td>USB port number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edpt_addr</td><td>Endpoint address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">result</td><td>Result of the transfer (successful or failed) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xferred_bytes</td><td>Number of bytes transferred</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the callback was handled successfully </dd>
<dd>
false If an error occurred during processing </dd></dl>

<p>Referenced by <a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga873bcba48292e5301b6f84ab9a9ae3c4">tud_audio_mounted()</a>.</p>

</div>
</div>
<a id="ga11bf9129dfada6cf2d4b82b70cee49e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11bf9129dfada6cf2d4b82b70cee49e1">&sect;&nbsp;</a></span>audiod_sof_isr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void audiod_sof_isr </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rhport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>frame_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process Start of Frame (SOF) interrupt for audio feedback. </p>
<p>This function is called by the USB device stack when a Start of Frame (SOF) interrupt is received. It is primarily used to calculate and update feedback values for isochronous audio endpoints that implement adaptive synchronization.</p>
<p>When both OUT endpoints and feedback endpoints are enabled, this function:</p><ul>
<li>Iterates through all configured audio functions</li>
<li>For each function with a feedback endpoint configured (audio-&gt;ep_fb != 0):<ul>
<li>Calculates the appropriate interval for feedback updates based on speed</li>
<li>Calls tud_audio_feedback_interval_isr() at the calculated intervals</li>
</ul>
</li>
</ul>
<p>The feedback mechanism is described in USB 2.0 specification section 5.12.4.2, allowing the device to communicate its actual sampling rate to the host for proper synchronization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhport</td><td>USB port number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_count</td><td>Current USB frame number </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___a_u_d_i_o___d_e_v_i_c_e.html#ga873bcba48292e5301b6f84ab9a9ae3c4">tud_audio_mounted()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">© Copyright 1995-2025</a>, Texas Instruments Incorporated. All rights reserved. <br/>
  <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
