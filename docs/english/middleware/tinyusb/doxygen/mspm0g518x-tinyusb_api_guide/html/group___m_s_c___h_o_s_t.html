<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>MSPM0G518xTinyUSBLibrary: MSC_HOST</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MSPM0G518xTinyUSBLibrary
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MSC_HOST</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtuh__msc__complete__data__t.html">tuh_msc_complete_data_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MSC SCSI operation completion data structure.  <a href="structtuh__msc__complete__data__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gabbde565604c0a9adac77c4309a64f81b"><td class="memItemLeft" align="right" valign="top"><a id="gabbde565604c0a9adac77c4309a64f81b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___h_o_s_t.html#gabbde565604c0a9adac77c4309a64f81b">CFG_TUH_MSC_MAXLUN</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:gabbde565604c0a9adac77c4309a64f81b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of logical unit number (LUN) supported. <br /></td></tr>
<tr class="separator:gabbde565604c0a9adac77c4309a64f81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaef514340a1b729dc1b223a31d90016d5"><td class="memItemLeft" align="right" valign="top"><a id="gaef514340a1b729dc1b223a31d90016d5"></a>
typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___h_o_s_t.html#gaef514340a1b729dc1b223a31d90016d5">tuh_msc_complete_cb_t</a>) (uint8_t dev_addr, <a class="el" href="structtuh__msc__complete__data__t.html">tuh_msc_complete_data_t</a> const *cb_data)</td></tr>
<tr class="memdesc:gaef514340a1b729dc1b223a31d90016d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">MSC SCSI operation completion callback. <br /></td></tr>
<tr class="separator:gaef514340a1b729dc1b223a31d90016d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf56760efb9f625521e4cf30721e15405"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___h_o_s_t.html#gaf56760efb9f625521e4cf30721e15405">tuh_msc_mounted</a> (uint8_t dev_addr)</td></tr>
<tr class="memdesc:gaf56760efb9f625521e4cf30721e15405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a device supports Mass Storage Class interface.  <a href="#gaf56760efb9f625521e4cf30721e15405">More...</a><br /></td></tr>
<tr class="separator:gaf56760efb9f625521e4cf30721e15405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62744669a76f6316ed24fd5af901f080"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___h_o_s_t.html#ga62744669a76f6316ed24fd5af901f080">tuh_msc_ready</a> (uint8_t dev_addr)</td></tr>
<tr class="memdesc:ga62744669a76f6316ed24fd5af901f080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a MSC device is ready for communication.  <a href="#ga62744669a76f6316ed24fd5af901f080">More...</a><br /></td></tr>
<tr class="separator:ga62744669a76f6316ed24fd5af901f080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7c9c5d34f0c193ccde36a41579a5bf7"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___h_o_s_t.html#gaa7c9c5d34f0c193ccde36a41579a5bf7">tuh_msc_get_maxlun</a> (uint8_t dev_addr)</td></tr>
<tr class="memdesc:gaa7c9c5d34f0c193ccde36a41579a5bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum Logical Unit Number (LUN) of a MSC device.  <a href="#gaa7c9c5d34f0c193ccde36a41579a5bf7">More...</a><br /></td></tr>
<tr class="separator:gaa7c9c5d34f0c193ccde36a41579a5bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ea757a33abe0f2684c28261729984bb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___h_o_s_t.html#ga6ea757a33abe0f2684c28261729984bb">tuh_msc_get_block_count</a> (uint8_t dev_addr, uint8_t lun)</td></tr>
<tr class="memdesc:ga6ea757a33abe0f2684c28261729984bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of blocks in a logical unit.  <a href="#ga6ea757a33abe0f2684c28261729984bb">More...</a><br /></td></tr>
<tr class="separator:ga6ea757a33abe0f2684c28261729984bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga530a42cf116fecfb2ff1b90bc9e6d699"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___h_o_s_t.html#ga530a42cf116fecfb2ff1b90bc9e6d699">tuh_msc_get_block_size</a> (uint8_t dev_addr, uint8_t lun)</td></tr>
<tr class="memdesc:ga530a42cf116fecfb2ff1b90bc9e6d699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the block size in bytes for a logical unit.  <a href="#ga530a42cf116fecfb2ff1b90bc9e6d699">More...</a><br /></td></tr>
<tr class="separator:ga530a42cf116fecfb2ff1b90bc9e6d699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5da4d9fe9224723b75c55971dcbb120"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___h_o_s_t.html#gaf5da4d9fe9224723b75c55971dcbb120">tuh_msc_scsi_command</a> (uint8_t daddr, msc_cbw_t const *cbw, void *data, <a class="el" href="group___m_s_c___h_o_s_t.html#gaef514340a1b729dc1b223a31d90016d5">tuh_msc_complete_cb_t</a> complete_cb, uintptr_t arg)</td></tr>
<tr class="memdesc:gaf5da4d9fe9224723b75c55971dcbb120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a custom SCSI command to an MSC device.  <a href="#gaf5da4d9fe9224723b75c55971dcbb120">More...</a><br /></td></tr>
<tr class="separator:gaf5da4d9fe9224723b75c55971dcbb120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a8cce19ae29a60bbfd99ca4050c21fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___h_o_s_t.html#ga0a8cce19ae29a60bbfd99ca4050c21fc">tuh_msc_inquiry</a> (uint8_t dev_addr, uint8_t lun, scsi_inquiry_resp_t *response, <a class="el" href="group___m_s_c___h_o_s_t.html#gaef514340a1b729dc1b223a31d90016d5">tuh_msc_complete_cb_t</a> complete_cb, uintptr_t arg)</td></tr>
<tr class="memdesc:ga0a8cce19ae29a60bbfd99ca4050c21fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a SCSI INQUIRY command on an MSC device.  <a href="#ga0a8cce19ae29a60bbfd99ca4050c21fc">More...</a><br /></td></tr>
<tr class="separator:ga0a8cce19ae29a60bbfd99ca4050c21fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaf6484eec89377adf95ef8bc2c8e6b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___h_o_s_t.html#gaaaf6484eec89377adf95ef8bc2c8e6b1">tuh_msc_test_unit_ready</a> (uint8_t dev_addr, uint8_t lun, <a class="el" href="group___m_s_c___h_o_s_t.html#gaef514340a1b729dc1b223a31d90016d5">tuh_msc_complete_cb_t</a> complete_cb, uintptr_t arg)</td></tr>
<tr class="memdesc:gaaaf6484eec89377adf95ef8bc2c8e6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a SCSI TEST UNIT READY command on an MSC device.  <a href="#gaaaf6484eec89377adf95ef8bc2c8e6b1">More...</a><br /></td></tr>
<tr class="separator:gaaaf6484eec89377adf95ef8bc2c8e6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f531f75b76afc1958b24291a94400cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___h_o_s_t.html#ga2f531f75b76afc1958b24291a94400cb">tuh_msc_request_sense</a> (uint8_t dev_addr, uint8_t lun, void *response, <a class="el" href="group___m_s_c___h_o_s_t.html#gaef514340a1b729dc1b223a31d90016d5">tuh_msc_complete_cb_t</a> complete_cb, uintptr_t arg)</td></tr>
<tr class="memdesc:ga2f531f75b76afc1958b24291a94400cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a SCSI REQUEST SENSE command on an MSC device.  <a href="#ga2f531f75b76afc1958b24291a94400cb">More...</a><br /></td></tr>
<tr class="separator:ga2f531f75b76afc1958b24291a94400cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac392a4b41053182db71518212216a75c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___h_o_s_t.html#gac392a4b41053182db71518212216a75c">tuh_msc_read10</a> (uint8_t dev_addr, uint8_t lun, void *buffer, uint32_t lba, uint16_t block_count, <a class="el" href="group___m_s_c___h_o_s_t.html#gaef514340a1b729dc1b223a31d90016d5">tuh_msc_complete_cb_t</a> complete_cb, uintptr_t arg)</td></tr>
<tr class="memdesc:gac392a4b41053182db71518212216a75c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a SCSI READ10 command on an MSC device.  <a href="#gac392a4b41053182db71518212216a75c">More...</a><br /></td></tr>
<tr class="separator:gac392a4b41053182db71518212216a75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab48125df2757c2cb90a546e35f8d2309"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___h_o_s_t.html#gab48125df2757c2cb90a546e35f8d2309">tuh_msc_write10</a> (uint8_t dev_addr, uint8_t lun, void const *buffer, uint32_t lba, uint16_t block_count, <a class="el" href="group___m_s_c___h_o_s_t.html#gaef514340a1b729dc1b223a31d90016d5">tuh_msc_complete_cb_t</a> complete_cb, uintptr_t arg)</td></tr>
<tr class="memdesc:gab48125df2757c2cb90a546e35f8d2309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a SCSI WRITE10 command on an MSC device.  <a href="#gab48125df2757c2cb90a546e35f8d2309">More...</a><br /></td></tr>
<tr class="separator:gab48125df2757c2cb90a546e35f8d2309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa56d227e007b00765aed14f7ac884018"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___h_o_s_t.html#gaa56d227e007b00765aed14f7ac884018">tuh_msc_read_capacity</a> (uint8_t dev_addr, uint8_t lun, scsi_read_capacity10_resp_t *response, <a class="el" href="group___m_s_c___h_o_s_t.html#gaef514340a1b729dc1b223a31d90016d5">tuh_msc_complete_cb_t</a> complete_cb, uintptr_t arg)</td></tr>
<tr class="memdesc:gaa56d227e007b00765aed14f7ac884018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a SCSI READ CAPACITY 10 command on an MSC device.  <a href="#gaa56d227e007b00765aed14f7ac884018">More...</a><br /></td></tr>
<tr class="separator:gaa56d227e007b00765aed14f7ac884018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafde0790b86ab242997dcc1c9ba9dd0e2"><td class="memItemLeft" align="right" valign="top">TU_ATTR_WEAK void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___h_o_s_t.html#gafde0790b86ab242997dcc1c9ba9dd0e2">tuh_msc_mount_cb</a> (uint8_t dev_addr)</td></tr>
<tr class="memdesc:gafde0790b86ab242997dcc1c9ba9dd0e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback when a Mass Storage Class device is mounted.  <a href="#gafde0790b86ab242997dcc1c9ba9dd0e2">More...</a><br /></td></tr>
<tr class="separator:gafde0790b86ab242997dcc1c9ba9dd0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a88ed257d45d0d6766b00e2fec7adee"><td class="memItemLeft" align="right" valign="top">TU_ATTR_WEAK void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___h_o_s_t.html#ga8a88ed257d45d0d6766b00e2fec7adee">tuh_msc_umount_cb</a> (uint8_t dev_addr)</td></tr>
<tr class="memdesc:ga8a88ed257d45d0d6766b00e2fec7adee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback when a Mass Storage Class device is unmounted.  <a href="#ga8a88ed257d45d0d6766b00e2fec7adee">More...</a><br /></td></tr>
<tr class="separator:ga8a88ed257d45d0d6766b00e2fec7adee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68ac067fd192fa723fd6b2033b205118"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___h_o_s_t.html#ga68ac067fd192fa723fd6b2033b205118">msch_init</a> (void)</td></tr>
<tr class="memdesc:ga68ac067fd192fa723fd6b2033b205118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the Mass Storage Class Host driver.  <a href="#ga68ac067fd192fa723fd6b2033b205118">More...</a><br /></td></tr>
<tr class="separator:ga68ac067fd192fa723fd6b2033b205118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf39352bf31c77f3baac73211435fe242"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___h_o_s_t.html#gaf39352bf31c77f3baac73211435fe242">msch_deinit</a> (void)</td></tr>
<tr class="memdesc:gaf39352bf31c77f3baac73211435fe242"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-initialize the Mass Storage Class Host driver.  <a href="#gaf39352bf31c77f3baac73211435fe242">More...</a><br /></td></tr>
<tr class="separator:gaf39352bf31c77f3baac73211435fe242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54d2ca02074b5424dc3b48b99a0a9a60"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___h_o_s_t.html#ga54d2ca02074b5424dc3b48b99a0a9a60">msch_open</a> (uint8_t rhport, uint8_t dev_addr, tusb_desc_interface_t const *desc_itf, uint16_t max_len)</td></tr>
<tr class="memdesc:ga54d2ca02074b5424dc3b48b99a0a9a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a Mass Storage Class interface.  <a href="#ga54d2ca02074b5424dc3b48b99a0a9a60">More...</a><br /></td></tr>
<tr class="separator:ga54d2ca02074b5424dc3b48b99a0a9a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga382683b401a8f36f0c69b3dd4094ae3d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___h_o_s_t.html#ga382683b401a8f36f0c69b3dd4094ae3d">msch_set_config</a> (uint8_t daddr, uint8_t itf_num)</td></tr>
<tr class="memdesc:ga382683b401a8f36f0c69b3dd4094ae3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure a Mass Storage Class interface.  <a href="#ga382683b401a8f36f0c69b3dd4094ae3d">More...</a><br /></td></tr>
<tr class="separator:ga382683b401a8f36f0c69b3dd4094ae3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6807cd61b3cd2833ade45c7f58663081"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___h_o_s_t.html#ga6807cd61b3cd2833ade45c7f58663081">msch_close</a> (uint8_t dev_addr)</td></tr>
<tr class="memdesc:ga6807cd61b3cd2833ade45c7f58663081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a Mass Storage Class interface.  <a href="#ga6807cd61b3cd2833ade45c7f58663081">More...</a><br /></td></tr>
<tr class="separator:ga6807cd61b3cd2833ade45c7f58663081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cd6b09df7e5d6ec3e1b00e5c1e98e7f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_c___h_o_s_t.html#ga9cd6b09df7e5d6ec3e1b00e5c1e98e7f">msch_xfer_cb</a> (uint8_t dev_addr, uint8_t ep_addr, xfer_result_t event, uint32_t xferred_bytes)</td></tr>
<tr class="memdesc:ga9cd6b09df7e5d6ec3e1b00e5c1e98e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer callback for Mass Storage Class interface.  <a href="#ga9cd6b09df7e5d6ec3e1b00e5c1e98e7f">More...</a><br /></td></tr>
<tr class="separator:ga9cd6b09df7e5d6ec3e1b00e5c1e98e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf56760efb9f625521e4cf30721e15405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf56760efb9f625521e4cf30721e15405">&sect;&nbsp;</a></span>tuh_msc_mounted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tuh_msc_mounted </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a device supports Mass Storage Class interface. </p>
<p>This function checks if the specified device has a mounted MSC interface. It returns true after the device has been successfully mounted (after tuh_msc_mounted_cb() is invoked) and returns false after the device has been unmounted (after tuh_msc_unmounted_cb() is invoked).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_addr</td><td>Device address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The device has a mounted MSC interface </dd>
<dd>
false The device does not have a mounted MSC interface </dd></dl>

</div>
</div>
<a id="ga62744669a76f6316ed24fd5af901f080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62744669a76f6316ed24fd5af901f080">&sect;&nbsp;</a></span>tuh_msc_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tuh_msc_ready </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a MSC device is ready for communication. </p>
<p>This function checks if the specified MSC device is ready for new commands. It verifies that the device is mounted and that no transfers are currently in progress on either the IN or OUT endpoints.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_addr</td><td>Device address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The device is mounted and not busy with any transfers </dd>
<dd>
false The device is either not mounted or busy with transfers</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should be called before initiating any new SCSI commands to ensure the device is in a state where it can accept them </dd></dl>

</div>
</div>
<a id="gaa7c9c5d34f0c193ccde36a41579a5bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7c9c5d34f0c193ccde36a41579a5bf7">&sect;&nbsp;</a></span>tuh_msc_get_maxlun()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t tuh_msc_get_maxlun </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum Logical Unit Number (LUN) of a MSC device. </p>
<p>This function returns the maximum LUN value for the specified MSC device. The LUN value indicates how many independent storage units are available on the device. For example, a multi-card reader may expose each card slot as a separate LUN.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_addr</td><td>Device address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum LUN value </dd></dl>

</div>
</div>
<a id="ga6ea757a33abe0f2684c28261729984bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ea757a33abe0f2684c28261729984bb">&sect;&nbsp;</a></span>tuh_msc_get_block_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t tuh_msc_get_block_count </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>lun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the total number of blocks in a logical unit. </p>
<p>This function returns the total number of addressable blocks for the specified logical unit on the MSC device. This value is obtained during device enumeration through a SCSI Read Capacity command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_addr</td><td>Device address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lun</td><td>Logical Unit Number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total number of addressable blocks </dd></dl>

</div>
</div>
<a id="ga530a42cf116fecfb2ff1b90bc9e6d699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga530a42cf116fecfb2ff1b90bc9e6d699">&sect;&nbsp;</a></span>tuh_msc_get_block_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t tuh_msc_get_block_size </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>lun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the block size in bytes for a logical unit. </p>
<p>This function returns the size in bytes of each addressable block for the specified logical unit on the MSC device. This value is obtained during device enumeration through a SCSI Read Capacity command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_addr</td><td>Device address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lun</td><td>Logical Unit Number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Block size in bytes, Returns 0 if the device is not mounted or if the specified LUN is invalid </dd></dl>

</div>
</div>
<a id="gaf5da4d9fe9224723b75c55971dcbb120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5da4d9fe9224723b75c55971dcbb120">&sect;&nbsp;</a></span>tuh_msc_scsi_command()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tuh_msc_scsi_command </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>daddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">msc_cbw_t const *&#160;</td>
          <td class="paramname"><em>cbw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___m_s_c___h_o_s_t.html#gaef514340a1b729dc1b223a31d90016d5">tuh_msc_complete_cb_t</a>&#160;</td>
          <td class="paramname"><em>complete_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a custom SCSI command to an MSC device. </p>
<p>This function sends a custom SCSI command to the specified MSC device. It provides low-level access to send any SCSI command defined in the SCSI specification or vendor-specific commands.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">daddr</td><td>Device address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cbw</td><td>Pointer to Command Block Wrapper (CBW) structure Must contain a properly formatted SCSI command </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>Pointer to data buffer for command<ul>
<li>For IN transfers: receives data from device</li>
<li>For OUT transfers: contains data to send to device</li>
<li>Can be NULL for commands with no data phase </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">complete_cb</td><td>Callback function to be invoked when the command completes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>User argument to be passed to the callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the command was successfully submitted </dd>
<dd>
False if the device is not configured or cannot accept commands </dd></dl>

</div>
</div>
<a id="ga0a8cce19ae29a60bbfd99ca4050c21fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a8cce19ae29a60bbfd99ca4050c21fc">&sect;&nbsp;</a></span>tuh_msc_inquiry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tuh_msc_inquiry </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>lun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scsi_inquiry_resp_t *&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___m_s_c___h_o_s_t.html#gaef514340a1b729dc1b223a31d90016d5">tuh_msc_complete_cb_t</a>&#160;</td>
          <td class="paramname"><em>complete_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a SCSI INQUIRY command on an MSC device. </p>
<p>This function sends a SCSI INQUIRY command to the specified logical unit of an MSC device. The INQUIRY command retrieves basic information about the device such as vendor ID, product ID, and revision level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_addr</td><td>Device address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lun</td><td>Logical Unit Number </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">response</td><td>Pointer to buffer where the inquiry response will be stored Must be at least sizeof(scsi_inquiry_resp_t) bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">complete_cb</td><td>Callback function to be invoked when the command completes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>User argument to be passed to the callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the command was successfully submitted </dd>
<dd>
False if the device is not mounted or busy </dd></dl>

</div>
</div>
<a id="gaaaf6484eec89377adf95ef8bc2c8e6b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaaf6484eec89377adf95ef8bc2c8e6b1">&sect;&nbsp;</a></span>tuh_msc_test_unit_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tuh_msc_test_unit_ready </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>lun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___m_s_c___h_o_s_t.html#gaef514340a1b729dc1b223a31d90016d5">tuh_msc_complete_cb_t</a>&#160;</td>
          <td class="paramname"><em>complete_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a SCSI TEST UNIT READY command on an MSC device. </p>
<p>This function sends a SCSI TEST UNIT READY command to check if the specified logical unit is ready to accept commands. This is commonly used to check if a device is initialized and operational.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_addr</td><td>Device address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lun</td><td>Logical Unit Number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">complete_cb</td><td>Callback function to be invoked when the command completes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>User argument to be passed to the callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the command was successfully submitted </dd>
<dd>
False if the device is not mounted or busy </dd></dl>

</div>
</div>
<a id="ga2f531f75b76afc1958b24291a94400cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f531f75b76afc1958b24291a94400cb">&sect;&nbsp;</a></span>tuh_msc_request_sense()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tuh_msc_request_sense </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>lun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___m_s_c___h_o_s_t.html#gaef514340a1b729dc1b223a31d90016d5">tuh_msc_complete_cb_t</a>&#160;</td>
          <td class="paramname"><em>complete_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a SCSI REQUEST SENSE command on an MSC device. </p>
<p>This function sends a SCSI REQUEST SENSE command to retrieve error information from the specified logical unit of an MSC device. It is typically called after a command fails to get detailed error information about why the command failed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_addr</td><td>Device address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lun</td><td>Logical Unit Number </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">response</td><td>Pointer to buffer where the sense data will be stored Must be accessible by USB/DMA controller, aligned correctly and multiple of cache line if enabled </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">complete_cb</td><td>Callback function to be invoked when the command completes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>User argument to be passed to the callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the command was successfully submitted </dd>
<dd>
False if the device is not mounted or busy </dd></dl>

</div>
</div>
<a id="gac392a4b41053182db71518212216a75c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac392a4b41053182db71518212216a75c">&sect;&nbsp;</a></span>tuh_msc_read10()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tuh_msc_read10 </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>lun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>block_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___m_s_c___h_o_s_t.html#gaef514340a1b729dc1b223a31d90016d5">tuh_msc_complete_cb_t</a>&#160;</td>
          <td class="paramname"><em>complete_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a SCSI READ10 command on an MSC device. </p>
<p>This function sends a SCSI READ10 command to read data blocks from the specified logical unit of an MSC device. It reads the specified number of blocks starting from the given Logical Block Address (LBA) into the provided buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_addr</td><td>Device address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lun</td><td>Logical Unit Number </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>Pointer to buffer where the read data will be stored Must be accessible by USB/DMA controller, aligned correctly and multiple of cache line if enabled </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lba</td><td>Logical Block Address to start reading from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_count</td><td>Number of blocks to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">complete_cb</td><td>Callback function to be invoked when the command completes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>User argument to be passed to the callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the command was successfully submitted </dd>
<dd>
False if the device is not mounted or busy </dd></dl>

</div>
</div>
<a id="gab48125df2757c2cb90a546e35f8d2309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab48125df2757c2cb90a546e35f8d2309">&sect;&nbsp;</a></span>tuh_msc_write10()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tuh_msc_write10 </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>lun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>block_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___m_s_c___h_o_s_t.html#gaef514340a1b729dc1b223a31d90016d5">tuh_msc_complete_cb_t</a>&#160;</td>
          <td class="paramname"><em>complete_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a SCSI WRITE10 command on an MSC device. </p>
<p>This function sends a SCSI WRITE10 command to write data blocks to the specified logical unit of an MSC device. It writes the specified number of blocks starting at the given Logical Block Address (LBA) from the provided buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_addr</td><td>Device address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lun</td><td>Logical Unit Number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to buffer containing the data to be written Must be accessible by USB/DMA controller, aligned correctly and multiple of cache line if enabled </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lba</td><td>Logical Block Address to start writing to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_count</td><td>Number of blocks to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">complete_cb</td><td>Callback function to be invoked when the command completes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>User argument to be passed to the callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the command was successfully submitted </dd>
<dd>
False if the device is not mounted or busy </dd></dl>

</div>
</div>
<a id="gaa56d227e007b00765aed14f7ac884018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa56d227e007b00765aed14f7ac884018">&sect;&nbsp;</a></span>tuh_msc_read_capacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tuh_msc_read_capacity </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>lun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scsi_read_capacity10_resp_t *&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___m_s_c___h_o_s_t.html#gaef514340a1b729dc1b223a31d90016d5">tuh_msc_complete_cb_t</a>&#160;</td>
          <td class="paramname"><em>complete_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a SCSI READ CAPACITY 10 command on an MSC device. </p>
<p>This function sends a SCSI READ CAPACITY 10 command to retrieve capacity information from the specified logical unit of an MSC device. The capacity information includes the total number of blocks and the size of each block.</p>
<dl class="section note"><dt>Note</dt><dd>During enumeration, the host stack already performs this request automatically. Applications can simply call <a class="el" href="group___m_s_c___h_o_s_t.html#ga6ea757a33abe0f2684c28261729984bb" title="Get the total number of blocks in a logical unit. ">tuh_msc_get_block_count()</a> and <a class="el" href="group___m_s_c___h_o_s_t.html#ga530a42cf116fecfb2ff1b90bc9e6d699" title="Get the block size in bytes for a logical unit. ">tuh_msc_get_block_size()</a> to retrieve the capacity information without executing this command again.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_addr</td><td>Device address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lun</td><td>Logical Unit Number </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">response</td><td>Pointer to buffer where capacity data will be stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">complete_cb</td><td>Callback function to be invoked when the command completes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>User argument to be passed to the callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the command was successfully submitted </dd>
<dd>
False if the device is not mounted or busy </dd></dl>

</div>
</div>
<a id="gafde0790b86ab242997dcc1c9ba9dd0e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafde0790b86ab242997dcc1c9ba9dd0e2">&sect;&nbsp;</a></span>tuh_msc_mount_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TU_ATTR_WEAK void tuh_msc_mount_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback when a Mass Storage Class device is mounted. </p>
<p>This callback function is invoked when a device with a Mass Storage interface is successfully enumerated and ready to use. It's marked as weak so that applications can override it to implement their own mount handling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_addr</td><td>Device address of the newly mounted MSC device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8a88ed257d45d0d6766b00e2fec7adee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a88ed257d45d0d6766b00e2fec7adee">&sect;&nbsp;</a></span>tuh_msc_umount_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TU_ATTR_WEAK void tuh_msc_umount_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback when a Mass Storage Class device is unmounted. </p>
<p>This callback function is invoked when a previously mounted MSC device is disconnected from the host or otherwise becomes unavailable. It's marked as weak so that applications can override it to implement their own unmount handling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_addr</td><td>Device address of the MSC device that was unmounted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga68ac067fd192fa723fd6b2033b205118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68ac067fd192fa723fd6b2033b205118">&sect;&nbsp;</a></span>msch_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool msch_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the Mass Storage Class Host driver. </p>
<p>This function initializes the MSC host driver's internal state. It is called during the TinyUSB host stack initialization process. The function clears the MSC interface structures (_msch_itf) to set all values to their default state.</p>
<p>This function is part of the internal class driver API and should not be called directly by applications. It is automatically invoked by the TinyUSB host stack during initialization.</p>
<dl class="section return"><dt>Returns</dt><dd>True if initialization is successful </dd></dl>

</div>
</div>
<a id="gaf39352bf31c77f3baac73211435fe242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf39352bf31c77f3baac73211435fe242">&sect;&nbsp;</a></span>msch_deinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool msch_deinit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-initialize the Mass Storage Class Host driver. </p>
<p>This function de-initializes the MSC host driver, releasing any resources that were allocated during initialization. It is called when the TinyUSB host stack is being shut down.</p>
<p>This function is part of the internal class driver API and should not be called directly by applications. It is automatically invoked by the TinyUSB host stack during the shutdown process.</p>
<dl class="section return"><dt>Returns</dt><dd>True if de-initialization is successful </dd></dl>

</div>
</div>
<a id="ga54d2ca02074b5424dc3b48b99a0a9a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54d2ca02074b5424dc3b48b99a0a9a60">&sect;&nbsp;</a></span>msch_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool msch_open </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rhport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tusb_desc_interface_t const *&#160;</td>
          <td class="paramname"><em>desc_itf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a Mass Storage Class interface. </p>
<p>This function initializes an MSC interface when a compatible interface is found during the enumeration process. It verifies that the interface is a Mass Storage Class interface with the correct subclass and protocol, and then configures the interface by initializing the interface structure and opening the required endpoints.</p>
<p>This function is part of the internal class driver API and should not be called directly by applications. It is automatically invoked by the TinyUSB host stack during the enumeration process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhport</td><td>Root Hub Port number where the device is connected </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_addr</td><td>Device address assigned by the host </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desc_itf</td><td>Pointer to the interface descriptor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_len</td><td>Maximum length of the descriptor set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the interface is successfully opened </dd>
<dd>
False if the interface is not supported or an error occurred </dd></dl>

</div>
</div>
<a id="ga382683b401a8f36f0c69b3dd4094ae3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga382683b401a8f36f0c69b3dd4094ae3d">&sect;&nbsp;</a></span>msch_set_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool msch_set_config </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>daddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>itf_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure a Mass Storage Class interface. </p>
<p>This function configures an MSC interface after the device has been addressed and the interface has been successfully opened. It marks the interface as configured and initiates the MSC enumeration process by sending a GET_MAX_LUN control request to determine the number of logical units supported by the device.</p>
<p>This function is part of the internal class driver API and should not be called directly by applications. It is automatically invoked by the TinyUSB host stack during the enumeration process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">daddr</td><td>Device address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">itf_num</td><td>Interface number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the configuration process was successfully initiated </dd>
<dd>
False if an error occurred during configuration </dd></dl>

</div>
</div>
<a id="ga6807cd61b3cd2833ade45c7f58663081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6807cd61b3cd2833ade45c7f58663081">&sect;&nbsp;</a></span>msch_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void msch_close </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a Mass Storage Class interface. </p>
<p>This function is called when a Mass Storage device is disconnected or needs to be deinitialized. It cleans up resources associated with the MSC interface and invokes the application callback to notify of the device unmount.</p>
<p>This function is part of the internal class driver API and should not be called directly by applications. It is automatically invoked by the TinyUSB host stack when a device is disconnected or the host is shutting down.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_addr</td><td>Device address of the MSC device to close </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9cd6b09df7e5d6ec3e1b00e5c1e98e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cd6b09df7e5d6ec3e1b00e5c1e98e7f">&sect;&nbsp;</a></span>msch_xfer_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool msch_xfer_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ep_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xfer_result_t&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xferred_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer callback for Mass Storage Class interface. </p>
<p>This function is called when a USB transfer completes on an MSC interface endpoint. It handles the state machine for the Bulk-Only Transport (BOT) protocol, processing the different stages of a SCSI command: Command, Data, and Status.</p>
<p>This function is part of the internal class driver API and should not be called directly by applications. It is automatically invoked by the TinyUSB host stack when a transfer completes on an MSC endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_addr</td><td>Device address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep_addr</td><td>Endpoint address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Transfer result event (success, failed, etc.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xferred_bytes</td><td>Number of bytes transferred</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the transfer callback is successfully processed </dd>
<dd>
False if an error occurred during processing </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">© Copyright 1995-2025</a>, Texas Instruments Incorporated. All rights reserved. <br/>
  <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
