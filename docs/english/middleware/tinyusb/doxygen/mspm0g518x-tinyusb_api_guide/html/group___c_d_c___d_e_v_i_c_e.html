<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>MSPM0G518xTinyUSBLibrary: CDC_DEVICE</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MSPM0G518xTinyUSBLibrary
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">CDC_DEVICE</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_t_u___a_t_t_r___p_a_c_k_e_d.html">TU_ATTR_PACKED</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration structure for CDC FIFO persistence options.  <a href="struct_t_u___a_t_t_r___p_a_c_k_e_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga9484fcfe46fd923c94d7fdd93af1179b"><td class="memItemLeft" align="right" valign="top"><a id="ga9484fcfe46fd923c94d7fdd93af1179b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga9484fcfe46fd923c94d7fdd93af1179b">CFG_TUD_CDC_EP_BUFSIZE</a>&#160;&#160;&#160;(TUD_OPT_HIGH_SPEED ? 512 : 64)</td></tr>
<tr class="memdesc:ga9484fcfe46fd923c94d7fdd93af1179b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of CDC endpoint buffer. <br /></td></tr>
<tr class="separator:ga9484fcfe46fd923c94d7fdd93af1179b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gade226fdfc22efc0f39e1558c20c6443d"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_t_u___a_t_t_r___p_a_c_k_e_d.html">TU_ATTR_PACKED</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gade226fdfc22efc0f39e1558c20c6443d">tud_cdc_configure_fifo_t</a></td></tr>
<tr class="memdesc:gade226fdfc22efc0f39e1558c20c6443d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration structure for CDC FIFO persistence options.  <a href="#gade226fdfc22efc0f39e1558c20c6443d">More...</a><br /></td></tr>
<tr class="separator:gade226fdfc22efc0f39e1558c20c6443d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab94707a5a1ec0e1f6df92742f9f363e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gab94707a5a1ec0e1f6df92742f9f363e1">tud_cdc_configure_fifo</a> (<a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gade226fdfc22efc0f39e1558c20c6443d">tud_cdc_configure_fifo_t</a> const *cfg)</td></tr>
<tr class="memdesc:gab94707a5a1ec0e1f6df92742f9f363e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure CDC FIFO persistence behavior.  <a href="#gab94707a5a1ec0e1f6df92742f9f363e1">More...</a><br /></td></tr>
<tr class="separator:gab94707a5a1ec0e1f6df92742f9f363e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d624f9ff117bfc93a611e84d49cabf5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga3d624f9ff117bfc93a611e84d49cabf5">tud_cdc_n_ready</a> (uint8_t itf)</td></tr>
<tr class="memdesc:ga3d624f9ff117bfc93a611e84d49cabf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if CDC interface is ready for communication.  <a href="#ga3d624f9ff117bfc93a611e84d49cabf5">More...</a><br /></td></tr>
<tr class="separator:ga3d624f9ff117bfc93a611e84d49cabf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3f01d42cabe29ca298fdbbf537f6480"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gaa3f01d42cabe29ca298fdbbf537f6480">tud_cdc_n_connected</a> (uint8_t itf)</td></tr>
<tr class="memdesc:gaa3f01d42cabe29ca298fdbbf537f6480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if terminal is connected to this CDC port.  <a href="#gaa3f01d42cabe29ca298fdbbf537f6480">More...</a><br /></td></tr>
<tr class="separator:gaa3f01d42cabe29ca298fdbbf537f6480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73446d498a2352563d0837ff62ca30ee"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga73446d498a2352563d0837ff62ca30ee">tud_cdc_n_get_line_state</a> (uint8_t itf)</td></tr>
<tr class="memdesc:ga73446d498a2352563d0837ff62ca30ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current line state for a CDC interface.  <a href="#ga73446d498a2352563d0837ff62ca30ee">More...</a><br /></td></tr>
<tr class="separator:ga73446d498a2352563d0837ff62ca30ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e544e512bcd4b247a943041d7b7c00b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga6e544e512bcd4b247a943041d7b7c00b">tud_cdc_n_get_line_coding</a> (uint8_t itf, cdc_line_coding_t *coding)</td></tr>
<tr class="memdesc:ga6e544e512bcd4b247a943041d7b7c00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current line coding parameters for a CDC interface.  <a href="#ga6e544e512bcd4b247a943041d7b7c00b">More...</a><br /></td></tr>
<tr class="separator:ga6e544e512bcd4b247a943041d7b7c00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50ebb7833da5241510b90444c25f6a94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga50ebb7833da5241510b90444c25f6a94">tud_cdc_n_set_wanted_char</a> (uint8_t itf, char wanted)</td></tr>
<tr class="memdesc:ga50ebb7833da5241510b90444c25f6a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set special character that will trigger a callback when received.  <a href="#ga50ebb7833da5241510b90444c25f6a94">More...</a><br /></td></tr>
<tr class="separator:ga50ebb7833da5241510b90444c25f6a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8cf7db23b940e2844fa29d54f94122d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gad8cf7db23b940e2844fa29d54f94122d">tud_cdc_n_available</a> (uint8_t itf)</td></tr>
<tr class="memdesc:gad8cf7db23b940e2844fa29d54f94122d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bytes available for reading.  <a href="#gad8cf7db23b940e2844fa29d54f94122d">More...</a><br /></td></tr>
<tr class="separator:gad8cf7db23b940e2844fa29d54f94122d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe59a6941bcfa522b54c464974f49194"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gabe59a6941bcfa522b54c464974f49194">tud_cdc_n_read</a> (uint8_t itf, void *buffer, uint32_t bufsize)</td></tr>
<tr class="memdesc:gabe59a6941bcfa522b54c464974f49194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from CDC interface receive buffer.  <a href="#gabe59a6941bcfa522b54c464974f49194">More...</a><br /></td></tr>
<tr class="separator:gabe59a6941bcfa522b54c464974f49194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa466f532bfa516b5a72911daef8ce21d"><td class="memItemLeft" align="right" valign="top">static TU_ATTR_ALWAYS_INLINE int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gaa466f532bfa516b5a72911daef8ce21d">tud_cdc_n_read_char</a> (uint8_t itf)</td></tr>
<tr class="memdesc:gaa466f532bfa516b5a72911daef8ce21d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single character from CDC interface.  <a href="#gaa466f532bfa516b5a72911daef8ce21d">More...</a><br /></td></tr>
<tr class="separator:gaa466f532bfa516b5a72911daef8ce21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5e7c8e39469766b0ca22bf5503e58cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gab5e7c8e39469766b0ca22bf5503e58cf">tud_cdc_n_read_flush</a> (uint8_t itf)</td></tr>
<tr class="memdesc:gab5e7c8e39469766b0ca22bf5503e58cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the received data FIFO buffer.  <a href="#gab5e7c8e39469766b0ca22bf5503e58cf">More...</a><br /></td></tr>
<tr class="separator:gab5e7c8e39469766b0ca22bf5503e58cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga545a4004b831f8e73fc3ff9098f3d98b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga545a4004b831f8e73fc3ff9098f3d98b">tud_cdc_n_peek</a> (uint8_t itf, uint8_t *ui8)</td></tr>
<tr class="memdesc:ga545a4004b831f8e73fc3ff9098f3d98b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek at the next byte in the receive buffer without removing it.  <a href="#ga545a4004b831f8e73fc3ff9098f3d98b">More...</a><br /></td></tr>
<tr class="separator:ga545a4004b831f8e73fc3ff9098f3d98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac09d0ce77b93d5d1e4fa3b84e7cdc3f9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gac09d0ce77b93d5d1e4fa3b84e7cdc3f9">tud_cdc_n_write</a> (uint8_t itf, void const *buffer, uint32_t bufsize)</td></tr>
<tr class="memdesc:gac09d0ce77b93d5d1e4fa3b84e7cdc3f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to CDC interface transmit buffer.  <a href="#gac09d0ce77b93d5d1e4fa3b84e7cdc3f9">More...</a><br /></td></tr>
<tr class="separator:gac09d0ce77b93d5d1e4fa3b84e7cdc3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10a23e97d0a84fcff5033df266d56930"><td class="memItemLeft" align="right" valign="top">static TU_ATTR_ALWAYS_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga10a23e97d0a84fcff5033df266d56930">tud_cdc_n_write_char</a> (uint8_t itf, char ch)</td></tr>
<tr class="memdesc:ga10a23e97d0a84fcff5033df266d56930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a single character to CDC interface.  <a href="#ga10a23e97d0a84fcff5033df266d56930">More...</a><br /></td></tr>
<tr class="separator:ga10a23e97d0a84fcff5033df266d56930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94786ddc8487057bf86af3dfb0e7c204"><td class="memItemLeft" align="right" valign="top">static TU_ATTR_ALWAYS_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga94786ddc8487057bf86af3dfb0e7c204">tud_cdc_n_write_str</a> (uint8_t itf, char const *str)</td></tr>
<tr class="memdesc:ga94786ddc8487057bf86af3dfb0e7c204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a null-terminated string to CDC interface.  <a href="#ga94786ddc8487057bf86af3dfb0e7c204">More...</a><br /></td></tr>
<tr class="separator:ga94786ddc8487057bf86af3dfb0e7c204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga109bdbab3f5f11c069c25ee7b18850ae"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga109bdbab3f5f11c069c25ee7b18850ae">tud_cdc_n_write_flush</a> (uint8_t itf)</td></tr>
<tr class="memdesc:ga109bdbab3f5f11c069c25ee7b18850ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force sending data if possible.  <a href="#ga109bdbab3f5f11c069c25ee7b18850ae">More...</a><br /></td></tr>
<tr class="separator:ga109bdbab3f5f11c069c25ee7b18850ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab57765a82a98b3a84ce2466f3df77db4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gab57765a82a98b3a84ce2466f3df77db4">tud_cdc_n_write_available</a> (uint8_t itf)</td></tr>
<tr class="memdesc:gab57765a82a98b3a84ce2466f3df77db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of bytes available for writing to TX FIFO buffer.  <a href="#gab57765a82a98b3a84ce2466f3df77db4">More...</a><br /></td></tr>
<tr class="separator:gab57765a82a98b3a84ce2466f3df77db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fe9fae111e700511a9b898c5f96073b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga3fe9fae111e700511a9b898c5f96073b">tud_cdc_n_write_clear</a> (uint8_t itf)</td></tr>
<tr class="memdesc:ga3fe9fae111e700511a9b898c5f96073b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the transmit FIFO buffer.  <a href="#ga3fe9fae111e700511a9b898c5f96073b">More...</a><br /></td></tr>
<tr class="separator:ga3fe9fae111e700511a9b898c5f96073b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d574ec007a0bbc4a8be24adffc2e592"><td class="memItemLeft" align="right" valign="top">static TU_ATTR_ALWAYS_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga6d574ec007a0bbc4a8be24adffc2e592">tud_cdc_ready</a> (void)</td></tr>
<tr class="memdesc:ga6d574ec007a0bbc4a8be24adffc2e592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the default CDC interface is ready for communication.  <a href="#ga6d574ec007a0bbc4a8be24adffc2e592">More...</a><br /></td></tr>
<tr class="separator:ga6d574ec007a0bbc4a8be24adffc2e592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac89eaeda6903752f1b0becc7211be7db"><td class="memItemLeft" align="right" valign="top">static TU_ATTR_ALWAYS_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gac89eaeda6903752f1b0becc7211be7db">tud_cdc_connected</a> (void)</td></tr>
<tr class="memdesc:gac89eaeda6903752f1b0becc7211be7db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if terminal is connected to the default CDC port.  <a href="#gac89eaeda6903752f1b0becc7211be7db">More...</a><br /></td></tr>
<tr class="separator:gac89eaeda6903752f1b0becc7211be7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga706393e6fc452314e6a8bd34642cd84c"><td class="memItemLeft" align="right" valign="top">static TU_ATTR_ALWAYS_INLINE uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga706393e6fc452314e6a8bd34642cd84c">tud_cdc_get_line_state</a> (void)</td></tr>
<tr class="memdesc:ga706393e6fc452314e6a8bd34642cd84c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current line state for the default CDC interface.  <a href="#ga706393e6fc452314e6a8bd34642cd84c">More...</a><br /></td></tr>
<tr class="separator:ga706393e6fc452314e6a8bd34642cd84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa472dcf87d276c08d482f34f732324fe"><td class="memItemLeft" align="right" valign="top">static TU_ATTR_ALWAYS_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gaa472dcf87d276c08d482f34f732324fe">tud_cdc_get_line_coding</a> (cdc_line_coding_t *coding)</td></tr>
<tr class="memdesc:gaa472dcf87d276c08d482f34f732324fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current line coding parameters for the default CDC interface.  <a href="#gaa472dcf87d276c08d482f34f732324fe">More...</a><br /></td></tr>
<tr class="separator:gaa472dcf87d276c08d482f34f732324fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5697db72f8b9c08d07e90304ae5ef4e5"><td class="memItemLeft" align="right" valign="top">static TU_ATTR_ALWAYS_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga5697db72f8b9c08d07e90304ae5ef4e5">tud_cdc_set_wanted_char</a> (char wanted)</td></tr>
<tr class="memdesc:ga5697db72f8b9c08d07e90304ae5ef4e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set special character that will trigger a callback when received.  <a href="#ga5697db72f8b9c08d07e90304ae5ef4e5">More...</a><br /></td></tr>
<tr class="separator:ga5697db72f8b9c08d07e90304ae5ef4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacba47d62e7b96cdb16245fee26bdc224"><td class="memItemLeft" align="right" valign="top">static TU_ATTR_ALWAYS_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gacba47d62e7b96cdb16245fee26bdc224">tud_cdc_available</a> (void)</td></tr>
<tr class="memdesc:gacba47d62e7b96cdb16245fee26bdc224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bytes available for reading from the default CDC interface.  <a href="#gacba47d62e7b96cdb16245fee26bdc224">More...</a><br /></td></tr>
<tr class="separator:gacba47d62e7b96cdb16245fee26bdc224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf6937e96d8b1cd52a38c8adfc83c896"><td class="memItemLeft" align="right" valign="top">static TU_ATTR_ALWAYS_INLINE int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gaaf6937e96d8b1cd52a38c8adfc83c896">tud_cdc_read_char</a> (void)</td></tr>
<tr class="memdesc:gaaf6937e96d8b1cd52a38c8adfc83c896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single character from the default CDC interface.  <a href="#gaaf6937e96d8b1cd52a38c8adfc83c896">More...</a><br /></td></tr>
<tr class="separator:gaaf6937e96d8b1cd52a38c8adfc83c896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7f470c70e78c4685fbdb6b1ffd38d12"><td class="memItemLeft" align="right" valign="top">static TU_ATTR_ALWAYS_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gaa7f470c70e78c4685fbdb6b1ffd38d12">tud_cdc_read</a> (void *buffer, uint32_t bufsize)</td></tr>
<tr class="memdesc:gaa7f470c70e78c4685fbdb6b1ffd38d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from the default CDC interface.  <a href="#gaa7f470c70e78c4685fbdb6b1ffd38d12">More...</a><br /></td></tr>
<tr class="separator:gaa7f470c70e78c4685fbdb6b1ffd38d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c18ae31a4f1d032112e8b2be5070238"><td class="memItemLeft" align="right" valign="top">static TU_ATTR_ALWAYS_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga5c18ae31a4f1d032112e8b2be5070238">tud_cdc_read_flush</a> (void)</td></tr>
<tr class="memdesc:ga5c18ae31a4f1d032112e8b2be5070238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the default CDC interface's receive buffer.  <a href="#ga5c18ae31a4f1d032112e8b2be5070238">More...</a><br /></td></tr>
<tr class="separator:ga5c18ae31a4f1d032112e8b2be5070238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d3aab1620df06f385d48b5df93c9d69"><td class="memItemLeft" align="right" valign="top">static TU_ATTR_ALWAYS_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga0d3aab1620df06f385d48b5df93c9d69">tud_cdc_peek</a> (uint8_t *ui8)</td></tr>
<tr class="memdesc:ga0d3aab1620df06f385d48b5df93c9d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek at the next byte in the default CDC interface's receive buffer.  <a href="#ga0d3aab1620df06f385d48b5df93c9d69">More...</a><br /></td></tr>
<tr class="separator:ga0d3aab1620df06f385d48b5df93c9d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3bfe89a9358a2b2fbb22d0ee8f7e13f"><td class="memItemLeft" align="right" valign="top">static TU_ATTR_ALWAYS_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gac3bfe89a9358a2b2fbb22d0ee8f7e13f">tud_cdc_write_char</a> (char ch)</td></tr>
<tr class="memdesc:gac3bfe89a9358a2b2fbb22d0ee8f7e13f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a single character to the default CDC interface.  <a href="#gac3bfe89a9358a2b2fbb22d0ee8f7e13f">More...</a><br /></td></tr>
<tr class="separator:gac3bfe89a9358a2b2fbb22d0ee8f7e13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbd2bcb46f347104b8955cea328c3969"><td class="memItemLeft" align="right" valign="top">static TU_ATTR_ALWAYS_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gabbd2bcb46f347104b8955cea328c3969">tud_cdc_write</a> (void const *buffer, uint32_t bufsize)</td></tr>
<tr class="memdesc:gabbd2bcb46f347104b8955cea328c3969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to the default CDC interface.  <a href="#gabbd2bcb46f347104b8955cea328c3969">More...</a><br /></td></tr>
<tr class="separator:gabbd2bcb46f347104b8955cea328c3969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga420e64b203ce9bc6de0e5faae8e912c6"><td class="memItemLeft" align="right" valign="top">static TU_ATTR_ALWAYS_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga420e64b203ce9bc6de0e5faae8e912c6">tud_cdc_write_str</a> (char const *str)</td></tr>
<tr class="memdesc:ga420e64b203ce9bc6de0e5faae8e912c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a null-terminated string to the default CDC interface.  <a href="#ga420e64b203ce9bc6de0e5faae8e912c6">More...</a><br /></td></tr>
<tr class="separator:ga420e64b203ce9bc6de0e5faae8e912c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60da271413c4b95530d1395e7b9d695b"><td class="memItemLeft" align="right" valign="top">static TU_ATTR_ALWAYS_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga60da271413c4b95530d1395e7b9d695b">tud_cdc_write_flush</a> (void)</td></tr>
<tr class="memdesc:ga60da271413c4b95530d1395e7b9d695b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the default CDC interface's transmit buffer.  <a href="#ga60da271413c4b95530d1395e7b9d695b">More...</a><br /></td></tr>
<tr class="separator:ga60da271413c4b95530d1395e7b9d695b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58ba594c0e32822f9fe1163b21272682"><td class="memItemLeft" align="right" valign="top">static TU_ATTR_ALWAYS_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga58ba594c0e32822f9fe1163b21272682">tud_cdc_write_available</a> (void)</td></tr>
<tr class="memdesc:ga58ba594c0e32822f9fe1163b21272682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the available space in the default CDC interface's transmit buffer.  <a href="#ga58ba594c0e32822f9fe1163b21272682">More...</a><br /></td></tr>
<tr class="separator:ga58ba594c0e32822f9fe1163b21272682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29e1d99d7141d60738e38ea3e2b02fee"><td class="memItemLeft" align="right" valign="top">static TU_ATTR_ALWAYS_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga29e1d99d7141d60738e38ea3e2b02fee">tud_cdc_write_clear</a> (void)</td></tr>
<tr class="memdesc:ga29e1d99d7141d60738e38ea3e2b02fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the default CDC interface's transmit buffer.  <a href="#ga29e1d99d7141d60738e38ea3e2b02fee">More...</a><br /></td></tr>
<tr class="separator:ga29e1d99d7141d60738e38ea3e2b02fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57657c3d68869f8e903f8f1143898b1f"><td class="memItemLeft" align="right" valign="top">TU_ATTR_WEAK void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga57657c3d68869f8e903f8f1143898b1f">tud_cdc_rx_cb</a> (uint8_t itf)</td></tr>
<tr class="memdesc:ga57657c3d68869f8e903f8f1143898b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function invoked when CDC interface receives data from host.  <a href="#ga57657c3d68869f8e903f8f1143898b1f">More...</a><br /></td></tr>
<tr class="separator:ga57657c3d68869f8e903f8f1143898b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf1d893ff0b83be89a6f073a7ac0d623"><td class="memItemLeft" align="right" valign="top">TU_ATTR_WEAK void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gadf1d893ff0b83be89a6f073a7ac0d623">tud_cdc_rx_wanted_cb</a> (uint8_t itf, char wanted_char)</td></tr>
<tr class="memdesc:gadf1d893ff0b83be89a6f073a7ac0d623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function invoked when a specific character is received.  <a href="#gadf1d893ff0b83be89a6f073a7ac0d623">More...</a><br /></td></tr>
<tr class="separator:gadf1d893ff0b83be89a6f073a7ac0d623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bed46c0fe94119b01c9a92453316cbf"><td class="memItemLeft" align="right" valign="top">TU_ATTR_WEAK void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga6bed46c0fe94119b01c9a92453316cbf">tud_cdc_tx_complete_cb</a> (uint8_t itf)</td></tr>
<tr class="memdesc:ga6bed46c0fe94119b01c9a92453316cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function invoked when a CDC transmit operation completes.  <a href="#ga6bed46c0fe94119b01c9a92453316cbf">More...</a><br /></td></tr>
<tr class="separator:ga6bed46c0fe94119b01c9a92453316cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7b995b92d92bbb627e286d81da4ceea"><td class="memItemLeft" align="right" valign="top">TU_ATTR_WEAK void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gab7b995b92d92bbb627e286d81da4ceea">tud_cdc_line_state_cb</a> (uint8_t itf, bool dtr, bool rts)</td></tr>
<tr class="memdesc:gab7b995b92d92bbb627e286d81da4ceea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function invoked when CDC line state changes.  <a href="#gab7b995b92d92bbb627e286d81da4ceea">More...</a><br /></td></tr>
<tr class="separator:gab7b995b92d92bbb627e286d81da4ceea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcb9d9c9140560c62d498156da1e52f4"><td class="memItemLeft" align="right" valign="top">TU_ATTR_WEAK void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gadcb9d9c9140560c62d498156da1e52f4">tud_cdc_line_coding_cb</a> (uint8_t itf, cdc_line_coding_t const *p_line_coding)</td></tr>
<tr class="memdesc:gadcb9d9c9140560c62d498156da1e52f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function invoked when CDC line coding parameters change.  <a href="#gadcb9d9c9140560c62d498156da1e52f4">More...</a><br /></td></tr>
<tr class="separator:gadcb9d9c9140560c62d498156da1e52f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46f56a1b30adcc9fec602e4b7a258b25"><td class="memItemLeft" align="right" valign="top">TU_ATTR_WEAK void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga46f56a1b30adcc9fec602e4b7a258b25">tud_cdc_send_break_cb</a> (uint8_t itf, uint16_t duration_ms)</td></tr>
<tr class="memdesc:ga46f56a1b30adcc9fec602e4b7a258b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function invoked when a break signal is received.  <a href="#ga46f56a1b30adcc9fec602e4b7a258b25">More...</a><br /></td></tr>
<tr class="separator:ga46f56a1b30adcc9fec602e4b7a258b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f0120f84ea5e8dc536b173b7b859e2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga6f0120f84ea5e8dc536b173b7b859e2c">cdcd_init</a> (void)</td></tr>
<tr class="memdesc:ga6f0120f84ea5e8dc536b173b7b859e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize CDC device driver.  <a href="#ga6f0120f84ea5e8dc536b173b7b859e2c">More...</a><br /></td></tr>
<tr class="separator:ga6f0120f84ea5e8dc536b173b7b859e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47a09e6df07bb519719aa1c013e24778"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga47a09e6df07bb519719aa1c013e24778">cdcd_deinit</a> (void)</td></tr>
<tr class="memdesc:ga47a09e6df07bb519719aa1c013e24778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinitialize CDC device driver.  <a href="#ga47a09e6df07bb519719aa1c013e24778">More...</a><br /></td></tr>
<tr class="separator:ga47a09e6df07bb519719aa1c013e24778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5205506dcd48ae5e820e724c5bb171b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga5205506dcd48ae5e820e724c5bb171b7">cdcd_reset</a> (uint8_t rhport)</td></tr>
<tr class="memdesc:ga5205506dcd48ae5e820e724c5bb171b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset CDC device driver.  <a href="#ga5205506dcd48ae5e820e724c5bb171b7">More...</a><br /></td></tr>
<tr class="separator:ga5205506dcd48ae5e820e724c5bb171b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21eb9e0af7f0faf4f6aed7678830bc88"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga21eb9e0af7f0faf4f6aed7678830bc88">cdcd_open</a> (uint8_t rhport, tusb_desc_interface_t const *itf_desc, uint16_t max_len)</td></tr>
<tr class="memdesc:ga21eb9e0af7f0faf4f6aed7678830bc88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open CDC device interface.  <a href="#ga21eb9e0af7f0faf4f6aed7678830bc88">More...</a><br /></td></tr>
<tr class="separator:ga21eb9e0af7f0faf4f6aed7678830bc88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89fc99d2107ec64712fe630691e89281"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga89fc99d2107ec64712fe630691e89281">cdcd_control_xfer_cb</a> (uint8_t rhport, uint8_t stage, tusb_control_request_t const *request)</td></tr>
<tr class="memdesc:ga89fc99d2107ec64712fe630691e89281"><td class="mdescLeft">&#160;</td><td class="mdescRight">CDC device control transfer callback.  <a href="#ga89fc99d2107ec64712fe630691e89281">More...</a><br /></td></tr>
<tr class="separator:ga89fc99d2107ec64712fe630691e89281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0de4758188ef0bdfaf1c11d5be091a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gab0de4758188ef0bdfaf1c11d5be091a7">cdcd_xfer_cb</a> (uint8_t rhport, uint8_t ep_addr, xfer_result_t result, uint32_t xferred_bytes)</td></tr>
<tr class="memdesc:gab0de4758188ef0bdfaf1c11d5be091a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">CDC device data transfer callback.  <a href="#gab0de4758188ef0bdfaf1c11d5be091a7">More...</a><br /></td></tr>
<tr class="separator:gab0de4758188ef0bdfaf1c11d5be091a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gade226fdfc22efc0f39e1558c20c6443d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade226fdfc22efc0f39e1558c20c6443d">&sect;&nbsp;</a></span>tud_cdc_configure_fifo_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_t_u___a_t_t_r___p_a_c_k_e_d.html">TU_ATTR_PACKED</a>  <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gade226fdfc22efc0f39e1558c20c6443d">tud_cdc_configure_fifo_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configuration structure for CDC FIFO persistence options. </p>
<p>This structure defines configuration options for CDC FIFO persistence across USB bus reset or disconnect events. The structure uses bit fields to minimize memory usage. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab94707a5a1ec0e1f6df92742f9f363e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab94707a5a1ec0e1f6df92742f9f363e1">&sect;&nbsp;</a></span>tud_cdc_configure_fifo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tud_cdc_configure_fifo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gade226fdfc22efc0f39e1558c20c6443d">tud_cdc_configure_fifo_t</a> const *&#160;</td>
          <td class="paramname"><em>cfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure CDC FIFO persistence behavior. </p>
<p>This function configures how the CDC FIFOs behave during USB bus reset or disconnect events. By default, FIFOs are cleared on reset/disconnect, but this behavior can be modified to maintain data integrity in certain applications.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cfg</td><td>Pointer to configuration structure containing persistence options. Set rx_persistent to keep RX FIFO data on reset/disconnect. Set tx_persistent to keep TX FIFO data on reset/disconnect.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if configuration was successful, false if cfg pointer is NULL </dd></dl>

</div>
</div>
<a id="ga3d624f9ff117bfc93a611e84d49cabf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d624f9ff117bfc93a611e84d49cabf5">&sect;&nbsp;</a></span>tud_cdc_n_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tud_cdc_n_ready </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>itf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if CDC interface is ready for communication. </p>
<p>This function checks if the specified CDC interface is ready for data transfer. An interface is considered ready when the device is connected to a host, the USB stack is ready, and both IN and OUT endpoints are configured.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">itf</td><td>CDC interface number (zero-based)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if the interface is ready for data transfer, false if not ready or not properly configured </dd></dl>

<p>Referenced by <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga6d574ec007a0bbc4a8be24adffc2e592">tud_cdc_ready()</a>.</p>

</div>
</div>
<a id="gaa3f01d42cabe29ca298fdbbf537f6480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3f01d42cabe29ca298fdbbf537f6480">&sect;&nbsp;</a></span>tud_cdc_n_connected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tud_cdc_n_connected </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>itf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if terminal is connected to this CDC port. </p>
<p>This function checks if a terminal client (like a serial terminal program) is connected to the specified CDC interface. The connection state is determined by checking the DTR (Data Terminal Ready) bit in the line state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">itf</td><td>CDC interface number (zero-based)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if a terminal is connected (DTR bit is active), false otherwise </dd></dl>

<p>Referenced by <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gac89eaeda6903752f1b0becc7211be7db">tud_cdc_connected()</a>.</p>

</div>
</div>
<a id="ga73446d498a2352563d0837ff62ca30ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73446d498a2352563d0837ff62ca30ee">&sect;&nbsp;</a></span>tud_cdc_n_get_line_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t tud_cdc_n_get_line_state </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>itf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current line state for a CDC interface. </p>
<p>This function returns the current line state control signals for the specified CDC interface. The line state contains information about the DTR (Data Terminal Ready) and RTS (Request To Send) signals from the host.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">itf</td><td>CDC interface number (zero-based)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint8_t The current line state with bit fields:<ul>
<li>Bit 0: DTR (Data Terminal Ready) signal</li>
<li>Bit 1: RTS (Request To Send) signal A value of 1 indicates the signal is active </li>
</ul>
</dd></dl>

<p>Referenced by <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga706393e6fc452314e6a8bd34642cd84c">tud_cdc_get_line_state()</a>.</p>

</div>
</div>
<a id="ga6e544e512bcd4b247a943041d7b7c00b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e544e512bcd4b247a943041d7b7c00b">&sect;&nbsp;</a></span>tud_cdc_n_get_line_coding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tud_cdc_n_get_line_coding </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>itf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cdc_line_coding_t *&#160;</td>
          <td class="paramname"><em>coding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current line coding parameters for a CDC interface. </p>
<p>This function retrieves the current line coding parameters for the specified CDC interface. Line coding includes communication parameters such as baud rate, number of data bits, stop bits, and parity type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">itf</td><td>CDC interface number (zero-based) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">coding</td><td>Pointer to a cdc_line_coding_t structure where the line coding parameters will be stored </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gaa472dcf87d276c08d482f34f732324fe">tud_cdc_get_line_coding()</a>.</p>

</div>
</div>
<a id="ga50ebb7833da5241510b90444c25f6a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50ebb7833da5241510b90444c25f6a94">&sect;&nbsp;</a></span>tud_cdc_n_set_wanted_char()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tud_cdc_n_set_wanted_char </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>itf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>wanted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set special character that will trigger a callback when received. </p>
<p>This function configures a specific character that, when received on the specified CDC interface, will trigger the <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gadf1d893ff0b83be89a6f073a7ac0d623" title="Callback function invoked when a specific character is received. ">tud_cdc_rx_wanted_cb()</a> callback. This provides a convenient way to detect and respond to special characters in the incoming data stream without having to manually scan the received data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">itf</td><td>CDC interface number (zero-based) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wanted</td><td>The character to detect in the incoming data stream </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga5697db72f8b9c08d07e90304ae5ef4e5">tud_cdc_set_wanted_char()</a>.</p>

</div>
</div>
<a id="gad8cf7db23b940e2844fa29d54f94122d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8cf7db23b940e2844fa29d54f94122d">&sect;&nbsp;</a></span>tud_cdc_n_available()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t tud_cdc_n_available </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>itf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of bytes available for reading. </p>
<p>This function returns the number of bytes currently available in the receive buffer of the specified CDC interface. These bytes have been received from the host and are ready to be read by the application.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">itf</td><td>CDC interface number (zero-based)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t The number of bytes available to read from the receive buffer </dd></dl>

<p>Referenced by <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gacba47d62e7b96cdb16245fee26bdc224">tud_cdc_available()</a>.</p>

</div>
</div>
<a id="gabe59a6941bcfa522b54c464974f49194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe59a6941bcfa522b54c464974f49194">&sect;&nbsp;</a></span>tud_cdc_n_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t tud_cdc_n_read </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>itf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bufsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from CDC interface receive buffer. </p>
<p>This function reads data that has been received from the host on the specified CDC interface. It transfers bytes from the internal receive FIFO buffer to the provided application buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">itf</td><td>CDC interface number (zero-based) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>Pointer to the buffer where data will be stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufsize</td><td>Maximum number of bytes to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t The actual number of bytes read, which may be less than requested if fewer bytes are available </dd></dl>

<p>Referenced by <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gaa466f532bfa516b5a72911daef8ce21d">tud_cdc_n_read_char()</a>, and <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gaa7f470c70e78c4685fbdb6b1ffd38d12">tud_cdc_read()</a>.</p>

</div>
</div>
<a id="gaa466f532bfa516b5a72911daef8ce21d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa466f532bfa516b5a72911daef8ce21d">&sect;&nbsp;</a></span>tud_cdc_n_read_char()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TU_ATTR_ALWAYS_INLINE int32_t tud_cdc_n_read_char </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>itf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a single character from CDC interface. </p>
<p>This function reads a single byte (character) from the receive buffer of the specified CDC interface. It's a convenience function for applications that process data one character at a time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">itf</td><td>CDC interface number (zero-based)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t The read character (0-255) if data is available, or -1 if no data is available </dd></dl>

<p>References <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga545a4004b831f8e73fc3ff9098f3d98b">tud_cdc_n_peek()</a>, <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gabe59a6941bcfa522b54c464974f49194">tud_cdc_n_read()</a>, <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gab5e7c8e39469766b0ca22bf5503e58cf">tud_cdc_n_read_flush()</a>, and <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gac09d0ce77b93d5d1e4fa3b84e7cdc3f9">tud_cdc_n_write()</a>.</p>

<p>Referenced by <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gaaf6937e96d8b1cd52a38c8adfc83c896">tud_cdc_read_char()</a>.</p>

</div>
</div>
<a id="gab5e7c8e39469766b0ca22bf5503e58cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5e7c8e39469766b0ca22bf5503e58cf">&sect;&nbsp;</a></span>tud_cdc_n_read_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tud_cdc_n_read_flush </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>itf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the received data FIFO buffer. </p>
<p>This function clears (discards) all data in the receive FIFO buffer for the specified CDC interface. It's useful when you want to ignore previously received data and start fresh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">itf</td><td>CDC interface number (zero-based) </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gaa466f532bfa516b5a72911daef8ce21d">tud_cdc_n_read_char()</a>, and <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga5c18ae31a4f1d032112e8b2be5070238">tud_cdc_read_flush()</a>.</p>

</div>
</div>
<a id="ga545a4004b831f8e73fc3ff9098f3d98b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga545a4004b831f8e73fc3ff9098f3d98b">&sect;&nbsp;</a></span>tud_cdc_n_peek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tud_cdc_n_peek </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>itf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>ui8</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Peek at the next byte in the receive buffer without removing it. </p>
<p>This function allows examining the next byte in the receive buffer of the specified CDC interface without actually removing it from the buffer. This is useful when you need to look ahead in the data stream without consuming the data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">itf</td><td>CDC interface number (zero-based) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ui8</td><td>Pointer to a byte variable where the peeked data will be stored</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if data was available and stored in ui8, false if no data is available </dd></dl>

<p>Referenced by <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gaa466f532bfa516b5a72911daef8ce21d">tud_cdc_n_read_char()</a>, and <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga0d3aab1620df06f385d48b5df93c9d69">tud_cdc_peek()</a>.</p>

</div>
</div>
<a id="gac09d0ce77b93d5d1e4fa3b84e7cdc3f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac09d0ce77b93d5d1e4fa3b84e7cdc3f9">&sect;&nbsp;</a></span>tud_cdc_n_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t tud_cdc_n_write </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>itf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bufsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to CDC interface transmit buffer. </p>
<p>This function writes data to the transmit buffer of the specified CDC interface. The data will be sent to the host when the buffer is sufficiently full or when explicitly flushed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">itf</td><td>CDC interface number (zero-based) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the data to be written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufsize</td><td>Number of bytes to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t The number of bytes actually written to the buffer, which may be less than requested if there's not enough space in the buffer </dd></dl>

<p>Referenced by <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gaa466f532bfa516b5a72911daef8ce21d">tud_cdc_n_read_char()</a>, <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga10a23e97d0a84fcff5033df266d56930">tud_cdc_n_write_char()</a>, <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga94786ddc8487057bf86af3dfb0e7c204">tud_cdc_n_write_str()</a>, and <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gabbd2bcb46f347104b8955cea328c3969">tud_cdc_write()</a>.</p>

</div>
</div>
<a id="ga10a23e97d0a84fcff5033df266d56930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10a23e97d0a84fcff5033df266d56930">&sect;&nbsp;</a></span>tud_cdc_n_write_char()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TU_ATTR_ALWAYS_INLINE uint32_t tud_cdc_n_write_char </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>itf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a single character to CDC interface. </p>
<p>This function writes a single byte (character) to the transmit buffer of the specified CDC interface. It's a convenience wrapper around <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gac09d0ce77b93d5d1e4fa3b84e7cdc3f9" title="Write data to CDC interface transmit buffer. ">tud_cdc_n_write()</a> for applications that process data one character at a time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">itf</td><td>CDC interface number (zero-based) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>The character to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t 1 if the character was written successfully, 0 if there was no space in the buffer </dd></dl>

<p>References <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gac09d0ce77b93d5d1e4fa3b84e7cdc3f9">tud_cdc_n_write()</a>.</p>

<p>Referenced by <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gac3bfe89a9358a2b2fbb22d0ee8f7e13f">tud_cdc_write_char()</a>.</p>

</div>
</div>
<a id="ga94786ddc8487057bf86af3dfb0e7c204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94786ddc8487057bf86af3dfb0e7c204">&sect;&nbsp;</a></span>tud_cdc_n_write_str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TU_ATTR_ALWAYS_INLINE uint32_t tud_cdc_n_write_str </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>itf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a null-terminated string to CDC interface. </p>
<p>This function writes a null-terminated string to the transmit buffer of the specified CDC interface. It's a convenience wrapper around <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gac09d0ce77b93d5d1e4fa3b84e7cdc3f9" title="Write data to CDC interface transmit buffer. ">tud_cdc_n_write()</a> for applications that need to send string data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">itf</td><td>CDC interface number (zero-based) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>Pointer to the null-terminated string to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t The number of bytes written to the buffer, which may be less than the string length if there's not enough space </dd></dl>

<p>References <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gac09d0ce77b93d5d1e4fa3b84e7cdc3f9">tud_cdc_n_write()</a>, <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gab57765a82a98b3a84ce2466f3df77db4">tud_cdc_n_write_available()</a>, <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga3fe9fae111e700511a9b898c5f96073b">tud_cdc_n_write_clear()</a>, and <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga109bdbab3f5f11c069c25ee7b18850ae">tud_cdc_n_write_flush()</a>.</p>

<p>Referenced by <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga420e64b203ce9bc6de0e5faae8e912c6">tud_cdc_write_str()</a>.</p>

</div>
</div>
<a id="ga109bdbab3f5f11c069c25ee7b18850ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga109bdbab3f5f11c069c25ee7b18850ae">&sect;&nbsp;</a></span>tud_cdc_n_write_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t tud_cdc_n_write_flush </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>itf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force sending data if possible. </p>
<p>This function attempts to send any data currently in the transmit buffer of the specified CDC interface to the host. It initiates a USB transfer with the buffered data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">itf</td><td>CDC interface number (zero-based)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t The number of bytes sent in this transfer, or 0 if no transfer was initiated (e.g., if USB is not ready or if there's no data to send) </dd></dl>

<p>Referenced by <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga94786ddc8487057bf86af3dfb0e7c204">tud_cdc_n_write_str()</a>, and <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga60da271413c4b95530d1395e7b9d695b">tud_cdc_write_flush()</a>.</p>

</div>
</div>
<a id="gab57765a82a98b3a84ce2466f3df77db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab57765a82a98b3a84ce2466f3df77db4">&sect;&nbsp;</a></span>tud_cdc_n_write_available()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t tud_cdc_n_write_available </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>itf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of bytes available for writing to TX FIFO buffer. </p>
<p>This function returns the amount of free space available in the transmit FIFO buffer of the specified CDC interface. Applications can use this to determine how much data can be written in a single call to <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gac09d0ce77b93d5d1e4fa3b84e7cdc3f9" title="Write data to CDC interface transmit buffer. ">tud_cdc_n_write()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">itf</td><td>CDC interface number (zero-based)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t The number of bytes that can be written to the transmit buffer </dd></dl>

<p>Referenced by <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga94786ddc8487057bf86af3dfb0e7c204">tud_cdc_n_write_str()</a>, and <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga58ba594c0e32822f9fe1163b21272682">tud_cdc_write_available()</a>.</p>

</div>
</div>
<a id="ga3fe9fae111e700511a9b898c5f96073b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fe9fae111e700511a9b898c5f96073b">&sect;&nbsp;</a></span>tud_cdc_n_write_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tud_cdc_n_write_clear </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>itf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the transmit FIFO buffer. </p>
<p>This function clears (discards) all data in the transmit FIFO buffer for the specified CDC interface. It's useful when you want to abort a pending transmission and start fresh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">itf</td><td>CDC interface number (zero-based)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if the operation was successful, false otherwise </dd></dl>

<p>Referenced by <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga94786ddc8487057bf86af3dfb0e7c204">tud_cdc_n_write_str()</a>, and <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga29e1d99d7141d60738e38ea3e2b02fee">tud_cdc_write_clear()</a>.</p>

</div>
</div>
<a id="ga6d574ec007a0bbc4a8be24adffc2e592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d574ec007a0bbc4a8be24adffc2e592">&sect;&nbsp;</a></span>tud_cdc_ready()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TU_ATTR_ALWAYS_INLINE bool tud_cdc_ready </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the default CDC interface is ready for communication. </p>
<p>This function checks if the default CDC interface (interface 0) is ready for data transfer. An interface is considered ready when the device is connected to a host, the USB stack is ready, and both IN and OUT endpoints are configured.</p>
<dl class="section return"><dt>Returns</dt><dd>bool true if the default CDC interface is ready for data transfer, false if not ready or not properly configured </dd></dl>

<p>References <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga3d624f9ff117bfc93a611e84d49cabf5">tud_cdc_n_ready()</a>.</p>

</div>
</div>
<a id="gac89eaeda6903752f1b0becc7211be7db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac89eaeda6903752f1b0becc7211be7db">&sect;&nbsp;</a></span>tud_cdc_connected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TU_ATTR_ALWAYS_INLINE bool tud_cdc_connected </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if terminal is connected to the default CDC port. </p>
<p>This function checks if a terminal client (like a serial terminal program) is connected to the default CDC interface (interface 0). The connection state is determined by checking the DTR (Data Terminal Ready) bit in the line state.</p>
<dl class="section return"><dt>Returns</dt><dd>bool true if a terminal is connected (DTR bit is active), false otherwise </dd></dl>

<p>References <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gaa3f01d42cabe29ca298fdbbf537f6480">tud_cdc_n_connected()</a>.</p>

</div>
</div>
<a id="ga706393e6fc452314e6a8bd34642cd84c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga706393e6fc452314e6a8bd34642cd84c">&sect;&nbsp;</a></span>tud_cdc_get_line_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TU_ATTR_ALWAYS_INLINE uint8_t tud_cdc_get_line_state </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current line state for the default CDC interface. </p>
<p>This function returns the current line state control signals for the default CDC interface (interface 0). The line state contains information about the DTR (Data Terminal Ready) and RTS (Request To Send) signals from the host.</p>
<dl class="section return"><dt>Returns</dt><dd>uint8_t The current line state with bit fields:<ul>
<li>Bit 0: DTR (Data Terminal Ready) signal</li>
<li>Bit 1: RTS (Request To Send) signal A value of 1 indicates the signal is active </li>
</ul>
</dd></dl>

<p>References <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga73446d498a2352563d0837ff62ca30ee">tud_cdc_n_get_line_state()</a>.</p>

</div>
</div>
<a id="gaa472dcf87d276c08d482f34f732324fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa472dcf87d276c08d482f34f732324fe">&sect;&nbsp;</a></span>tud_cdc_get_line_coding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TU_ATTR_ALWAYS_INLINE void tud_cdc_get_line_coding </td>
          <td>(</td>
          <td class="paramtype">cdc_line_coding_t *&#160;</td>
          <td class="paramname"><em>coding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current line coding parameters for the default CDC interface. </p>
<p>This function retrieves the current line coding parameters for the default CDC interface (interface 0). Line coding includes communication parameters such as baud rate, number of data bits, stop bits, and parity type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">coding</td><td>Pointer to a cdc_line_coding_t structure where the line coding parameters will be stored </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga6e544e512bcd4b247a943041d7b7c00b">tud_cdc_n_get_line_coding()</a>.</p>

</div>
</div>
<a id="ga5697db72f8b9c08d07e90304ae5ef4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5697db72f8b9c08d07e90304ae5ef4e5">&sect;&nbsp;</a></span>tud_cdc_set_wanted_char()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TU_ATTR_ALWAYS_INLINE void tud_cdc_set_wanted_char </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>wanted</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set special character that will trigger a callback when received. </p>
<p>This function configures a specific character that, when received on the default CDC interface (interface 0), will trigger the <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gadf1d893ff0b83be89a6f073a7ac0d623" title="Callback function invoked when a specific character is received. ">tud_cdc_rx_wanted_cb()</a> callback. This provides a convenient way to detect and respond to special characters in the incoming data stream without having to manually scan the received data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wanted</td><td>The character to detect in the incoming data stream </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga50ebb7833da5241510b90444c25f6a94">tud_cdc_n_set_wanted_char()</a>.</p>

</div>
</div>
<a id="gacba47d62e7b96cdb16245fee26bdc224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacba47d62e7b96cdb16245fee26bdc224">&sect;&nbsp;</a></span>tud_cdc_available()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TU_ATTR_ALWAYS_INLINE uint32_t tud_cdc_available </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of bytes available for reading from the default CDC interface. </p>
<p>This function returns the number of bytes currently available in the receive buffer of the default CDC interface (interface 0). These bytes have been received from the host and are ready to be read by the application.</p>
<dl class="section return"><dt>Returns</dt><dd>uint32_t The number of bytes available to read from the receive buffer </dd></dl>

<p>References <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gad8cf7db23b940e2844fa29d54f94122d">tud_cdc_n_available()</a>.</p>

</div>
</div>
<a id="gaaf6937e96d8b1cd52a38c8adfc83c896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf6937e96d8b1cd52a38c8adfc83c896">&sect;&nbsp;</a></span>tud_cdc_read_char()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TU_ATTR_ALWAYS_INLINE int32_t tud_cdc_read_char </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a single character from the default CDC interface. </p>
<p>This function reads a single byte (character) from the receive buffer of the default CDC interface (interface 0). It's a convenience function for applications that process data one character at a time.</p>
<dl class="section return"><dt>Returns</dt><dd>int32_t The read character (0-255) if data is available, or -1 if no data is available </dd></dl>

<p>References <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gaa466f532bfa516b5a72911daef8ce21d">tud_cdc_n_read_char()</a>.</p>

</div>
</div>
<a id="gaa7f470c70e78c4685fbdb6b1ffd38d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7f470c70e78c4685fbdb6b1ffd38d12">&sect;&nbsp;</a></span>tud_cdc_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TU_ATTR_ALWAYS_INLINE uint32_t tud_cdc_read </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bufsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data from the default CDC interface. </p>
<p>This function reads data from the receive buffer of the default CDC interface (interface 0). It transfers up to 'bufsize' bytes from the CDC receive FIFO into the provided buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>Pointer to the buffer where read data will be stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufsize</td><td>Maximum number of bytes to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t The number of bytes actually read from the receive buffer </dd></dl>

<p>References <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gabe59a6941bcfa522b54c464974f49194">tud_cdc_n_read()</a>.</p>

</div>
</div>
<a id="ga5c18ae31a4f1d032112e8b2be5070238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c18ae31a4f1d032112e8b2be5070238">&sect;&nbsp;</a></span>tud_cdc_read_flush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TU_ATTR_ALWAYS_INLINE void tud_cdc_read_flush </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flush the default CDC interface's receive buffer. </p>
<p>This function discards all data in the receive buffer of the default CDC interface (interface 0).</p>
<dl class="section return"><dt>Returns</dt><dd>bool true if successful, false otherwise </dd></dl>

<p>References <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gab5e7c8e39469766b0ca22bf5503e58cf">tud_cdc_n_read_flush()</a>.</p>

</div>
</div>
<a id="ga0d3aab1620df06f385d48b5df93c9d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d3aab1620df06f385d48b5df93c9d69">&sect;&nbsp;</a></span>tud_cdc_peek()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TU_ATTR_ALWAYS_INLINE bool tud_cdc_peek </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>ui8</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peek at the next byte in the default CDC interface's receive buffer. </p>
<p>This function looks at the next byte in the receive buffer of the default CDC interface (interface 0) without removing it from the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ui8</td><td>Pointer to store the peeked character</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if a character was successfully peeked, false if the buffer is empty </dd></dl>

<p>References <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga545a4004b831f8e73fc3ff9098f3d98b">tud_cdc_n_peek()</a>.</p>

</div>
</div>
<a id="gac3bfe89a9358a2b2fbb22d0ee8f7e13f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3bfe89a9358a2b2fbb22d0ee8f7e13f">&sect;&nbsp;</a></span>tud_cdc_write_char()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TU_ATTR_ALWAYS_INLINE uint32_t tud_cdc_write_char </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a single character to the default CDC interface. </p>
<p>This function writes a single character to the transmit buffer of the default CDC interface (interface 0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>The character to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t 1 if character was successfully written, 0 if the buffer is full </dd></dl>

<p>References <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga10a23e97d0a84fcff5033df266d56930">tud_cdc_n_write_char()</a>.</p>

</div>
</div>
<a id="gabbd2bcb46f347104b8955cea328c3969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbd2bcb46f347104b8955cea328c3969">&sect;&nbsp;</a></span>tud_cdc_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TU_ATTR_ALWAYS_INLINE uint32_t tud_cdc_write </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bufsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data to the default CDC interface. </p>
<p>This function writes data to the transmit buffer of the default CDC interface (interface 0). It transfers up to 'bufsize' bytes from the provided buffer into the CDC transmit FIFO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the data to be written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufsize</td><td>Number of bytes to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t The number of bytes actually written to the transmit buffer </dd></dl>

<p>References <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gac09d0ce77b93d5d1e4fa3b84e7cdc3f9">tud_cdc_n_write()</a>.</p>

</div>
</div>
<a id="ga420e64b203ce9bc6de0e5faae8e912c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga420e64b203ce9bc6de0e5faae8e912c6">&sect;&nbsp;</a></span>tud_cdc_write_str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TU_ATTR_ALWAYS_INLINE uint32_t tud_cdc_write_str </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a null-terminated string to the default CDC interface. </p>
<p>This function writes a null-terminated string to the transmit buffer of the default CDC interface (interface 0). It calls tud_cdc_n_write_str with interface ID 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>Pointer to the null-terminated string to be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t The number of bytes written to the transmit buffer </dd></dl>

<p>References <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga94786ddc8487057bf86af3dfb0e7c204">tud_cdc_n_write_str()</a>.</p>

</div>
</div>
<a id="ga60da271413c4b95530d1395e7b9d695b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60da271413c4b95530d1395e7b9d695b">&sect;&nbsp;</a></span>tud_cdc_write_flush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TU_ATTR_ALWAYS_INLINE uint32_t tud_cdc_write_flush </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flush the default CDC interface's transmit buffer. </p>
<p>This function attempts to send all buffered data in the transmit buffer of the default CDC interface (interface 0) to the host. It ensures that any pending data is actually transmitted.</p>
<dl class="section return"><dt>Returns</dt><dd>bool true if successful, false otherwise </dd></dl>

<p>References <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga109bdbab3f5f11c069c25ee7b18850ae">tud_cdc_n_write_flush()</a>.</p>

</div>
</div>
<a id="ga58ba594c0e32822f9fe1163b21272682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58ba594c0e32822f9fe1163b21272682">&sect;&nbsp;</a></span>tud_cdc_write_available()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TU_ATTR_ALWAYS_INLINE uint32_t tud_cdc_write_available </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the available space in the default CDC interface's transmit buffer. </p>
<p>This function returns the number of bytes that can be written to the transmit buffer of the default CDC interface (interface 0) without overflowing.</p>
<dl class="section return"><dt>Returns</dt><dd>uint32_t The number of bytes available in the transmit buffer </dd></dl>

<p>References <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gab57765a82a98b3a84ce2466f3df77db4">tud_cdc_n_write_available()</a>.</p>

</div>
</div>
<a id="ga29e1d99d7141d60738e38ea3e2b02fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29e1d99d7141d60738e38ea3e2b02fee">&sect;&nbsp;</a></span>tud_cdc_write_clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TU_ATTR_ALWAYS_INLINE bool tud_cdc_write_clear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the default CDC interface's transmit buffer. </p>
<p>This function discards all data in the transmit buffer of the default CDC interface (interface 0). Any pending data waiting to be sent will be lost.</p>
<dl class="section return"><dt>Returns</dt><dd>bool true if successful, false otherwise </dd></dl>

<p>References <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga89fc99d2107ec64712fe630691e89281">cdcd_control_xfer_cb()</a>, <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga47a09e6df07bb519719aa1c013e24778">cdcd_deinit()</a>, <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga6f0120f84ea5e8dc536b173b7b859e2c">cdcd_init()</a>, <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga21eb9e0af7f0faf4f6aed7678830bc88">cdcd_open()</a>, <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga5205506dcd48ae5e820e724c5bb171b7">cdcd_reset()</a>, <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gab0de4758188ef0bdfaf1c11d5be091a7">cdcd_xfer_cb()</a>, <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gadcb9d9c9140560c62d498156da1e52f4">tud_cdc_line_coding_cb()</a>, <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gab7b995b92d92bbb627e286d81da4ceea">tud_cdc_line_state_cb()</a>, <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga3fe9fae111e700511a9b898c5f96073b">tud_cdc_n_write_clear()</a>, <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga57657c3d68869f8e903f8f1143898b1f">tud_cdc_rx_cb()</a>, <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gadf1d893ff0b83be89a6f073a7ac0d623">tud_cdc_rx_wanted_cb()</a>, <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga46f56a1b30adcc9fec602e4b7a258b25">tud_cdc_send_break_cb()</a>, and <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga6bed46c0fe94119b01c9a92453316cbf">tud_cdc_tx_complete_cb()</a>.</p>

</div>
</div>
<a id="ga57657c3d68869f8e903f8f1143898b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57657c3d68869f8e903f8f1143898b1f">&sect;&nbsp;</a></span>tud_cdc_rx_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TU_ATTR_WEAK void tud_cdc_rx_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>itf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function invoked when CDC interface receives data from host. </p>
<p>This callback is called when new data has been received from the USB host on the specified CDC interface. Application code should implement this function to process the received data. The received data can be retrieved using the <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gaa7f470c70e78c4685fbdb6b1ffd38d12" title="Read data from the default CDC interface. ">tud_cdc_read()</a> or <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#gabe59a6941bcfa522b54c464974f49194" title="Read data from CDC interface receive buffer. ">tud_cdc_n_read()</a> functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">itf</td><td>CDC interface number on which data was received </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga29e1d99d7141d60738e38ea3e2b02fee">tud_cdc_write_clear()</a>.</p>

</div>
</div>
<a id="gadf1d893ff0b83be89a6f073a7ac0d623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf1d893ff0b83be89a6f073a7ac0d623">&sect;&nbsp;</a></span>tud_cdc_rx_wanted_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TU_ATTR_WEAK void tud_cdc_rx_wanted_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>itf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>wanted_char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function invoked when a specific character is received. </p>
<p>This callback is triggered when the character previously set by <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga5697db72f8b9c08d07e90304ae5ef4e5" title="Set special character that will trigger a callback when received. ">tud_cdc_set_wanted_char()</a> is received on the specified CDC interface. This provides an efficient way to detect special characters in the incoming data stream without having to manually scan all received data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">itf</td><td>CDC interface number on which the character was received </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wanted_char</td><td>The specific character that was detected in the data stream </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga29e1d99d7141d60738e38ea3e2b02fee">tud_cdc_write_clear()</a>.</p>

</div>
</div>
<a id="ga6bed46c0fe94119b01c9a92453316cbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bed46c0fe94119b01c9a92453316cbf">&sect;&nbsp;</a></span>tud_cdc_tx_complete_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TU_ATTR_WEAK void tud_cdc_tx_complete_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>itf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function invoked when a CDC transmit operation completes. </p>
<p>This callback is triggered when all pending data in the CDC transmit buffer has been successfully sent to the USB host. It can be used to implement flow control or to initiate the next data transmission.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">itf</td><td>CDC interface number on which the transmission completed </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga29e1d99d7141d60738e38ea3e2b02fee">tud_cdc_write_clear()</a>.</p>

</div>
</div>
<a id="gab7b995b92d92bbb627e286d81da4ceea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7b995b92d92bbb627e286d81da4ceea">&sect;&nbsp;</a></span>tud_cdc_line_state_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TU_ATTR_WEAK void tud_cdc_line_state_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>itf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function invoked when CDC line state changes. </p>
<p>This callback is triggered when the USB host changes the CDC line state, specifically the DTR (Data Terminal Ready) and RTS (Request To Send) signals. It can be used to detect when a terminal program connects or disconnects from the CDC interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">itf</td><td>CDC interface number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dtr</td><td>True if Data Terminal Ready (DTR) is active </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rts</td><td>True if Request To Send (RTS) is active </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga29e1d99d7141d60738e38ea3e2b02fee">tud_cdc_write_clear()</a>.</p>

</div>
</div>
<a id="gadcb9d9c9140560c62d498156da1e52f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcb9d9c9140560c62d498156da1e52f4">&sect;&nbsp;</a></span>tud_cdc_line_coding_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TU_ATTR_WEAK void tud_cdc_line_coding_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>itf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cdc_line_coding_t const *&#160;</td>
          <td class="paramname"><em>p_line_coding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function invoked when CDC line coding parameters change. </p>
<p>This callback is triggered when the USB host changes the line coding parameters such as baud rate, data bits, parity, and stop bits. It allows the device to respond to these configuration changes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">itf</td><td>CDC interface number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_line_coding</td><td>Pointer to the new line coding parameters structure (cdc_line_coding_t) </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga29e1d99d7141d60738e38ea3e2b02fee">tud_cdc_write_clear()</a>.</p>

</div>
</div>
<a id="ga46f56a1b30adcc9fec602e4b7a258b25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46f56a1b30adcc9fec602e4b7a258b25">&sect;&nbsp;</a></span>tud_cdc_send_break_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TU_ATTR_WEAK void tud_cdc_send_break_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>itf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>duration_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function invoked when a break signal is received. </p>
<p>This callback is triggered when the USB host sends a break signal through the CDC interface. The duration parameter indicates the length of the break signal in milliseconds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">itf</td><td>CDC interface number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">duration_ms</td><td>Duration of the break signal in milliseconds </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga29e1d99d7141d60738e38ea3e2b02fee">tud_cdc_write_clear()</a>.</p>

</div>
</div>
<a id="ga6f0120f84ea5e8dc536b173b7b859e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f0120f84ea5e8dc536b173b7b859e2c">&sect;&nbsp;</a></span>cdcd_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cdcd_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize CDC device driver. </p>
<p>This internal function initializes the CDC device driver data structures and buffers. It's called during the USB device stack initialization process and should not be called directly by applications.</p>
<p>The function:</p><ul>
<li>Clears CDC interface structures</li>
<li>Sets default line coding parameters (115200 baud, 8N1)</li>
<li>Configures RX and TX FIFOs with appropriate buffer sizes</li>
<li>Sets up mutex protection for the FIFOs if OSAL_MUTEX_REQUIRED is enabled </li>
</ul>

<p>Referenced by <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga29e1d99d7141d60738e38ea3e2b02fee">tud_cdc_write_clear()</a>.</p>

</div>
</div>
<a id="ga47a09e6df07bb519719aa1c013e24778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47a09e6df07bb519719aa1c013e24778">&sect;&nbsp;</a></span>cdcd_deinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cdcd_deinit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deinitialize CDC device driver. </p>
<p>This internal function deinitializes the CDC device driver, releasing any resources that were allocated during initialization. It's called during the USB device stack deinitialization process and should not be called directly by applications.</p>
<p>The function:</p><ul>
<li>Releases any allocated buffers</li>
<li>Clears CDC interface state information</li>
<li>Destroys mutex protection for the FIFOs if OSAL_MUTEX_REQUIRED is enabled</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>bool true if deinitialization was successful, false otherwise </dd></dl>

<p>Referenced by <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga29e1d99d7141d60738e38ea3e2b02fee">tud_cdc_write_clear()</a>.</p>

</div>
</div>
<a id="ga5205506dcd48ae5e820e724c5bb171b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5205506dcd48ae5e820e724c5bb171b7">&sect;&nbsp;</a></span>cdcd_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cdcd_reset </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rhport</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset CDC device driver. </p>
<p>This internal function resets the CDC device driver to its initial state. It's called when a USB bus reset occurs or when the device is disconnected. The function resets all CDC interfaces to their default states without deallocating resources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhport</td><td>USB root hub port where the device is connected </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga29e1d99d7141d60738e38ea3e2b02fee">tud_cdc_write_clear()</a>.</p>

</div>
</div>
<a id="ga21eb9e0af7f0faf4f6aed7678830bc88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21eb9e0af7f0faf4f6aed7678830bc88">&sect;&nbsp;</a></span>cdcd_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t cdcd_open </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rhport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tusb_desc_interface_t const *&#160;</td>
          <td class="paramname"><em>itf_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open CDC device interface. </p>
<p>This internal function is called when a CDC interface is opened by the USB host. It prepares the specified CDC interface for operation by initializing its state and preparing the data structures needed for communication.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhport</td><td>USB root hub port where the device is connected </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">itf_desc</td><td>Interface descriptor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_len</td><td>Maximum length of the descriptor that can be processed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint16_t Number of bytes processed from the descriptor, or 0 if the descriptor cannot be processed </dd></dl>

<p>Referenced by <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga29e1d99d7141d60738e38ea3e2b02fee">tud_cdc_write_clear()</a>.</p>

</div>
</div>
<a id="ga89fc99d2107ec64712fe630691e89281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89fc99d2107ec64712fe630691e89281">&sect;&nbsp;</a></span>cdcd_control_xfer_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cdcd_control_xfer_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rhport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tusb_control_request_t const *&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CDC device control transfer callback. </p>
<p>This internal function handles USB control transfers specific to CDC interfaces. It processes CDC-specific requests such as SET_LINE_CODING, GET_LINE_CODING, SET_CONTROL_LINE_STATE, and SEND_BREAK.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhport</td><td>USB root hub port where the device is connected </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stage</td><td>Current stage of the control transfer (setup, data, ack) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">request</td><td>USB setup packet containing the control request</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if the control request was handled, false otherwise </dd></dl>

<p>Referenced by <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga29e1d99d7141d60738e38ea3e2b02fee">tud_cdc_write_clear()</a>.</p>

</div>
</div>
<a id="gab0de4758188ef0bdfaf1c11d5be091a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0de4758188ef0bdfaf1c11d5be091a7">&sect;&nbsp;</a></span>cdcd_xfer_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cdcd_xfer_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rhport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ep_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xfer_result_t&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xferred_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CDC device data transfer callback. </p>
<p>This internal function is called when a data transfer on a CDC endpoint completes. It handles both IN and OUT endpoint transfers, updating the appropriate FIFOs and invoking user callbacks when necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhport</td><td>USB root hub port where the device is connected </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep_addr</td><td>Endpoint address (including direction bit) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">result</td><td>Result of the transfer operation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xferred_bytes</td><td>Number of bytes transferred</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if the transfer was handled successfully, false otherwise </dd></dl>

<p>Referenced by <a class="el" href="group___c_d_c___d_e_v_i_c_e.html#ga29e1d99d7141d60738e38ea3e2b02fee">tud_cdc_write_clear()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">© Copyright 1995-2025</a>, Texas Instruments Incorporated. All rights reserved. <br/>
  <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
