<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>MSPM0L11XX_L13XX Driver Library: Serial Peripheral Interface (SPI)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MSPM0L11XX_L13XX Driver Library
   &#160;<span id="projectnumber">2.05.01.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Serial Peripheral Interface (SPI)</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Serial Peripheral Interface (SPI):</div>
<div class="dyncontent">
<center><table><tr><td><img src="group___s_p_i.png" border="0" alt="" usemap="#group______s__p__i"/>
<map name="group______s__p__i" id="group______s__p__i">
<area shape="rect" id="node1" href="group___d_l___s_p_i___d_m_a___i_n_t_e_r_r_u_p_t___r_x.html" title="DL_SPI_DMA_INTERRUPT_RX" alt="" coords="244,5,455,32"/>
<area shape="rect" id="node3" href="group___d_l___s_p_i___c_d___m_o_d_e.html" title="DL_SPI_CD_MODE" alt="" coords="280,56,419,83"/>
<area shape="rect" id="node4" href="group___d_l___s_p_i___i_n_t_e_r_r_u_p_t.html" title="DL_SPI_INTERRUPT" alt="" coords="276,107,423,133"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group___d_l___s_p_i___c_d___m_o_d_e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_l___s_p_i___c_d___m_o_d_e.html">DL_SPI_CD_MODE</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___d_l___s_p_i___i_n_t_e_r_r_u_p_t"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_l___s_p_i___i_n_t_e_r_r_u_p_t.html">DL_SPI_INTERRUPT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___d_l___s_p_i___d_m_a___i_n_t_e_r_r_u_p_t___r_x"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_l___s_p_i___d_m_a___i_n_t_e_r_r_u_p_t___r_x.html">DL_SPI_DMA_INTERRUPT_RX</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l___s_p_i___config.html">DL_SPI_Config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration struct for <a class="el" href="group___s_p_i.html#ga7bcdb2b1100ab58dbd64366feadfbf1e">DL_SPI_init</a>.  <a href="struct_d_l___s_p_i___config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l___s_p_i___clock_config.html">DL_SPI_ClockConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration struct for <a class="el" href="group___s_p_i.html#ga506f26dd75f5319b437ad6cf6fd44e2f">DL_SPI_setClockConfig</a>.  <a href="struct_d_l___s_p_i___clock_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l___s_p_i__backup_config.html">DL_SPI_backupConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration structure to backup SPI peripheral state before going to STOP/STANDBY mode. Used by <a class="el" href="group___s_p_i.html#gae172cfc4e1d9695af65d87198d19e89f">DL_SPI_saveConfiguration</a> and <a class="el" href="group___s_p_i.html#gab6405771e41906765135cf943ef43d03">DL_SPI_restoreConfiguration</a>.  <a href="struct_d_l___s_p_i__backup_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga7aee472abfd5d78dfdac23ea78f434b9"><td class="memItemLeft" align="right" valign="top"><a id="ga7aee472abfd5d78dfdac23ea78f434b9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga7aee472abfd5d78dfdac23ea78f434b9">DL_SPI_DMA_INTERRUPT_TX</a>&#160;&#160;&#160;(SPI_DMA_TRIG_TX_IMASK_TX_SET)</td></tr>
<tr class="memdesc:ga7aee472abfd5d78dfdac23ea78f434b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI interrupt for enabling SPI transmit as DMA trigger. <br /></td></tr>
<tr class="separator:ga7aee472abfd5d78dfdac23ea78f434b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gac662dc4ffc6d7fbd2c8059f9d978f0f6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gac662dc4ffc6d7fbd2c8059f9d978f0f6">DL_SPI_DMA_IIDX_RX</a> { <br />
&#160;&#160;<a class="el" href="group___s_p_i.html#ggac662dc4ffc6d7fbd2c8059f9d978f0f6a9c8fe591502b5d60b8c0a464331f1624">DL_SPI_DMA_IIDX_RX_TRIGGER</a> = SPI_DMA_TRIG_RX_IIDX_STAT_RX_EVT, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#ggac662dc4ffc6d7fbd2c8059f9d978f0f6ad5d4be77f142e7e0296984024f532cb4">DL_SPI_DMA_IIDX_RX_TIMEOUT_TRIGGER</a> = SPI_DMA_TRIG_RX_IIDX_STAT_RTOUT_EVT
<br />
 }</td></tr>
<tr class="separator:gac662dc4ffc6d7fbd2c8059f9d978f0f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4edac7e2fad897c33fddb539363eabdd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga4edac7e2fad897c33fddb539363eabdd">DL_SPI_DMA_IIDX_TX</a> { <a class="el" href="group___s_p_i.html#gga4edac7e2fad897c33fddb539363eabdda4376892f01b53c8ea6f16c40bb86e391">DL_SPI_DMA_IIDX_TX_TRIGGER</a> = SPI_DMA_TRIG_TX_IIDX_STAT_TX_EVT
 }</td></tr>
<tr class="separator:ga4edac7e2fad897c33fddb539363eabdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga773029828a0b68cdff80d13e1fda363b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga773029828a0b68cdff80d13e1fda363b">DL_SPI_PARITY</a> { <br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga773029828a0b68cdff80d13e1fda363bafb807f04f1ff9e7a680743f613911af6">DL_SPI_PARITY_EVEN</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga773029828a0b68cdff80d13e1fda363ba08e50ae539ffea21d62f322349d88814">DL_SPI_PARITY_ODD</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga773029828a0b68cdff80d13e1fda363ba74d6cfb81a9045badfdeed0b05064ef7">DL_SPI_PARITY_NONE</a> = (SPI_CTL1_PREN_DISABLE | SPI_CTL1_PTEN_DISABLE)
<br />
 }</td></tr>
<tr class="separator:ga773029828a0b68cdff80d13e1fda363b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1778f795709b41d93eb1408b279e1bd1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga1778f795709b41d93eb1408b279e1bd1">DL_SPI_FRAME_FORMAT</a> { <br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga1778f795709b41d93eb1408b279e1bd1a27a4ca6631bdd276011fbbc5945adedd">DL_SPI_FRAME_FORMAT_MOTO3_POL0_PHA0</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga1778f795709b41d93eb1408b279e1bd1a7698d1a20993904d623376c374336e96">DL_SPI_FRAME_FORMAT_MOTO3_POL0_PHA1</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga1778f795709b41d93eb1408b279e1bd1a3e642fe572393dff885f0b6398fe1517">DL_SPI_FRAME_FORMAT_MOTO3_POL1_PHA0</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga1778f795709b41d93eb1408b279e1bd1a467532e43794c934d5fde685d6092527">DL_SPI_FRAME_FORMAT_MOTO3_POL1_PHA1</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga1778f795709b41d93eb1408b279e1bd1a889cdba0616273308242070aa3c23415">DL_SPI_FRAME_FORMAT_MOTO4_POL0_PHA0</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga1778f795709b41d93eb1408b279e1bd1aea1a45f04370098f4e1e088c3ff39920">DL_SPI_FRAME_FORMAT_MOTO4_POL0_PHA1</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga1778f795709b41d93eb1408b279e1bd1a1680c3cab4e46cd6e5fff0e1f3b31e76">DL_SPI_FRAME_FORMAT_MOTO4_POL1_PHA0</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga1778f795709b41d93eb1408b279e1bd1ae1c69be67fdb1c844425a33cb21335bd">DL_SPI_FRAME_FORMAT_MOTO4_POL1_PHA1</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga1778f795709b41d93eb1408b279e1bd1a510e2fbaed450b103d75b09f4dbfd0b7">DL_SPI_FRAME_FORMAT_TI_SYNC</a> = (SPI_CTL0_FRF_TI_SYNC)
<br />
 }</td></tr>
<tr class="separator:ga1778f795709b41d93eb1408b279e1bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5d9c38bb4fa37d93aaa0e67eb22b7ae"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gab5d9c38bb4fa37d93aaa0e67eb22b7ae">DL_SPI_MODE</a> { <br />
&#160;&#160;<a class="el" href="group___s_p_i.html#ggab5d9c38bb4fa37d93aaa0e67eb22b7aea5b07b2b02432e3eeee94da49ba286b7f">DL_SPI_MODE_CONTROLLER</a> = (SPI_CTL1_CP_ENABLE), 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#ggab5d9c38bb4fa37d93aaa0e67eb22b7aea3db1834c8f1ce6b1ac97bb86587bf0fe">DL_SPI_MODE_PERIPHERAL</a> = (SPI_CTL1_CP_DISABLE)
<br />
 }</td></tr>
<tr class="separator:gab5d9c38bb4fa37d93aaa0e67eb22b7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79d02b79cd7d5383b93311454ed5f3ef"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga79d02b79cd7d5383b93311454ed5f3ef">DL_SPI_BIT_ORDER</a> { <br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga79d02b79cd7d5383b93311454ed5f3efaf2bceaa49d585bf730cebb88c121fcf9">DL_SPI_BIT_ORDER_MSB_FIRST</a> = (SPI_CTL1_MSB_ENABLE), 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga79d02b79cd7d5383b93311454ed5f3efab084a7b9a774fbcf58eba78342e9f9ea">DL_SPI_BIT_ORDER_LSB_FIRST</a> = (SPI_CTL1_MSB_DISABLE)
<br />
 }</td></tr>
<tr class="separator:ga79d02b79cd7d5383b93311454ed5f3ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06925b84fe07eb69a8e1f23ab30d80da"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga06925b84fe07eb69a8e1f23ab30d80da">DL_SPI_DATA_SIZE</a> { <br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga06925b84fe07eb69a8e1f23ab30d80daa7997ed3f079a0266f4a469cb63fec786">DL_SPI_DATA_SIZE_4</a> = (SPI_CTL0_DSS_DSS_4), 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga06925b84fe07eb69a8e1f23ab30d80daaa6e8f410f354e563f0e23b905b5f13bb">DL_SPI_DATA_SIZE_5</a> = (SPI_CTL0_DSS_DSS_5), 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga06925b84fe07eb69a8e1f23ab30d80daa3fa58ffbefaf1022f39003eb1b28b0b0">DL_SPI_DATA_SIZE_6</a> = (SPI_CTL0_DSS_DSS_6), 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga06925b84fe07eb69a8e1f23ab30d80daaf01c3d840262daea42d9a29b08edcd0c">DL_SPI_DATA_SIZE_7</a> = (SPI_CTL0_DSS_DSS_7), 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga06925b84fe07eb69a8e1f23ab30d80daa7343ddb73f93ee03440626df4f549e89">DL_SPI_DATA_SIZE_8</a> = (SPI_CTL0_DSS_DSS_8), 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga06925b84fe07eb69a8e1f23ab30d80daa3f3ef2ecc4791e7f97c789ca64d37026">DL_SPI_DATA_SIZE_9</a> = (SPI_CTL0_DSS_DSS_9), 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga06925b84fe07eb69a8e1f23ab30d80daa9b1d16811f116e0b793ebb68c83d4b4b">DL_SPI_DATA_SIZE_10</a> = (SPI_CTL0_DSS_DSS_10), 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga06925b84fe07eb69a8e1f23ab30d80daa8b6473c34ee7b4ffcea9fa5bd304ce8f">DL_SPI_DATA_SIZE_11</a> = (SPI_CTL0_DSS_DSS_11), 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga06925b84fe07eb69a8e1f23ab30d80daa5c72f5a5d5cc7edddbb432641d80e906">DL_SPI_DATA_SIZE_12</a> = (SPI_CTL0_DSS_DSS_12), 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga06925b84fe07eb69a8e1f23ab30d80daa6e283c1d9f3bf5f511629bf1a31889bd">DL_SPI_DATA_SIZE_13</a> = (SPI_CTL0_DSS_DSS_13), 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga06925b84fe07eb69a8e1f23ab30d80daab0d18a521582b11fcdcefe2f01f6dc77">DL_SPI_DATA_SIZE_14</a> = (SPI_CTL0_DSS_DSS_14), 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga06925b84fe07eb69a8e1f23ab30d80daa8a31728e462d2811bf7e7b4d99a16ad2">DL_SPI_DATA_SIZE_15</a> = (SPI_CTL0_DSS_DSS_15), 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga06925b84fe07eb69a8e1f23ab30d80daa72419facdf4f677b84a4c5b555d30d4e">DL_SPI_DATA_SIZE_16</a> = (SPI_CTL0_DSS_DSS_16)
<br />
 }</td></tr>
<tr class="separator:ga06925b84fe07eb69a8e1f23ab30d80da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5b7531f268fb581f2f3117bd08eb4a0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gac5b7531f268fb581f2f3117bd08eb4a0">DL_SPI_CHIP_SELECT</a> { <br />
&#160;&#160;<a class="el" href="group___s_p_i.html#ggac5b7531f268fb581f2f3117bd08eb4a0a04e270bb79f5f11f6858dc5247d193ec">DL_SPI_CHIP_SELECT_0</a> = (SPI_CTL0_CSSEL_CSSEL_0), 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#ggac5b7531f268fb581f2f3117bd08eb4a0aada96b045390f06063629996abe875e8">DL_SPI_CHIP_SELECT_1</a> = (SPI_CTL0_CSSEL_CSSEL_1), 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#ggac5b7531f268fb581f2f3117bd08eb4a0adc9526b4f2bb7908ad2375aa33a9b856">DL_SPI_CHIP_SELECT_2</a> = (SPI_CTL0_CSSEL_CSSEL_2), 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#ggac5b7531f268fb581f2f3117bd08eb4a0a93b0df91104ed89ecdb148c212fd3708">DL_SPI_CHIP_SELECT_3</a> = (SPI_CTL0_CSSEL_CSSEL_3), 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#ggac5b7531f268fb581f2f3117bd08eb4a0a1fc468efce3d853c9425a3d3ecda61fd">DL_SPI_CHIP_SELECT_NONE</a> = (0)
<br />
 }</td></tr>
<tr class="separator:gac5b7531f268fb581f2f3117bd08eb4a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15208bcdee85c9fdd007a85e761a4843"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga15208bcdee85c9fdd007a85e761a4843">DL_SPI_TX_FIFO_LEVEL</a> { <br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga15208bcdee85c9fdd007a85e761a4843abb43613de18290dda1cec93c708c5396">DL_SPI_TX_FIFO_LEVEL_3_4_EMPTY</a> = SPI_IFLS_TXIFLSEL_LVL_3_4, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga15208bcdee85c9fdd007a85e761a4843a6f14fbf777adbf55ce16dbe062cdf31c">DL_SPI_TX_FIFO_LEVEL_1_2_EMPTY</a> = SPI_IFLS_TXIFLSEL_LVL_1_2, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga15208bcdee85c9fdd007a85e761a4843a9e34611ade1ee18e1bf53b0ecc1ebf39">DL_SPI_TX_FIFO_LEVEL_1_4_EMPTY</a> = SPI_IFLS_TXIFLSEL_LVL_1_4, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga15208bcdee85c9fdd007a85e761a4843a99805227a259d9b05d640b29f2997a15">DL_SPI_TX_FIFO_LEVEL_EMPTY</a> = SPI_IFLS_TXIFLSEL_LVL_EMPTY, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga15208bcdee85c9fdd007a85e761a4843af9ee1cf64d3159c7b5d3d2e0d46059a9">DL_SPI_TX_FIFO_LEVEL_ONE_FRAME</a> = SPI_IFLS_TXIFLSEL_LEVEL_1
<br />
 }</td></tr>
<tr class="separator:ga15208bcdee85c9fdd007a85e761a4843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad62dc10499a7ad2a0285128125f75b51"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gad62dc10499a7ad2a0285128125f75b51">DL_SPI_RX_FIFO_LEVEL</a> { <br />
&#160;&#160;<a class="el" href="group___s_p_i.html#ggad62dc10499a7ad2a0285128125f75b51a58da669c09210fbd7d66c535c3f52d0d">DL_SPI_RX_FIFO_LEVEL_ONE_FRAME</a> = SPI_IFLS_RXIFLSEL_LEVEL_1, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#ggad62dc10499a7ad2a0285128125f75b51a9c682129358968ea39ab7c069142b124">DL_SPI_RX_FIFO_LEVEL_FULL</a> = SPI_IFLS_RXIFLSEL_LVL_FULL, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#ggad62dc10499a7ad2a0285128125f75b51ab4aed4387e855feae1cbe6d8e99dda09">DL_SPI_RX_FIFO_LEVEL_3_4_FULL</a> = SPI_IFLS_RXIFLSEL_LVL_3_4, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#ggad62dc10499a7ad2a0285128125f75b51ae737c589bc33852c2a667e4dec8622d4">DL_SPI_RX_FIFO_LEVEL_1_2_FULL</a> = SPI_IFLS_RXIFLSEL_LVL_1_2, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#ggad62dc10499a7ad2a0285128125f75b51aad46bfbffdf2e46071271a9b53ed2e02">DL_SPI_RX_FIFO_LEVEL_1_4_FULL</a> = SPI_IFLS_RXIFLSEL_LVL_1_4
<br />
 }</td></tr>
<tr class="separator:gad62dc10499a7ad2a0285128125f75b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2856971e4f44c549983e6358d0fde683"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga2856971e4f44c549983e6358d0fde683">DL_SPI_IIDX</a> { <br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga2856971e4f44c549983e6358d0fde683ada8236595ccbd339e18d7bac60a1f9c5">DL_SPI_IIDX_DMA_DONE_TX</a> = SPI_CPU_INT_IIDX_STAT_DMA_DONE_TX_EVT, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga2856971e4f44c549983e6358d0fde683ad66d08e9d70cab90afb1be5394a60ff0">DL_SPI_IIDX_DMA_DONE_RX</a> = SPI_CPU_INT_IIDX_STAT_DMA_DONE_RX_EVT, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga2856971e4f44c549983e6358d0fde683a6bac3917b4fbe3ef3f430c39c6993887">DL_SPI_IIDX_IDLE</a> = SPI_CPU_INT_IIDX_STAT_IDLE_EVT, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga2856971e4f44c549983e6358d0fde683aa2bc017cf293a353c915ceeef37b7191">DL_SPI_IIDX_TX_EMPTY</a> = SPI_CPU_INT_IIDX_STAT_TX_EMPTY, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga2856971e4f44c549983e6358d0fde683af4d318475c008712649630977815f658">DL_SPI_IIDX_TX</a> = SPI_CPU_INT_IIDX_STAT_TX_EVT, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga2856971e4f44c549983e6358d0fde683aeae8178b043e82392af6aa3610c002d7">DL_SPI_IIDX_RX</a> = SPI_CPU_INT_IIDX_STAT_RX_EVT, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga2856971e4f44c549983e6358d0fde683a1845f4c15b4aeb3a851d231df83f0351">DL_SPI_IIDX_RX_TIMEOUT</a> = SPI_CPU_INT_IIDX_STAT_RTOUT_EVT, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga2856971e4f44c549983e6358d0fde683a22e489f7f850aeff02d28181b8c9aa40">DL_SPI_IIDX_RX_FULL</a> = SPI_CPU_INT_IIDX_STAT_RXFULL_EVT, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga2856971e4f44c549983e6358d0fde683ad8d4f9e952f648a5fdeeeed097b414d3">DL_SPI_IIDX_TX_UNDERFLOW</a> = SPI_CPU_INT_IIDX_STAT_TXFIFO_UNF_EVT, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga2856971e4f44c549983e6358d0fde683abbe680e02dae4b5932c47577b00e0eb1">DL_SPI_IIDX_PARITY_ERROR</a> = SPI_CPU_INT_IIDX_STAT_PER_EVT, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga2856971e4f44c549983e6358d0fde683a0b53f7111949b1d8b08e65f44d7845a7">DL_SPI_IIDX_RX_OVERFLOW</a> = SPI_CPU_INT_IIDX_STAT_RXFIFO_OFV_EVT
<br />
 }</td></tr>
<tr class="separator:ga2856971e4f44c549983e6358d0fde683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5eaef8ef8e93903687af3edd8b3684e5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga5eaef8ef8e93903687af3edd8b3684e5">DL_SPI_CLOCK_DIVIDE_RATIO</a> { <br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga5eaef8ef8e93903687af3edd8b3684e5a42c4d8e044a542ef104786973a4e4984">DL_SPI_CLOCK_DIVIDE_RATIO_1</a> = SPI_CLKDIV_RATIO_DIV_BY_1, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga5eaef8ef8e93903687af3edd8b3684e5a29d85bce11775e265d98b07d16019a89">DL_SPI_CLOCK_DIVIDE_RATIO_2</a> = SPI_CLKDIV_RATIO_DIV_BY_2, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga5eaef8ef8e93903687af3edd8b3684e5addda6d99499d349f4355d1e2b9c634b2">DL_SPI_CLOCK_DIVIDE_RATIO_3</a> = SPI_CLKDIV_RATIO_DIV_BY_3, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga5eaef8ef8e93903687af3edd8b3684e5ad6e2c336b339209383e69ef114344b8c">DL_SPI_CLOCK_DIVIDE_RATIO_4</a> = SPI_CLKDIV_RATIO_DIV_BY_4, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga5eaef8ef8e93903687af3edd8b3684e5a03e0631527626808afee6782ac3cf644">DL_SPI_CLOCK_DIVIDE_RATIO_5</a> = SPI_CLKDIV_RATIO_DIV_BY_5, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga5eaef8ef8e93903687af3edd8b3684e5a9a2f53485e5e406d87014888adf9e0d7">DL_SPI_CLOCK_DIVIDE_RATIO_6</a> = SPI_CLKDIV_RATIO_DIV_BY_6, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga5eaef8ef8e93903687af3edd8b3684e5aa13ed10b6b2ea0e346ac3257daeec59e">DL_SPI_CLOCK_DIVIDE_RATIO_7</a> = SPI_CLKDIV_RATIO_DIV_BY_7, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga5eaef8ef8e93903687af3edd8b3684e5ac0bbf359eb360b92a3b4ef81da1f73f4">DL_SPI_CLOCK_DIVIDE_RATIO_8</a> = SPI_CLKDIV_RATIO_DIV_BY_8
<br />
 }</td></tr>
<tr class="separator:ga5eaef8ef8e93903687af3edd8b3684e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacadd49262d90984a5c6ff8aec05762f8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gacadd49262d90984a5c6ff8aec05762f8">DL_SPI_CLOCK</a> { <br />
&#160;&#160;<a class="el" href="group___s_p_i.html#ggacadd49262d90984a5c6ff8aec05762f8a139558fe09fdf42df80cae07513ef15e">DL_SPI_CLOCK_BUSCLK</a> = SPI_CLKSEL_SYSCLK_SEL_ENABLE, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#ggacadd49262d90984a5c6ff8aec05762f8a5990f8c8231fdce6d11e600197bbb05c">DL_SPI_CLOCK_MFCLK</a> = SPI_CLKSEL_MFCLK_SEL_ENABLE, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#ggacadd49262d90984a5c6ff8aec05762f8a842d8879838b01e15eeeb872cd8642b9">DL_SPI_CLOCK_LFCLK</a> = SPI_CLKSEL_LFCLK_SEL_ENABLE
<br />
 }</td></tr>
<tr class="separator:gacadd49262d90984a5c6ff8aec05762f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7bcdb2b1100ab58dbd64366feadfbf1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga7bcdb2b1100ab58dbd64366feadfbf1e">DL_SPI_init</a> (SPI_Regs *spi, const <a class="el" href="struct_d_l___s_p_i___config.html">DL_SPI_Config</a> *config)</td></tr>
<tr class="memdesc:ga7bcdb2b1100ab58dbd64366feadfbf1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the SPI peripheral.  <a href="#ga7bcdb2b1100ab58dbd64366feadfbf1e">More...</a><br /></td></tr>
<tr class="separator:ga7bcdb2b1100ab58dbd64366feadfbf1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga251d33c1951365dad8e4850bfe49bcc7"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga251d33c1951365dad8e4850bfe49bcc7">DL_SPI_enablePower</a> (SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga251d33c1951365dad8e4850bfe49bcc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the Peripheral Write Enable (PWREN) register for the SPI.  <a href="#ga251d33c1951365dad8e4850bfe49bcc7">More...</a><br /></td></tr>
<tr class="separator:ga251d33c1951365dad8e4850bfe49bcc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga750d9c1fcb11d51008a1b760e741f38e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga750d9c1fcb11d51008a1b760e741f38e">DL_SPI_disablePower</a> (SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga750d9c1fcb11d51008a1b760e741f38e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the Peripheral Write Enable (PWREN) register for the SPI.  <a href="#ga750d9c1fcb11d51008a1b760e741f38e">More...</a><br /></td></tr>
<tr class="separator:ga750d9c1fcb11d51008a1b760e741f38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe45eb6bdf7219a5ebe6124bc11989a0"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gabe45eb6bdf7219a5ebe6124bc11989a0">DL_SPI_isPowerEnabled</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:gabe45eb6bdf7219a5ebe6124bc11989a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the Peripheral Write Enable (PWREN) register for the SPI is enabled.  <a href="#gabe45eb6bdf7219a5ebe6124bc11989a0">More...</a><br /></td></tr>
<tr class="separator:gabe45eb6bdf7219a5ebe6124bc11989a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12b8798df3c18c5065d9eb86c568ee6b"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga12b8798df3c18c5065d9eb86c568ee6b">DL_SPI_reset</a> (SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga12b8798df3c18c5065d9eb86c568ee6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets spi peripheral.  <a href="#ga12b8798df3c18c5065d9eb86c568ee6b">More...</a><br /></td></tr>
<tr class="separator:ga12b8798df3c18c5065d9eb86c568ee6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab51bd85ac83b08f3bae584a82492e17f"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gab51bd85ac83b08f3bae584a82492e17f">DL_SPI_isReset</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:gab51bd85ac83b08f3bae584a82492e17f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if spi peripheral was reset.  <a href="#gab51bd85ac83b08f3bae584a82492e17f">More...</a><br /></td></tr>
<tr class="separator:gab51bd85ac83b08f3bae584a82492e17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a40961940d940325e1b41ead149a843"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga0a40961940d940325e1b41ead149a843">DL_SPI_enable</a> (SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga0a40961940d940325e1b41ead149a843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the SPI peripheral.  <a href="#ga0a40961940d940325e1b41ead149a843">More...</a><br /></td></tr>
<tr class="separator:ga0a40961940d940325e1b41ead149a843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga192cea97b92bf07c52f9d4701c364720"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga192cea97b92bf07c52f9d4701c364720">DL_SPI_isEnabled</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga192cea97b92bf07c52f9d4701c364720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the SPI peripheral is enabled.  <a href="#ga192cea97b92bf07c52f9d4701c364720">More...</a><br /></td></tr>
<tr class="separator:ga192cea97b92bf07c52f9d4701c364720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09199015c560aefd53f38b724bf2377e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga09199015c560aefd53f38b724bf2377e">DL_SPI_disable</a> (SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga09199015c560aefd53f38b724bf2377e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the SPI peripheral.  <a href="#ga09199015c560aefd53f38b724bf2377e">More...</a><br /></td></tr>
<tr class="separator:ga09199015c560aefd53f38b724bf2377e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga506f26dd75f5319b437ad6cf6fd44e2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga506f26dd75f5319b437ad6cf6fd44e2f">DL_SPI_setClockConfig</a> (SPI_Regs *spi, const <a class="el" href="struct_d_l___s_p_i___clock_config.html">DL_SPI_ClockConfig</a> *config)</td></tr>
<tr class="memdesc:ga506f26dd75f5319b437ad6cf6fd44e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure SPI source clock.  <a href="#ga506f26dd75f5319b437ad6cf6fd44e2f">More...</a><br /></td></tr>
<tr class="separator:ga506f26dd75f5319b437ad6cf6fd44e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc50a08fe4900de16ca36f49bfd4d793"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gabc50a08fe4900de16ca36f49bfd4d793">DL_SPI_getClockConfig</a> (const SPI_Regs *spi, <a class="el" href="struct_d_l___s_p_i___clock_config.html">DL_SPI_ClockConfig</a> *config)</td></tr>
<tr class="memdesc:gabc50a08fe4900de16ca36f49bfd4d793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get SPI source clock configuration.  <a href="#gabc50a08fe4900de16ca36f49bfd4d793">More...</a><br /></td></tr>
<tr class="separator:gabc50a08fe4900de16ca36f49bfd4d793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18c0f490973a924325b5e99e9efd9033"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga18c0f490973a924325b5e99e9efd9033">DL_SPI_isBusy</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga18c0f490973a924325b5e99e9efd9033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the SPI is busy transmitting.  <a href="#ga18c0f490973a924325b5e99e9efd9033">More...</a><br /></td></tr>
<tr class="separator:ga18c0f490973a924325b5e99e9efd9033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaadbd0fa4cd5497cea0e15f723fd328"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gacaadbd0fa4cd5497cea0e15f723fd328">DL_SPI_isTXFIFOEmpty</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:gacaadbd0fa4cd5497cea0e15f723fd328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the TX FIFO is empty.  <a href="#gacaadbd0fa4cd5497cea0e15f723fd328">More...</a><br /></td></tr>
<tr class="separator:gacaadbd0fa4cd5497cea0e15f723fd328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02f1ebf87a797e2be89ae2b2843db431"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga02f1ebf87a797e2be89ae2b2843db431">DL_SPI_isTXFIFOFull</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga02f1ebf87a797e2be89ae2b2843db431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the TX FIFO is full.  <a href="#ga02f1ebf87a797e2be89ae2b2843db431">More...</a><br /></td></tr>
<tr class="separator:ga02f1ebf87a797e2be89ae2b2843db431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b4632aa604b78631e255e974e4d6e77"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga8b4632aa604b78631e255e974e4d6e77">DL_SPI_isRXFIFOEmpty</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga8b4632aa604b78631e255e974e4d6e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the RX FIFO is empty.  <a href="#ga8b4632aa604b78631e255e974e4d6e77">More...</a><br /></td></tr>
<tr class="separator:ga8b4632aa604b78631e255e974e4d6e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ec87dd4175e15a2987824d2a3e172ce"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga8ec87dd4175e15a2987824d2a3e172ce">DL_SPI_isRXFIFOFull</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga8ec87dd4175e15a2987824d2a3e172ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the RX FIFO is full.  <a href="#ga8ec87dd4175e15a2987824d2a3e172ce">More...</a><br /></td></tr>
<tr class="separator:ga8ec87dd4175e15a2987824d2a3e172ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff618299ef6569927676f5e6ca6a1922"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gaff618299ef6569927676f5e6ca6a1922">DL_SPI_setParity</a> (SPI_Regs *spi, <a class="el" href="group___s_p_i.html#ga773029828a0b68cdff80d13e1fda363b">DL_SPI_PARITY</a> parity)</td></tr>
<tr class="memdesc:gaff618299ef6569927676f5e6ca6a1922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the parity configuration used for transactions.  <a href="#gaff618299ef6569927676f5e6ca6a1922">More...</a><br /></td></tr>
<tr class="separator:gaff618299ef6569927676f5e6ca6a1922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c4a7b9791ecca17d0271fe7ecf0395b"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___s_p_i.html#ga773029828a0b68cdff80d13e1fda363b">DL_SPI_PARITY</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga5c4a7b9791ecca17d0271fe7ecf0395b">DL_SPI_getParity</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga5c4a7b9791ecca17d0271fe7ecf0395b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current receive and transmit parity configuration.  <a href="#ga5c4a7b9791ecca17d0271fe7ecf0395b">More...</a><br /></td></tr>
<tr class="separator:ga5c4a7b9791ecca17d0271fe7ecf0395b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4881e1a2ac73d62c56314387df91437f"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga4881e1a2ac73d62c56314387df91437f">DL_SPI_enableReceiveParity</a> (SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga4881e1a2ac73d62c56314387df91437f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables receive parity.  <a href="#ga4881e1a2ac73d62c56314387df91437f">More...</a><br /></td></tr>
<tr class="separator:ga4881e1a2ac73d62c56314387df91437f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga711ec7e7000ae8647244df1ec0e000ad"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga711ec7e7000ae8647244df1ec0e000ad">DL_SPI_disableReceiveParity</a> (SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga711ec7e7000ae8647244df1ec0e000ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables receive parity.  <a href="#ga711ec7e7000ae8647244df1ec0e000ad">More...</a><br /></td></tr>
<tr class="separator:ga711ec7e7000ae8647244df1ec0e000ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabefe2e5c8312d0e85359f7c6061e69ce"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gabefe2e5c8312d0e85359f7c6061e69ce">DL_SPI_isReceiveParityEnabled</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:gabefe2e5c8312d0e85359f7c6061e69ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if receive parity is enabled.  <a href="#gabefe2e5c8312d0e85359f7c6061e69ce">More...</a><br /></td></tr>
<tr class="separator:gabefe2e5c8312d0e85359f7c6061e69ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf3c638f0e8aaa977f819be8a30d04ca"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gadf3c638f0e8aaa977f819be8a30d04ca">DL_SPI_enableTransmitParity</a> (SPI_Regs *spi)</td></tr>
<tr class="memdesc:gadf3c638f0e8aaa977f819be8a30d04ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables transmit parity.  <a href="#gadf3c638f0e8aaa977f819be8a30d04ca">More...</a><br /></td></tr>
<tr class="separator:gadf3c638f0e8aaa977f819be8a30d04ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad881d36c83db69c35fe1211e0c53920b"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gad881d36c83db69c35fe1211e0c53920b">DL_SPI_disableTransmitParity</a> (SPI_Regs *spi)</td></tr>
<tr class="memdesc:gad881d36c83db69c35fe1211e0c53920b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables transmit parity.  <a href="#gad881d36c83db69c35fe1211e0c53920b">More...</a><br /></td></tr>
<tr class="separator:gad881d36c83db69c35fe1211e0c53920b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfb2de588357e1010fc4d25afb110dd3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gabfb2de588357e1010fc4d25afb110dd3">DL_SPI_isTransmitParityEnabled</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:gabfb2de588357e1010fc4d25afb110dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if transmit parity is enabled.  <a href="#gabfb2de588357e1010fc4d25afb110dd3">More...</a><br /></td></tr>
<tr class="separator:gabfb2de588357e1010fc4d25afb110dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4913586ba59c5143952522934ca550a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gae4913586ba59c5143952522934ca550a">DL_SPI_setFrameFormat</a> (SPI_Regs *spi, <a class="el" href="group___s_p_i.html#ga1778f795709b41d93eb1408b279e1bd1">DL_SPI_FRAME_FORMAT</a> frameFormat)</td></tr>
<tr class="memdesc:gae4913586ba59c5143952522934ca550a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the frame format to use.  <a href="#gae4913586ba59c5143952522934ca550a">More...</a><br /></td></tr>
<tr class="separator:gae4913586ba59c5143952522934ca550a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10784e1384b10451ec0d6d732f2b70d4"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___s_p_i.html#ga1778f795709b41d93eb1408b279e1bd1">DL_SPI_FRAME_FORMAT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga10784e1384b10451ec0d6d732f2b70d4">DL_SPI_getFrameFormat</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga10784e1384b10451ec0d6d732f2b70d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the frame format configuration.  <a href="#ga10784e1384b10451ec0d6d732f2b70d4">More...</a><br /></td></tr>
<tr class="separator:ga10784e1384b10451ec0d6d732f2b70d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb7227ea45c66da923fc1dd644f27122"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gabb7227ea45c66da923fc1dd644f27122">DL_SPI_setDataSize</a> (SPI_Regs *spi, <a class="el" href="group___s_p_i.html#ga06925b84fe07eb69a8e1f23ab30d80da">DL_SPI_DATA_SIZE</a> dataSize)</td></tr>
<tr class="memdesc:gabb7227ea45c66da923fc1dd644f27122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the size for transfers.  <a href="#gabb7227ea45c66da923fc1dd644f27122">More...</a><br /></td></tr>
<tr class="separator:gabb7227ea45c66da923fc1dd644f27122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d6329786f3972f228b324b03c2f649e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___s_p_i.html#ga06925b84fe07eb69a8e1f23ab30d80da">DL_SPI_DATA_SIZE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga9d6329786f3972f228b324b03c2f649e">DL_SPI_getDataSize</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga9d6329786f3972f228b324b03c2f649e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the configured size for transfers.  <a href="#ga9d6329786f3972f228b324b03c2f649e">More...</a><br /></td></tr>
<tr class="separator:ga9d6329786f3972f228b324b03c2f649e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d153fe0c2f28f8c4165c0bce4c895cf"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga7d153fe0c2f28f8c4165c0bce4c895cf">DL_SPI_setMode</a> (SPI_Regs *spi, <a class="el" href="group___s_p_i.html#gab5d9c38bb4fa37d93aaa0e67eb22b7ae">DL_SPI_MODE</a> mode)</td></tr>
<tr class="memdesc:ga7d153fe0c2f28f8c4165c0bce4c895cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether the device should be in controller/peripheral mode.  <a href="#ga7d153fe0c2f28f8c4165c0bce4c895cf">More...</a><br /></td></tr>
<tr class="separator:ga7d153fe0c2f28f8c4165c0bce4c895cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6004442fbd29c2ed4cb07a7ad16e140b"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___s_p_i.html#gab5d9c38bb4fa37d93aaa0e67eb22b7ae">DL_SPI_MODE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga6004442fbd29c2ed4cb07a7ad16e140b">DL_SPI_getMode</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga6004442fbd29c2ed4cb07a7ad16e140b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current mode for the SPI (controller/peripheral)  <a href="#ga6004442fbd29c2ed4cb07a7ad16e140b">More...</a><br /></td></tr>
<tr class="separator:ga6004442fbd29c2ed4cb07a7ad16e140b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2eef87b89f47d4bfa2b110ee2232fc7a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga2eef87b89f47d4bfa2b110ee2232fc7a">DL_SPI_setBitOrder</a> (SPI_Regs *spi, <a class="el" href="group___s_p_i.html#ga79d02b79cd7d5383b93311454ed5f3ef">DL_SPI_BIT_ORDER</a> bitOrder)</td></tr>
<tr class="memdesc:ga2eef87b89f47d4bfa2b110ee2232fc7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the bit order used for transfers.  <a href="#ga2eef87b89f47d4bfa2b110ee2232fc7a">More...</a><br /></td></tr>
<tr class="separator:ga2eef87b89f47d4bfa2b110ee2232fc7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace909483aab21f028a68e76f11b03a04"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___s_p_i.html#ga79d02b79cd7d5383b93311454ed5f3ef">DL_SPI_BIT_ORDER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gace909483aab21f028a68e76f11b03a04">DL_SPI_getBitOrder</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:gace909483aab21f028a68e76f11b03a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current bit order used for transfers.  <a href="#gace909483aab21f028a68e76f11b03a04">More...</a><br /></td></tr>
<tr class="separator:gace909483aab21f028a68e76f11b03a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95f58fa6481f1096caf19b5bde02a721"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga95f58fa6481f1096caf19b5bde02a721">DL_SPI_enableLoopbackMode</a> (SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga95f58fa6481f1096caf19b5bde02a721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables loopback mode.  <a href="#ga95f58fa6481f1096caf19b5bde02a721">More...</a><br /></td></tr>
<tr class="separator:ga95f58fa6481f1096caf19b5bde02a721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fea93168e5ed13fdbfcbb2fdc5eaf29"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga1fea93168e5ed13fdbfcbb2fdc5eaf29">DL_SPI_disableLoopbackMode</a> (SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga1fea93168e5ed13fdbfcbb2fdc5eaf29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables loopback mode.  <a href="#ga1fea93168e5ed13fdbfcbb2fdc5eaf29">More...</a><br /></td></tr>
<tr class="separator:ga1fea93168e5ed13fdbfcbb2fdc5eaf29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1ba6608163cf3db3f01ef92acfc605e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gad1ba6608163cf3db3f01ef92acfc605e">DL_SPI_isLoopbackModeEnabled</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:gad1ba6608163cf3db3f01ef92acfc605e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the loopback mode is enabled.  <a href="#gad1ba6608163cf3db3f01ef92acfc605e">More...</a><br /></td></tr>
<tr class="separator:gad1ba6608163cf3db3f01ef92acfc605e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab702c162ca66cbe0fb435f42c4e45bed"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gab702c162ca66cbe0fb435f42c4e45bed">DL_SPI_setRepeatTransmit</a> (SPI_Regs *spi, uint32_t numRepeats)</td></tr>
<tr class="memdesc:gab702c162ca66cbe0fb435f42c4e45bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set counter for repeated transmit.  <a href="#gab702c162ca66cbe0fb435f42c4e45bed">More...</a><br /></td></tr>
<tr class="separator:gab702c162ca66cbe0fb435f42c4e45bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28a91c75a55dbfdc5b67c82fd14f51ec"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga28a91c75a55dbfdc5b67c82fd14f51ec">DL_SPI_getRepeatTransmit</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga28a91c75a55dbfdc5b67c82fd14f51ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get counter for repeated transmit.  <a href="#ga28a91c75a55dbfdc5b67c82fd14f51ec">More...</a><br /></td></tr>
<tr class="separator:ga28a91c75a55dbfdc5b67c82fd14f51ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95013d33706c0f408ea5059cfcdbdd6e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga95013d33706c0f408ea5059cfcdbdd6e">DL_SPI_enablePeripheralAlignDataOnChipSelect</a> (SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga95013d33706c0f408ea5059cfcdbdd6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables data alignment on chip select for peripherals.  <a href="#ga95013d33706c0f408ea5059cfcdbdd6e">More...</a><br /></td></tr>
<tr class="separator:ga95013d33706c0f408ea5059cfcdbdd6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada4a4222d9d346236330744ce648be80"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gada4a4222d9d346236330744ce648be80">DL_SPI_disablePeripheralAlignDataOnChipSelect</a> (SPI_Regs *spi)</td></tr>
<tr class="memdesc:gada4a4222d9d346236330744ce648be80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables data alignment on chip select for peripherals.  <a href="#gada4a4222d9d346236330744ce648be80">More...</a><br /></td></tr>
<tr class="separator:gada4a4222d9d346236330744ce648be80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6427aead1f56189686c9b3fc295624bf"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga6427aead1f56189686c9b3fc295624bf">DL_SPI_isPeripheralAlignDataOnChipSelectEnabled</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga6427aead1f56189686c9b3fc295624bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if data alignment on chip select for peripherals is enabled.  <a href="#ga6427aead1f56189686c9b3fc295624bf">More...</a><br /></td></tr>
<tr class="separator:ga6427aead1f56189686c9b3fc295624bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1c1d31aeb86e180b4d617956b2b90b6"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gad1c1d31aeb86e180b4d617956b2b90b6">DL_SPI_enablePacking</a> (SPI_Regs *spi)</td></tr>
<tr class="memdesc:gad1c1d31aeb86e180b4d617956b2b90b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables packing feature.  <a href="#gad1c1d31aeb86e180b4d617956b2b90b6">More...</a><br /></td></tr>
<tr class="separator:gad1c1d31aeb86e180b4d617956b2b90b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe32a2370e84eb7db0673e2affd338aa"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gafe32a2370e84eb7db0673e2affd338aa">DL_SPI_disablePacking</a> (SPI_Regs *spi)</td></tr>
<tr class="memdesc:gafe32a2370e84eb7db0673e2affd338aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables packing feature.  <a href="#gafe32a2370e84eb7db0673e2affd338aa">More...</a><br /></td></tr>
<tr class="separator:gafe32a2370e84eb7db0673e2affd338aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a5a5107f72c4dc7788d0750f4b0c169"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga0a5a5107f72c4dc7788d0750f4b0c169">DL_SPI_isPackingEnabled</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga0a5a5107f72c4dc7788d0750f4b0c169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if packing feature is enabled.  <a href="#ga0a5a5107f72c4dc7788d0750f4b0c169">More...</a><br /></td></tr>
<tr class="separator:ga0a5a5107f72c4dc7788d0750f4b0c169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49d8de0e6e9fe919c8879e9ec8256359"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga49d8de0e6e9fe919c8879e9ec8256359">DL_SPI_setChipSelect</a> (SPI_Regs *spi, <a class="el" href="group___s_p_i.html#gac5b7531f268fb581f2f3117bd08eb4a0">DL_SPI_CHIP_SELECT</a> chipSelect)</td></tr>
<tr class="memdesc:ga49d8de0e6e9fe919c8879e9ec8256359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set chip select used for controller or peripheral mode.  <a href="#ga49d8de0e6e9fe919c8879e9ec8256359">More...</a><br /></td></tr>
<tr class="separator:ga49d8de0e6e9fe919c8879e9ec8256359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffadbc18dce16e01845061cec9539998"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___s_p_i.html#gac5b7531f268fb581f2f3117bd08eb4a0">DL_SPI_CHIP_SELECT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gaffadbc18dce16e01845061cec9539998">DL_SPI_getChipSelect</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:gaffadbc18dce16e01845061cec9539998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get chip select used for controller or peripheral mode.  <a href="#gaffadbc18dce16e01845061cec9539998">More...</a><br /></td></tr>
<tr class="separator:gaffadbc18dce16e01845061cec9539998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d77b7c9ab09a76d23b905e014b483ab"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga6d77b7c9ab09a76d23b905e014b483ab">DL_SPI_setPeripheralReceiveTimeout</a> (SPI_Regs *spi, uint32_t timeout)</td></tr>
<tr class="memdesc:ga6d77b7c9ab09a76d23b905e014b483ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set peripheral receive timeout.  <a href="#ga6d77b7c9ab09a76d23b905e014b483ab">More...</a><br /></td></tr>
<tr class="separator:ga6d77b7c9ab09a76d23b905e014b483ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8110072434861d79f3b125c14b97327"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gab8110072434861d79f3b125c14b97327">DL_SPI_getPeripheralReceiveTimeout</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:gab8110072434861d79f3b125c14b97327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get peripheral receive timeout.  <a href="#gab8110072434861d79f3b125c14b97327">More...</a><br /></td></tr>
<tr class="separator:gab8110072434861d79f3b125c14b97327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80b3037d10bf86943a061938fe71af66"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga80b3037d10bf86943a061938fe71af66">DL_SPI_setControllerCommandDataModeConfig</a> (SPI_Regs *spi, uint32_t config)</td></tr>
<tr class="memdesc:ga80b3037d10bf86943a061938fe71af66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the command/data mode.  <a href="#ga80b3037d10bf86943a061938fe71af66">More...</a><br /></td></tr>
<tr class="separator:ga80b3037d10bf86943a061938fe71af66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff81d2cfa6dbfaf0df1c002f793f204a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gaff81d2cfa6dbfaf0df1c002f793f204a">DL_SPI_getControllerCommandDataModeConfig</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:gaff81d2cfa6dbfaf0df1c002f793f204a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the command/data mode configuration.  <a href="#gaff81d2cfa6dbfaf0df1c002f793f204a">More...</a><br /></td></tr>
<tr class="separator:gaff81d2cfa6dbfaf0df1c002f793f204a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga755438cfca0ea7692c0828b107b8d72a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga755438cfca0ea7692c0828b107b8d72a">DL_SPI_enableControllerCommandDataMode</a> (SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga755438cfca0ea7692c0828b107b8d72a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables command/data mode.  <a href="#ga755438cfca0ea7692c0828b107b8d72a">More...</a><br /></td></tr>
<tr class="separator:ga755438cfca0ea7692c0828b107b8d72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c8385ae7f94401e02abb79d198c4ced"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga2c8385ae7f94401e02abb79d198c4ced">DL_SPI_disableControllerCommandDataMode</a> (SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga2c8385ae7f94401e02abb79d198c4ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables command/data mode.  <a href="#ga2c8385ae7f94401e02abb79d198c4ced">More...</a><br /></td></tr>
<tr class="separator:ga2c8385ae7f94401e02abb79d198c4ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga936e03e47bb826f48cde00b2490cb0df"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga936e03e47bb826f48cde00b2490cb0df">DL_SPI_isControllerCommandDataModeEnabled</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga936e03e47bb826f48cde00b2490cb0df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if command/data mode is enabled.  <a href="#ga936e03e47bb826f48cde00b2490cb0df">More...</a><br /></td></tr>
<tr class="separator:ga936e03e47bb826f48cde00b2490cb0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeab493584934784e399b486d8d706d6"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gadeab493584934784e399b486d8d706d6">DL_SPI_enablePeripheralDataOutput</a> (SPI_Regs *spi)</td></tr>
<tr class="memdesc:gadeab493584934784e399b486d8d706d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables peripheral data output.  <a href="#gadeab493584934784e399b486d8d706d6">More...</a><br /></td></tr>
<tr class="separator:gadeab493584934784e399b486d8d706d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga477925103d4cf5e813b3dd322a94e491"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga477925103d4cf5e813b3dd322a94e491">DL_SPI_disablePeripheralDataOutput</a> (SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga477925103d4cf5e813b3dd322a94e491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables peripheral data output.  <a href="#ga477925103d4cf5e813b3dd322a94e491">More...</a><br /></td></tr>
<tr class="separator:ga477925103d4cf5e813b3dd322a94e491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6acfb31a26f9d040539205f7e5a5506"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gad6acfb31a26f9d040539205f7e5a5506">DL_SPI_isPeripheralDataOutputEnabled</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:gad6acfb31a26f9d040539205f7e5a5506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if peripheral data output is enabled.  <a href="#gad6acfb31a26f9d040539205f7e5a5506">More...</a><br /></td></tr>
<tr class="separator:gad6acfb31a26f9d040539205f7e5a5506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69517779fd6a6dc63b7035a382afe938"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga69517779fd6a6dc63b7035a382afe938">DL_SPI_setDelayedSampling</a> (SPI_Regs *spi, uint32_t delay)</td></tr>
<tr class="memdesc:ga69517779fd6a6dc63b7035a382afe938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the delay sampling.  <a href="#ga69517779fd6a6dc63b7035a382afe938">More...</a><br /></td></tr>
<tr class="separator:ga69517779fd6a6dc63b7035a382afe938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0131073cd9e16115e96f091371d3399c"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga0131073cd9e16115e96f091371d3399c">DL_SPI_getDelayedSampling</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga0131073cd9e16115e96f091371d3399c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the delay sampling.  <a href="#ga0131073cd9e16115e96f091371d3399c">More...</a><br /></td></tr>
<tr class="separator:ga0131073cd9e16115e96f091371d3399c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga964944349d443791436c86969f5dd490"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga964944349d443791436c86969f5dd490">DL_SPI_setFIFOThreshold</a> (SPI_Regs *spi, <a class="el" href="group___s_p_i.html#gad62dc10499a7ad2a0285128125f75b51">DL_SPI_RX_FIFO_LEVEL</a> rxThreshold, <a class="el" href="group___s_p_i.html#ga15208bcdee85c9fdd007a85e761a4843">DL_SPI_TX_FIFO_LEVEL</a> txThreshold)</td></tr>
<tr class="memdesc:ga964944349d443791436c86969f5dd490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the RX and TX FIFO interrupt threshold level.  <a href="#ga964944349d443791436c86969f5dd490">More...</a><br /></td></tr>
<tr class="separator:ga964944349d443791436c86969f5dd490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7a261d22530dd8159a4127225cb11f9"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___s_p_i.html#ga15208bcdee85c9fdd007a85e761a4843">DL_SPI_TX_FIFO_LEVEL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gad7a261d22530dd8159a4127225cb11f9">DL_SPI_getTXFIFOThreshold</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:gad7a261d22530dd8159a4127225cb11f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the TX FIFO interrupt threshold level.  <a href="#gad7a261d22530dd8159a4127225cb11f9">More...</a><br /></td></tr>
<tr class="separator:gad7a261d22530dd8159a4127225cb11f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c0965ede169729e0671efefc86039b4"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___s_p_i.html#gad62dc10499a7ad2a0285128125f75b51">DL_SPI_RX_FIFO_LEVEL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga5c0965ede169729e0671efefc86039b4">DL_SPI_getRXFIFOThreshold</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga5c0965ede169729e0671efefc86039b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the RX FIFO interrupt threshold level.  <a href="#ga5c0965ede169729e0671efefc86039b4">More...</a><br /></td></tr>
<tr class="separator:ga5c0965ede169729e0671efefc86039b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c4a02c29afd23921de3499f67fac64e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga3c4a02c29afd23921de3499f67fac64e">DL_SPI_setBitRateSerialClockDivider</a> (SPI_Regs *spi, uint32_t SCR)</td></tr>
<tr class="memdesc:ga3c4a02c29afd23921de3499f67fac64e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the SPI bit rate serial clock divider (SCR)  <a href="#ga3c4a02c29afd23921de3499f67fac64e">More...</a><br /></td></tr>
<tr class="separator:ga3c4a02c29afd23921de3499f67fac64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0ae83a4e6b86488a627f86cb42e881c"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gae0ae83a4e6b86488a627f86cb42e881c">DL_SPI_getBitRateSerialClockDivider</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:gae0ae83a4e6b86488a627f86cb42e881c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the SPI bit rate serial clock divider (SCR)  <a href="#gae0ae83a4e6b86488a627f86cb42e881c">More...</a><br /></td></tr>
<tr class="separator:gae0ae83a4e6b86488a627f86cb42e881c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1db81249e51e1d7d083b1f08ac3c74f8"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga1db81249e51e1d7d083b1f08ac3c74f8">DL_SPI_transmitData8</a> (SPI_Regs *spi, uint8_t data)</td></tr>
<tr class="memdesc:ga1db81249e51e1d7d083b1f08ac3c74f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes 8-bit data into the TX FIFO for transmit.  <a href="#ga1db81249e51e1d7d083b1f08ac3c74f8">More...</a><br /></td></tr>
<tr class="separator:ga1db81249e51e1d7d083b1f08ac3c74f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd62074cdf1d5c54262a99c20b233421"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gadd62074cdf1d5c54262a99c20b233421">DL_SPI_transmitData16</a> (SPI_Regs *spi, uint16_t data)</td></tr>
<tr class="memdesc:gadd62074cdf1d5c54262a99c20b233421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes 16-bit data into the TX FIFO for transmit.  <a href="#gadd62074cdf1d5c54262a99c20b233421">More...</a><br /></td></tr>
<tr class="separator:gadd62074cdf1d5c54262a99c20b233421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea8f2bccfe6a5d794262a9b6820c8275"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gaea8f2bccfe6a5d794262a9b6820c8275">DL_SPI_transmitData32</a> (SPI_Regs *spi, uint32_t data)</td></tr>
<tr class="memdesc:gaea8f2bccfe6a5d794262a9b6820c8275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes 32-bit data into the TX FIFO for transmit.  <a href="#gaea8f2bccfe6a5d794262a9b6820c8275">More...</a><br /></td></tr>
<tr class="separator:gaea8f2bccfe6a5d794262a9b6820c8275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4567c4c2551bafbfc9b4646e8522631f"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga4567c4c2551bafbfc9b4646e8522631f">DL_SPI_receiveData8</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga4567c4c2551bafbfc9b4646e8522631f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads 8-bit data from the RX FIFO.  <a href="#ga4567c4c2551bafbfc9b4646e8522631f">More...</a><br /></td></tr>
<tr class="separator:ga4567c4c2551bafbfc9b4646e8522631f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac94abca28d5be6a6e8ef3587012b6071"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gac94abca28d5be6a6e8ef3587012b6071">DL_SPI_receiveData16</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:gac94abca28d5be6a6e8ef3587012b6071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads 16-bit data from the RX FIFO.  <a href="#gac94abca28d5be6a6e8ef3587012b6071">More...</a><br /></td></tr>
<tr class="separator:gac94abca28d5be6a6e8ef3587012b6071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga717ecfe8b54b8135b448419d25659d01"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga717ecfe8b54b8135b448419d25659d01">DL_SPI_receiveData32</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga717ecfe8b54b8135b448419d25659d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads 32-bit data from the RX FIFO.  <a href="#ga717ecfe8b54b8135b448419d25659d01">More...</a><br /></td></tr>
<tr class="separator:ga717ecfe8b54b8135b448419d25659d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a86c2fb7c36d466076b497af09b18e5"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga0a86c2fb7c36d466076b497af09b18e5">DL_SPI_enableInterrupt</a> (SPI_Regs *spi, uint32_t interruptMask)</td></tr>
<tr class="memdesc:ga0a86c2fb7c36d466076b497af09b18e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable SPI interrupts.  <a href="#ga0a86c2fb7c36d466076b497af09b18e5">More...</a><br /></td></tr>
<tr class="separator:ga0a86c2fb7c36d466076b497af09b18e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65638f5a3719afe2856ba0da9a2921ba"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga65638f5a3719afe2856ba0da9a2921ba">DL_SPI_disableInterrupt</a> (SPI_Regs *spi, uint32_t interruptMask)</td></tr>
<tr class="memdesc:ga65638f5a3719afe2856ba0da9a2921ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable SPI interrupts.  <a href="#ga65638f5a3719afe2856ba0da9a2921ba">More...</a><br /></td></tr>
<tr class="separator:ga65638f5a3719afe2856ba0da9a2921ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga970ffa57f3c30c27b6219db984ae4dd8"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga970ffa57f3c30c27b6219db984ae4dd8">DL_SPI_getEnabledInterrupts</a> (const SPI_Regs *spi, uint32_t interruptMask)</td></tr>
<tr class="memdesc:ga970ffa57f3c30c27b6219db984ae4dd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check which SPI interrupts are enabled.  <a href="#ga970ffa57f3c30c27b6219db984ae4dd8">More...</a><br /></td></tr>
<tr class="separator:ga970ffa57f3c30c27b6219db984ae4dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe8d63c06cb83e51b8f0859cbeca8fd8"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gabe8d63c06cb83e51b8f0859cbeca8fd8">DL_SPI_getEnabledInterruptStatus</a> (const SPI_Regs *spi, uint32_t interruptMask)</td></tr>
<tr class="memdesc:gabe8d63c06cb83e51b8f0859cbeca8fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check interrupt flag of enabled SPI interrupts.  <a href="#gabe8d63c06cb83e51b8f0859cbeca8fd8">More...</a><br /></td></tr>
<tr class="separator:gabe8d63c06cb83e51b8f0859cbeca8fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfa0c97668147c1537616b25d041543e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gadfa0c97668147c1537616b25d041543e">DL_SPI_getRawInterruptStatus</a> (const SPI_Regs *spi, uint32_t interruptMask)</td></tr>
<tr class="memdesc:gadfa0c97668147c1537616b25d041543e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check interrupt flag of any SPI interrupt.  <a href="#gadfa0c97668147c1537616b25d041543e">More...</a><br /></td></tr>
<tr class="separator:gadfa0c97668147c1537616b25d041543e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5561e3632fa0de4f0d2637a4a59bfb9"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___s_p_i.html#ga2856971e4f44c549983e6358d0fde683">DL_SPI_IIDX</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gaa5561e3632fa0de4f0d2637a4a59bfb9">DL_SPI_getPendingInterrupt</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:gaa5561e3632fa0de4f0d2637a4a59bfb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get highest priority pending SPI interrupt.  <a href="#gaa5561e3632fa0de4f0d2637a4a59bfb9">More...</a><br /></td></tr>
<tr class="separator:gaa5561e3632fa0de4f0d2637a4a59bfb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a3adedc52cb49293eb395e3b61a3365"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga3a3adedc52cb49293eb395e3b61a3365">DL_SPI_clearInterruptStatus</a> (SPI_Regs *spi, uint32_t interruptMask)</td></tr>
<tr class="memdesc:ga3a3adedc52cb49293eb395e3b61a3365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear pending SPI interrupts.  <a href="#ga3a3adedc52cb49293eb395e3b61a3365">More...</a><br /></td></tr>
<tr class="separator:ga3a3adedc52cb49293eb395e3b61a3365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a49cffcc93cd7f5f28691656084aa35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga5a49cffcc93cd7f5f28691656084aa35">DL_SPI_transmitDataBlocking8</a> (SPI_Regs *spi, uint8_t data)</td></tr>
<tr class="memdesc:ga5a49cffcc93cd7f5f28691656084aa35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks to ensure transmit is ready before sending data.  <a href="#ga5a49cffcc93cd7f5f28691656084aa35">More...</a><br /></td></tr>
<tr class="separator:ga5a49cffcc93cd7f5f28691656084aa35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6adff0a4426d68ec4460498076edd045"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga6adff0a4426d68ec4460498076edd045">DL_SPI_transmitDataBlocking16</a> (SPI_Regs *spi, uint16_t data)</td></tr>
<tr class="memdesc:ga6adff0a4426d68ec4460498076edd045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks to ensure transmit is ready before sending data.  <a href="#ga6adff0a4426d68ec4460498076edd045">More...</a><br /></td></tr>
<tr class="separator:ga6adff0a4426d68ec4460498076edd045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b8cd4c5a324feeeb75e9ad05576d762"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga9b8cd4c5a324feeeb75e9ad05576d762">DL_SPI_transmitDataBlocking32</a> (SPI_Regs *spi, uint32_t data)</td></tr>
<tr class="memdesc:ga9b8cd4c5a324feeeb75e9ad05576d762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks to ensure transmit is ready before sending data.  <a href="#ga9b8cd4c5a324feeeb75e9ad05576d762">More...</a><br /></td></tr>
<tr class="separator:ga9b8cd4c5a324feeeb75e9ad05576d762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6042d86a27dc1f0ac793a6b14c19d60f"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga6042d86a27dc1f0ac793a6b14c19d60f">DL_SPI_receiveDataBlocking8</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga6042d86a27dc1f0ac793a6b14c19d60f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks to ensure receive is ready before reading data.  <a href="#ga6042d86a27dc1f0ac793a6b14c19d60f">More...</a><br /></td></tr>
<tr class="separator:ga6042d86a27dc1f0ac793a6b14c19d60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bcdc016db3fa393f09bd17e624856fd"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga4bcdc016db3fa393f09bd17e624856fd">DL_SPI_receiveDataBlocking16</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga4bcdc016db3fa393f09bd17e624856fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks to ensure receive is ready before reading data.  <a href="#ga4bcdc016db3fa393f09bd17e624856fd">More...</a><br /></td></tr>
<tr class="separator:ga4bcdc016db3fa393f09bd17e624856fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d5a7664cd307273cbcaf9da299b3b91"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga1d5a7664cd307273cbcaf9da299b3b91">DL_SPI_receiveDataBlocking32</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga1d5a7664cd307273cbcaf9da299b3b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks to ensure receive is ready before reading data.  <a href="#ga1d5a7664cd307273cbcaf9da299b3b91">More...</a><br /></td></tr>
<tr class="separator:ga1d5a7664cd307273cbcaf9da299b3b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa747ac1ef89a31a25f59edd36e7434b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gaa747ac1ef89a31a25f59edd36e7434b1">DL_SPI_transmitDataCheck8</a> (SPI_Regs *spi, uint8_t data)</td></tr>
<tr class="memdesc:gaa747ac1ef89a31a25f59edd36e7434b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the TX FIFO before trying to transmit data.  <a href="#gaa747ac1ef89a31a25f59edd36e7434b1">More...</a><br /></td></tr>
<tr class="separator:gaa747ac1ef89a31a25f59edd36e7434b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ccfdddda9f493d31a7886b93fe97ffd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga0ccfdddda9f493d31a7886b93fe97ffd">DL_SPI_transmitDataCheck16</a> (SPI_Regs *spi, uint16_t data)</td></tr>
<tr class="memdesc:ga0ccfdddda9f493d31a7886b93fe97ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the TX FIFO before trying to transmit data.  <a href="#ga0ccfdddda9f493d31a7886b93fe97ffd">More...</a><br /></td></tr>
<tr class="separator:ga0ccfdddda9f493d31a7886b93fe97ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49621278af197222784b1d12bea75fc3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga49621278af197222784b1d12bea75fc3">DL_SPI_transmitDataCheck32</a> (SPI_Regs *spi, uint32_t data)</td></tr>
<tr class="memdesc:ga49621278af197222784b1d12bea75fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the TX FIFO before trying to transmit data.  <a href="#ga49621278af197222784b1d12bea75fc3">More...</a><br /></td></tr>
<tr class="separator:ga49621278af197222784b1d12bea75fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed7d1780e6dbf7b1429c4add272accdf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gaed7d1780e6dbf7b1429c4add272accdf">DL_SPI_receiveDataCheck8</a> (const SPI_Regs *spi, uint8_t *buffer)</td></tr>
<tr class="memdesc:gaed7d1780e6dbf7b1429c4add272accdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the RX FIFO before trying to transmit data.  <a href="#gaed7d1780e6dbf7b1429c4add272accdf">More...</a><br /></td></tr>
<tr class="separator:gaed7d1780e6dbf7b1429c4add272accdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf632787409736f5804b74a8e78995100"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gaf632787409736f5804b74a8e78995100">DL_SPI_receiveDataCheck16</a> (const SPI_Regs *spi, uint16_t *buffer)</td></tr>
<tr class="memdesc:gaf632787409736f5804b74a8e78995100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the RX FIFO before trying to transmit data.  <a href="#gaf632787409736f5804b74a8e78995100">More...</a><br /></td></tr>
<tr class="separator:gaf632787409736f5804b74a8e78995100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga222c7dffefa2bf155766cd7c84d023f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga222c7dffefa2bf155766cd7c84d023f2">DL_SPI_receiveDataCheck32</a> (const SPI_Regs *spi, uint32_t *buffer)</td></tr>
<tr class="memdesc:ga222c7dffefa2bf155766cd7c84d023f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the RX FIFO before trying to transmit data.  <a href="#ga222c7dffefa2bf155766cd7c84d023f2">More...</a><br /></td></tr>
<tr class="separator:ga222c7dffefa2bf155766cd7c84d023f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1636bbb8fd41d76c6d9514306477e914"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga1636bbb8fd41d76c6d9514306477e914">DL_SPI_drainRXFIFO8</a> (const SPI_Regs *spi, uint8_t *buffer, uint32_t maxCount)</td></tr>
<tr class="memdesc:ga1636bbb8fd41d76c6d9514306477e914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read all available data out of the RX FIFO using 8 bit access.  <a href="#ga1636bbb8fd41d76c6d9514306477e914">More...</a><br /></td></tr>
<tr class="separator:ga1636bbb8fd41d76c6d9514306477e914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3476eca47770d35f187b5c04e60b632"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gaf3476eca47770d35f187b5c04e60b632">DL_SPI_drainRXFIFO16</a> (const SPI_Regs *spi, uint16_t *buffer, uint32_t maxCount)</td></tr>
<tr class="memdesc:gaf3476eca47770d35f187b5c04e60b632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read all available data out of the RX FIFO using 16 bit access.  <a href="#gaf3476eca47770d35f187b5c04e60b632">More...</a><br /></td></tr>
<tr class="separator:gaf3476eca47770d35f187b5c04e60b632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5ce50f3a0f751d8cb2f4ed499755e93"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gab5ce50f3a0f751d8cb2f4ed499755e93">DL_SPI_drainRXFIFO32</a> (const SPI_Regs *spi, uint32_t *buffer, uint32_t maxCount)</td></tr>
<tr class="memdesc:gab5ce50f3a0f751d8cb2f4ed499755e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read all available data out of the RX FIFO using 32 bit access.  <a href="#gab5ce50f3a0f751d8cb2f4ed499755e93">More...</a><br /></td></tr>
<tr class="separator:gab5ce50f3a0f751d8cb2f4ed499755e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad002b7ba9034c365ad8fde923bdf0107"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gad002b7ba9034c365ad8fde923bdf0107">DL_SPI_fillTXFIFO8</a> (SPI_Regs *spi, const uint8_t *buffer, uint32_t count)</td></tr>
<tr class="memdesc:gad002b7ba9034c365ad8fde923bdf0107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the TX FIFO using 8 bit access.  <a href="#gad002b7ba9034c365ad8fde923bdf0107">More...</a><br /></td></tr>
<tr class="separator:gad002b7ba9034c365ad8fde923bdf0107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93e856d5f712743ea02f133d3292c5ea"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga93e856d5f712743ea02f133d3292c5ea">DL_SPI_fillTXFIFO16</a> (SPI_Regs *spi, const uint16_t *buffer, uint32_t count)</td></tr>
<tr class="memdesc:ga93e856d5f712743ea02f133d3292c5ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the TX FIFO using 16 bit access.  <a href="#ga93e856d5f712743ea02f133d3292c5ea">More...</a><br /></td></tr>
<tr class="separator:ga93e856d5f712743ea02f133d3292c5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7af3ac6f55af2348e02d16d5c67e1b29"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga7af3ac6f55af2348e02d16d5c67e1b29">DL_SPI_fillTXFIFO32</a> (SPI_Regs *spi, const uint32_t *buffer, uint32_t count)</td></tr>
<tr class="memdesc:ga7af3ac6f55af2348e02d16d5c67e1b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the TX FIFO using 32 bit access.  <a href="#ga7af3ac6f55af2348e02d16d5c67e1b29">More...</a><br /></td></tr>
<tr class="separator:ga7af3ac6f55af2348e02d16d5c67e1b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19bfcce992f283ee00bddb23bf50d18a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga19bfcce992f283ee00bddb23bf50d18a">DL_SPI_enableDMAReceiveEvent</a> (SPI_Regs *spi, uint32_t interrupt)</td></tr>
<tr class="memdesc:ga19bfcce992f283ee00bddb23bf50d18a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable SPI interrupt for triggering the DMA receive event.  <a href="#ga19bfcce992f283ee00bddb23bf50d18a">More...</a><br /></td></tr>
<tr class="separator:ga19bfcce992f283ee00bddb23bf50d18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03ed3e347e596e8f3a043b8cc807f0ac"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga03ed3e347e596e8f3a043b8cc807f0ac">DL_SPI_enableDMATransmitEvent</a> (SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga03ed3e347e596e8f3a043b8cc807f0ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable SPI interrupt for triggering the DMA transmit event.  <a href="#ga03ed3e347e596e8f3a043b8cc807f0ac">More...</a><br /></td></tr>
<tr class="separator:ga03ed3e347e596e8f3a043b8cc807f0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8d6f0b4f8e7d3f68d2e14ca2f04215d"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gad8d6f0b4f8e7d3f68d2e14ca2f04215d">DL_SPI_disableDMAReceiveEvent</a> (SPI_Regs *spi, uint32_t interrupt)</td></tr>
<tr class="memdesc:gad8d6f0b4f8e7d3f68d2e14ca2f04215d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables SPI interrupt from triggering the DMA receive event.  <a href="#gad8d6f0b4f8e7d3f68d2e14ca2f04215d">More...</a><br /></td></tr>
<tr class="separator:gad8d6f0b4f8e7d3f68d2e14ca2f04215d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77eb49fb26f889729b483357839ea907"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga77eb49fb26f889729b483357839ea907">DL_SPI_disableDMATransmitEvent</a> (SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga77eb49fb26f889729b483357839ea907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables SPI interrupt from triggering the DMA transmit event.  <a href="#ga77eb49fb26f889729b483357839ea907">More...</a><br /></td></tr>
<tr class="separator:ga77eb49fb26f889729b483357839ea907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab89a3ffb4daa9ef6b8efb5fdf6f2377d"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gab89a3ffb4daa9ef6b8efb5fdf6f2377d">DL_SPI_getEnabledDMAReceiveEvent</a> (const SPI_Regs *spi, uint32_t interruptMask)</td></tr>
<tr class="memdesc:gab89a3ffb4daa9ef6b8efb5fdf6f2377d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check which SPI interrupt for DMA receive events is enabled.  <a href="#gab89a3ffb4daa9ef6b8efb5fdf6f2377d">More...</a><br /></td></tr>
<tr class="separator:gab89a3ffb4daa9ef6b8efb5fdf6f2377d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5d4d2f49631235e03bd43133b31892a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gac5d4d2f49631235e03bd43133b31892a">DL_SPI_getEnabledDMATransmitEvent</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:gac5d4d2f49631235e03bd43133b31892a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if SPI interrupt for DMA transmit event is enabled.  <a href="#gac5d4d2f49631235e03bd43133b31892a">More...</a><br /></td></tr>
<tr class="separator:gac5d4d2f49631235e03bd43133b31892a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c1428ee1b7bbadb399ebc3d04b01a82"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga4c1428ee1b7bbadb399ebc3d04b01a82">DL_SPI_getEnabledDMAReceiveEventStatus</a> (const SPI_Regs *spi, uint32_t interruptMask)</td></tr>
<tr class="memdesc:ga4c1428ee1b7bbadb399ebc3d04b01a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check interrupt flag of enabled SPI interrupt for DMA receive event.  <a href="#ga4c1428ee1b7bbadb399ebc3d04b01a82">More...</a><br /></td></tr>
<tr class="separator:ga4c1428ee1b7bbadb399ebc3d04b01a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac76266ff3cef7b9efe539a338ab6763e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gac76266ff3cef7b9efe539a338ab6763e">DL_SPI_getEnabledDMATransmitEventStatus</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:gac76266ff3cef7b9efe539a338ab6763e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check interrupt flag of enabled SPI interrupt for DMA transmit event.  <a href="#gac76266ff3cef7b9efe539a338ab6763e">More...</a><br /></td></tr>
<tr class="separator:gac76266ff3cef7b9efe539a338ab6763e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ba09f8f4c7f038edd29869306f19176"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga7ba09f8f4c7f038edd29869306f19176">DL_SPI_getRawDMAReceiveEventStatus</a> (const SPI_Regs *spi, uint32_t interruptMask)</td></tr>
<tr class="memdesc:ga7ba09f8f4c7f038edd29869306f19176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check interrupt flag of any SPI interrupt for DMA receive event.  <a href="#ga7ba09f8f4c7f038edd29869306f19176">More...</a><br /></td></tr>
<tr class="separator:ga7ba09f8f4c7f038edd29869306f19176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcd3c71425a2848f31ed24f325c6e403"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gafcd3c71425a2848f31ed24f325c6e403">DL_SPI_getRawDMATransmitEventStatus</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:gafcd3c71425a2848f31ed24f325c6e403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check interrupt flag of any SPI interrupt for DMA transmit event.  <a href="#gafcd3c71425a2848f31ed24f325c6e403">More...</a><br /></td></tr>
<tr class="separator:gafcd3c71425a2848f31ed24f325c6e403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b2a07f8b6ddc8e504898d6b26ff0aea"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___s_p_i.html#gac662dc4ffc6d7fbd2c8059f9d978f0f6">DL_SPI_DMA_IIDX_RX</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga4b2a07f8b6ddc8e504898d6b26ff0aea">DL_SPI_getPendingDMAReceiveEvent</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga4b2a07f8b6ddc8e504898d6b26ff0aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get highest priority pending SPI interrupt for DMA receive event.  <a href="#ga4b2a07f8b6ddc8e504898d6b26ff0aea">More...</a><br /></td></tr>
<tr class="separator:ga4b2a07f8b6ddc8e504898d6b26ff0aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96cd4c2386a039ab586535d66972d8d4"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___s_p_i.html#ga4edac7e2fad897c33fddb539363eabdd">DL_SPI_DMA_IIDX_TX</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga96cd4c2386a039ab586535d66972d8d4">DL_SPI_getPendingDMATransmitEvent</a> (const SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga96cd4c2386a039ab586535d66972d8d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get highest priority pending SPI interrupt for DMA transmit event.  <a href="#ga96cd4c2386a039ab586535d66972d8d4">More...</a><br /></td></tr>
<tr class="separator:ga96cd4c2386a039ab586535d66972d8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga211e65c5c974b47eb771c0b5949fdd80"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga211e65c5c974b47eb771c0b5949fdd80">DL_SPI_clearDMAReceiveEventStatus</a> (SPI_Regs *spi, uint32_t interruptMask)</td></tr>
<tr class="memdesc:ga211e65c5c974b47eb771c0b5949fdd80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear pending SPI interrupts for DMA receive event.  <a href="#ga211e65c5c974b47eb771c0b5949fdd80">More...</a><br /></td></tr>
<tr class="separator:ga211e65c5c974b47eb771c0b5949fdd80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cc267432eef43cd197ed315bf9d22f4"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga1cc267432eef43cd197ed315bf9d22f4">DL_SPI_clearDMATransmitEventStatus</a> (SPI_Regs *spi)</td></tr>
<tr class="memdesc:ga1cc267432eef43cd197ed315bf9d22f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear pending SPI interrupt for DMA transmit event.  <a href="#ga1cc267432eef43cd197ed315bf9d22f4">More...</a><br /></td></tr>
<tr class="separator:ga1cc267432eef43cd197ed315bf9d22f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae172cfc4e1d9695af65d87198d19e89f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gae172cfc4e1d9695af65d87198d19e89f">DL_SPI_saveConfiguration</a> (const SPI_Regs *spi, <a class="el" href="struct_d_l___s_p_i__backup_config.html">DL_SPI_backupConfig</a> *ptr)</td></tr>
<tr class="memdesc:gae172cfc4e1d9695af65d87198d19e89f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save SPI configuration before entering a power loss state.  <a href="#gae172cfc4e1d9695af65d87198d19e89f">More...</a><br /></td></tr>
<tr class="separator:gae172cfc4e1d9695af65d87198d19e89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6405771e41906765135cf943ef43d03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gab6405771e41906765135cf943ef43d03">DL_SPI_restoreConfiguration</a> (SPI_Regs *spi, <a class="el" href="struct_d_l___s_p_i__backup_config.html">DL_SPI_backupConfig</a> *ptr)</td></tr>
<tr class="memdesc:gab6405771e41906765135cf943ef43d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore SPI configuration after leaving a power loss state.  <a href="#gab6405771e41906765135cf943ef43d03">More...</a><br /></td></tr>
<tr class="separator:gab6405771e41906765135cf943ef43d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><a class="anchor" id="ti_dl_dl_spi_Overview"></a></p><h1>Overview</h1>
<p>The Serial Peripheral Interface Driver Library allows full configuration of the MSPM0 SPI module. The serial peripheral interface (SPI) module provides a standardized serial interface to transfer data between MSPM0 devices and other external devices with SPI interface.</p>
<hr/>
 <h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gac662dc4ffc6d7fbd2c8059f9d978f0f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac662dc4ffc6d7fbd2c8059f9d978f0f6">&sect;&nbsp;</a></span>DL_SPI_DMA_IIDX_RX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_p_i.html#gac662dc4ffc6d7fbd2c8059f9d978f0f6">DL_SPI_DMA_IIDX_RX</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac662dc4ffc6d7fbd2c8059f9d978f0f6a9c8fe591502b5d60b8c0a464331f1624"></a>DL_SPI_DMA_IIDX_RX_TRIGGER&#160;</td><td class="fielddoc"><p>SPI interrupt index for enabling SPI receive as DMA trigger </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac662dc4ffc6d7fbd2c8059f9d978f0f6ad5d4be77f142e7e0296984024f532cb4"></a>DL_SPI_DMA_IIDX_RX_TIMEOUT_TRIGGER&#160;</td><td class="fielddoc"><p>SPI interrupt index for enabling SPI receive timeout as DMA trigger </p>
</td></tr>
</table>

</div>
</div>
<a id="ga4edac7e2fad897c33fddb539363eabdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4edac7e2fad897c33fddb539363eabdd">&sect;&nbsp;</a></span>DL_SPI_DMA_IIDX_TX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_p_i.html#ga4edac7e2fad897c33fddb539363eabdd">DL_SPI_DMA_IIDX_TX</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga4edac7e2fad897c33fddb539363eabdda4376892f01b53c8ea6f16c40bb86e391"></a>DL_SPI_DMA_IIDX_TX_TRIGGER&#160;</td><td class="fielddoc"><p>SPI interrupt index for enabling SPI transmit as DMA trigger </p>
</td></tr>
</table>

</div>
</div>
<a id="ga773029828a0b68cdff80d13e1fda363b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga773029828a0b68cdff80d13e1fda363b">&sect;&nbsp;</a></span>DL_SPI_PARITY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_p_i.html#ga773029828a0b68cdff80d13e1fda363b">DL_SPI_PARITY</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga773029828a0b68cdff80d13e1fda363bafb807f04f1ff9e7a680743f613911af6"></a>DL_SPI_PARITY_EVEN&#160;</td><td class="fielddoc"><p>Use even parity, enable transmit and receive parity </p>
</td></tr>
<tr><td class="fieldname"><a id="gga773029828a0b68cdff80d13e1fda363ba08e50ae539ffea21d62f322349d88814"></a>DL_SPI_PARITY_ODD&#160;</td><td class="fielddoc"><p>Use odd parity, enable transmit and receive parity </p>
</td></tr>
<tr><td class="fieldname"><a id="gga773029828a0b68cdff80d13e1fda363ba74d6cfb81a9045badfdeed0b05064ef7"></a>DL_SPI_PARITY_NONE&#160;</td><td class="fielddoc"><p>Disable receive and transmit parity </p>
</td></tr>
</table>

</div>
</div>
<a id="ga1778f795709b41d93eb1408b279e1bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1778f795709b41d93eb1408b279e1bd1">&sect;&nbsp;</a></span>DL_SPI_FRAME_FORMAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_p_i.html#ga1778f795709b41d93eb1408b279e1bd1">DL_SPI_FRAME_FORMAT</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga1778f795709b41d93eb1408b279e1bd1a27a4ca6631bdd276011fbbc5945adedd"></a>DL_SPI_FRAME_FORMAT_MOTO3_POL0_PHA0&#160;</td><td class="fielddoc"><p>Motorola 3 Wire with Polarity 0, Phase 0 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1778f795709b41d93eb1408b279e1bd1a7698d1a20993904d623376c374336e96"></a>DL_SPI_FRAME_FORMAT_MOTO3_POL0_PHA1&#160;</td><td class="fielddoc"><p>Motorola 3 Wire with Polarity 0, Phase 1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1778f795709b41d93eb1408b279e1bd1a3e642fe572393dff885f0b6398fe1517"></a>DL_SPI_FRAME_FORMAT_MOTO3_POL1_PHA0&#160;</td><td class="fielddoc"><p>Motorola 3 Wire with Polarity 1, Phase 0 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1778f795709b41d93eb1408b279e1bd1a467532e43794c934d5fde685d6092527"></a>DL_SPI_FRAME_FORMAT_MOTO3_POL1_PHA1&#160;</td><td class="fielddoc"><p>Motorola 3 Wire with Polarity 1, Phase 1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1778f795709b41d93eb1408b279e1bd1a889cdba0616273308242070aa3c23415"></a>DL_SPI_FRAME_FORMAT_MOTO4_POL0_PHA0&#160;</td><td class="fielddoc"><p>Motorola 4 Wire with Polarity 0, Phase 0 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1778f795709b41d93eb1408b279e1bd1aea1a45f04370098f4e1e088c3ff39920"></a>DL_SPI_FRAME_FORMAT_MOTO4_POL0_PHA1&#160;</td><td class="fielddoc"><p>Motorola 4 Wire with Polarity 0, Phase 1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1778f795709b41d93eb1408b279e1bd1a1680c3cab4e46cd6e5fff0e1f3b31e76"></a>DL_SPI_FRAME_FORMAT_MOTO4_POL1_PHA0&#160;</td><td class="fielddoc"><p>Motorola 4 Wire with Polarity 1, Phase 0 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1778f795709b41d93eb1408b279e1bd1ae1c69be67fdb1c844425a33cb21335bd"></a>DL_SPI_FRAME_FORMAT_MOTO4_POL1_PHA1&#160;</td><td class="fielddoc"><p>Motorola 4 Wire with Polarity 1, Phase 1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1778f795709b41d93eb1408b279e1bd1a510e2fbaed450b103d75b09f4dbfd0b7"></a>DL_SPI_FRAME_FORMAT_TI_SYNC&#160;</td><td class="fielddoc"><p>TI Sync Frame Format </p>
</td></tr>
</table>

</div>
</div>
<a id="gab5d9c38bb4fa37d93aaa0e67eb22b7ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5d9c38bb4fa37d93aaa0e67eb22b7ae">&sect;&nbsp;</a></span>DL_SPI_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_p_i.html#gab5d9c38bb4fa37d93aaa0e67eb22b7ae">DL_SPI_MODE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab5d9c38bb4fa37d93aaa0e67eb22b7aea5b07b2b02432e3eeee94da49ba286b7f"></a>DL_SPI_MODE_CONTROLLER&#160;</td><td class="fielddoc"><p>Controller mode </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab5d9c38bb4fa37d93aaa0e67eb22b7aea3db1834c8f1ce6b1ac97bb86587bf0fe"></a>DL_SPI_MODE_PERIPHERAL&#160;</td><td class="fielddoc"><p>Peripheral mode </p>
</td></tr>
</table>

</div>
</div>
<a id="ga79d02b79cd7d5383b93311454ed5f3ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79d02b79cd7d5383b93311454ed5f3ef">&sect;&nbsp;</a></span>DL_SPI_BIT_ORDER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_p_i.html#ga79d02b79cd7d5383b93311454ed5f3ef">DL_SPI_BIT_ORDER</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga79d02b79cd7d5383b93311454ed5f3efaf2bceaa49d585bf730cebb88c121fcf9"></a>DL_SPI_BIT_ORDER_MSB_FIRST&#160;</td><td class="fielddoc"><p>MSB First </p>
</td></tr>
<tr><td class="fieldname"><a id="gga79d02b79cd7d5383b93311454ed5f3efab084a7b9a774fbcf58eba78342e9f9ea"></a>DL_SPI_BIT_ORDER_LSB_FIRST&#160;</td><td class="fielddoc"><p>LSB First </p>
</td></tr>
</table>

</div>
</div>
<a id="ga06925b84fe07eb69a8e1f23ab30d80da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06925b84fe07eb69a8e1f23ab30d80da">&sect;&nbsp;</a></span>DL_SPI_DATA_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_p_i.html#ga06925b84fe07eb69a8e1f23ab30d80da">DL_SPI_DATA_SIZE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga06925b84fe07eb69a8e1f23ab30d80daa7997ed3f079a0266f4a469cb63fec786"></a>DL_SPI_DATA_SIZE_4&#160;</td><td class="fielddoc"><p>Data size 4 bits </p>
</td></tr>
<tr><td class="fieldname"><a id="gga06925b84fe07eb69a8e1f23ab30d80daaa6e8f410f354e563f0e23b905b5f13bb"></a>DL_SPI_DATA_SIZE_5&#160;</td><td class="fielddoc"><p>Data size 5 bits </p>
</td></tr>
<tr><td class="fieldname"><a id="gga06925b84fe07eb69a8e1f23ab30d80daa3fa58ffbefaf1022f39003eb1b28b0b0"></a>DL_SPI_DATA_SIZE_6&#160;</td><td class="fielddoc"><p>Data size 6 bits </p>
</td></tr>
<tr><td class="fieldname"><a id="gga06925b84fe07eb69a8e1f23ab30d80daaf01c3d840262daea42d9a29b08edcd0c"></a>DL_SPI_DATA_SIZE_7&#160;</td><td class="fielddoc"><p>Data size 7 bits </p>
</td></tr>
<tr><td class="fieldname"><a id="gga06925b84fe07eb69a8e1f23ab30d80daa7343ddb73f93ee03440626df4f549e89"></a>DL_SPI_DATA_SIZE_8&#160;</td><td class="fielddoc"><p>Data size 8 bits </p>
</td></tr>
<tr><td class="fieldname"><a id="gga06925b84fe07eb69a8e1f23ab30d80daa3f3ef2ecc4791e7f97c789ca64d37026"></a>DL_SPI_DATA_SIZE_9&#160;</td><td class="fielddoc"><p>Data size 9 bits </p>
</td></tr>
<tr><td class="fieldname"><a id="gga06925b84fe07eb69a8e1f23ab30d80daa9b1d16811f116e0b793ebb68c83d4b4b"></a>DL_SPI_DATA_SIZE_10&#160;</td><td class="fielddoc"><p>Data size 10 bits </p>
</td></tr>
<tr><td class="fieldname"><a id="gga06925b84fe07eb69a8e1f23ab30d80daa8b6473c34ee7b4ffcea9fa5bd304ce8f"></a>DL_SPI_DATA_SIZE_11&#160;</td><td class="fielddoc"><p>Data size 11 bits </p>
</td></tr>
<tr><td class="fieldname"><a id="gga06925b84fe07eb69a8e1f23ab30d80daa5c72f5a5d5cc7edddbb432641d80e906"></a>DL_SPI_DATA_SIZE_12&#160;</td><td class="fielddoc"><p>Data size 12 bits </p>
</td></tr>
<tr><td class="fieldname"><a id="gga06925b84fe07eb69a8e1f23ab30d80daa6e283c1d9f3bf5f511629bf1a31889bd"></a>DL_SPI_DATA_SIZE_13&#160;</td><td class="fielddoc"><p>Data size 13 bits </p>
</td></tr>
<tr><td class="fieldname"><a id="gga06925b84fe07eb69a8e1f23ab30d80daab0d18a521582b11fcdcefe2f01f6dc77"></a>DL_SPI_DATA_SIZE_14&#160;</td><td class="fielddoc"><p>Data size 14 bits </p>
</td></tr>
<tr><td class="fieldname"><a id="gga06925b84fe07eb69a8e1f23ab30d80daa8a31728e462d2811bf7e7b4d99a16ad2"></a>DL_SPI_DATA_SIZE_15&#160;</td><td class="fielddoc"><p>Data size 15 bits </p>
</td></tr>
<tr><td class="fieldname"><a id="gga06925b84fe07eb69a8e1f23ab30d80daa72419facdf4f677b84a4c5b555d30d4e"></a>DL_SPI_DATA_SIZE_16&#160;</td><td class="fielddoc"><p>Data size 16 bits </p>
</td></tr>
</table>

</div>
</div>
<a id="gac5b7531f268fb581f2f3117bd08eb4a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5b7531f268fb581f2f3117bd08eb4a0">&sect;&nbsp;</a></span>DL_SPI_CHIP_SELECT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_p_i.html#gac5b7531f268fb581f2f3117bd08eb4a0">DL_SPI_CHIP_SELECT</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac5b7531f268fb581f2f3117bd08eb4a0a04e270bb79f5f11f6858dc5247d193ec"></a>DL_SPI_CHIP_SELECT_0&#160;</td><td class="fielddoc"><p>Chip Select 0 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac5b7531f268fb581f2f3117bd08eb4a0aada96b045390f06063629996abe875e8"></a>DL_SPI_CHIP_SELECT_1&#160;</td><td class="fielddoc"><p>Chip Select 1 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac5b7531f268fb581f2f3117bd08eb4a0adc9526b4f2bb7908ad2375aa33a9b856"></a>DL_SPI_CHIP_SELECT_2&#160;</td><td class="fielddoc"><p>Chip Select 2 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac5b7531f268fb581f2f3117bd08eb4a0a93b0df91104ed89ecdb148c212fd3708"></a>DL_SPI_CHIP_SELECT_3&#160;</td><td class="fielddoc"><p>Chip Select 3 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac5b7531f268fb581f2f3117bd08eb4a0a1fc468efce3d853c9425a3d3ecda61fd"></a>DL_SPI_CHIP_SELECT_NONE&#160;</td><td class="fielddoc"><p>No chip select </p>
</td></tr>
</table>

</div>
</div>
<a id="ga15208bcdee85c9fdd007a85e761a4843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15208bcdee85c9fdd007a85e761a4843">&sect;&nbsp;</a></span>DL_SPI_TX_FIFO_LEVEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_p_i.html#ga15208bcdee85c9fdd007a85e761a4843">DL_SPI_TX_FIFO_LEVEL</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga15208bcdee85c9fdd007a85e761a4843abb43613de18290dda1cec93c708c5396"></a>DL_SPI_TX_FIFO_LEVEL_3_4_EMPTY&#160;</td><td class="fielddoc"><p>Interrupt triggers when TX FIFO &lt;= 3/4 empty </p>
</td></tr>
<tr><td class="fieldname"><a id="gga15208bcdee85c9fdd007a85e761a4843a6f14fbf777adbf55ce16dbe062cdf31c"></a>DL_SPI_TX_FIFO_LEVEL_1_2_EMPTY&#160;</td><td class="fielddoc"><p>Interrupt triggers when TX FIFO &lt;= 1/2 empty (default) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga15208bcdee85c9fdd007a85e761a4843a9e34611ade1ee18e1bf53b0ecc1ebf39"></a>DL_SPI_TX_FIFO_LEVEL_1_4_EMPTY&#160;</td><td class="fielddoc"><p>Interrupt triggers when TX FIFO &lt;= 1/4 empty </p>
</td></tr>
<tr><td class="fieldname"><a id="gga15208bcdee85c9fdd007a85e761a4843a99805227a259d9b05d640b29f2997a15"></a>DL_SPI_TX_FIFO_LEVEL_EMPTY&#160;</td><td class="fielddoc"><p>Interrupt triggers when TX FIFO is empty </p>
</td></tr>
<tr><td class="fieldname"><a id="gga15208bcdee85c9fdd007a85e761a4843af9ee1cf64d3159c7b5d3d2e0d46059a9"></a>DL_SPI_TX_FIFO_LEVEL_ONE_FRAME&#160;</td><td class="fielddoc"><p>Interrupt triggers when TX FIFO has &gt;= 1 frame free. Should be used with DMA </p>
</td></tr>
</table>

</div>
</div>
<a id="gad62dc10499a7ad2a0285128125f75b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad62dc10499a7ad2a0285128125f75b51">&sect;&nbsp;</a></span>DL_SPI_RX_FIFO_LEVEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_p_i.html#gad62dc10499a7ad2a0285128125f75b51">DL_SPI_RX_FIFO_LEVEL</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad62dc10499a7ad2a0285128125f75b51a58da669c09210fbd7d66c535c3f52d0d"></a>DL_SPI_RX_FIFO_LEVEL_ONE_FRAME&#160;</td><td class="fielddoc"><p>Interrupt triggers when RX FIFO contains &gt;= 1 frame. Should be used with DMA </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62dc10499a7ad2a0285128125f75b51a9c682129358968ea39ab7c069142b124"></a>DL_SPI_RX_FIFO_LEVEL_FULL&#160;</td><td class="fielddoc"><p>Interrupt triggers when RX FIFO is full </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62dc10499a7ad2a0285128125f75b51ab4aed4387e855feae1cbe6d8e99dda09"></a>DL_SPI_RX_FIFO_LEVEL_3_4_FULL&#160;</td><td class="fielddoc"><p>Interrupt triggers when RX FIFO &gt;= 3/4 full </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62dc10499a7ad2a0285128125f75b51ae737c589bc33852c2a667e4dec8622d4"></a>DL_SPI_RX_FIFO_LEVEL_1_2_FULL&#160;</td><td class="fielddoc"><p>Interrupt triggers when RX FIFO &gt;= 1/2 full (default) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad62dc10499a7ad2a0285128125f75b51aad46bfbffdf2e46071271a9b53ed2e02"></a>DL_SPI_RX_FIFO_LEVEL_1_4_FULL&#160;</td><td class="fielddoc"><p>Interrupt triggers when RX FIFO &gt;= 1/4 full </p>
</td></tr>
</table>

</div>
</div>
<a id="ga2856971e4f44c549983e6358d0fde683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2856971e4f44c549983e6358d0fde683">&sect;&nbsp;</a></span>DL_SPI_IIDX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_p_i.html#ga2856971e4f44c549983e6358d0fde683">DL_SPI_IIDX</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga2856971e4f44c549983e6358d0fde683ada8236595ccbd339e18d7bac60a1f9c5"></a>DL_SPI_IIDX_DMA_DONE_TX&#160;</td><td class="fielddoc"><p>SPI interrupt index for DMA Done 1 event for transmit </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2856971e4f44c549983e6358d0fde683ad66d08e9d70cab90afb1be5394a60ff0"></a>DL_SPI_IIDX_DMA_DONE_RX&#160;</td><td class="fielddoc"><p>SPI interrupt index for DMA Done 1 event for receive </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2856971e4f44c549983e6358d0fde683a6bac3917b4fbe3ef3f430c39c6993887"></a>DL_SPI_IIDX_IDLE&#160;</td><td class="fielddoc"><p>SPI interrupt index for SPI to signal it has finished transfers and changed into idle mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2856971e4f44c549983e6358d0fde683aa2bc017cf293a353c915ceeef37b7191"></a>DL_SPI_IIDX_TX_EMPTY&#160;</td><td class="fielddoc"><p>SPI interrupt index for transmit FIFO empty </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2856971e4f44c549983e6358d0fde683af4d318475c008712649630977815f658"></a>DL_SPI_IIDX_TX&#160;</td><td class="fielddoc"><p>SPI interrupt index for transmit FIFO </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2856971e4f44c549983e6358d0fde683aeae8178b043e82392af6aa3610c002d7"></a>DL_SPI_IIDX_RX&#160;</td><td class="fielddoc"><p>SPI interrupt index for receive FIFO </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2856971e4f44c549983e6358d0fde683a1845f4c15b4aeb3a851d231df83f0351"></a>DL_SPI_IIDX_RX_TIMEOUT&#160;</td><td class="fielddoc"><p>SPI interrupt index for receive timeout </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2856971e4f44c549983e6358d0fde683a22e489f7f850aeff02d28181b8c9aa40"></a>DL_SPI_IIDX_RX_FULL&#160;</td><td class="fielddoc"><p>SPI interrupt index for receive FIFO full </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2856971e4f44c549983e6358d0fde683ad8d4f9e952f648a5fdeeeed097b414d3"></a>DL_SPI_IIDX_TX_UNDERFLOW&#160;</td><td class="fielddoc"><p>SPI interrupt index for transmit FIFO underflow </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2856971e4f44c549983e6358d0fde683abbe680e02dae4b5932c47577b00e0eb1"></a>DL_SPI_IIDX_PARITY_ERROR&#160;</td><td class="fielddoc"><p>SPI interrupt index for parity error </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2856971e4f44c549983e6358d0fde683a0b53f7111949b1d8b08e65f44d7845a7"></a>DL_SPI_IIDX_RX_OVERFLOW&#160;</td><td class="fielddoc"><p>SPI interrupt index for receive FIFO overflow </p>
</td></tr>
</table>

</div>
</div>
<a id="ga5eaef8ef8e93903687af3edd8b3684e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5eaef8ef8e93903687af3edd8b3684e5">&sect;&nbsp;</a></span>DL_SPI_CLOCK_DIVIDE_RATIO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_p_i.html#ga5eaef8ef8e93903687af3edd8b3684e5">DL_SPI_CLOCK_DIVIDE_RATIO</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga5eaef8ef8e93903687af3edd8b3684e5a42c4d8e044a542ef104786973a4e4984"></a>DL_SPI_CLOCK_DIVIDE_RATIO_1&#160;</td><td class="fielddoc"><p>SPI source clock divide ratio set to 1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5eaef8ef8e93903687af3edd8b3684e5a29d85bce11775e265d98b07d16019a89"></a>DL_SPI_CLOCK_DIVIDE_RATIO_2&#160;</td><td class="fielddoc"><p>SPI source clock divide ratio set to 2 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5eaef8ef8e93903687af3edd8b3684e5addda6d99499d349f4355d1e2b9c634b2"></a>DL_SPI_CLOCK_DIVIDE_RATIO_3&#160;</td><td class="fielddoc"><p>SPI source clock divide ratio set to 3 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5eaef8ef8e93903687af3edd8b3684e5ad6e2c336b339209383e69ef114344b8c"></a>DL_SPI_CLOCK_DIVIDE_RATIO_4&#160;</td><td class="fielddoc"><p>SPI source clock divide ratio set to 4 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5eaef8ef8e93903687af3edd8b3684e5a03e0631527626808afee6782ac3cf644"></a>DL_SPI_CLOCK_DIVIDE_RATIO_5&#160;</td><td class="fielddoc"><p>SPI source clock divide ratio set to 5 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5eaef8ef8e93903687af3edd8b3684e5a9a2f53485e5e406d87014888adf9e0d7"></a>DL_SPI_CLOCK_DIVIDE_RATIO_6&#160;</td><td class="fielddoc"><p>SPI source clock divide ratio set to 6 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5eaef8ef8e93903687af3edd8b3684e5aa13ed10b6b2ea0e346ac3257daeec59e"></a>DL_SPI_CLOCK_DIVIDE_RATIO_7&#160;</td><td class="fielddoc"><p>SPI source clock divide ratio set to 7 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5eaef8ef8e93903687af3edd8b3684e5ac0bbf359eb360b92a3b4ef81da1f73f4"></a>DL_SPI_CLOCK_DIVIDE_RATIO_8&#160;</td><td class="fielddoc"><p>SPI source clock divide ratio set to 8 </p>
</td></tr>
</table>

</div>
</div>
<a id="gacadd49262d90984a5c6ff8aec05762f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacadd49262d90984a5c6ff8aec05762f8">&sect;&nbsp;</a></span>DL_SPI_CLOCK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_p_i.html#gacadd49262d90984a5c6ff8aec05762f8">DL_SPI_CLOCK</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggacadd49262d90984a5c6ff8aec05762f8a139558fe09fdf42df80cae07513ef15e"></a>DL_SPI_CLOCK_BUSCLK&#160;</td><td class="fielddoc"><p>Selects BUSCLK as the clock source </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacadd49262d90984a5c6ff8aec05762f8a5990f8c8231fdce6d11e600197bbb05c"></a>DL_SPI_CLOCK_MFCLK&#160;</td><td class="fielddoc"><p>Selects MFCLK as the clock source </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacadd49262d90984a5c6ff8aec05762f8a842d8879838b01e15eeeb872cd8642b9"></a>DL_SPI_CLOCK_LFCLK&#160;</td><td class="fielddoc"><p>Selects LFCLK as the clock source </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga7bcdb2b1100ab58dbd64366feadfbf1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bcdb2b1100ab58dbd64366feadfbf1e">&sect;&nbsp;</a></span>DL_SPI_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_SPI_init </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_d_l___s_p_i___config.html">DL_SPI_Config</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the SPI peripheral. </p>
<p>Initializes all the common configurable options for the SPI peripheral. Any other custom configuration can be done after calling this API. The SPI is not enabled in this API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Configuration for SPI peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga251d33c1951365dad8e4850bfe49bcc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga251d33c1951365dad8e4850bfe49bcc7">&sect;&nbsp;</a></span>DL_SPI_enablePower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_enablePower </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the Peripheral Write Enable (PWREN) register for the SPI. </p>
<p>Before any peripheral registers can be configured by software, the peripheral itself must be enabled by writing the ENABLE bit together with the appropriate KEY value to the peripheral's PWREN register.</p>
<dl class="section note"><dt>Note</dt><dd>For power savings, please refer to <a class="el" href="group___s_p_i.html#ga0a40961940d940325e1b41ead149a843">DL_SPI_enable</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga750d9c1fcb11d51008a1b760e741f38e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga750d9c1fcb11d51008a1b760e741f38e">&sect;&nbsp;</a></span>DL_SPI_disablePower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_disablePower </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the Peripheral Write Enable (PWREN) register for the SPI. </p>
<p>When the PWREN.ENABLE bit is cleared, the peripheral's registers are not accessible for read/write operations.</p>
<dl class="section note"><dt>Note</dt><dd>This API does not provide large power savings. For power savings, please refer to <a class="el" href="group___s_p_i.html#ga0a40961940d940325e1b41ead149a843">DL_SPI_enable</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabe45eb6bdf7219a5ebe6124bc11989a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe45eb6bdf7219a5ebe6124bc11989a0">&sect;&nbsp;</a></span>DL_SPI_isPowerEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_SPI_isPowerEnabled </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if the Peripheral Write Enable (PWREN) register for the SPI is enabled. </p>
<p>Before any peripheral registers can be configured by software, the peripheral itself must be enabled by writing the ENABLE bit together with the appropriate KEY value to the peripheral's PWREN register.</p>
<p>When the PWREN.ENABLE bit is cleared, the peripheral's registers are not accessible for read/write operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if peripheral register access is enabled </dd>
<dd>
false if peripheral register access is disabled </dd></dl>

</div>
</div>
<a id="ga12b8798df3c18c5065d9eb86c568ee6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12b8798df3c18c5065d9eb86c568ee6b">&sect;&nbsp;</a></span>DL_SPI_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_reset </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets spi peripheral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab51bd85ac83b08f3bae584a82492e17f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab51bd85ac83b08f3bae584a82492e17f">&sect;&nbsp;</a></span>DL_SPI_isReset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_SPI_isReset </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if spi peripheral was reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if peripheral was reset </dd>
<dd>
false if peripheral wasn't reset </dd></dl>

</div>
</div>
<a id="ga0a40961940d940325e1b41ead149a843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a40961940d940325e1b41ead149a843">&sect;&nbsp;</a></span>DL_SPI_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_enable </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the SPI peripheral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga192cea97b92bf07c52f9d4701c364720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga192cea97b92bf07c52f9d4701c364720">&sect;&nbsp;</a></span>DL_SPI_isEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_SPI_isEnabled </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the SPI peripheral is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the enabled status of the SPI</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The SPI peripheral is enabled </td></tr>
    <tr><td class="paramname">false</td><td>The SPI peripheral is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga09199015c560aefd53f38b724bf2377e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09199015c560aefd53f38b724bf2377e">&sect;&nbsp;</a></span>DL_SPI_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_disable </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the SPI peripheral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___s_p_i.html#gabc50a08fe4900de16ca36f49bfd4d793">DL_SPI_getClockConfig()</a>, and <a class="el" href="group___s_p_i.html#ga506f26dd75f5319b437ad6cf6fd44e2f">DL_SPI_setClockConfig()</a>.</p>

</div>
</div>
<a id="ga506f26dd75f5319b437ad6cf6fd44e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga506f26dd75f5319b437ad6cf6fd44e2f">&sect;&nbsp;</a></span>DL_SPI_setClockConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_SPI_setClockConfig </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_d_l___s_p_i___clock_config.html">DL_SPI_ClockConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure SPI source clock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Pointer to the clock configuration struct <a class="el" href="struct_d_l___s_p_i___clock_config.html">DL_SPI_ClockConfig</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___s_p_i.html#ga09199015c560aefd53f38b724bf2377e">DL_SPI_disable()</a>.</p>

</div>
</div>
<a id="gabc50a08fe4900de16ca36f49bfd4d793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc50a08fe4900de16ca36f49bfd4d793">&sect;&nbsp;</a></span>DL_SPI_getClockConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_SPI_getClockConfig </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_d_l___s_p_i___clock_config.html">DL_SPI_ClockConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get SPI source clock configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Pointer to the clock configuration struct <a class="el" href="struct_d_l___s_p_i___clock_config.html">DL_SPI_ClockConfig</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___s_p_i.html#ga09199015c560aefd53f38b724bf2377e">DL_SPI_disable()</a>.</p>

</div>
</div>
<a id="ga18c0f490973a924325b5e99e9efd9033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18c0f490973a924325b5e99e9efd9033">&sect;&nbsp;</a></span>DL_SPI_isBusy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_SPI_isBusy </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the SPI is busy transmitting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the busy status of the SPI</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The SPI is transmitting </td></tr>
    <tr><td class="paramname">false</td><td>The SPI is idle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacaadbd0fa4cd5497cea0e15f723fd328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacaadbd0fa4cd5497cea0e15f723fd328">&sect;&nbsp;</a></span>DL_SPI_isTXFIFOEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_SPI_isTXFIFOEmpty </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the TX FIFO is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the empty status of the TX FIFO</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The TX FIFO is empty </td></tr>
    <tr><td class="paramname">false</td><td>The TX FIFO is not empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga02f1ebf87a797e2be89ae2b2843db431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02f1ebf87a797e2be89ae2b2843db431">&sect;&nbsp;</a></span>DL_SPI_isTXFIFOFull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_SPI_isTXFIFOFull </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the TX FIFO is full. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the full status of the TX FIFO</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The TX FIFO is full </td></tr>
    <tr><td class="paramname">false</td><td>The TX FIFO is not full </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8b4632aa604b78631e255e974e4d6e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b4632aa604b78631e255e974e4d6e77">&sect;&nbsp;</a></span>DL_SPI_isRXFIFOEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_SPI_isRXFIFOEmpty </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the RX FIFO is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the empty status of the RX FIFO</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The RX FIFO is empty </td></tr>
    <tr><td class="paramname">false</td><td>The RX FIFO is not empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8ec87dd4175e15a2987824d2a3e172ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ec87dd4175e15a2987824d2a3e172ce">&sect;&nbsp;</a></span>DL_SPI_isRXFIFOFull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_SPI_isRXFIFOFull </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the RX FIFO is full. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the full status of the RX FIFO</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The RX FIFO is full </td></tr>
    <tr><td class="paramname">false</td><td>The RX FIFO is not full </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaff618299ef6569927676f5e6ca6a1922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff618299ef6569927676f5e6ca6a1922">&sect;&nbsp;</a></span>DL_SPI_setParity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_setParity </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_p_i.html#ga773029828a0b68cdff80d13e1fda363b">DL_SPI_PARITY</a>&#160;</td>
          <td class="paramname"><em>parity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the parity configuration used for transactions. </p>
<p>This API sets the configuration for both receive parity and transmit parity. This includes which bit is used, and whether even or odd parity is set.</p>
<p>To individually enable or dsiable the receive or transmit parity, refer to the APIs listed below.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parity</td><td>Parity configuration to use. One of <a class="el" href="group___s_p_i.html#ga773029828a0b68cdff80d13e1fda363b">DL_SPI_PARITY</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i.html#ga7bcdb2b1100ab58dbd64366feadfbf1e" title="Initialize the SPI peripheral. ">DL_SPI_init</a> </dd>
<dd>
<a class="el" href="group___s_p_i.html#ga4881e1a2ac73d62c56314387df91437f" title="Enables receive parity. ">DL_SPI_enableReceiveParity</a> </dd>
<dd>
<a class="el" href="group___s_p_i.html#ga711ec7e7000ae8647244df1ec0e000ad" title="Disables receive parity. ">DL_SPI_disableReceiveParity</a> </dd>
<dd>
<a class="el" href="group___s_p_i.html#gadf3c638f0e8aaa977f819be8a30d04ca" title="Enables transmit parity. ">DL_SPI_enableTransmitParity</a> </dd>
<dd>
<a class="el" href="group___s_p_i.html#gad881d36c83db69c35fe1211e0c53920b" title="Disables transmit parity. ">DL_SPI_disableTransmitParity</a> </dd></dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga5c4a7b9791ecca17d0271fe7ecf0395b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c4a7b9791ecca17d0271fe7ecf0395b">&sect;&nbsp;</a></span>DL_SPI_getParity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___s_p_i.html#ga773029828a0b68cdff80d13e1fda363b">DL_SPI_PARITY</a> DL_SPI_getParity </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current receive and transmit parity configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current parity configuration being used</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___s_p_i.html#ga773029828a0b68cdff80d13e1fda363b">DL_SPI_PARITY</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4881e1a2ac73d62c56314387df91437f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4881e1a2ac73d62c56314387df91437f">&sect;&nbsp;</a></span>DL_SPI_enableReceiveParity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_enableReceiveParity </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables receive parity. </p>
<p>This API only enables receive parity, it does not configure the parity mode used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i.html#gaff618299ef6569927676f5e6ca6a1922" title="Sets the parity configuration used for transactions. ">DL_SPI_setParity</a> </dd></dl>

</div>
</div>
<a id="ga711ec7e7000ae8647244df1ec0e000ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga711ec7e7000ae8647244df1ec0e000ad">&sect;&nbsp;</a></span>DL_SPI_disableReceiveParity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_disableReceiveParity </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables receive parity. </p>
<p>This API only disable receive parity, it does not configure the parity mode used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i.html#gaff618299ef6569927676f5e6ca6a1922" title="Sets the parity configuration used for transactions. ">DL_SPI_setParity</a> </dd></dl>

</div>
</div>
<a id="gabefe2e5c8312d0e85359f7c6061e69ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabefe2e5c8312d0e85359f7c6061e69ce">&sect;&nbsp;</a></span>DL_SPI_isReceiveParityEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_SPI_isReceiveParityEnabled </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if receive parity is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If receive parity is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Receive parity is enabled </td></tr>
    <tr><td class="paramname">false</td><td>Receive parity is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadf3c638f0e8aaa977f819be8a30d04ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf3c638f0e8aaa977f819be8a30d04ca">&sect;&nbsp;</a></span>DL_SPI_enableTransmitParity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_enableTransmitParity </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables transmit parity. </p>
<p>This API only enables transmit parity, it does not configure the parity mode used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i.html#gaff618299ef6569927676f5e6ca6a1922" title="Sets the parity configuration used for transactions. ">DL_SPI_setParity</a> </dd></dl>

</div>
</div>
<a id="gad881d36c83db69c35fe1211e0c53920b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad881d36c83db69c35fe1211e0c53920b">&sect;&nbsp;</a></span>DL_SPI_disableTransmitParity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_disableTransmitParity </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables transmit parity. </p>
<p>This API only disables transmit parity, it does not configure the parity mode used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i.html#gaff618299ef6569927676f5e6ca6a1922" title="Sets the parity configuration used for transactions. ">DL_SPI_setParity</a> </dd></dl>

</div>
</div>
<a id="gabfb2de588357e1010fc4d25afb110dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfb2de588357e1010fc4d25afb110dd3">&sect;&nbsp;</a></span>DL_SPI_isTransmitParityEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_SPI_isTransmitParityEnabled </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if transmit parity is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If transmit parity is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Transmit parity is enabled </td></tr>
    <tr><td class="paramname">false</td><td>Transmit parity is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae4913586ba59c5143952522934ca550a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4913586ba59c5143952522934ca550a">&sect;&nbsp;</a></span>DL_SPI_setFrameFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_setFrameFormat </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_p_i.html#ga1778f795709b41d93eb1408b279e1bd1">DL_SPI_FRAME_FORMAT</a>&#160;</td>
          <td class="paramname"><em>frameFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the frame format to use. </p>
<p>Configures the frame format to use for transactions. If you are using chip select you must use one of the Motorola 4 wire frame formats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frameFormat</td><td>Frame format to use. One of <a class="el" href="group___s_p_i.html#ga1778f795709b41d93eb1408b279e1bd1">DL_SPI_FRAME_FORMAT</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i.html#ga7bcdb2b1100ab58dbd64366feadfbf1e" title="Initialize the SPI peripheral. ">DL_SPI_init</a> </dd></dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga10784e1384b10451ec0d6d732f2b70d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10784e1384b10451ec0d6d732f2b70d4">&sect;&nbsp;</a></span>DL_SPI_getFrameFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___s_p_i.html#ga1778f795709b41d93eb1408b279e1bd1">DL_SPI_FRAME_FORMAT</a> DL_SPI_getFrameFormat </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the frame format configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current frame format being used</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___s_p_i.html#ga1778f795709b41d93eb1408b279e1bd1">DL_SPI_FRAME_FORMAT</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabb7227ea45c66da923fc1dd644f27122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb7227ea45c66da923fc1dd644f27122">&sect;&nbsp;</a></span>DL_SPI_setDataSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_setDataSize </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_p_i.html#ga06925b84fe07eb69a8e1f23ab30d80da">DL_SPI_DATA_SIZE</a>&#160;</td>
          <td class="paramname"><em>dataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the size for transfers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataSize</td><td>Number of bits used in a transfer. One of <a class="el" href="group___s_p_i.html#ga06925b84fe07eb69a8e1f23ab30d80da">DL_SPI_DATA_SIZE</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i.html#ga7bcdb2b1100ab58dbd64366feadfbf1e" title="Initialize the SPI peripheral. ">DL_SPI_init</a> </dd></dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga9d6329786f3972f228b324b03c2f649e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d6329786f3972f228b324b03c2f649e">&sect;&nbsp;</a></span>DL_SPI_getDataSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___s_p_i.html#ga06925b84fe07eb69a8e1f23ab30d80da">DL_SPI_DATA_SIZE</a> DL_SPI_getDataSize </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the configured size for transfers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The currently configured size for transfers</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___s_p_i.html#ga06925b84fe07eb69a8e1f23ab30d80da">DL_SPI_DATA_SIZE</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7d153fe0c2f28f8c4165c0bce4c895cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d153fe0c2f28f8c4165c0bce4c895cf">&sect;&nbsp;</a></span>DL_SPI_setMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_setMode </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_p_i.html#gab5d9c38bb4fa37d93aaa0e67eb22b7ae">DL_SPI_MODE</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether the device should be in controller/peripheral mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Mode to configure the SPI into. One of <a class="el" href="group___s_p_i.html#gab5d9c38bb4fa37d93aaa0e67eb22b7ae">DL_SPI_MODE</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i.html#ga7bcdb2b1100ab58dbd64366feadfbf1e" title="Initialize the SPI peripheral. ">DL_SPI_init</a> </dd></dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga6004442fbd29c2ed4cb07a7ad16e140b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6004442fbd29c2ed4cb07a7ad16e140b">&sect;&nbsp;</a></span>DL_SPI_getMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___s_p_i.html#gab5d9c38bb4fa37d93aaa0e67eb22b7ae">DL_SPI_MODE</a> DL_SPI_getMode </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current mode for the SPI (controller/peripheral) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The currently configured mode for the SPI (controller/peripheral)</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___s_p_i.html#gab5d9c38bb4fa37d93aaa0e67eb22b7ae">DL_SPI_MODE</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2eef87b89f47d4bfa2b110ee2232fc7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2eef87b89f47d4bfa2b110ee2232fc7a">&sect;&nbsp;</a></span>DL_SPI_setBitOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_setBitOrder </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_p_i.html#ga79d02b79cd7d5383b93311454ed5f3ef">DL_SPI_BIT_ORDER</a>&#160;</td>
          <td class="paramname"><em>bitOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the bit order used for transfers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bitOrder</td><td>Order for bits to be sent out during transfer. One of <a class="el" href="group___s_p_i.html#ga79d02b79cd7d5383b93311454ed5f3ef">DL_SPI_BIT_ORDER</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i.html#ga7bcdb2b1100ab58dbd64366feadfbf1e" title="Initialize the SPI peripheral. ">DL_SPI_init</a> </dd></dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="gace909483aab21f028a68e76f11b03a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace909483aab21f028a68e76f11b03a04">&sect;&nbsp;</a></span>DL_SPI_getBitOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___s_p_i.html#ga79d02b79cd7d5383b93311454ed5f3ef">DL_SPI_BIT_ORDER</a> DL_SPI_getBitOrder </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current bit order used for transfers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The currently configured bit order</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___s_p_i.html#ga79d02b79cd7d5383b93311454ed5f3ef">DL_SPI_BIT_ORDER</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga95f58fa6481f1096caf19b5bde02a721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95f58fa6481f1096caf19b5bde02a721">&sect;&nbsp;</a></span>DL_SPI_enableLoopbackMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_enableLoopbackMode </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables loopback mode. </p>
<p>Enables the loopback mode. When enabled, the output of the transmit serial shifter is connected to the input of the receive serial shifter internally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1fea93168e5ed13fdbfcbb2fdc5eaf29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fea93168e5ed13fdbfcbb2fdc5eaf29">&sect;&nbsp;</a></span>DL_SPI_disableLoopbackMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_disableLoopbackMode </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables loopback mode. </p>
<p>Disables the loopback mode. When disabled, the transmit serial shifter and receive serial shifter are not connected internally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad1ba6608163cf3db3f01ef92acfc605e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1ba6608163cf3db3f01ef92acfc605e">&sect;&nbsp;</a></span>DL_SPI_isLoopbackModeEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_SPI_isLoopbackModeEnabled </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the loopback mode is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status of the loopback mode</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if loopback mode is enabled </td></tr>
    <tr><td class="paramname">false</td><td>if loopback mode is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab702c162ca66cbe0fb435f42c4e45bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab702c162ca66cbe0fb435f42c4e45bed">&sect;&nbsp;</a></span>DL_SPI_setRepeatTransmit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_setRepeatTransmit </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numRepeats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set counter for repeated transmit. </p>
<p>Repeated transmit allows you to send the same data multiple times. This is essentially the same as writing the data into the transmit buffer repeatedly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numRepeats</td><td>number of times to repeat the transfer. Should be a value between 0-255. <ul>
<li>0 disables the repeated transfer </li>
<li>1-255 repeats that many times. So will be sent numRepeats + 1 times in total. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga28a91c75a55dbfdc5b67c82fd14f51ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28a91c75a55dbfdc5b67c82fd14f51ec">&sect;&nbsp;</a></span>DL_SPI_getRepeatTransmit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_SPI_getRepeatTransmit </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get counter for repeated transmit. </p>
<p>Repeated transmit allows you to send the same data multiple times. This is essentially the same as writing the data into the transmit buffer repeatedly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of repeats used for transfer</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Repeated transfer is disabled </td></tr>
    <tr><td class="paramname">1-255</td><td>Repeat that many times. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga95013d33706c0f408ea5059cfcdbdd6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95013d33706c0f408ea5059cfcdbdd6e">&sect;&nbsp;</a></span>DL_SPI_enablePeripheralAlignDataOnChipSelect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_enablePeripheralAlignDataOnChipSelect </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables data alignment on chip select for peripherals. </p>
<p>When enabled, the receieve bit counter is cleared automatically when the chip select gets set inactive. This helps the peripheral synchronize again to the controller in case of a disturbance or glitch on the clock line or during initialization.</p>
<p>This is only relevant when in peripheral mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gada4a4222d9d346236330744ce648be80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada4a4222d9d346236330744ce648be80">&sect;&nbsp;</a></span>DL_SPI_disablePeripheralAlignDataOnChipSelect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_disablePeripheralAlignDataOnChipSelect </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables data alignment on chip select for peripherals. </p>
<p>When disable, the receieve bit counter is not cleared automatically when the chip select gets set inactive.</p>
<p>This is only relevant when in peripheral mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6427aead1f56189686c9b3fc295624bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6427aead1f56189686c9b3fc295624bf">&sect;&nbsp;</a></span>DL_SPI_isPeripheralAlignDataOnChipSelectEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_SPI_isPeripheralAlignDataOnChipSelectEnabled </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if data alignment on chip select for peripherals is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status of data alignment on chip select</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Data alignment on chip select is enabled </td></tr>
    <tr><td class="paramname">false</td><td>Data alignment on chip select is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad1c1d31aeb86e180b4d617956b2b90b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1c1d31aeb86e180b4d617956b2b90b6">&sect;&nbsp;</a></span>DL_SPI_enablePacking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_enablePacking </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables packing feature. </p>
<p>When enabled, two entries of the RX FIFO are returned as a 32-bit value. When reading the TX FIFO, if the last write to that field was a 32-bit write, those 32-bits will be returned. When writing to the TX FIFO, a 32-bit write will be written as one FIFO entry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafe32a2370e84eb7db0673e2affd338aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe32a2370e84eb7db0673e2affd338aa">&sect;&nbsp;</a></span>DL_SPI_disablePacking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_disablePacking </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables packing feature. </p>
<p>When disabled, 1 entry of the RX FIFO is returned as a 16-bit value. When reading the TX FIFO, if the last write to that field was a 16-bit write, those 16-bits wil be returned. When writing to the TX FIFO, a 32-bit write will be written as two FIFO entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0a5a5107f72c4dc7788d0750f4b0c169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a5a5107f72c4dc7788d0750f4b0c169">&sect;&nbsp;</a></span>DL_SPI_isPackingEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_SPI_isPackingEnabled </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if packing feature is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packing is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Packing is enabled </td></tr>
    <tr><td class="paramname">false</td><td>Packing is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga49d8de0e6e9fe919c8879e9ec8256359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49d8de0e6e9fe919c8879e9ec8256359">&sect;&nbsp;</a></span>DL_SPI_setChipSelect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_setChipSelect </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_p_i.html#gac5b7531f268fb581f2f3117bd08eb4a0">DL_SPI_CHIP_SELECT</a>&#160;</td>
          <td class="paramname"><em>chipSelect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set chip select used for controller or peripheral mode. </p>
<p>Choose which chip select should be used for data transfer. User must ensure one of the 4-wire frame formats were selected using <a class="el" href="group___s_p_i.html#ga7bcdb2b1100ab58dbd64366feadfbf1e">DL_SPI_init</a> or <a class="el" href="group___s_p_i.html#gae4913586ba59c5143952522934ca550a">DL_SPI_setFrameFormat</a>.</p>
<p>This API is for both controller and peripheral modes, and the chip select can be changed in the application by calling this API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chipSelect</td><td>the chip select pin to use. One of <a class="el" href="group___s_p_i.html#gac5b7531f268fb581f2f3117bd08eb4a0">DL_SPI_CHIP_SELECT</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="gaffadbc18dce16e01845061cec9539998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffadbc18dce16e01845061cec9539998">&sect;&nbsp;</a></span>DL_SPI_getChipSelect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___s_p_i.html#gac5b7531f268fb581f2f3117bd08eb4a0">DL_SPI_CHIP_SELECT</a> DL_SPI_getChipSelect </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get chip select used for controller or peripheral mode. </p>
<p>This API is for both controller and peripheral modes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current chip selected used for data transfer</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___s_p_i.html#gac5b7531f268fb581f2f3117bd08eb4a0">DL_SPI_CHIP_SELECT</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6d77b7c9ab09a76d23b905e014b483ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d77b7c9ab09a76d23b905e014b483ab">&sect;&nbsp;</a></span>DL_SPI_setPeripheralReceiveTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_setPeripheralReceiveTimeout </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set peripheral receive timeout. </p>
<p>Sets the number of clock cycles before a receive timeout occurs.</p>
<p>This is only relevant when in peripheral mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Number of clock cycles before a receive timeout occurs. Must be between 0-63. <ul>
<li>0 Disables receive timeout </li>
<li>1-63 Number of clock cycles before timeout </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="gab8110072434861d79f3b125c14b97327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8110072434861d79f3b125c14b97327">&sect;&nbsp;</a></span>DL_SPI_getPeripheralReceiveTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_SPI_getPeripheralReceiveTimeout </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get peripheral receive timeout. </p>
<p>This is only relevant when in peripheral mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current amount of cycles used for a peripheral timeout</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>indicating that receive timeout is disabled </td></tr>
    <tr><td class="paramname">1-63</td><td>number of clock cycles before a receive timeout occurs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga80b3037d10bf86943a061938fe71af66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80b3037d10bf86943a061938fe71af66">&sect;&nbsp;</a></span>DL_SPI_setControllerCommandDataModeConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_setControllerCommandDataModeConfig </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the command/data mode. </p>
<p>Command/data mode allows the hardware to control the C/D pin to indicate whether the data being transferred is a command or just data. The C/D pin is low for commands and high for data.</p>
<p>You can use this API to manually set the C/D pin by passing in <a class="el" href="group___d_l___s_p_i___c_d___m_o_d_e.html#ga1f6e013f4b39760684a3d6414fffd106">DL_SPI_CD_MODE_DATA</a> or <a class="el" href="group___d_l___s_p_i___c_d___m_o_d_e.html#ga70a5796da0f80315d88f609d739756b6">DL_SPI_CD_MODE_COMMAND</a>. You can also have the C/D pin switch automatically by passing in how many bytes are part of the command transfer. The C/D pin will stay low until that many bytes are sent out and then automatically switch to high.</p>
<p>This is only relevant when in controller mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>configuration for command/data mode. One of: <ul>
<li>DL_SPI_CD_MODE_DATA </li>
<li>DL_SPI_CD_MODE_COMMAND </li>
<li>A value between 1-14 to indicate how many bytes should be sent as command </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="gaff81d2cfa6dbfaf0df1c002f793f204a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff81d2cfa6dbfaf0df1c002f793f204a">&sect;&nbsp;</a></span>DL_SPI_getControllerCommandDataModeConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_SPI_getControllerCommandDataModeConfig </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the command/data mode configuration. </p>
<p>Returns the current configuration for command/data mode. When using the automatic C/D pin the value read back will be the number of command bytes remaining to be sent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current configuration for command/data mode</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_SPI_CD_MODE_DATA</td><td>if in manual data mode </td></tr>
    <tr><td class="paramname">DL_SPI_CD_MODE_COMMAND</td><td>if in manual command mode </td></tr>
    <tr><td class="paramname">1-14</td><td>indicating how many command bytes still need to be sent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga755438cfca0ea7692c0828b107b8d72a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga755438cfca0ea7692c0828b107b8d72a">&sect;&nbsp;</a></span>DL_SPI_enableControllerCommandDataMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_enableControllerCommandDataMode </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables command/data mode. </p>
<p>When command/data mode is enabled, the C/D pin is used to differentiate between command and data during the transaction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i.html#ga80b3037d10bf86943a061938fe71af66" title="Configure the command/data mode. ">DL_SPI_setControllerCommandDataModeConfig</a> </dd></dl>

</div>
</div>
<a id="ga2c8385ae7f94401e02abb79d198c4ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c8385ae7f94401e02abb79d198c4ced">&sect;&nbsp;</a></span>DL_SPI_disableControllerCommandDataMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_disableControllerCommandDataMode </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables command/data mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga936e03e47bb826f48cde00b2490cb0df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga936e03e47bb826f48cde00b2490cb0df">&sect;&nbsp;</a></span>DL_SPI_isControllerCommandDataModeEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_SPI_isControllerCommandDataModeEnabled </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if command/data mode is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status of command/data mode</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Command/data mode is enabled </td></tr>
    <tr><td class="paramname">false</td><td>Command/data mode is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadeab493584934784e399b486d8d706d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadeab493584934784e399b486d8d706d6">&sect;&nbsp;</a></span>DL_SPI_enablePeripheralDataOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_enablePeripheralDataOutput </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables peripheral data output. </p>
<p>When peripheral data output is enabled, the peripheral can drive the POCI output pin. This will cause problems if all peripherals have their RXD lines tied together and the controller is trying to broadcast a message to all peripherals while ensuring only one peripheral drives data onto its serial output line.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga477925103d4cf5e813b3dd322a94e491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga477925103d4cf5e813b3dd322a94e491">&sect;&nbsp;</a></span>DL_SPI_disablePeripheralDataOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_disablePeripheralDataOutput </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables peripheral data output. </p>
<p>When peripheral data output is disabled, the peripheral cannot drive the POCI output pin. This allows multiple peripherals that have their RXD lines tied together to receive a broadcasted message from a controller.</p>
<p>This is only relevant when in peripheral mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad6acfb31a26f9d040539205f7e5a5506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6acfb31a26f9d040539205f7e5a5506">&sect;&nbsp;</a></span>DL_SPI_isPeripheralDataOutputEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_SPI_isPeripheralDataOutputEnabled </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if peripheral data output is enabled. </p>
<p>This is only relevant when in peripheral mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If peripheral data output is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if peripheral data output is enabled </td></tr>
    <tr><td class="paramname">false</td><td>if peripheral data output is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga69517779fd6a6dc63b7035a382afe938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69517779fd6a6dc63b7035a382afe938">&sect;&nbsp;</a></span>DL_SPI_setDelayedSampling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_setDelayedSampling </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the delay sampling. </p>
<p>In controller mode only, the data on the input pin will be delayed sampled by the defined SPI clock cycles. The delay can be adjusted in steps of SPI input clock steps. The maximum allowed delay should not exceed the length of one data frame</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delay</td><td>The number of SPI clock cycles to delay sampling on input pin. Value between 0-15. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga0131073cd9e16115e96f091371d3399c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0131073cd9e16115e96f091371d3399c">&sect;&nbsp;</a></span>DL_SPI_getDelayedSampling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_SPI_getDelayedSampling </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the delay sampling. </p>
<p>In controller mode only, the data on the input pin will be delayed sampled by the defined SPI clock cycles. The delay can be adjusted in steps of SPI input clock steps. The maximum allowed delay should not exceed the length of one data frame</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The amount of delay sampling on the input pin in SPI clock cycles.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- 15. The amount of delay sampling in SPI clock cycles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga964944349d443791436c86969f5dd490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga964944349d443791436c86969f5dd490">&sect;&nbsp;</a></span>DL_SPI_setFIFOThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_setFIFOThreshold </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_p_i.html#gad62dc10499a7ad2a0285128125f75b51">DL_SPI_RX_FIFO_LEVEL</a>&#160;</td>
          <td class="paramname"><em>rxThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_p_i.html#ga15208bcdee85c9fdd007a85e761a4843">DL_SPI_TX_FIFO_LEVEL</a>&#160;</td>
          <td class="paramname"><em>txThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the RX and TX FIFO interrupt threshold level. </p>
<p>Select the threshold for the receive and transmit FIFO interrupts. The interrupts are generated based on a transition through a level rather than being based on the level. That is, the interrupts are generated when the fill level progresses through the trigger level.</p>
<p>For example, if the trigger level is set to the half-way mark, the interrupt is triggered when the FIFO becomes half empty/full.</p>
<p>Out of reset, the FIFOs are triggered to interrupt at half-way mark.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rxThreshold</td><td>One of <a class="el" href="group___s_p_i.html#gad62dc10499a7ad2a0285128125f75b51">DL_SPI_RX_FIFO_LEVEL</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">txThreshold</td><td>One of <a class="el" href="group___s_p_i.html#ga15208bcdee85c9fdd007a85e761a4843">DL_SPI_TX_FIFO_LEVEL</a> </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="gad7a261d22530dd8159a4127225cb11f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7a261d22530dd8159a4127225cb11f9">&sect;&nbsp;</a></span>DL_SPI_getTXFIFOThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___s_p_i.html#ga15208bcdee85c9fdd007a85e761a4843">DL_SPI_TX_FIFO_LEVEL</a> DL_SPI_getTXFIFOThreshold </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the TX FIFO interrupt threshold level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The TX FIFO interrupt threshold level</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___s_p_i.html#ga15208bcdee85c9fdd007a85e761a4843">DL_SPI_TX_FIFO_LEVEL</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5c0965ede169729e0671efefc86039b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c0965ede169729e0671efefc86039b4">&sect;&nbsp;</a></span>DL_SPI_getRXFIFOThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___s_p_i.html#gad62dc10499a7ad2a0285128125f75b51">DL_SPI_RX_FIFO_LEVEL</a> DL_SPI_getRXFIFOThreshold </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the RX FIFO interrupt threshold level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The RX FIFO interrupt threshold level</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___s_p_i.html#gad62dc10499a7ad2a0285128125f75b51">DL_SPI_RX_FIFO_LEVEL</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3c4a02c29afd23921de3499f67fac64e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c4a02c29afd23921de3499f67fac64e">&sect;&nbsp;</a></span>DL_SPI_setBitRateSerialClockDivider()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_setBitRateSerialClockDivider </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>SCR</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the SPI bit rate serial clock divider (SCR) </p>
<p>The SPI includes a programmable bit rate clock divider and prescaler to generate the serial output clock. The bit rates are supported up to FUNCCLK/2. The functional clock selection depends on the specific device, please refer to the device datasheet and PMU/Clock section.</p>
<p>The SPI output bit rate is calculated with the following formula: SPI bit rate = (SPI functional clock) / ((1 + SCR)*2) Given this formula, the SCR can be calculated: SCR = (SPI functional clock) / ((2 * SPI bit rate) - 1)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SCR</td><td>The SPI serial clock divider. Value between 0-1023. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="gae0ae83a4e6b86488a627f86cb42e881c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0ae83a4e6b86488a627f86cb42e881c">&sect;&nbsp;</a></span>DL_SPI_getBitRateSerialClockDivider()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_SPI_getBitRateSerialClockDivider </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the SPI bit rate serial clock divider (SCR) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current bit rate serial clock divider</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>SPI SCR. Value from 0-1023 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1db81249e51e1d7d083b1f08ac3c74f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1db81249e51e1d7d083b1f08ac3c74f8">&sect;&nbsp;</a></span>DL_SPI_transmitData8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_transmitData8 </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes 8-bit data into the TX FIFO for transmit. </p>
<p>Puts the data into the TX FIFO without checking its status. Use if already sure the TX FIFO has space for the write. See related APIs for additional transmit options.</p>
<p>Can be used for any data transfers that are less than or equal to 8 bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>data to send</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i.html#ga5a49cffcc93cd7f5f28691656084aa35" title="Blocks to ensure transmit is ready before sending data. ">DL_SPI_transmitDataBlocking8</a> </dd>
<dd>
<a class="el" href="group___s_p_i.html#gaa747ac1ef89a31a25f59edd36e7434b1" title="Checks the TX FIFO before trying to transmit data. ">DL_SPI_transmitDataCheck8</a> </dd></dl>

</div>
</div>
<a id="gadd62074cdf1d5c54262a99c20b233421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd62074cdf1d5c54262a99c20b233421">&sect;&nbsp;</a></span>DL_SPI_transmitData16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_transmitData16 </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes 16-bit data into the TX FIFO for transmit. </p>
<p>Puts the data into the TX FIFO without checking its status. Use if already sure the TX FIFO has space for the write. See related APIs for additional transmit options.</p>
<p>Can be used for any data transfers that are less than or equal to 16 bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>data to send</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i.html#ga6adff0a4426d68ec4460498076edd045" title="Blocks to ensure transmit is ready before sending data. ">DL_SPI_transmitDataBlocking16</a> </dd>
<dd>
<a class="el" href="group___s_p_i.html#ga0ccfdddda9f493d31a7886b93fe97ffd" title="Checks the TX FIFO before trying to transmit data. ">DL_SPI_transmitDataCheck16</a> </dd></dl>

</div>
</div>
<a id="gaea8f2bccfe6a5d794262a9b6820c8275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea8f2bccfe6a5d794262a9b6820c8275">&sect;&nbsp;</a></span>DL_SPI_transmitData32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_transmitData32 </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes 32-bit data into the TX FIFO for transmit. </p>
<p>Puts the data into the TX FIFO without checking its status. Use if already sure the TX FIFO has space for the write. See related APIs for additional transmit options.</p>
<p>Can be used for any data transfers that are less than or equal to 32 bits.</p>
<p>NOTE: If packing is enabled by calling <a class="el" href="group___s_p_i.html#gad1c1d31aeb86e180b4d617956b2b90b6">DL_SPI_enablePacking</a> prior to calling this API, then a 32-bit write will be written as one FIFO entry. If packing is disabled, then a 32-bit write will be written as two FIFO entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>data to send</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i.html#gad1c1d31aeb86e180b4d617956b2b90b6" title="Enables packing feature. ">DL_SPI_enablePacking</a> </dd>
<dd>
<a class="el" href="group___s_p_i.html#ga9b8cd4c5a324feeeb75e9ad05576d762" title="Blocks to ensure transmit is ready before sending data. ">DL_SPI_transmitDataBlocking32</a> </dd>
<dd>
<a class="el" href="group___s_p_i.html#ga49621278af197222784b1d12bea75fc3" title="Checks the TX FIFO before trying to transmit data. ">DL_SPI_transmitDataCheck32</a> </dd></dl>

</div>
</div>
<a id="ga4567c4c2551bafbfc9b4646e8522631f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4567c4c2551bafbfc9b4646e8522631f">&sect;&nbsp;</a></span>DL_SPI_receiveData8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint8_t DL_SPI_receiveData8 </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads 8-bit data from the RX FIFO. </p>
<p>Reads the data from the RX FIFO without checking its status. Use if already sure the RX FIFO has data available. See related APIs for additional receive options.</p>
<p>Can be used for any data transfers that are less than or equal to 8 bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data in the RX FIFO</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i.html#ga6042d86a27dc1f0ac793a6b14c19d60f" title="Blocks to ensure receive is ready before reading data. ">DL_SPI_receiveDataBlocking8</a> </dd>
<dd>
<a class="el" href="group___s_p_i.html#gaed7d1780e6dbf7b1429c4add272accdf" title="Checks the RX FIFO before trying to transmit data. ">DL_SPI_receiveDataCheck8</a> </dd></dl>

</div>
</div>
<a id="gac94abca28d5be6a6e8ef3587012b6071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac94abca28d5be6a6e8ef3587012b6071">&sect;&nbsp;</a></span>DL_SPI_receiveData16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint16_t DL_SPI_receiveData16 </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads 16-bit data from the RX FIFO. </p>
<p>Reads the data from the RX FIFO without checking its status. Use if already sure the RX FIFO has data available. See related APIs for additional receive options.</p>
<p>Can be used for any data transfers that are less than or equal to 16 bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data in the RX FIFO</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i.html#ga4bcdc016db3fa393f09bd17e624856fd" title="Blocks to ensure receive is ready before reading data. ">DL_SPI_receiveDataBlocking16</a> </dd>
<dd>
<a class="el" href="group___s_p_i.html#gaf632787409736f5804b74a8e78995100" title="Checks the RX FIFO before trying to transmit data. ">DL_SPI_receiveDataCheck16</a> </dd></dl>

</div>
</div>
<a id="ga717ecfe8b54b8135b448419d25659d01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga717ecfe8b54b8135b448419d25659d01">&sect;&nbsp;</a></span>DL_SPI_receiveData32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_SPI_receiveData32 </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads 32-bit data from the RX FIFO. </p>
<p>Reads the data from the RX FIFO without checking its status. Use if already sure the RX FIFO has data available. See related APIs for additional receive options.</p>
<p>Can be used for any data transfers that are less than or equal to 32 bits.</p>
<p>NOTE: Requires that packing has been enabled by calling <a class="el" href="group___s_p_i.html#gad1c1d31aeb86e180b4d617956b2b90b6">DL_SPI_enablePacking</a> prior to calling this API. When packing is enabled, two entries of the RX FIFO are returned as a 32-bit value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data in the RX FIFO</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>DL_SPI_enablePacking</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i.html#ga1d5a7664cd307273cbcaf9da299b3b91" title="Blocks to ensure receive is ready before reading data. ">DL_SPI_receiveDataBlocking32</a> </dd>
<dd>
<a class="el" href="group___s_p_i.html#ga222c7dffefa2bf155766cd7c84d023f2" title="Checks the RX FIFO before trying to transmit data. ">DL_SPI_receiveDataCheck32</a> </dd></dl>

</div>
</div>
<a id="ga0a86c2fb7c36d466076b497af09b18e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a86c2fb7c36d466076b497af09b18e5">&sect;&nbsp;</a></span>DL_SPI_enableInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_enableInterrupt </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable SPI interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptMask</td><td>Bit mask of interrupts to enable. Bitwise OR of <a class="el" href="group___d_l___s_p_i___i_n_t_e_r_r_u_p_t.html">DL_SPI_INTERRUPT</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga65638f5a3719afe2856ba0da9a2921ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65638f5a3719afe2856ba0da9a2921ba">&sect;&nbsp;</a></span>DL_SPI_disableInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_disableInterrupt </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable SPI interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptMask</td><td>Bit mask of interrupts to disable. Bitwise OR of <a class="el" href="group___d_l___s_p_i___i_n_t_e_r_r_u_p_t.html">DL_SPI_INTERRUPT</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga970ffa57f3c30c27b6219db984ae4dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga970ffa57f3c30c27b6219db984ae4dd8">&sect;&nbsp;</a></span>DL_SPI_getEnabledInterrupts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_SPI_getEnabledInterrupts </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check which SPI interrupts are enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptMask</td><td>Bit mask of interrupts to check. Bitwise OR of <a class="el" href="group___d_l___s_p_i___i_n_t_e_r_r_u_p_t.html">DL_SPI_INTERRUPT</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Which of the requested SPI interrupts are enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Bitwise</td><td>OR of <a class="el" href="group___d_l___s_p_i___i_n_t_e_r_r_u_p_t.html">DL_SPI_INTERRUPT</a> values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabe8d63c06cb83e51b8f0859cbeca8fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe8d63c06cb83e51b8f0859cbeca8fd8">&sect;&nbsp;</a></span>DL_SPI_getEnabledInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_SPI_getEnabledInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check interrupt flag of enabled SPI interrupts. </p>
<p>Checks if any of the SPI interrupts that were previously enabled are pending.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptMask</td><td>Bit mask of interrupts to check. Bitwise OR of <a class="el" href="group___d_l___s_p_i___i_n_t_e_r_r_u_p_t.html">DL_SPI_INTERRUPT</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Which of the requested SPI interrupts are pending</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Bitwise</td><td>OR of <a class="el" href="group___d_l___s_p_i___i_n_t_e_r_r_u_p_t.html">DL_SPI_INTERRUPT</a> values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i.html#ga0a86c2fb7c36d466076b497af09b18e5" title="Enable SPI interrupts. ">DL_SPI_enableInterrupt</a> </dd></dl>

</div>
</div>
<a id="gadfa0c97668147c1537616b25d041543e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfa0c97668147c1537616b25d041543e">&sect;&nbsp;</a></span>DL_SPI_getRawInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_SPI_getRawInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check interrupt flag of any SPI interrupt. </p>
<p>Checks if any of the SPI interrupts are pending. Interrupts do not have to be previously enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptMask</td><td>Bit mask of interrupts to check. Bitwise OR of <a class="el" href="group___d_l___s_p_i___i_n_t_e_r_r_u_p_t.html">DL_SPI_INTERRUPT</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Which of the requested SPI interrupts are pending</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Bitwise</td><td>OR of <a class="el" href="group___d_l___s_p_i___i_n_t_e_r_r_u_p_t.html">DL_SPI_INTERRUPT</a> values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa5561e3632fa0de4f0d2637a4a59bfb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5561e3632fa0de4f0d2637a4a59bfb9">&sect;&nbsp;</a></span>DL_SPI_getPendingInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___s_p_i.html#ga2856971e4f44c549983e6358d0fde683">DL_SPI_IIDX</a> DL_SPI_getPendingInterrupt </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get highest priority pending SPI interrupt. </p>
<p>Checks if any of the SPI interrupts are pending. Interrupts do not have to be previously enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The highest priority pending SPI interrupt. One of <a class="el" href="group___s_p_i.html#ga2856971e4f44c549983e6358d0fde683">DL_SPI_IIDX</a> </dd></dl>

</div>
</div>
<a id="ga3a3adedc52cb49293eb395e3b61a3365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a3adedc52cb49293eb395e3b61a3365">&sect;&nbsp;</a></span>DL_SPI_clearInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_clearInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear pending SPI interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptMask</td><td>Bit mask of interrupts to clear. Bitwise OR of <a class="el" href="group___d_l___s_p_i___i_n_t_e_r_r_u_p_t.html">DL_SPI_INTERRUPT</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___s_p_i.html#gaf3476eca47770d35f187b5c04e60b632">DL_SPI_drainRXFIFO16()</a>, <a class="el" href="group___s_p_i.html#gab5ce50f3a0f751d8cb2f4ed499755e93">DL_SPI_drainRXFIFO32()</a>, <a class="el" href="group___s_p_i.html#ga1636bbb8fd41d76c6d9514306477e914">DL_SPI_drainRXFIFO8()</a>, <a class="el" href="group___s_p_i.html#ga93e856d5f712743ea02f133d3292c5ea">DL_SPI_fillTXFIFO16()</a>, <a class="el" href="group___s_p_i.html#ga7af3ac6f55af2348e02d16d5c67e1b29">DL_SPI_fillTXFIFO32()</a>, <a class="el" href="group___s_p_i.html#gad002b7ba9034c365ad8fde923bdf0107">DL_SPI_fillTXFIFO8()</a>, <a class="el" href="group___s_p_i.html#ga4bcdc016db3fa393f09bd17e624856fd">DL_SPI_receiveDataBlocking16()</a>, <a class="el" href="group___s_p_i.html#ga1d5a7664cd307273cbcaf9da299b3b91">DL_SPI_receiveDataBlocking32()</a>, <a class="el" href="group___s_p_i.html#ga6042d86a27dc1f0ac793a6b14c19d60f">DL_SPI_receiveDataBlocking8()</a>, <a class="el" href="group___s_p_i.html#gaf632787409736f5804b74a8e78995100">DL_SPI_receiveDataCheck16()</a>, <a class="el" href="group___s_p_i.html#ga222c7dffefa2bf155766cd7c84d023f2">DL_SPI_receiveDataCheck32()</a>, <a class="el" href="group___s_p_i.html#gaed7d1780e6dbf7b1429c4add272accdf">DL_SPI_receiveDataCheck8()</a>, <a class="el" href="group___s_p_i.html#ga6adff0a4426d68ec4460498076edd045">DL_SPI_transmitDataBlocking16()</a>, <a class="el" href="group___s_p_i.html#ga9b8cd4c5a324feeeb75e9ad05576d762">DL_SPI_transmitDataBlocking32()</a>, <a class="el" href="group___s_p_i.html#ga5a49cffcc93cd7f5f28691656084aa35">DL_SPI_transmitDataBlocking8()</a>, <a class="el" href="group___s_p_i.html#ga0ccfdddda9f493d31a7886b93fe97ffd">DL_SPI_transmitDataCheck16()</a>, <a class="el" href="group___s_p_i.html#ga49621278af197222784b1d12bea75fc3">DL_SPI_transmitDataCheck32()</a>, and <a class="el" href="group___s_p_i.html#gaa747ac1ef89a31a25f59edd36e7434b1">DL_SPI_transmitDataCheck8()</a>.</p>

</div>
</div>
<a id="ga5a49cffcc93cd7f5f28691656084aa35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a49cffcc93cd7f5f28691656084aa35">&sect;&nbsp;</a></span>DL_SPI_transmitDataBlocking8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_SPI_transmitDataBlocking8 </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks to ensure transmit is ready before sending data. </p>
<p>Puts the data into the TX FIFO after blocking to ensure the TX FIFO is not full. Will wait indefinitely until there is space in the TX FIFO. See related APIs for additional transmit options.</p>
<p>Can be used for any data transfers that are less than or equal to 8 bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>data to send</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i.html#ga1db81249e51e1d7d083b1f08ac3c74f8" title="Writes 8-bit data into the TX FIFO for transmit. ">DL_SPI_transmitData8</a> </dd>
<dd>
<a class="el" href="group___s_p_i.html#gaa747ac1ef89a31a25f59edd36e7434b1" title="Checks the TX FIFO before trying to transmit data. ">DL_SPI_transmitDataCheck8</a> </dd></dl>

<p>Referenced by <a class="el" href="group___s_p_i.html#ga3a3adedc52cb49293eb395e3b61a3365">DL_SPI_clearInterruptStatus()</a>.</p>

</div>
</div>
<a id="ga6adff0a4426d68ec4460498076edd045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6adff0a4426d68ec4460498076edd045">&sect;&nbsp;</a></span>DL_SPI_transmitDataBlocking16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_SPI_transmitDataBlocking16 </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks to ensure transmit is ready before sending data. </p>
<p>Puts the data into the TX FIFO after blocking to ensure the TX FIFO is not full. Will wait indefinitely until there is space in the TX FIFO. See related APIs for additional transmit options.</p>
<p>Can be used for any data transfers that are less than or equal to 16 bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>data to send</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i.html#gadd62074cdf1d5c54262a99c20b233421" title="Writes 16-bit data into the TX FIFO for transmit. ">DL_SPI_transmitData16</a> </dd>
<dd>
<a class="el" href="group___s_p_i.html#ga0ccfdddda9f493d31a7886b93fe97ffd" title="Checks the TX FIFO before trying to transmit data. ">DL_SPI_transmitDataCheck16</a> </dd></dl>

<p>Referenced by <a class="el" href="group___s_p_i.html#ga3a3adedc52cb49293eb395e3b61a3365">DL_SPI_clearInterruptStatus()</a>.</p>

</div>
</div>
<a id="ga9b8cd4c5a324feeeb75e9ad05576d762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b8cd4c5a324feeeb75e9ad05576d762">&sect;&nbsp;</a></span>DL_SPI_transmitDataBlocking32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_SPI_transmitDataBlocking32 </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks to ensure transmit is ready before sending data. </p>
<p>Puts the data into the TX FIFO after blocking to ensure the TX FIFO is not full. Will wait indefinitely until there is space in the TX FIFO. See related APIs for additional transmit options.</p>
<p>Can be used for any data transfers that are less than or equal to 32 bits.</p>
<p>NOTE: If packing is enabled by calling <a class="el" href="group___s_p_i.html#gad1c1d31aeb86e180b4d617956b2b90b6">DL_SPI_enablePacking</a> prior to calling this API, then a 32-bit write will be written as one FIFO entry. If packing is disabled, then a 32-bit write will be written as two FIFO entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>data to send</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i.html#gad1c1d31aeb86e180b4d617956b2b90b6" title="Enables packing feature. ">DL_SPI_enablePacking</a> </dd>
<dd>
<a class="el" href="group___s_p_i.html#gaea8f2bccfe6a5d794262a9b6820c8275" title="Writes 32-bit data into the TX FIFO for transmit. ">DL_SPI_transmitData32</a> </dd>
<dd>
<a class="el" href="group___s_p_i.html#ga49621278af197222784b1d12bea75fc3" title="Checks the TX FIFO before trying to transmit data. ">DL_SPI_transmitDataCheck32</a> </dd></dl>

<p>Referenced by <a class="el" href="group___s_p_i.html#ga3a3adedc52cb49293eb395e3b61a3365">DL_SPI_clearInterruptStatus()</a>.</p>

</div>
</div>
<a id="ga6042d86a27dc1f0ac793a6b14c19d60f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6042d86a27dc1f0ac793a6b14c19d60f">&sect;&nbsp;</a></span>DL_SPI_receiveDataBlocking8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t DL_SPI_receiveDataBlocking8 </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks to ensure receive is ready before reading data. </p>
<p>Reads the data from the RX FIFO after blocking to ensure the RX FIFO is not empty. Will wait indefinitely until there is data in the RX FIFO. See related APIs for additional receive options.</p>
<p>Can be used for any data transfers that are less than or equal to 8 bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data in the RX FIFO</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i.html#ga1db81249e51e1d7d083b1f08ac3c74f8" title="Writes 8-bit data into the TX FIFO for transmit. ">DL_SPI_transmitData8</a> </dd>
<dd>
<a class="el" href="group___s_p_i.html#gaa747ac1ef89a31a25f59edd36e7434b1" title="Checks the TX FIFO before trying to transmit data. ">DL_SPI_transmitDataCheck8</a> </dd></dl>

<p>Referenced by <a class="el" href="group___s_p_i.html#ga3a3adedc52cb49293eb395e3b61a3365">DL_SPI_clearInterruptStatus()</a>.</p>

</div>
</div>
<a id="ga4bcdc016db3fa393f09bd17e624856fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bcdc016db3fa393f09bd17e624856fd">&sect;&nbsp;</a></span>DL_SPI_receiveDataBlocking16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t DL_SPI_receiveDataBlocking16 </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks to ensure receive is ready before reading data. </p>
<p>Reads the data from the RX FIFO after blocking to ensure the RX FIFO is not empty. Will wait indefinitely until there is data in the RX FIFO. See related APIs for additional receive options.</p>
<p>Can be used for any data transfers that are less than or equal to 16 bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data in the RX FIFO</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i.html#gadd62074cdf1d5c54262a99c20b233421" title="Writes 16-bit data into the TX FIFO for transmit. ">DL_SPI_transmitData16</a> </dd>
<dd>
<a class="el" href="group___s_p_i.html#ga0ccfdddda9f493d31a7886b93fe97ffd" title="Checks the TX FIFO before trying to transmit data. ">DL_SPI_transmitDataCheck16</a> </dd></dl>

<p>Referenced by <a class="el" href="group___s_p_i.html#ga3a3adedc52cb49293eb395e3b61a3365">DL_SPI_clearInterruptStatus()</a>.</p>

</div>
</div>
<a id="ga1d5a7664cd307273cbcaf9da299b3b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d5a7664cd307273cbcaf9da299b3b91">&sect;&nbsp;</a></span>DL_SPI_receiveDataBlocking32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t DL_SPI_receiveDataBlocking32 </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks to ensure receive is ready before reading data. </p>
<p>Reads the data from the RX FIFO after blocking to ensure the RX FIFO is not empty. Will wait indefinitely until there is data in the RX FIFO. See related APIs for additional receive options.</p>
<p>Can be used for any data transfers that are less than or equal to 32 bits.</p>
<p>NOTE: Requires that packing has been enabled by calling <a class="el" href="group___s_p_i.html#gad1c1d31aeb86e180b4d617956b2b90b6">DL_SPI_enablePacking</a> prior to calling this API. When packing is enabled, two entries of the RX FIFO are returned as a 32-bit value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data in the RX FIFO</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>DL_SPI_enablePacking</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i.html#gaea8f2bccfe6a5d794262a9b6820c8275" title="Writes 32-bit data into the TX FIFO for transmit. ">DL_SPI_transmitData32</a> </dd>
<dd>
<a class="el" href="group___s_p_i.html#ga49621278af197222784b1d12bea75fc3" title="Checks the TX FIFO before trying to transmit data. ">DL_SPI_transmitDataCheck32</a> </dd></dl>

<p>Referenced by <a class="el" href="group___s_p_i.html#ga3a3adedc52cb49293eb395e3b61a3365">DL_SPI_clearInterruptStatus()</a>.</p>

</div>
</div>
<a id="gaa747ac1ef89a31a25f59edd36e7434b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa747ac1ef89a31a25f59edd36e7434b1">&sect;&nbsp;</a></span>DL_SPI_transmitDataCheck8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DL_SPI_transmitDataCheck8 </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the TX FIFO before trying to transmit data. </p>
<p>Checks if the TX FIFO is already full before trying to add new data to the FIFO. Exits immediately if full rather than trying to block. See related APIs for additional transmit options.</p>
<p>Can be used for any data transfers that are less than or equal to 8 bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>data to send</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the transmit occurred</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if data was added to the TX FIFO </td></tr>
    <tr><td class="paramname">false</td><td>if the TX FIFO was full and data was not added</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i.html#ga1db81249e51e1d7d083b1f08ac3c74f8" title="Writes 8-bit data into the TX FIFO for transmit. ">DL_SPI_transmitData8</a> </dd>
<dd>
<a class="el" href="group___s_p_i.html#ga5a49cffcc93cd7f5f28691656084aa35" title="Blocks to ensure transmit is ready before sending data. ">DL_SPI_transmitDataBlocking8</a> </dd></dl>

<p>Referenced by <a class="el" href="group___s_p_i.html#ga3a3adedc52cb49293eb395e3b61a3365">DL_SPI_clearInterruptStatus()</a>.</p>

</div>
</div>
<a id="ga0ccfdddda9f493d31a7886b93fe97ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ccfdddda9f493d31a7886b93fe97ffd">&sect;&nbsp;</a></span>DL_SPI_transmitDataCheck16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DL_SPI_transmitDataCheck16 </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the TX FIFO before trying to transmit data. </p>
<p>Checks if the TX FIFO is already full before trying to add new data to the FIFO. Exits immediately if full rather than trying to block. See related APIs for additional transmit options.</p>
<p>Can be used for any data transfers that are less than or equal to 16 bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>data to send</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the transmit occurred</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if data was added to the TX FIFO </td></tr>
    <tr><td class="paramname">false</td><td>if the TX FIFO was full and data was not added</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i.html#gadd62074cdf1d5c54262a99c20b233421" title="Writes 16-bit data into the TX FIFO for transmit. ">DL_SPI_transmitData16</a> </dd>
<dd>
<a class="el" href="group___s_p_i.html#ga6adff0a4426d68ec4460498076edd045" title="Blocks to ensure transmit is ready before sending data. ">DL_SPI_transmitDataBlocking16</a> </dd></dl>

<p>Referenced by <a class="el" href="group___s_p_i.html#ga3a3adedc52cb49293eb395e3b61a3365">DL_SPI_clearInterruptStatus()</a>.</p>

</div>
</div>
<a id="ga49621278af197222784b1d12bea75fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49621278af197222784b1d12bea75fc3">&sect;&nbsp;</a></span>DL_SPI_transmitDataCheck32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DL_SPI_transmitDataCheck32 </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the TX FIFO before trying to transmit data. </p>
<p>Checks if the TX FIFO is already full before trying to add new data to the FIFO. Exits immediately if full rather than trying to block. See related APIs for additional transmit options.</p>
<p>Can be used for any data transfers that are less than or equal to 32 bits.</p>
<p>NOTE: If packing is enabled by calling <a class="el" href="group___s_p_i.html#gad1c1d31aeb86e180b4d617956b2b90b6">DL_SPI_enablePacking</a> prior to calling this API, then a 32-bit write will be written as one FIFO entry. If packing is disabled, then a 32-bit write will be written as two FIFO entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>data to send</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the transmit occurred</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if data was added to the TX FIFO </td></tr>
    <tr><td class="paramname">false</td><td>if the TX FIFO was full and data was not added</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i.html#gad1c1d31aeb86e180b4d617956b2b90b6" title="Enables packing feature. ">DL_SPI_enablePacking</a> </dd>
<dd>
<a class="el" href="group___s_p_i.html#gaea8f2bccfe6a5d794262a9b6820c8275" title="Writes 32-bit data into the TX FIFO for transmit. ">DL_SPI_transmitData32</a> </dd>
<dd>
<a class="el" href="group___s_p_i.html#ga9b8cd4c5a324feeeb75e9ad05576d762" title="Blocks to ensure transmit is ready before sending data. ">DL_SPI_transmitDataBlocking32</a> </dd></dl>

<p>Referenced by <a class="el" href="group___s_p_i.html#ga3a3adedc52cb49293eb395e3b61a3365">DL_SPI_clearInterruptStatus()</a>.</p>

</div>
</div>
<a id="gaed7d1780e6dbf7b1429c4add272accdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed7d1780e6dbf7b1429c4add272accdf">&sect;&nbsp;</a></span>DL_SPI_receiveDataCheck8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DL_SPI_receiveDataCheck8 </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the RX FIFO before trying to transmit data. </p>
<p>Checks if the RX FIFO is already empty before trying to read new data from the FIFO. Exits immediately if empty rather than trying to block. See related APIs for additional receive options.</p>
<p>Can be used for any data transfers that are less than or equal to 8 bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>a buffer to write the received data into</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the receive occurred</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if data was read from the RX FIFO </td></tr>
    <tr><td class="paramname">false</td><td>if the RX FIFO was empty and data was not read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i.html#ga4567c4c2551bafbfc9b4646e8522631f" title="Reads 8-bit data from the RX FIFO. ">DL_SPI_receiveData8</a> </dd>
<dd>
<a class="el" href="group___s_p_i.html#ga6042d86a27dc1f0ac793a6b14c19d60f" title="Blocks to ensure receive is ready before reading data. ">DL_SPI_receiveDataBlocking8</a> </dd></dl>

<p>Referenced by <a class="el" href="group___s_p_i.html#ga3a3adedc52cb49293eb395e3b61a3365">DL_SPI_clearInterruptStatus()</a>.</p>

</div>
</div>
<a id="gaf632787409736f5804b74a8e78995100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf632787409736f5804b74a8e78995100">&sect;&nbsp;</a></span>DL_SPI_receiveDataCheck16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DL_SPI_receiveDataCheck16 </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the RX FIFO before trying to transmit data. </p>
<p>Checks if the RX FIFO is already empty before trying to read new data from the FIFO. Exits immediately if empty rather than trying to block. See related APIs for additional receive options.</p>
<p>Can be used for any data transfers that are less than or equal to 16 bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>a buffer to write the received data into</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the receive occurred</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if data was read from the RX FIFO </td></tr>
    <tr><td class="paramname">false</td><td>if the RX FIFO was empty and data was not read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i.html#gac94abca28d5be6a6e8ef3587012b6071" title="Reads 16-bit data from the RX FIFO. ">DL_SPI_receiveData16</a> </dd>
<dd>
<a class="el" href="group___s_p_i.html#ga4bcdc016db3fa393f09bd17e624856fd" title="Blocks to ensure receive is ready before reading data. ">DL_SPI_receiveDataBlocking16</a> </dd></dl>

<p>Referenced by <a class="el" href="group___s_p_i.html#ga3a3adedc52cb49293eb395e3b61a3365">DL_SPI_clearInterruptStatus()</a>.</p>

</div>
</div>
<a id="ga222c7dffefa2bf155766cd7c84d023f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga222c7dffefa2bf155766cd7c84d023f2">&sect;&nbsp;</a></span>DL_SPI_receiveDataCheck32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DL_SPI_receiveDataCheck32 </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the RX FIFO before trying to transmit data. </p>
<p>Checks if the RX FIFO is already empty before trying to read new data from the FIFO. Exits immediately if empty rather than trying to block. See related APIs for additional receive options.</p>
<p>Can be used for any data transfers that are less than or equal to 32 bits.</p>
<p>NOTE: Requires that packing has been enabled by calling <a class="el" href="group___s_p_i.html#gad1c1d31aeb86e180b4d617956b2b90b6">DL_SPI_enablePacking</a> prior to calling this API. When packing is enabled, two entries of the RX FIFO are returned as a 32-bit value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>a buffer to write the received data into</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the receive occurred</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if data was read from the RX FIFO </td></tr>
    <tr><td class="paramname">false</td><td>if the RX FIFO was empty and data was not read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>DL_SPI_enablePacking</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i.html#ga717ecfe8b54b8135b448419d25659d01" title="Reads 32-bit data from the RX FIFO. ">DL_SPI_receiveData32</a> </dd>
<dd>
<a class="el" href="group___s_p_i.html#ga1d5a7664cd307273cbcaf9da299b3b91" title="Blocks to ensure receive is ready before reading data. ">DL_SPI_receiveDataBlocking32</a> </dd></dl>

<p>Referenced by <a class="el" href="group___s_p_i.html#ga3a3adedc52cb49293eb395e3b61a3365">DL_SPI_clearInterruptStatus()</a>.</p>

</div>
</div>
<a id="ga1636bbb8fd41d76c6d9514306477e914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1636bbb8fd41d76c6d9514306477e914">&sect;&nbsp;</a></span>DL_SPI_drainRXFIFO8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t DL_SPI_drainRXFIFO8 </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read all available data out of the RX FIFO using 8 bit access. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>Buffer to write received data into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxCount</td><td>Max number of bytes to read from the RX FIFO</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes read from the RX FIFO </dd></dl>

<p>Referenced by <a class="el" href="group___s_p_i.html#ga3a3adedc52cb49293eb395e3b61a3365">DL_SPI_clearInterruptStatus()</a>.</p>

</div>
</div>
<a id="gaf3476eca47770d35f187b5c04e60b632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3476eca47770d35f187b5c04e60b632">&sect;&nbsp;</a></span>DL_SPI_drainRXFIFO16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t DL_SPI_drainRXFIFO16 </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read all available data out of the RX FIFO using 16 bit access. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>Buffer to write received data into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxCount</td><td>Max number of halfwords to read from the RX FIFO</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of halfwords read from the RX FIFO </dd></dl>

<p>Referenced by <a class="el" href="group___s_p_i.html#ga3a3adedc52cb49293eb395e3b61a3365">DL_SPI_clearInterruptStatus()</a>.</p>

</div>
</div>
<a id="gab5ce50f3a0f751d8cb2f4ed499755e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5ce50f3a0f751d8cb2f4ed499755e93">&sect;&nbsp;</a></span>DL_SPI_drainRXFIFO32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t DL_SPI_drainRXFIFO32 </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read all available data out of the RX FIFO using 32 bit access. </p>
<p>NOTE: Requires that packing has been enabled by calling <a class="el" href="group___s_p_i.html#gad1c1d31aeb86e180b4d617956b2b90b6">DL_SPI_enablePacking</a> prior to calling this API. When packing is enabled, two entries of the RX FIFO are returned as a 32-bit value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>Buffer to write received data into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxCount</td><td>Max number of words to read from the RX FIFO</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of words read from the RX FIFO</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>DL_SPI_enablePacking </dd></dl>

<p>Referenced by <a class="el" href="group___s_p_i.html#ga3a3adedc52cb49293eb395e3b61a3365">DL_SPI_clearInterruptStatus()</a>.</p>

</div>
</div>
<a id="gad002b7ba9034c365ad8fde923bdf0107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad002b7ba9034c365ad8fde923bdf0107">&sect;&nbsp;</a></span>DL_SPI_fillTXFIFO8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t DL_SPI_fillTXFIFO8 </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the TX FIFO using 8 bit access. </p>
<p>Continuously write data into the TX FIFO until it is filled up or count has been reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Buffer of data to write to the TX FIFO </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Max number of bytes to write to the TX FIFO</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes written to the TX FIFO </dd></dl>

<p>Referenced by <a class="el" href="group___s_p_i.html#ga3a3adedc52cb49293eb395e3b61a3365">DL_SPI_clearInterruptStatus()</a>.</p>

</div>
</div>
<a id="ga93e856d5f712743ea02f133d3292c5ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93e856d5f712743ea02f133d3292c5ea">&sect;&nbsp;</a></span>DL_SPI_fillTXFIFO16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t DL_SPI_fillTXFIFO16 </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the TX FIFO using 16 bit access. </p>
<p>Continuously write data into the TX FIFO until it is filled up or count has been reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Buffer of data to write to the TX FIFO </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Max number of halfwords to write to the TX FIFO</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of halfwords written to the TX FIFO </dd></dl>

<p>Referenced by <a class="el" href="group___s_p_i.html#ga3a3adedc52cb49293eb395e3b61a3365">DL_SPI_clearInterruptStatus()</a>.</p>

</div>
</div>
<a id="ga7af3ac6f55af2348e02d16d5c67e1b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7af3ac6f55af2348e02d16d5c67e1b29">&sect;&nbsp;</a></span>DL_SPI_fillTXFIFO32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t DL_SPI_fillTXFIFO32 </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the TX FIFO using 32 bit access. </p>
<p>Continuously write data into the TX FIFO until it is filled up or count has been reached.</p>
<p>NOTE: If packing is enabled by calling <a class="el" href="group___s_p_i.html#gad1c1d31aeb86e180b4d617956b2b90b6">DL_SPI_enablePacking</a> prior to calling this API, then a 32-bit write will be written as one FIFO entry. If packing is disabled, then a 32-bit write will be written as two FIFO entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Buffer of data to write to the TX FIFO </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Max number of words to write to the TX FIFO</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of words written to the TX FIFO</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i.html#gad1c1d31aeb86e180b4d617956b2b90b6" title="Enables packing feature. ">DL_SPI_enablePacking</a> </dd></dl>

<p>Referenced by <a class="el" href="group___s_p_i.html#ga3a3adedc52cb49293eb395e3b61a3365">DL_SPI_clearInterruptStatus()</a>.</p>

</div>
</div>
<a id="ga19bfcce992f283ee00bddb23bf50d18a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19bfcce992f283ee00bddb23bf50d18a">&sect;&nbsp;</a></span>DL_SPI_enableDMAReceiveEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_enableDMAReceiveEvent </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interrupt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable SPI interrupt for triggering the DMA receive event. </p>
<p>Enables the SPI interrupt to be used as the condition to generate an event to directly trigger the DMA. This API configures the DMA_TRIG_RX register, which is the event publisher used for triggering the DMA to do a receive data transfer.</p>
<dl class="section note"><dt>Note</dt><dd>Only one interrupt source should be enabled at a time.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interrupt</td><td>Interrupt to enable as the trigger condition for the DMA. One of <a class="el" href="group___d_l___s_p_i___d_m_a___i_n_t_e_r_r_u_p_t___r_x.html">DL_SPI_DMA_INTERRUPT_RX</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga03ed3e347e596e8f3a043b8cc807f0ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03ed3e347e596e8f3a043b8cc807f0ac">&sect;&nbsp;</a></span>DL_SPI_enableDMATransmitEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_enableDMATransmitEvent </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable SPI interrupt for triggering the DMA transmit event. </p>
<p>Enables the SPI interrupt to be used as the condition to generate an event to directly trigger the DMA. This API configures the DMA_TRIG_TX register, which is the event publisher used for triggering the DMA to do a transmit data transfer.</p>
<dl class="section note"><dt>Note</dt><dd>DMA_TRIG_TX only has one transmit interrupt source</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad8d6f0b4f8e7d3f68d2e14ca2f04215d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8d6f0b4f8e7d3f68d2e14ca2f04215d">&sect;&nbsp;</a></span>DL_SPI_disableDMAReceiveEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_disableDMAReceiveEvent </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interrupt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables SPI interrupt from triggering the DMA receive event. </p>
<p>Disables the SPI interrupt as the condition to generate an event to directly trigger the DMA. This API configures the DMA_TRIG_RX register, which is the event publisher used for triggering the DMA to do a receive data transfer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interrupt</td><td>Interrupt to disable as the trigger condition for the DMA. One of <a class="el" href="group___d_l___s_p_i___d_m_a___i_n_t_e_r_r_u_p_t___r_x.html">DL_SPI_DMA_INTERRUPT_RX</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga77eb49fb26f889729b483357839ea907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77eb49fb26f889729b483357839ea907">&sect;&nbsp;</a></span>DL_SPI_disableDMATransmitEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_disableDMATransmitEvent </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables SPI interrupt from triggering the DMA transmit event. </p>
<p>Disables the SPI interrupt as the condition to generate an event to directly trigger the DMA. This API configures the DMA_TRIG_TX register, which is the event publisher used for triggering the DMA to do a transmit data transfer.</p>
<dl class="section note"><dt>Note</dt><dd>DMA_TRIG_TX only has one transmit interrupt source</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab89a3ffb4daa9ef6b8efb5fdf6f2377d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab89a3ffb4daa9ef6b8efb5fdf6f2377d">&sect;&nbsp;</a></span>DL_SPI_getEnabledDMAReceiveEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_SPI_getEnabledDMAReceiveEvent </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check which SPI interrupt for DMA receive events is enabled. </p>
<p>This API checks the DMA_TRIG_RX register, which is the event publisher used for triggering the DMA to do a receive data transfer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptMask</td><td>Bit mask of interrupts to check. Bitwise OR of <a class="el" href="group___d_l___s_p_i___d_m_a___i_n_t_e_r_r_u_p_t___r_x.html">DL_SPI_DMA_INTERRUPT_RX</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only one interrupt source should be enabled at a time.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Which of the requested SPI interrupts is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___d_l___s_p_i___d_m_a___i_n_t_e_r_r_u_p_t___r_x.html">DL_SPI_DMA_INTERRUPT_RX</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac5d4d2f49631235e03bd43133b31892a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5d4d2f49631235e03bd43133b31892a">&sect;&nbsp;</a></span>DL_SPI_getEnabledDMATransmitEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_SPI_getEnabledDMATransmitEvent </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if SPI interrupt for DMA transmit event is enabled. </p>
<p>This API checks the DMA_TRIG_TX register, which is the event publisher used for triggering the DMA to do a transmit data transfer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested SPI interrupt status</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_SPI_DMA_INTERRUPT_TX</td><td>if enabled, 0 if not enabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4c1428ee1b7bbadb399ebc3d04b01a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c1428ee1b7bbadb399ebc3d04b01a82">&sect;&nbsp;</a></span>DL_SPI_getEnabledDMAReceiveEventStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_SPI_getEnabledDMAReceiveEventStatus </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check interrupt flag of enabled SPI interrupt for DMA receive event. </p>
<p>Checks if any of the SPI interrupts for the DMA receive event that were previously enabled are pending. This API checks the DMA_TRIG_RX register, which is the event publisher used for triggering the DMA to do a receive data transfer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptMask</td><td>Bit mask of interrupts to check. Bitwise OR of <a class="el" href="group___d_l___s_p_i___d_m_a___i_n_t_e_r_r_u_p_t___r_x.html">DL_SPI_DMA_INTERRUPT_RX</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only one interrupt source should be enabled at a time.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The requested SPI interrupt status</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___d_l___s_p_i___d_m_a___i_n_t_e_r_r_u_p_t___r_x.html">DL_SPI_DMA_INTERRUPT_RX</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i.html#ga19bfcce992f283ee00bddb23bf50d18a" title="Enable SPI interrupt for triggering the DMA receive event. ">DL_SPI_enableDMAReceiveEvent</a> </dd></dl>

</div>
</div>
<a id="gac76266ff3cef7b9efe539a338ab6763e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac76266ff3cef7b9efe539a338ab6763e">&sect;&nbsp;</a></span>DL_SPI_getEnabledDMATransmitEventStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_SPI_getEnabledDMATransmitEventStatus </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check interrupt flag of enabled SPI interrupt for DMA transmit event. </p>
<p>Checks if the SPI interrupt for the DMA transmit event that was previously enabled is pending. This API checks the DMA_TRIG_TX register, which is the event publisher used for triggering the DMA to do a transmit data transfer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested SPI interrupt status</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_SPI_DMA_INTERRUPT_TX</td><td>if enabled, 0 if not enabled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i.html#ga03ed3e347e596e8f3a043b8cc807f0ac" title="Enable SPI interrupt for triggering the DMA transmit event. ">DL_SPI_enableDMATransmitEvent</a> </dd></dl>

</div>
</div>
<a id="ga7ba09f8f4c7f038edd29869306f19176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ba09f8f4c7f038edd29869306f19176">&sect;&nbsp;</a></span>DL_SPI_getRawDMAReceiveEventStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_SPI_getRawDMAReceiveEventStatus </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check interrupt flag of any SPI interrupt for DMA receive event. </p>
<p>Checks if any of the SPI interrupts for DMA receive event are pending. Interrupts do not have to be previously enabled. This API checks the DMA_TRIG_RX register, which is the event publisher used for triggering the DMA to do a receive data transfer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptMask</td><td>Bit mask of interrupts to check. Bitwise OR of <a class="el" href="group___d_l___s_p_i___d_m_a___i_n_t_e_r_r_u_p_t___r_x.html">DL_SPI_DMA_INTERRUPT_RX</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Which of the requested SPI interrupts are pending</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Bitwise</td><td>OR of <a class="el" href="group___d_l___s_p_i___d_m_a___i_n_t_e_r_r_u_p_t___r_x.html">DL_SPI_DMA_INTERRUPT_RX</a> values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafcd3c71425a2848f31ed24f325c6e403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafcd3c71425a2848f31ed24f325c6e403">&sect;&nbsp;</a></span>DL_SPI_getRawDMATransmitEventStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_SPI_getRawDMATransmitEventStatus </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check interrupt flag of any SPI interrupt for DMA transmit event. </p>
<p>Checks if any of the SPI interrupts for DMA transmit event are pending. Interrupts do not have to be previously enabled. This API checks the DMA_TRIG_TX register, which is the event publisher used for triggering the DMA to do a transmit data transfer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested SPI interrupt status</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_SPI_DMA_INTERRUPT_TX</td><td>if enabled, 0 if not enabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4b2a07f8b6ddc8e504898d6b26ff0aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b2a07f8b6ddc8e504898d6b26ff0aea">&sect;&nbsp;</a></span>DL_SPI_getPendingDMAReceiveEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___s_p_i.html#gac662dc4ffc6d7fbd2c8059f9d978f0f6">DL_SPI_DMA_IIDX_RX</a> DL_SPI_getPendingDMAReceiveEvent </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get highest priority pending SPI interrupt for DMA receive event. </p>
<p>Checks if any of the SPI interrupts for DMA receive event are pending. Interrupts do not have to be previously enabled. This API checks the DMA_TRIG_RX register, which is the event publisher used for triggering the DMA to do a receive data transfer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The highest priority pending SPI interrupt</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___s_p_i.html#gac662dc4ffc6d7fbd2c8059f9d978f0f6">DL_SPI_DMA_IIDX_RX</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga96cd4c2386a039ab586535d66972d8d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96cd4c2386a039ab586535d66972d8d4">&sect;&nbsp;</a></span>DL_SPI_getPendingDMATransmitEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___s_p_i.html#ga4edac7e2fad897c33fddb539363eabdd">DL_SPI_DMA_IIDX_TX</a> DL_SPI_getPendingDMATransmitEvent </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get highest priority pending SPI interrupt for DMA transmit event. </p>
<p>Checks if the SPI interrupt for DMA transmit event is pending. Interrupts do not have to be previously enabled. This API checks the DMA_TRIG_TX register, which is the event publisher used for triggering the DMA to do a transmit data transfer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The highest priority pending SPI interrupt</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_SPI_DMA_IIDX_TX</td><td>if pending, 0 if not pending </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga211e65c5c974b47eb771c0b5949fdd80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga211e65c5c974b47eb771c0b5949fdd80">&sect;&nbsp;</a></span>DL_SPI_clearDMAReceiveEventStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_clearDMAReceiveEventStatus </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear pending SPI interrupts for DMA receive event. </p>
<p>This API checks the DMA_TRIG_RX register, which is the event publisher used for triggering the DMA to do a receive data transfer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptMask</td><td>Bit mask of interrupts to clear. Bitwise OR of <a class="el" href="group___d_l___s_p_i___d_m_a___i_n_t_e_r_r_u_p_t___r_x.html">DL_SPI_DMA_INTERRUPT_RX</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1cc267432eef43cd197ed315bf9d22f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cc267432eef43cd197ed315bf9d22f4">&sect;&nbsp;</a></span>DL_SPI_clearDMATransmitEventStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SPI_clearDMATransmitEventStatus </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear pending SPI interrupt for DMA transmit event. </p>
<p>This API checks the DMA_TRIG_TX register, which is the event publisher used for triggering the DMA to do a transmit data transfer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>DMA_TRIG_TX only has one transmit interrupt source </dd></dl>

<p>References <a class="el" href="group___s_p_i.html#gab6405771e41906765135cf943ef43d03">DL_SPI_restoreConfiguration()</a>, and <a class="el" href="group___s_p_i.html#gae172cfc4e1d9695af65d87198d19e89f">DL_SPI_saveConfiguration()</a>.</p>

</div>
</div>
<a id="gae172cfc4e1d9695af65d87198d19e89f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae172cfc4e1d9695af65d87198d19e89f">&sect;&nbsp;</a></span>DL_SPI_saveConfiguration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DL_SPI_saveConfiguration </td>
          <td>(</td>
          <td class="paramtype">const SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_d_l___s_p_i__backup_config.html">DL_SPI_backupConfig</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save SPI configuration before entering a power loss state. </p>
<p>Some MSPM0G peripherals residing in PD1 domain do not retain register contents when entering STOP or STANDBY modes. Please refer to the datasheet for the full list of peripheral instances that exhibit this behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Configuration backup setup structure. See <a class="el" href="struct_d_l___s_p_i__backup_config.html">DL_SPI_backupConfig</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>if a configuration already exists in ptr (will not be overwritten). TRUE if a configuration was successfully saved</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i.html#gab6405771e41906765135cf943ef43d03" title="Restore SPI configuration after leaving a power loss state. ">DL_SPI_restoreConfiguration</a> </dd></dl>

<p>Referenced by <a class="el" href="group___s_p_i.html#ga1cc267432eef43cd197ed315bf9d22f4">DL_SPI_clearDMATransmitEventStatus()</a>.</p>

</div>
</div>
<a id="gab6405771e41906765135cf943ef43d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6405771e41906765135cf943ef43d03">&sect;&nbsp;</a></span>DL_SPI_restoreConfiguration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DL_SPI_restoreConfiguration </td>
          <td>(</td>
          <td class="paramtype">SPI_Regs *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_d_l___s_p_i__backup_config.html">DL_SPI_backupConfig</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore SPI configuration after leaving a power loss state. </p>
<p>Some MSPM0G peripherals residing in PD1 domain do not retain register contents when entering STOP or STANDBY modes. Please refer to the datasheet for the full list of peripheral instances that exhibit this behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the register overlay for the peripheral</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Configuration backup setup structure. See <a class="el" href="struct_d_l___s_p_i__backup_config.html">DL_SPI_backupConfig</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>if a configuration does not exist in ptr (will not be loaded). TRUE if a configuration successfully loaded</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i.html#gae172cfc4e1d9695af65d87198d19e89f" title="Save SPI configuration before entering a power loss state. ">DL_SPI_saveConfiguration</a> </dd></dl>

<p>Referenced by <a class="el" href="group___s_p_i.html#ga1cc267432eef43cd197ed315bf9d22f4">DL_SPI_clearDMATransmitEventStatus()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="https://www.ti.com/corp/docs/legal/copyright.shtml"> Copyright 1995-2025</a>, Texas Instruments Incorporated. All rights reserved. <br/>
  <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
