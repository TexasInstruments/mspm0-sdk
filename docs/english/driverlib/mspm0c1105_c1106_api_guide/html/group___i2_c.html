<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>MSPM0C1105_C1106 Driver Library: Inter-Integrated Circuit (I2C)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MSPM0C1105_C1106 Driver Library
   &#160;<span id="projectnumber">2.05.01.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Inter-Integrated Circuit (I2C)</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Inter-Integrated Circuit (I2C):</div>
<div class="dyncontent">
<center><table><tr><td><img src="group___i2_c.png" border="0" alt="" usemap="#group______i2__c"/>
<map name="group______i2__c" id="group______i2__c">
<area shape="rect" id="node1" href="group___d_l___i2_c___d_m_a___i_n_t_e_r_r_u_p_t.html" title="DL_I2C_DMA_INTERRUPT" alt="" coords="239,5,426,32"/>
<area shape="rect" id="node2" href="group___d_l___i2_c___t_a_r_g_e_t___s_t_a_t_u_s.html" title="DL_I2C_TARGET_STATUS" alt="" coords="242,56,423,83"/>
<area shape="rect" id="node4" href="group___d_l___i2_c___c_o_n_t_r_o_l_l_e_r___s_t_a_t_u_s.html" title="DL_I2C_CONTROLLER_STATUS" alt="" coords="224,107,441,133"/>
<area shape="rect" id="node5" href="group___d_l___i2_c___i_n_t_e_r_r_u_p_t.html" title="DL_I2C_INTERRUPT" alt="" coords="259,157,407,184"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group___d_l___i2_c___c_o_n_t_r_o_l_l_e_r___s_t_a_t_u_s"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_l___i2_c___c_o_n_t_r_o_l_l_e_r___s_t_a_t_u_s.html">DL_I2C_CONTROLLER_STATUS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___d_l___i2_c___t_a_r_g_e_t___s_t_a_t_u_s"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_l___i2_c___t_a_r_g_e_t___s_t_a_t_u_s.html">DL_I2C_TARGET_STATUS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___d_l___i2_c___i_n_t_e_r_r_u_p_t"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_l___i2_c___i_n_t_e_r_r_u_p_t.html">DL_I2C_INTERRUPT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___d_l___i2_c___d_m_a___i_n_t_e_r_r_u_p_t"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_l___i2_c___d_m_a___i_n_t_e_r_r_u_p_t.html">DL_I2C_DMA_INTERRUPT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l___i2_c___clock_config.html">DL_I2C_ClockConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration struct for <a class="el" href="group___i2_c.html#gafe52f423d12f219571380491a7ad95d1">DL_I2C_setClockConfig</a>.  <a href="struct_d_l___i2_c___clock_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gadc068c6d6df6e875e4ea73d14b420e7e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gadc068c6d6df6e875e4ea73d14b420e7e">DL_I2C_TX_FIFO_COUNT_MAXIMUM</a>&#160;&#160;&#160;((uint32_t)I2C_SYS_FENTRIES &lt;&lt; 8)</td></tr>
<tr class="memdesc:gadc068c6d6df6e875e4ea73d14b420e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C number of bytes which could be put into the TX FIFO.  <a href="#gadc068c6d6df6e875e4ea73d14b420e7e">More...</a><br /></td></tr>
<tr class="separator:gadc068c6d6df6e875e4ea73d14b420e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2031ae56b0ebaf369e94df7f98fb9222"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga2031ae56b0ebaf369e94df7f98fb9222">DL_I2C_RX_FIFO_COUNT_MAXIMUM</a>&#160;&#160;&#160;((uint32_t)I2C_SYS_FENTRIES)</td></tr>
<tr class="memdesc:ga2031ae56b0ebaf369e94df7f98fb9222"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C number of bytes which could be put into the RX FIFO.  <a href="#ga2031ae56b0ebaf369e94df7f98fb9222">More...</a><br /></td></tr>
<tr class="separator:ga2031ae56b0ebaf369e94df7f98fb9222"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaed43e22303286e1d4d9490c2b6ddf9bd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaed43e22303286e1d4d9490c2b6ddf9bd">DL_I2C_DMA_IIDX</a> { <br />
&#160;&#160;<a class="el" href="group___i2_c.html#ggaed43e22303286e1d4d9490c2b6ddf9bda765e3a6413b62d19764dc17090371f4f">DL_I2C_DMA_IIDX_TARGET_TXFIFO_TRIGGER</a> = I2C_DMA_TRIG1_IIDX_STAT_MTXFIFOTRG, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#ggaed43e22303286e1d4d9490c2b6ddf9bda2fc3cd509080efe4196a8ac7c439b43a">DL_I2C_DMA_IIDX_TARGET_RXFIFO_TRIGGER</a> = I2C_DMA_TRIG1_IIDX_STAT_MRXFIFOTRG, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#ggaed43e22303286e1d4d9490c2b6ddf9bdad0a20190e3e9f65b9e3957b7ad938611">DL_I2C_DMA_IIDX_CONTROLLER_TXFIFO_TRIGGER</a>, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#ggaed43e22303286e1d4d9490c2b6ddf9bdac29ea194e952e5335386c496640b50d6">DL_I2C_DMA_IIDX_CONTROLLER_RXFIFO_TRIGGER</a>
<br />
 }</td></tr>
<tr class="separator:gaed43e22303286e1d4d9490c2b6ddf9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d85e40e4e1b371a6958921cb4d2369f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga5d85e40e4e1b371a6958921cb4d2369f">DL_I2C_EVENT_ROUTE</a> { <br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga5d85e40e4e1b371a6958921cb4d2369fa191a6c43cb5070513da653e40459a707">DL_I2C_EVENT_ROUTE_1</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga5d85e40e4e1b371a6958921cb4d2369faa271de21d766a1ada248b4e85db9df80">DL_I2C_EVENT_ROUTE_2</a> = 12
<br />
 }</td></tr>
<tr class="separator:ga5d85e40e4e1b371a6958921cb4d2369f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad912db0203e9bb0e55bb0ddbc0ddcfcc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gad912db0203e9bb0e55bb0ddbc0ddcfcc">DL_I2C_CLOCK</a> { <br />
&#160;&#160;<a class="el" href="group___i2_c.html#ggad912db0203e9bb0e55bb0ddbc0ddcfccad6d5055d0035f33da71821c1ff686452">DL_I2C_CLOCK_BUSCLK</a> = I2C_CLKSEL_BUSCLK_SEL_ENABLE, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#ggad912db0203e9bb0e55bb0ddbc0ddcfcca38fef132dae64de3e08b7d323d72d86e">DL_I2C_CLOCK_MFCLK</a> = I2C_CLKSEL_MFCLK_SEL_ENABLE
<br />
 }</td></tr>
<tr class="separator:gad912db0203e9bb0e55bb0ddbc0ddcfcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03737f74607dfbe4048cff93862c9faa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga03737f74607dfbe4048cff93862c9faa">DL_I2C_CLOCK_DIVIDE</a> { <br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga03737f74607dfbe4048cff93862c9faaa03cb2520917670ad5a8e72a9590e0d25">DL_I2C_CLOCK_DIVIDE_1</a> = I2C_CLKDIV_RATIO_DIV_BY_1, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga03737f74607dfbe4048cff93862c9faaadc3b13b2c0059a4cf1f257603f6416bc">DL_I2C_CLOCK_DIVIDE_2</a> = I2C_CLKDIV_RATIO_DIV_BY_2, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga03737f74607dfbe4048cff93862c9faaae0d53a45d337662928344059f72b0aa9">DL_I2C_CLOCK_DIVIDE_3</a> = I2C_CLKDIV_RATIO_DIV_BY_3, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga03737f74607dfbe4048cff93862c9faaa4a12832b1d69e2c75bb71048f40fc843">DL_I2C_CLOCK_DIVIDE_4</a> = I2C_CLKDIV_RATIO_DIV_BY_4, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga03737f74607dfbe4048cff93862c9faaaed0431c060281cf244429f3941da24d4">DL_I2C_CLOCK_DIVIDE_5</a> = I2C_CLKDIV_RATIO_DIV_BY_5, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga03737f74607dfbe4048cff93862c9faaa9b8ae5d4144ff65d753c7dd232433f29">DL_I2C_CLOCK_DIVIDE_6</a> = I2C_CLKDIV_RATIO_DIV_BY_6, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga03737f74607dfbe4048cff93862c9faaae406db08b149041a41cfa76abdfcf5ad">DL_I2C_CLOCK_DIVIDE_7</a> = I2C_CLKDIV_RATIO_DIV_BY_7, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga03737f74607dfbe4048cff93862c9faaadb3c2e813fffaf2625eee4678191610f">DL_I2C_CLOCK_DIVIDE_8</a> = I2C_CLKDIV_RATIO_DIV_BY_8
<br />
 }</td></tr>
<tr class="separator:ga03737f74607dfbe4048cff93862c9faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ad6170a9004cf1b5296bde4da948661"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga2ad6170a9004cf1b5296bde4da948661">DL_I2C_TARGET_ADDRESSING_MODE</a> { <br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga2ad6170a9004cf1b5296bde4da948661aa06eaaa6ab08211ba70e138991e76add">DL_I2C_TARGET_ADDRESSING_MODE_7_BIT</a> = I2C_SOAR_SMODE_MODE7, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga2ad6170a9004cf1b5296bde4da948661ab3ea325a9f99efafd970924dcda8ef73">DL_I2C_TARGET_ADDRESSING_MODE_10_BIT</a> = I2C_SOAR_SMODE_MODE10
<br />
 }</td></tr>
<tr class="separator:ga2ad6170a9004cf1b5296bde4da948661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb5095cf27ba13dbca5226da84dbbf18"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gafb5095cf27ba13dbca5226da84dbbf18">DL_I2C_TARGET_PEC_STATUS</a> { <br />
&#160;&#160;<a class="el" href="group___i2_c.html#ggafb5095cf27ba13dbca5226da84dbbf18a621e97a1d5400f1fcb2f7b0a242a0dfe">DL_I2C_TARGET_PEC_STATUS_CHECKED</a> = I2C_TARGET_PECSR_PECSTS_CHECK_SET, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#ggafb5095cf27ba13dbca5226da84dbbf18a6381d0639c0d81a547fe93f737324ea4">DL_I2C_TARGET_PEC_STATUS_NOT_CHECKED</a>
<br />
 }</td></tr>
<tr class="separator:gafb5095cf27ba13dbca5226da84dbbf18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96c525c4ee883f347cf21e8676d7c32e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga96c525c4ee883f347cf21e8676d7c32e">DL_I2C_TARGET_PEC_CHECK_ERROR</a> { <br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga96c525c4ee883f347cf21e8676d7c32ea72ff826ecd7fcdaac021b0f787356eae">DL_I2C_TARGET_PEC_CHECK_ERROR_CLEARED</a>, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga96c525c4ee883f347cf21e8676d7c32eaa6767e7f503cda619aa26c7210e75fac">DL_I2C_TARGET_PEC_CHECK_ERROR_SET</a> = I2C_TARGET_PECSR_PECSTS_ERROR_SET
<br />
 }</td></tr>
<tr class="separator:ga96c525c4ee883f347cf21e8676d7c32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga031f0b093a1d7448b0ba89a6ecc0a32a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga031f0b093a1d7448b0ba89a6ecc0a32a">DL_I2C_ANALOG_GLITCH_FILTER_WIDTH</a> { <br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga031f0b093a1d7448b0ba89a6ecc0a32aab775e2e3cf0f0c919a44a5e5f43f8b87">DL_I2C_ANALOG_GLITCH_FILTER_WIDTH_5NS</a> = I2C_GFCTL_AGFSEL_AGLIT_5, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga031f0b093a1d7448b0ba89a6ecc0a32aa459f9759f5f9dea0e111e09dc0cfd161">DL_I2C_ANALOG_GLITCH_FILTER_WIDTH_10NS</a> = I2C_GFCTL_AGFSEL_AGLIT_10, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga031f0b093a1d7448b0ba89a6ecc0a32aa884f120236ff2979011b8836e4d37da2">DL_I2C_ANALOG_GLITCH_FILTER_WIDTH_25NS</a> = I2C_GFCTL_AGFSEL_AGLIT_25, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga031f0b093a1d7448b0ba89a6ecc0a32aa2244c58b0085f4edcf75220f2f3db3b1">DL_I2C_ANALOG_GLITCH_FILTER_WIDTH_50NS</a> = I2C_GFCTL_AGFSEL_AGLIT_50
<br />
 }</td></tr>
<tr class="separator:ga031f0b093a1d7448b0ba89a6ecc0a32a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f42d16d0c14219c0ce8e45016bed5e4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga9f42d16d0c14219c0ce8e45016bed5e4">DL_I2C_DIGITAL_GLITCH_FILTER_WIDTH</a> { <br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga9f42d16d0c14219c0ce8e45016bed5e4a7d88539b627ff2a6d5161217ba41e4e7">DL_I2C_DIGITAL_GLITCH_FILTER_WIDTH_DISABLED</a> = I2C_GFCTL_DGFSEL_DISABLED, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga9f42d16d0c14219c0ce8e45016bed5e4a94b3c8ef94dc6e42f8de9ce54a0e9bd3">DL_I2C_DIGITAL_GLITCH_FILTER_WIDTH_CLOCKS_1</a> = I2C_GFCTL_DGFSEL_CLK_1, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga9f42d16d0c14219c0ce8e45016bed5e4a368f4bd84a917a0702a579baf40a5739">DL_I2C_DIGITAL_GLITCH_FILTER_WIDTH_CLOCKS_2</a> = I2C_GFCTL_DGFSEL_CLK_2, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga9f42d16d0c14219c0ce8e45016bed5e4a1b15c0cf6eb6ea3361b0323cde7e465b">DL_I2C_DIGITAL_GLITCH_FILTER_WIDTH_CLOCKS_3</a> = I2C_GFCTL_DGFSEL_CLK_3, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga9f42d16d0c14219c0ce8e45016bed5e4a2e59906228bf66af6733bf5aa5aff16e">DL_I2C_DIGITAL_GLITCH_FILTER_WIDTH_CLOCKS_4</a> = I2C_GFCTL_DGFSEL_CLK_4, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga9f42d16d0c14219c0ce8e45016bed5e4af255619ace040812fb6203a3030c49e9">DL_I2C_DIGITAL_GLITCH_FILTER_WIDTH_CLOCKS_8</a> = I2C_GFCTL_DGFSEL_CLK_8, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga9f42d16d0c14219c0ce8e45016bed5e4a45cd0f0f9b1464905d3e8ee41c19b476">DL_I2C_DIGITAL_GLITCH_FILTER_WIDTH_CLOCKS_16</a> = I2C_GFCTL_DGFSEL_CLK_16, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga9f42d16d0c14219c0ce8e45016bed5e4ab540667df6dc47b8a8b3f8417982adcf">DL_I2C_DIGITAL_GLITCH_FILTER_WIDTH_CLOCKS_31</a> = I2C_GFCTL_DGFSEL_CLK_31
<br />
 }</td></tr>
<tr class="separator:ga9f42d16d0c14219c0ce8e45016bed5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e5bff33e69ea760e7f8364b2f1cf259"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga4e5bff33e69ea760e7f8364b2f1cf259">DL_I2C_CONTROLLER_DIRECTION</a> { <br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga4e5bff33e69ea760e7f8364b2f1cf259a79ef2507cfb08c2fde3acdba7b80b125">DL_I2C_CONTROLLER_DIRECTION_TX</a> = I2C_MSA_DIR_TRANSMIT, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga4e5bff33e69ea760e7f8364b2f1cf259aa8f2ea2136ff8e671803b31399f41e3a">DL_I2C_CONTROLLER_DIRECTION_RX</a> = I2C_MSA_DIR_RECEIVE
<br />
 }</td></tr>
<tr class="separator:ga4e5bff33e69ea760e7f8364b2f1cf259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga286008e7442aee9279befbb3cace3d47"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga286008e7442aee9279befbb3cace3d47">DL_I2C_CONTROLLER_ADDRESSING_MODE</a> { <br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga286008e7442aee9279befbb3cace3d47a61a007a02e62f515679d621ea2d8c925">DL_I2C_CONTROLLER_ADDRESSING_MODE_7_BIT</a> = I2C_MSA_MMODE_MODE7, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga286008e7442aee9279befbb3cace3d47a8e00692656fafe882df26f836df967bc">DL_I2C_CONTROLLER_ADDRESSING_MODE_10_BIT</a> = I2C_MSA_MMODE_MODE10
<br />
 }</td></tr>
<tr class="separator:ga286008e7442aee9279befbb3cace3d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae90754611bdbab4885bc634bcddadca4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gae90754611bdbab4885bc634bcddadca4">DL_I2C_CONTROLLER_PEC_STATUS</a> { <br />
&#160;&#160;<a class="el" href="group___i2_c.html#ggae90754611bdbab4885bc634bcddadca4a2d495a76cb3d80604560302009ef0b72">DL_I2C_CONTROLLER_PEC_STATUS_CHECKED</a>, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#ggae90754611bdbab4885bc634bcddadca4afe75d521f85cabbe99bf4468260459e4">DL_I2C_CONTROLLER_PEC_STATUS_NOT_CHECKED</a>
<br />
 }</td></tr>
<tr class="separator:gae90754611bdbab4885bc634bcddadca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga560b453b65c64ad5bffb37ae05c88553"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga560b453b65c64ad5bffb37ae05c88553">DL_I2C_CONTROLLER_PEC_CHECK_ERROR</a> { <br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga560b453b65c64ad5bffb37ae05c88553a97981a23a99255f71228d844c8c568f4">DL_I2C_CONTROLLER_PEC_CHECK_ERROR_SET</a>, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga560b453b65c64ad5bffb37ae05c88553a5504faa3459c73d2ad7146e25ace0bc2">DL_I2C_CONTROLLER_PEC_CHECK_ERROR_CLEARED</a>
<br />
 }</td></tr>
<tr class="separator:ga560b453b65c64ad5bffb37ae05c88553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc56f44666d64364128360ea3dfb4f8e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gabc56f44666d64364128360ea3dfb4f8e">DL_I2C_CONTROLLER_SCL</a> { <br />
&#160;&#160;<a class="el" href="group___i2_c.html#ggabc56f44666d64364128360ea3dfb4f8ea21c7f6c2b39849462ee3918bbbe9707a">DL_I2C_CONTROLLER_SCL_HIGH</a> = I2C_MBMON_SCL_SET, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#ggabc56f44666d64364128360ea3dfb4f8ea732fdcfdcd867619bb301ec6059ce59b">DL_I2C_CONTROLLER_SCL_LOW</a> = I2C_MBMON_SCL_CLEARED
<br />
 }</td></tr>
<tr class="separator:gabc56f44666d64364128360ea3dfb4f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56a2070002c41b873cfddfa37f776caa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga56a2070002c41b873cfddfa37f776caa">DL_I2C_CONTROLLER_SDA</a> { <br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga56a2070002c41b873cfddfa37f776caaa100b9d2e4e5dc9aec9d7be22c75afb2e">DL_I2C_CONTROLLER_SDA_HIGH</a> = I2C_MBMON_SDA_SET, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga56a2070002c41b873cfddfa37f776caaa4751ecc4f98be98d10ebb1ed40877b4e">DL_I2C_CONTROLLER_SDA_LOW</a> = I2C_MBMON_SDA_CLEARED
<br />
 }</td></tr>
<tr class="separator:ga56a2070002c41b873cfddfa37f776caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5722df24b0d57c0b2bf18c1068a36ca1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga5722df24b0d57c0b2bf18c1068a36ca1">DL_I2C_CONTROLLER_START</a> { <br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga5722df24b0d57c0b2bf18c1068a36ca1a766659f96b6bbc497047ff2bed0b3db1">DL_I2C_CONTROLLER_START_ENABLE</a> = I2C_MCTR_START_ENABLE, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga5722df24b0d57c0b2bf18c1068a36ca1a9095d4e5634ba52a1b5219737dfb7641">DL_I2C_CONTROLLER_START_DISABLE</a> = I2C_MCTR_START_DISABLE
<br />
 }</td></tr>
<tr class="separator:ga5722df24b0d57c0b2bf18c1068a36ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8996cddfa139bd7118880aa51e32f0f7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga8996cddfa139bd7118880aa51e32f0f7">DL_I2C_CONTROLLER_STOP</a> { <br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga8996cddfa139bd7118880aa51e32f0f7a324783fff416f86fa19dc9fa6d3258a5">DL_I2C_CONTROLLER_STOP_ENABLE</a> = I2C_MCTR_STOP_ENABLE, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga8996cddfa139bd7118880aa51e32f0f7a084bde99c4b726f824eff942b4f18546">DL_I2C_CONTROLLER_STOP_DISABLE</a> = I2C_MCTR_STOP_DISABLE
<br />
 }</td></tr>
<tr class="separator:ga8996cddfa139bd7118880aa51e32f0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab55947b23ba571c233ab80d34bf7182"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaab55947b23ba571c233ab80d34bf7182">DL_I2C_CONTROLLER_ACK</a> { <br />
&#160;&#160;<a class="el" href="group___i2_c.html#ggaab55947b23ba571c233ab80d34bf7182a0c8efe9fc42d1630dd9ad4bd50019928">DL_I2C_CONTROLLER_ACK_ENABLE</a> = I2C_MCTR_ACK_ENABLE, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#ggaab55947b23ba571c233ab80d34bf7182a8853d7564e6178fc719ac8276a4110f6">DL_I2C_CONTROLLER_ACK_DISABLE</a> = I2C_MCTR_ACK_DISABLE
<br />
 }</td></tr>
<tr class="separator:gaab55947b23ba571c233ab80d34bf7182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f984a9185dfb1fde64fd3d8a9b3786c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga5f984a9185dfb1fde64fd3d8a9b3786c">DL_I2C_TX_FIFO_LEVEL</a> { <br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga5f984a9185dfb1fde64fd3d8a9b3786ca89c9092c250e869ae2377841682ae60e">DL_I2C_TX_FIFO_LEVEL_EMPTY</a> = I2C_MFIFOCTL_TXTRIG_EMPTY, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga5f984a9185dfb1fde64fd3d8a9b3786ca86332753d599c5d77d5d9d3ee79b08c0">DL_I2C_TX_FIFO_LEVEL_BYTES_1</a> = I2C_MFIFOCTL_TXTRIG_LEVEL_1, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga5f984a9185dfb1fde64fd3d8a9b3786ca0692bc55e1aaa32deb5c3bf0c800d0c1">DL_I2C_TX_FIFO_LEVEL_BYTES_2</a> = I2C_MFIFOCTL_TXTRIG_LEVEL_2, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga5f984a9185dfb1fde64fd3d8a9b3786cae1d705529bdc53209ce03dffd374da59">DL_I2C_TX_FIFO_LEVEL_BYTES_3</a> = I2C_MFIFOCTL_TXTRIG_LEVEL_3, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga5f984a9185dfb1fde64fd3d8a9b3786ca791cff1548acfae5f8400b760f137976">DL_I2C_TX_FIFO_LEVEL_BYTES_4</a> = I2C_MFIFOCTL_TXTRIG_LEVEL_4, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga5f984a9185dfb1fde64fd3d8a9b3786ca0cefb453ccff2083124f1a77a74d0cb2">DL_I2C_TX_FIFO_LEVEL_BYTES_5</a> = I2C_MFIFOCTL_TXTRIG_LEVEL_5, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga5f984a9185dfb1fde64fd3d8a9b3786ca91fb0e513d65d89bbe26cb787e58de55">DL_I2C_TX_FIFO_LEVEL_BYTES_6</a> = I2C_MFIFOCTL_TXTRIG_LEVEL_6, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga5f984a9185dfb1fde64fd3d8a9b3786cadb66b796a51a2c1be0f0ca44682df9c4">DL_I2C_TX_FIFO_LEVEL_BYTES_7</a> = I2C_MFIFOCTL_TXTRIG_LEVEL_7
<br />
 }</td></tr>
<tr class="separator:ga5f984a9185dfb1fde64fd3d8a9b3786c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57b2e0df2ed811c2f561b1d6157eded3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga57b2e0df2ed811c2f561b1d6157eded3">DL_I2C_RX_FIFO_LEVEL</a> { <br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga57b2e0df2ed811c2f561b1d6157eded3ad39a247d5692a58771cff1fecc860162">DL_I2C_RX_FIFO_LEVEL_BYTES_1</a> = I2C_MFIFOCTL_RXTRIG_LEVEL_1, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga57b2e0df2ed811c2f561b1d6157eded3ad5a31e8395385c4f72bd8d670dce3274">DL_I2C_RX_FIFO_LEVEL_BYTES_2</a> = I2C_MFIFOCTL_RXTRIG_LEVEL_2, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga57b2e0df2ed811c2f561b1d6157eded3a37436ed98e74e619ed332f9a3cbc27ab">DL_I2C_RX_FIFO_LEVEL_BYTES_3</a> = I2C_MFIFOCTL_RXTRIG_LEVEL_3, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga57b2e0df2ed811c2f561b1d6157eded3aba72e73e9fcb175a54536598df08f1b1">DL_I2C_RX_FIFO_LEVEL_BYTES_4</a> = I2C_MFIFOCTL_RXTRIG_LEVEL_4, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga57b2e0df2ed811c2f561b1d6157eded3a6f1adbb5dd8b773e548037b0be589bc4">DL_I2C_RX_FIFO_LEVEL_BYTES_5</a> = I2C_MFIFOCTL_RXTRIG_LEVEL_5, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga57b2e0df2ed811c2f561b1d6157eded3a1ec5c383ff0076b5b7f7dbcdff26761c">DL_I2C_RX_FIFO_LEVEL_BYTES_6</a> = I2C_MFIFOCTL_RXTRIG_LEVEL_6, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga57b2e0df2ed811c2f561b1d6157eded3a0c713c92ed3d196b86cb21aa211bf06b">DL_I2C_RX_FIFO_LEVEL_BYTES_7</a> = I2C_MFIFOCTL_RXTRIG_LEVEL_7, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga57b2e0df2ed811c2f561b1d6157eded3adff98ce928d23fdb8a50f1295bf05254">DL_I2C_RX_FIFO_LEVEL_BYTES_8</a> = I2C_MFIFOCTL_RXTRIG_LEVEL_8
<br />
 }</td></tr>
<tr class="separator:ga57b2e0df2ed811c2f561b1d6157eded3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3585e512aa5c37880960b13fe6cc212e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga3585e512aa5c37880960b13fe6cc212e">DL_I2C_TARGET_RESPONSE_OVERRIDE_VALUE</a> { <br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga3585e512aa5c37880960b13fe6cc212ea0d4745e13efb92a569742097f8b85302">DL_I2C_TARGET_RESPONSE_OVERRIDE_VALUE_ACK</a> = I2C_SACKCTL_ACKOVAL_DISABLE, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga3585e512aa5c37880960b13fe6cc212eabd4a970773bb4720ff2f44c1e213a36a">DL_I2C_TARGET_RESPONSE_OVERRIDE_VALUE_NACK</a> = I2C_SACKCTL_ACKOVAL_ENABLE
<br />
 }</td></tr>
<tr class="separator:ga3585e512aa5c37880960b13fe6cc212e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aee910b31c80683b76ded8e3c15776a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga2aee910b31c80683b76ded8e3c15776a">DL_I2C_IIDX</a> { <br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga2aee910b31c80683b76ded8e3c15776aabaac69c1dbcfed9ae03236dfd69b64bf">DL_I2C_IIDX_NO_INT</a> = I2C_CPU_INT_IIDX_STAT_NO_INTR, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga2aee910b31c80683b76ded8e3c15776aa53a79e9b4f24f759bdbd461c06456626">DL_I2C_IIDX_CONTROLLER_RX_DONE</a> = I2C_CPU_INT_IIDX_STAT_MRXDONEFG, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga2aee910b31c80683b76ded8e3c15776aaa97a6de057b0079d3a6cadb0704733d5">DL_I2C_IIDX_CONTROLLER_TX_DONE</a> = I2C_CPU_INT_IIDX_STAT_MTXDONEFG, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga2aee910b31c80683b76ded8e3c15776aa1e461b17ec7097e88a6048f5578ca3f9">DL_I2C_IIDX_CONTROLLER_RXFIFO_TRIGGER</a> = I2C_CPU_INT_IIDX_STAT_MRXFIFOTRG, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga2aee910b31c80683b76ded8e3c15776aab5ffb8e0819510fb0e3e29ce75a22d5d">DL_I2C_IIDX_CONTROLLER_TXFIFO_TRIGGER</a> = I2C_CPU_INT_IIDX_STAT_MTXFIFOTRG, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga2aee910b31c80683b76ded8e3c15776aa1c98cd984480ee0b6637f6ddb94c9286">DL_I2C_IIDX_CONTROLLER_RXFIFO_FULL</a> = I2C_CPU_INT_IIDX_STAT_MRXFIFOFULL, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga2aee910b31c80683b76ded8e3c15776aaeb8db42d16a0987b6a33d4861a534d38">DL_I2C_IIDX_CONTROLLER_TXFIFO_EMPTY</a> = I2C_CPU_INT_IIDX_STAT_MTX_EMPTY, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga2aee910b31c80683b76ded8e3c15776aa37cadf329e082f4d0854d5021ea78884">DL_I2C_IIDX_CONTROLLER_NACK</a> = I2C_CPU_INT_IIDX_STAT_MNACKFG, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga2aee910b31c80683b76ded8e3c15776aadb51ac2466168e965fd9ccd0c9b28591">DL_I2C_IIDX_CONTROLLER_START</a> = I2C_CPU_INT_IIDX_STAT_MSTARTFG, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga2aee910b31c80683b76ded8e3c15776aaed7e9651767195f6cc317118c5e0ac5c">DL_I2C_IIDX_CONTROLLER_STOP</a> = I2C_CPU_INT_IIDX_STAT_MSTOPFG, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga2aee910b31c80683b76ded8e3c15776aa23036b1d02737ac60404d4d539dfc2c8">DL_I2C_IIDX_CONTROLLER_ARBITRATION_LOST</a> = I2C_CPU_INT_IIDX_STAT_MARBLOSTFG, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga2aee910b31c80683b76ded8e3c15776aafbaaabec72df5a965072fb99253ff598">DL_I2C_IIDX_CONTROLLER_EVENT1_DMA_DONE</a>, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga2aee910b31c80683b76ded8e3c15776aa2f271d19734a375d941bf722305945a7">DL_I2C_IIDX_CONTROLLER_EVENT2_DMA_DONE</a>, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga2aee910b31c80683b76ded8e3c15776aae4bba5be1b4f22fcf3019d6a41dcb885">DL_I2C_IIDX_CONTROLLER_PEC_RX_ERROR</a> = I2C_CPU_INT_IIDX_STAT_MPEC_RX_ERR, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga2aee910b31c80683b76ded8e3c15776aad06e89020af15b386e952907f79baa87">DL_I2C_IIDX_TIMEOUT_A</a> = I2C_CPU_INT_IIDX_STAT_TIMEOUTA, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga2aee910b31c80683b76ded8e3c15776aad55bfb7e578da4c59e9b9295a6703aaa">DL_I2C_IIDX_TIMEOUT_B</a> = I2C_CPU_INT_IIDX_STAT_TIMEOUTB, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga2aee910b31c80683b76ded8e3c15776aa9e38ffb5f14ef92ce140166f1b0414b9">DL_I2C_IIDX_TARGET_RX_DONE</a> = I2C_CPU_INT_IIDX_STAT_SRXDONEFG, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga2aee910b31c80683b76ded8e3c15776aaadbacccbc1ce87d39d584321bf22d595">DL_I2C_IIDX_TARGET_TX_DONE</a> = I2C_CPU_INT_IIDX_STAT_STXDONEFG, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga2aee910b31c80683b76ded8e3c15776aa5e884776b04ae240fe09d9c9cd339753">DL_I2C_IIDX_TARGET_RXFIFO_TRIGGER</a> = I2C_CPU_INT_IIDX_STAT_SRXFIFOTRG, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga2aee910b31c80683b76ded8e3c15776aac51a2851387a2a6bcf571524b84701fd">DL_I2C_IIDX_TARGET_TXFIFO_TRIGGER</a> = I2C_CPU_INT_IIDX_STAT_STXFIFOTRG, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga2aee910b31c80683b76ded8e3c15776aac764349084de3b39053b6c9518b4337e">DL_I2C_IIDX_TARGET_RXFIFO_FULL</a> = I2C_CPU_INT_IIDX_STAT_SRXFIFOFULL, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga2aee910b31c80683b76ded8e3c15776aa4ac338feb7a05e95489e5cfbdc3c1c54">DL_I2C_IIDX_TARGET_TXFIFO_EMPTY</a> = I2C_CPU_INT_IIDX_STAT_STXEMPTY, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga2aee910b31c80683b76ded8e3c15776aa3308692293435721f802db2a3546f060">DL_I2C_IIDX_TARGET_START</a> = I2C_CPU_INT_IIDX_STAT_SSTARTFG, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga2aee910b31c80683b76ded8e3c15776aa22ec6271aa34f6a57039f8184558deb5">DL_I2C_IIDX_TARGET_STOP</a> = I2C_CPU_INT_IIDX_STAT_SSTOPFG, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga2aee910b31c80683b76ded8e3c15776aa1988192e4e647c9d2615e4d5c9530e79">DL_I2C_IIDX_TARGET_GENERAL_CALL</a> = I2C_CPU_INT_IIDX_STAT_SGENCALL, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga2aee910b31c80683b76ded8e3c15776aa4b1dfecfbc62ea40e6be2b8c3f88b2f0">DL_I2C_IIDX_TARGET_EVENT1_DMA_DONE</a> = I2C_CPU_INT_IIDX_STAT_SDMA_DONE_TX, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga2aee910b31c80683b76ded8e3c15776aa59e3ffff56c8204214d9b392b5b571ac">DL_I2C_IIDX_TARGET_EVENT2_DMA_DONE</a> = I2C_CPU_INT_IIDX_STAT_SDMA_DONE_RX, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga2aee910b31c80683b76ded8e3c15776aae3c2b65db30bcaaec287321afe49361a">DL_I2C_IIDX_TARGET_PEC_RX_ERROR</a> = I2C_CPU_INT_IIDX_STAT_SPEC_RX_ERR, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga2aee910b31c80683b76ded8e3c15776aa9b99580bd73995620ec2fa814370cd14">DL_I2C_IIDX_TARGET_TXFIFO_UNDERFLOW</a> = I2C_CPU_INT_IIDX_STAT_STX_UNFL, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga2aee910b31c80683b76ded8e3c15776aa4465940455ef0a0b8d3e82160267c946">DL_I2C_IIDX_TARGET_RXFIFO_OVERFLOW</a> = I2C_CPU_INT_IIDX_STAT_SRX_OVFL, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga2aee910b31c80683b76ded8e3c15776aaa746057d76d8bb9195b50b599cd4ef57">DL_I2C_IIDX_TARGET_ARBITRATION_LOST</a> = I2C_CPU_INT_IIDX_STAT_SARBLOST, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga2aee910b31c80683b76ded8e3c15776aaccaab921ddd8e5d2dd78bc41449e72df">DL_I2C_IIDX_INTERRUPT_OVERFLOW</a> = I2C_CPU_INT_IIDX_STAT_INTR_OVFL
<br />
 }</td></tr>
<tr class="separator:ga2aee910b31c80683b76ded8e3c15776a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gafe52f423d12f219571380491a7ad95d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gafe52f423d12f219571380491a7ad95d1">DL_I2C_setClockConfig</a> (I2C_Regs *i2c, const <a class="el" href="struct_d_l___i2_c___clock_config.html">DL_I2C_ClockConfig</a> *config)</td></tr>
<tr class="memdesc:gafe52f423d12f219571380491a7ad95d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure I2C source clock.  <a href="#gafe52f423d12f219571380491a7ad95d1">More...</a><br /></td></tr>
<tr class="separator:gafe52f423d12f219571380491a7ad95d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9082406188ca55be3d9ca009517797fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga9082406188ca55be3d9ca009517797fa">DL_I2C_getClockConfig</a> (const I2C_Regs *i2c, <a class="el" href="struct_d_l___i2_c___clock_config.html">DL_I2C_ClockConfig</a> *config)</td></tr>
<tr class="memdesc:ga9082406188ca55be3d9ca009517797fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get I2C source clock configuration.  <a href="#ga9082406188ca55be3d9ca009517797fa">More...</a><br /></td></tr>
<tr class="separator:ga9082406188ca55be3d9ca009517797fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabeeb1670ab63e9656da06c5148b80153"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gabeeb1670ab63e9656da06c5148b80153">DL_I2C_fillControllerTXFIFO</a> (I2C_Regs *i2c, const uint8_t *buffer, uint16_t count)</td></tr>
<tr class="memdesc:gabeeb1670ab63e9656da06c5148b80153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the controller TX FIFO with data.  <a href="#gabeeb1670ab63e9656da06c5148b80153">More...</a><br /></td></tr>
<tr class="separator:gabeeb1670ab63e9656da06c5148b80153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfcb7a745c177c5ec8a9291f7a77c5e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gacfcb7a745c177c5ec8a9291f7a77c5e8">DL_I2C_flushControllerTXFIFO</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gacfcb7a745c177c5ec8a9291f7a77c5e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes/removes all elements in the controller TX FIFO.  <a href="#gacfcb7a745c177c5ec8a9291f7a77c5e8">More...</a><br /></td></tr>
<tr class="separator:gacfcb7a745c177c5ec8a9291f7a77c5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96a1251b84773ba8018e28e217288021"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga96a1251b84773ba8018e28e217288021">DL_I2C_flushControllerRXFIFO</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga96a1251b84773ba8018e28e217288021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes/removes all elements in the controller RX FIFO.  <a href="#ga96a1251b84773ba8018e28e217288021">More...</a><br /></td></tr>
<tr class="separator:ga96a1251b84773ba8018e28e217288021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga413f826364f588a18ead8ae2816ed9f4"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga413f826364f588a18ead8ae2816ed9f4">DL_I2C_isControllerTXFIFOFull</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga413f826364f588a18ead8ae2816ed9f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if controller TX FIFO is full.  <a href="#ga413f826364f588a18ead8ae2816ed9f4">More...</a><br /></td></tr>
<tr class="separator:ga413f826364f588a18ead8ae2816ed9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea6e1d20664eb58d38d090132ff759a7"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaea6e1d20664eb58d38d090132ff759a7">DL_I2C_isControllerTXFIFOEmpty</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gaea6e1d20664eb58d38d090132ff759a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if controller TX FIFO is empty.  <a href="#gaea6e1d20664eb58d38d090132ff759a7">More...</a><br /></td></tr>
<tr class="separator:gaea6e1d20664eb58d38d090132ff759a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53f6a562cdc3ade95d3f9602c6144bcb"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga53f6a562cdc3ade95d3f9602c6144bcb">DL_I2C_isControllerRXFIFOEmpty</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga53f6a562cdc3ade95d3f9602c6144bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if controller RX FIFO is empty.  <a href="#ga53f6a562cdc3ade95d3f9602c6144bcb">More...</a><br /></td></tr>
<tr class="separator:ga53f6a562cdc3ade95d3f9602c6144bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d7bd1eb2fbbb0b5144962458d1d1c5c"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga8d7bd1eb2fbbb0b5144962458d1d1c5c">DL_I2C_resetControllerTransfer</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga8d7bd1eb2fbbb0b5144962458d1d1c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset transfers from from I2C controller.  <a href="#ga8d7bd1eb2fbbb0b5144962458d1d1c5c">More...</a><br /></td></tr>
<tr class="separator:ga8d7bd1eb2fbbb0b5144962458d1d1c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc914d02e83818035b69347376dd1fae"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gabc914d02e83818035b69347376dd1fae">DL_I2C_startControllerTransfer</a> (I2C_Regs *i2c, uint32_t targetAddr, <a class="el" href="group___i2_c.html#ga4e5bff33e69ea760e7f8364b2f1cf259">DL_I2C_CONTROLLER_DIRECTION</a> direction, uint16_t length)</td></tr>
<tr class="memdesc:gabc914d02e83818035b69347376dd1fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up a transfer from I2C controller.  <a href="#gabc914d02e83818035b69347376dd1fae">More...</a><br /></td></tr>
<tr class="separator:gabc914d02e83818035b69347376dd1fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0d5a085c2e5ea50f61960a4e18be424"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaa0d5a085c2e5ea50f61960a4e18be424">DL_I2C_startControllerTransferAdvanced</a> (I2C_Regs *i2c, uint32_t targetAddr, <a class="el" href="group___i2_c.html#ga4e5bff33e69ea760e7f8364b2f1cf259">DL_I2C_CONTROLLER_DIRECTION</a> direction, uint16_t length, <a class="el" href="group___i2_c.html#ga5722df24b0d57c0b2bf18c1068a36ca1">DL_I2C_CONTROLLER_START</a> start, <a class="el" href="group___i2_c.html#ga8996cddfa139bd7118880aa51e32f0f7">DL_I2C_CONTROLLER_STOP</a> stop, <a class="el" href="group___i2_c.html#gaab55947b23ba571c233ab80d34bf7182">DL_I2C_CONTROLLER_ACK</a> ack)</td></tr>
<tr class="memdesc:gaa0d5a085c2e5ea50f61960a4e18be424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up a transfer from I2C controller with control of START, STOP and ACK.  <a href="#gaa0d5a085c2e5ea50f61960a4e18be424">More...</a><br /></td></tr>
<tr class="separator:gaa0d5a085c2e5ea50f61960a4e18be424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ce06770ca54c22ed184318514fa3050"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga3ce06770ca54c22ed184318514fa3050">DL_I2C_isTargetTXFIFOFull</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga3ce06770ca54c22ed184318514fa3050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if target TX FIFO is full.  <a href="#ga3ce06770ca54c22ed184318514fa3050">More...</a><br /></td></tr>
<tr class="separator:ga3ce06770ca54c22ed184318514fa3050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d724998617836aaf2aa74587ef6bee8"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga9d724998617836aaf2aa74587ef6bee8">DL_I2C_isTargetTXFIFOEmpty</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga9d724998617836aaf2aa74587ef6bee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if target TX FIFO is empty.  <a href="#ga9d724998617836aaf2aa74587ef6bee8">More...</a><br /></td></tr>
<tr class="separator:ga9d724998617836aaf2aa74587ef6bee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga285819b2a1c642fd3559b40578bab94d"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga285819b2a1c642fd3559b40578bab94d">DL_I2C_isTargetRXFIFOEmpty</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga285819b2a1c642fd3559b40578bab94d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if target RX FIFO is empty.  <a href="#ga285819b2a1c642fd3559b40578bab94d">More...</a><br /></td></tr>
<tr class="separator:ga285819b2a1c642fd3559b40578bab94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64db37623fb55d78aa168c45f0bf533e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga64db37623fb55d78aa168c45f0bf533e">DL_I2C_fillTargetTXFIFO</a> (I2C_Regs *i2c, const uint8_t *buffer, uint8_t count)</td></tr>
<tr class="memdesc:ga64db37623fb55d78aa168c45f0bf533e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the target TX FIFO with data.  <a href="#ga64db37623fb55d78aa168c45f0bf533e">More...</a><br /></td></tr>
<tr class="separator:ga64db37623fb55d78aa168c45f0bf533e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65d96af5bd435f74a4aab60ae33f0156"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga65d96af5bd435f74a4aab60ae33f0156">DL_I2C_flushTargetTXFIFO</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga65d96af5bd435f74a4aab60ae33f0156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes/removes all elements in the target TX FIFO.  <a href="#ga65d96af5bd435f74a4aab60ae33f0156">More...</a><br /></td></tr>
<tr class="separator:ga65d96af5bd435f74a4aab60ae33f0156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f332a1d9f230510571654708d638816"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga8f332a1d9f230510571654708d638816">DL_I2C_flushTargetRXFIFO</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga8f332a1d9f230510571654708d638816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes/removes all elements in the target RX FIFO.  <a href="#ga8f332a1d9f230510571654708d638816">More...</a><br /></td></tr>
<tr class="separator:ga8f332a1d9f230510571654708d638816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f56db4764b0e7acc0ef47e8439d79be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga5f56db4764b0e7acc0ef47e8439d79be">DL_I2C_transmitTargetDataBlocking</a> (I2C_Regs *i2c, uint8_t data)</td></tr>
<tr class="memdesc:ga5f56db4764b0e7acc0ef47e8439d79be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit target data, waiting until transmit request.  <a href="#ga5f56db4764b0e7acc0ef47e8439d79be">More...</a><br /></td></tr>
<tr class="separator:ga5f56db4764b0e7acc0ef47e8439d79be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1568de96bfa23a32f14989f5596b9ade"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga1568de96bfa23a32f14989f5596b9ade">DL_I2C_transmitTargetDataCheck</a> (I2C_Regs *i2c, uint8_t data)</td></tr>
<tr class="memdesc:ga1568de96bfa23a32f14989f5596b9ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit target data.  <a href="#ga1568de96bfa23a32f14989f5596b9ade">More...</a><br /></td></tr>
<tr class="separator:ga1568de96bfa23a32f14989f5596b9ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47c34bc2633f8923165358d3c31d12e2"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga47c34bc2633f8923165358d3c31d12e2">DL_I2C_receiveTargetDataBlocking</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga47c34bc2633f8923165358d3c31d12e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive target data, waiting until receive request.  <a href="#ga47c34bc2633f8923165358d3c31d12e2">More...</a><br /></td></tr>
<tr class="separator:ga47c34bc2633f8923165358d3c31d12e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66a302555ef7477d023f506cdb7354c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga66a302555ef7477d023f506cdb7354c0">DL_I2C_receiveTargetDataCheck</a> (const I2C_Regs *i2c, uint8_t *buffer)</td></tr>
<tr class="memdesc:ga66a302555ef7477d023f506cdb7354c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive target data.  <a href="#ga66a302555ef7477d023f506cdb7354c0">More...</a><br /></td></tr>
<tr class="separator:ga66a302555ef7477d023f506cdb7354c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga040aa421dee03e9cd4adb3777e8147e0"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga040aa421dee03e9cd4adb3777e8147e0">DL_I2C_enablePower</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga040aa421dee03e9cd4adb3777e8147e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the Peripheral Write Enable (PWREN) register for the I2C.  <a href="#ga040aa421dee03e9cd4adb3777e8147e0">More...</a><br /></td></tr>
<tr class="separator:ga040aa421dee03e9cd4adb3777e8147e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ea9a4a26ffbdf4c4c0f2ae615c9c195"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga6ea9a4a26ffbdf4c4c0f2ae615c9c195">DL_I2C_disablePower</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga6ea9a4a26ffbdf4c4c0f2ae615c9c195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the Peripheral Write Enable (PWREN) register for the I2C.  <a href="#ga6ea9a4a26ffbdf4c4c0f2ae615c9c195">More...</a><br /></td></tr>
<tr class="separator:ga6ea9a4a26ffbdf4c4c0f2ae615c9c195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d0c945b48c12ef15437f68437499f5c"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga4d0c945b48c12ef15437f68437499f5c">DL_I2C_isPowerEnabled</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga4d0c945b48c12ef15437f68437499f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the Peripheral Write Enable (PWREN) register for the I2C is enabled.  <a href="#ga4d0c945b48c12ef15437f68437499f5c">More...</a><br /></td></tr>
<tr class="separator:ga4d0c945b48c12ef15437f68437499f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5d5c92ce48214c4f933da1ff95ea859"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaf5d5c92ce48214c4f933da1ff95ea859">DL_I2C_reset</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gaf5d5c92ce48214c4f933da1ff95ea859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets i2c peripheral.  <a href="#gaf5d5c92ce48214c4f933da1ff95ea859">More...</a><br /></td></tr>
<tr class="separator:gaf5d5c92ce48214c4f933da1ff95ea859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7be75e95c5c2f58cbcd1ed27cd851f46"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga7be75e95c5c2f58cbcd1ed27cd851f46">DL_I2C_isReset</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga7be75e95c5c2f58cbcd1ed27cd851f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if i2c peripheral was reset.  <a href="#ga7be75e95c5c2f58cbcd1ed27cd851f46">More...</a><br /></td></tr>
<tr class="separator:ga7be75e95c5c2f58cbcd1ed27cd851f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga083d8a13d9928b213eeaf84401379ab3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga083d8a13d9928b213eeaf84401379ab3">DL_I2C_selectClockSource</a> (I2C_Regs *i2c, <a class="el" href="group___i2_c.html#gad912db0203e9bb0e55bb0ddbc0ddcfcc">DL_I2C_CLOCK</a> clockSource)</td></tr>
<tr class="memdesc:ga083d8a13d9928b213eeaf84401379ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Clock Source.  <a href="#ga083d8a13d9928b213eeaf84401379ab3">More...</a><br /></td></tr>
<tr class="separator:ga083d8a13d9928b213eeaf84401379ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga809ad478e82c04c4e05a1620492ce89f"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga809ad478e82c04c4e05a1620492ce89f">DL_I2C_selectClockDivider</a> (I2C_Regs *i2c, <a class="el" href="group___i2_c.html#ga03737f74607dfbe4048cff93862c9faa">DL_I2C_CLOCK_DIVIDE</a> clockDivider)</td></tr>
<tr class="memdesc:ga809ad478e82c04c4e05a1620492ce89f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Clock Divider.  <a href="#ga809ad478e82c04c4e05a1620492ce89f">More...</a><br /></td></tr>
<tr class="separator:ga809ad478e82c04c4e05a1620492ce89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f9d183ec3a668b26763246e0c9561ca"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___i2_c.html#ga031f0b093a1d7448b0ba89a6ecc0a32a">DL_I2C_ANALOG_GLITCH_FILTER_WIDTH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga6f9d183ec3a668b26763246e0c9561ca">DL_I2C_getAnalogGlitchFilterPulseWidth</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga6f9d183ec3a668b26763246e0c9561ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Analog Glitch Suppression Pulse Width.  <a href="#ga6f9d183ec3a668b26763246e0c9561ca">More...</a><br /></td></tr>
<tr class="separator:ga6f9d183ec3a668b26763246e0c9561ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaf73e16477c0bf6b0c7485ce9160814"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaaaf73e16477c0bf6b0c7485ce9160814">DL_I2C_setAnalogGlitchFilterPulseWidth</a> (I2C_Regs *i2c, <a class="el" href="group___i2_c.html#ga031f0b093a1d7448b0ba89a6ecc0a32a">DL_I2C_ANALOG_GLITCH_FILTER_WIDTH</a> filterWidth)</td></tr>
<tr class="memdesc:gaaaf73e16477c0bf6b0c7485ce9160814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Analog Glitch Suppression Pulse Width.  <a href="#gaaaf73e16477c0bf6b0c7485ce9160814">More...</a><br /></td></tr>
<tr class="separator:gaaaf73e16477c0bf6b0c7485ce9160814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1da7a0e2083d9f43223b41f2589d4d78"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___i2_c.html#ga9f42d16d0c14219c0ce8e45016bed5e4">DL_I2C_DIGITAL_GLITCH_FILTER_WIDTH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga1da7a0e2083d9f43223b41f2589d4d78">DL_I2C_getDigitalGlitchFilterPulseWidth</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga1da7a0e2083d9f43223b41f2589d4d78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Digital Glitch Suppression Pulse Width.  <a href="#ga1da7a0e2083d9f43223b41f2589d4d78">More...</a><br /></td></tr>
<tr class="separator:ga1da7a0e2083d9f43223b41f2589d4d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b57b523f7e35273532ad4d6411fd8ca"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga9b57b523f7e35273532ad4d6411fd8ca">DL_I2C_setDigitalGlitchFilterPulseWidth</a> (I2C_Regs *i2c, <a class="el" href="group___i2_c.html#ga9f42d16d0c14219c0ce8e45016bed5e4">DL_I2C_DIGITAL_GLITCH_FILTER_WIDTH</a> filterWidth)</td></tr>
<tr class="memdesc:ga9b57b523f7e35273532ad4d6411fd8ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Digital Glitch Suppression Pulse Width.  <a href="#ga9b57b523f7e35273532ad4d6411fd8ca">More...</a><br /></td></tr>
<tr class="separator:ga9b57b523f7e35273532ad4d6411fd8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60638213fd307de071f25fb94ba4e3d7"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga60638213fd307de071f25fb94ba4e3d7">DL_I2C_disableAnalogGlitchFilter</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga60638213fd307de071f25fb94ba4e3d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable Analog Glitch Suppression.  <a href="#ga60638213fd307de071f25fb94ba4e3d7">More...</a><br /></td></tr>
<tr class="separator:ga60638213fd307de071f25fb94ba4e3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf88b49609149e01a74a40ab4fb0a459"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gadf88b49609149e01a74a40ab4fb0a459">DL_I2C_isAnalogGlitchFilterEnabled</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gadf88b49609149e01a74a40ab4fb0a459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if analog glitch suppression is enabled.  <a href="#gadf88b49609149e01a74a40ab4fb0a459">More...</a><br /></td></tr>
<tr class="separator:gadf88b49609149e01a74a40ab4fb0a459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga140a6bf809d3a3cfa3260a458acd2d05"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga140a6bf809d3a3cfa3260a458acd2d05">DL_I2C_enableAnalogGlitchFilter</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga140a6bf809d3a3cfa3260a458acd2d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable Analog Glitch Suppression.  <a href="#ga140a6bf809d3a3cfa3260a458acd2d05">More...</a><br /></td></tr>
<tr class="separator:ga140a6bf809d3a3cfa3260a458acd2d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81abbad2d469957cd3495748f6b2e948"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___i2_c.html#ga4e5bff33e69ea760e7f8364b2f1cf259">DL_I2C_CONTROLLER_DIRECTION</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga81abbad2d469957cd3495748f6b2e948">DL_I2C_getControllerDirection</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga81abbad2d469957cd3495748f6b2e948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get direction of next controller operation.  <a href="#ga81abbad2d469957cd3495748f6b2e948">More...</a><br /></td></tr>
<tr class="separator:ga81abbad2d469957cd3495748f6b2e948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7114948c22ab198aaa5202c02c982c3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaa7114948c22ab198aaa5202c02c982c3">DL_I2C_setControllerDirection</a> (I2C_Regs *i2c, <a class="el" href="group___i2_c.html#ga4e5bff33e69ea760e7f8364b2f1cf259">DL_I2C_CONTROLLER_DIRECTION</a> direction)</td></tr>
<tr class="memdesc:gaa7114948c22ab198aaa5202c02c982c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set direction of next controller operation.  <a href="#gaa7114948c22ab198aaa5202c02c982c3">More...</a><br /></td></tr>
<tr class="separator:gaa7114948c22ab198aaa5202c02c982c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2eb3a9d4dc0b98fb388aadf5628039a7"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga2eb3a9d4dc0b98fb388aadf5628039a7">DL_I2C_getTargetAddress</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga2eb3a9d4dc0b98fb388aadf5628039a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the address of the target being addressed when configured as an I2C controller.  <a href="#ga2eb3a9d4dc0b98fb388aadf5628039a7">More...</a><br /></td></tr>
<tr class="separator:ga2eb3a9d4dc0b98fb388aadf5628039a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fe60c04fa69e0aa0036751c7572b8fd"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga6fe60c04fa69e0aa0036751c7572b8fd">DL_I2C_setTargetAddress</a> (I2C_Regs *i2c, uint32_t targetAddress)</td></tr>
<tr class="memdesc:ga6fe60c04fa69e0aa0036751c7572b8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the address of the target being addressed when configured as an I2C controller.  <a href="#ga6fe60c04fa69e0aa0036751c7572b8fd">More...</a><br /></td></tr>
<tr class="separator:ga6fe60c04fa69e0aa0036751c7572b8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga255deb2c3288221ad037acc13fc94147"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___i2_c.html#ga286008e7442aee9279befbb3cace3d47">DL_I2C_CONTROLLER_ADDRESSING_MODE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga255deb2c3288221ad037acc13fc94147">DL_I2C_getControllerAddressingMode</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga255deb2c3288221ad037acc13fc94147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get controller addressing mode.  <a href="#ga255deb2c3288221ad037acc13fc94147">More...</a><br /></td></tr>
<tr class="separator:ga255deb2c3288221ad037acc13fc94147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fb3012c627a5ef35d2b84f6a1e126b3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga1fb3012c627a5ef35d2b84f6a1e126b3">DL_I2C_setControllerAddressingMode</a> (I2C_Regs *i2c, <a class="el" href="group___i2_c.html#ga286008e7442aee9279befbb3cace3d47">DL_I2C_CONTROLLER_ADDRESSING_MODE</a> mode)</td></tr>
<tr class="memdesc:ga1fb3012c627a5ef35d2b84f6a1e126b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set controller addressing mode between 7-bit and 10-bit mode.  <a href="#ga1fb3012c627a5ef35d2b84f6a1e126b3">More...</a><br /></td></tr>
<tr class="separator:ga1fb3012c627a5ef35d2b84f6a1e126b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga002a1ad899ae9981211a2e1ceb45d55f"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga002a1ad899ae9981211a2e1ceb45d55f">DL_I2C_disableControllerACKOverride</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga002a1ad899ae9981211a2e1ceb45d55f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable controller ACK override.  <a href="#ga002a1ad899ae9981211a2e1ceb45d55f">More...</a><br /></td></tr>
<tr class="separator:ga002a1ad899ae9981211a2e1ceb45d55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae017801cc456ba6f3a0c496755c1e38c"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gae017801cc456ba6f3a0c496755c1e38c">DL_I2C_isControllerACKOverrideEnabled</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gae017801cc456ba6f3a0c496755c1e38c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if controller ACK override is enabled.  <a href="#gae017801cc456ba6f3a0c496755c1e38c">More...</a><br /></td></tr>
<tr class="separator:gae017801cc456ba6f3a0c496755c1e38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga267b63be2893efd4ab6b4e48fdd595cd"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga267b63be2893efd4ab6b4e48fdd595cd">DL_I2C_enableControllerACKOverride</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga267b63be2893efd4ab6b4e48fdd595cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable controller ACK override.  <a href="#ga267b63be2893efd4ab6b4e48fdd595cd">More...</a><br /></td></tr>
<tr class="separator:ga267b63be2893efd4ab6b4e48fdd595cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ce108fc849d8973615a4be0804a28b5"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga8ce108fc849d8973615a4be0804a28b5">DL_I2C_disableControllerReadOnTXEmpty</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga8ce108fc849d8973615a4be0804a28b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable controller read on TX empty.  <a href="#ga8ce108fc849d8973615a4be0804a28b5">More...</a><br /></td></tr>
<tr class="separator:ga8ce108fc849d8973615a4be0804a28b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbc1cc912d0ae4af531cde7a493ec8bf"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gadbc1cc912d0ae4af531cde7a493ec8bf">DL_I2C_isControllerReadOnTXEmptyEnabled</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gadbc1cc912d0ae4af531cde7a493ec8bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if controller read on TX empty is enabled.  <a href="#gadbc1cc912d0ae4af531cde7a493ec8bf">More...</a><br /></td></tr>
<tr class="separator:gadbc1cc912d0ae4af531cde7a493ec8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga345ce0bec611dbc4552f8770de13f47c"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga345ce0bec611dbc4552f8770de13f47c">DL_I2C_enableControllerReadOnTXEmpty</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga345ce0bec611dbc4552f8770de13f47c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable controller read on TX empty.  <a href="#ga345ce0bec611dbc4552f8770de13f47c">More...</a><br /></td></tr>
<tr class="separator:ga345ce0bec611dbc4552f8770de13f47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e31e3aea1af4a8acecd8db4aac97648"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga6e31e3aea1af4a8acecd8db4aac97648">DL_I2C_getControllerPECCountValue</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga6e31e3aea1af4a8acecd8db4aac97648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the SMBus/PMBus Packet Error Checking (PEC) count value.  <a href="#ga6e31e3aea1af4a8acecd8db4aac97648">More...</a><br /></td></tr>
<tr class="separator:ga6e31e3aea1af4a8acecd8db4aac97648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae6c467bc9b77f37d82a135b489826e3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaae6c467bc9b77f37d82a135b489826e3">DL_I2C_setControllerPECCountValue</a> (I2C_Regs *i2c, uint32_t count)</td></tr>
<tr class="memdesc:gaae6c467bc9b77f37d82a135b489826e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the SMBus/PMBus Packet Error Checking (PEC) count value.  <a href="#gaae6c467bc9b77f37d82a135b489826e3">More...</a><br /></td></tr>
<tr class="separator:gaae6c467bc9b77f37d82a135b489826e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4c387ec78dae0360077a6e60db5081f"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaa4c387ec78dae0360077a6e60db5081f">DL_I2C_disableControllerPEC</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gaa4c387ec78dae0360077a6e60db5081f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable controller SMBus/PMBus Packet Error Checking (PEC)  <a href="#gaa4c387ec78dae0360077a6e60db5081f">More...</a><br /></td></tr>
<tr class="separator:gaa4c387ec78dae0360077a6e60db5081f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa96c29ab403c501dba7738963f42d4b7"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaa96c29ab403c501dba7738963f42d4b7">DL_I2C_isControllerPECEnabled</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gaa96c29ab403c501dba7738963f42d4b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if controller SMBus/PMBus Packet Error Checking (PEC) is enabled.  <a href="#gaa96c29ab403c501dba7738963f42d4b7">More...</a><br /></td></tr>
<tr class="separator:gaa96c29ab403c501dba7738963f42d4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e45ed6ab0c41eb3362db7f113423349"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga5e45ed6ab0c41eb3362db7f113423349">DL_I2C_enableControllerPEC</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga5e45ed6ab0c41eb3362db7f113423349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable controller SMBus/PMBus Packet Error Checking (PEC)  <a href="#ga5e45ed6ab0c41eb3362db7f113423349">More...</a><br /></td></tr>
<tr class="separator:ga5e45ed6ab0c41eb3362db7f113423349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a599911eaac7007428277f0732a2a15"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga2a599911eaac7007428277f0732a2a15">DL_I2C_getControllerCurrentPECCount</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga2a599911eaac7007428277f0732a2a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current SMBus/PMBus PEC byte count of the controller state machine.  <a href="#ga2a599911eaac7007428277f0732a2a15">More...</a><br /></td></tr>
<tr class="separator:ga2a599911eaac7007428277f0732a2a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88bb3a8a69f297d2e911c58f6b8d65fb"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___i2_c.html#gae90754611bdbab4885bc634bcddadca4">DL_I2C_CONTROLLER_PEC_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga88bb3a8a69f297d2e911c58f6b8d65fb">DL_I2C_getControllerPECCheckedStatus</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga88bb3a8a69f297d2e911c58f6b8d65fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">If controller SMBus/PMBus PEC was checked in last transaction.  <a href="#ga88bb3a8a69f297d2e911c58f6b8d65fb">More...</a><br /></td></tr>
<tr class="separator:ga88bb3a8a69f297d2e911c58f6b8d65fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a64b995755cd0c236b983d09216e9d1"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___i2_c.html#ga560b453b65c64ad5bffb37ae05c88553">DL_I2C_CONTROLLER_PEC_CHECK_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga6a64b995755cd0c236b983d09216e9d1">DL_I2C_getControllerPECCheckError</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga6a64b995755cd0c236b983d09216e9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the status of the controller SMBus/PMBus PEC Check error.  <a href="#ga6a64b995755cd0c236b983d09216e9d1">More...</a><br /></td></tr>
<tr class="separator:ga6a64b995755cd0c236b983d09216e9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94e0be0a87e33bf66741c164c0b41052"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga94e0be0a87e33bf66741c164c0b41052">DL_I2C_disableControllerBurst</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga94e0be0a87e33bf66741c164c0b41052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable I2C controller burst mode.  <a href="#ga94e0be0a87e33bf66741c164c0b41052">More...</a><br /></td></tr>
<tr class="separator:ga94e0be0a87e33bf66741c164c0b41052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga646b281a6094b9d0f6577e388f893386"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga646b281a6094b9d0f6577e388f893386">DL_I2C_isControllerBurstEnabled</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga646b281a6094b9d0f6577e388f893386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if I2C controller burst mode is enabled.  <a href="#ga646b281a6094b9d0f6577e388f893386">More...</a><br /></td></tr>
<tr class="separator:ga646b281a6094b9d0f6577e388f893386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7609e2a1ea220f277b8fca9df941216f"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga7609e2a1ea220f277b8fca9df941216f">DL_I2C_enableControllerBurst</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga7609e2a1ea220f277b8fca9df941216f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable I2C controller burst mode.  <a href="#ga7609e2a1ea220f277b8fca9df941216f">More...</a><br /></td></tr>
<tr class="separator:ga7609e2a1ea220f277b8fca9df941216f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ece43f6cfcc48eb08dbe583441c3525"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga6ece43f6cfcc48eb08dbe583441c3525">DL_I2C_disableStartCondition</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga6ece43f6cfcc48eb08dbe583441c3525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable I2C START generation.  <a href="#ga6ece43f6cfcc48eb08dbe583441c3525">More...</a><br /></td></tr>
<tr class="separator:ga6ece43f6cfcc48eb08dbe583441c3525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf434454eb54f8e75dd560f43af485a2d"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaf434454eb54f8e75dd560f43af485a2d">DL_I2C_isStartConditionEnabled</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gaf434454eb54f8e75dd560f43af485a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if I2C START generation is enabled.  <a href="#gaf434454eb54f8e75dd560f43af485a2d">More...</a><br /></td></tr>
<tr class="separator:gaf434454eb54f8e75dd560f43af485a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58dec8789bcfb77143d263dfa4f316a2"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga58dec8789bcfb77143d263dfa4f316a2">DL_I2C_enableStartCondition</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga58dec8789bcfb77143d263dfa4f316a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable I2C START generation.  <a href="#ga58dec8789bcfb77143d263dfa4f316a2">More...</a><br /></td></tr>
<tr class="separator:ga58dec8789bcfb77143d263dfa4f316a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab78daabc26c563ede833407e0d9be983"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gab78daabc26c563ede833407e0d9be983">DL_I2C_disableStopCondition</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gab78daabc26c563ede833407e0d9be983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable I2C STOP generation.  <a href="#gab78daabc26c563ede833407e0d9be983">More...</a><br /></td></tr>
<tr class="separator:gab78daabc26c563ede833407e0d9be983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada93982a93156ce61b029bd54bd370c2"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gada93982a93156ce61b029bd54bd370c2">DL_I2C_isStopConditionEnabled</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gada93982a93156ce61b029bd54bd370c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if I2C STOP generation is enabled.  <a href="#gada93982a93156ce61b029bd54bd370c2">More...</a><br /></td></tr>
<tr class="separator:gada93982a93156ce61b029bd54bd370c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga205da6ec66f7438a2f2852055d0a7c5f"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga205da6ec66f7438a2f2852055d0a7c5f">DL_I2C_enableStopCondition</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga205da6ec66f7438a2f2852055d0a7c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable I2C STOP generation.  <a href="#ga205da6ec66f7438a2f2852055d0a7c5f">More...</a><br /></td></tr>
<tr class="separator:ga205da6ec66f7438a2f2852055d0a7c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d6b9750470cfda31aace0db785c6479"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga5d6b9750470cfda31aace0db785c6479">DL_I2C_disableControllerACK</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga5d6b9750470cfda31aace0db785c6479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable I2C controller data acknowledge (ACK or NACK)  <a href="#ga5d6b9750470cfda31aace0db785c6479">More...</a><br /></td></tr>
<tr class="separator:ga5d6b9750470cfda31aace0db785c6479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga598b72a9ead67479156ee41bd8e4eaf8"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga598b72a9ead67479156ee41bd8e4eaf8">DL_I2C_isControllerACKEnabled</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga598b72a9ead67479156ee41bd8e4eaf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if I2C controller data acknowledge (ACK or NACK) is enabled.  <a href="#ga598b72a9ead67479156ee41bd8e4eaf8">More...</a><br /></td></tr>
<tr class="separator:ga598b72a9ead67479156ee41bd8e4eaf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b8ac2f0d12315c7bb98562b6f6e0b61"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga5b8ac2f0d12315c7bb98562b6f6e0b61">DL_I2C_enableControllerACK</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga5b8ac2f0d12315c7bb98562b6f6e0b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable I2C controller data acknowledge (ACK or NACK)  <a href="#ga5b8ac2f0d12315c7bb98562b6f6e0b61">More...</a><br /></td></tr>
<tr class="separator:ga5b8ac2f0d12315c7bb98562b6f6e0b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b70c82454879281797d5de0231af669"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga7b70c82454879281797d5de0231af669">DL_I2C_getTransactionLength</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga7b70c82454879281797d5de0231af669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get transaction length in bytes.  <a href="#ga7b70c82454879281797d5de0231af669">More...</a><br /></td></tr>
<tr class="separator:ga7b70c82454879281797d5de0231af669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad614a1764f251d9fcbe0669b97c6cec2"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gad614a1764f251d9fcbe0669b97c6cec2">DL_I2C_setTransactionLength</a> (I2C_Regs *i2c, uint32_t length)</td></tr>
<tr class="memdesc:gad614a1764f251d9fcbe0669b97c6cec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set transaction length in bytes.  <a href="#gad614a1764f251d9fcbe0669b97c6cec2">More...</a><br /></td></tr>
<tr class="separator:gad614a1764f251d9fcbe0669b97c6cec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50097248e2a4fa0f790437d817315572"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga50097248e2a4fa0f790437d817315572">DL_I2C_getControllerStatus</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga50097248e2a4fa0f790437d817315572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get status of I2C bus controller for controller.  <a href="#ga50097248e2a4fa0f790437d817315572">More...</a><br /></td></tr>
<tr class="separator:ga50097248e2a4fa0f790437d817315572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa33116abdeaab5e853474ec72f350cf"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaaa33116abdeaab5e853474ec72f350cf">DL_I2C_getTransactionCount</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gaaa33116abdeaab5e853474ec72f350cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get transaction count in bytes.  <a href="#gaaa33116abdeaab5e853474ec72f350cf">More...</a><br /></td></tr>
<tr class="separator:gaaa33116abdeaab5e853474ec72f350cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57b87c5b3bc52f16b76aede1947c7440"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga57b87c5b3bc52f16b76aede1947c7440">DL_I2C_receiveControllerData</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga57b87c5b3bc52f16b76aede1947c7440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get byte of data from I2C controller.  <a href="#ga57b87c5b3bc52f16b76aede1947c7440">More...</a><br /></td></tr>
<tr class="separator:ga57b87c5b3bc52f16b76aede1947c7440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c86dbbeacddba4fe315cf7204bdf80a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga8c86dbbeacddba4fe315cf7204bdf80a">DL_I2C_transmitControllerData</a> (I2C_Regs *i2c, uint8_t data)</td></tr>
<tr class="memdesc:ga8c86dbbeacddba4fe315cf7204bdf80a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set next byte to be transferred during the next transaction.  <a href="#ga8c86dbbeacddba4fe315cf7204bdf80a">More...</a><br /></td></tr>
<tr class="separator:ga8c86dbbeacddba4fe315cf7204bdf80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga056b90edad93a16b0e0acf09d00d8a37"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga056b90edad93a16b0e0acf09d00d8a37">DL_I2C_getTimerPeriod</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga056b90edad93a16b0e0acf09d00d8a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get timer period This field is used in the equation to configure SCL_PERIOD:  <a href="#ga056b90edad93a16b0e0acf09d00d8a37">More...</a><br /></td></tr>
<tr class="separator:ga056b90edad93a16b0e0acf09d00d8a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5757bad74706a15ce16f99664ee44994"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga5757bad74706a15ce16f99664ee44994">DL_I2C_setTimerPeriod</a> (I2C_Regs *i2c, uint8_t period)</td></tr>
<tr class="memdesc:ga5757bad74706a15ce16f99664ee44994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set timer period This field is used in the equation to configure SCL_PERIOD:  <a href="#ga5757bad74706a15ce16f99664ee44994">More...</a><br /></td></tr>
<tr class="separator:ga5757bad74706a15ce16f99664ee44994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30395d7966646002a905dc4e9bd8db95"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga30395d7966646002a905dc4e9bd8db95">DL_I2C_disableLoopbackMode</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga30395d7966646002a905dc4e9bd8db95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable loopback mode.  <a href="#ga30395d7966646002a905dc4e9bd8db95">More...</a><br /></td></tr>
<tr class="separator:ga30395d7966646002a905dc4e9bd8db95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac479032a9028dcce993ed47c333bcca7"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gac479032a9028dcce993ed47c333bcca7">DL_I2C_isLoopbackModeEnabled</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gac479032a9028dcce993ed47c333bcca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if loopback mode is enabled.  <a href="#gac479032a9028dcce993ed47c333bcca7">More...</a><br /></td></tr>
<tr class="separator:gac479032a9028dcce993ed47c333bcca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbdbeaa1079afc2d296dcd182df3b4fd"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gacbdbeaa1079afc2d296dcd182df3b4fd">DL_I2C_enableLoopbackMode</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gacbdbeaa1079afc2d296dcd182df3b4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable loopback mode.  <a href="#gacbdbeaa1079afc2d296dcd182df3b4fd">More...</a><br /></td></tr>
<tr class="separator:gacbdbeaa1079afc2d296dcd182df3b4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaa42910112a6f1d77f47082922a71a7"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gabaa42910112a6f1d77f47082922a71a7">DL_I2C_disableMultiControllerMode</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gabaa42910112a6f1d77f47082922a71a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable multicontroller mode.  <a href="#gabaa42910112a6f1d77f47082922a71a7">More...</a><br /></td></tr>
<tr class="separator:gabaa42910112a6f1d77f47082922a71a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf56279efb8dabe4aa7bc201485d8b75"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gacf56279efb8dabe4aa7bc201485d8b75">DL_I2C_isMultiControllerModeEnabled</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gacf56279efb8dabe4aa7bc201485d8b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if multicontroller mode is enabled.  <a href="#gacf56279efb8dabe4aa7bc201485d8b75">More...</a><br /></td></tr>
<tr class="separator:gacf56279efb8dabe4aa7bc201485d8b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga810d83f60b2fb4c199da9ae6d104fdfb"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga810d83f60b2fb4c199da9ae6d104fdfb">DL_I2C_enableMultiControllerMode</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga810d83f60b2fb4c199da9ae6d104fdfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable multicontroller mode.  <a href="#ga810d83f60b2fb4c199da9ae6d104fdfb">More...</a><br /></td></tr>
<tr class="separator:ga810d83f60b2fb4c199da9ae6d104fdfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20a60d19c852bd5211b1bb22159eddd3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga20a60d19c852bd5211b1bb22159eddd3">DL_I2C_disableController</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga20a60d19c852bd5211b1bb22159eddd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable controller.  <a href="#ga20a60d19c852bd5211b1bb22159eddd3">More...</a><br /></td></tr>
<tr class="separator:ga20a60d19c852bd5211b1bb22159eddd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a9c904bd34d9d9bd6988de91e50d3da"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga6a9c904bd34d9d9bd6988de91e50d3da">DL_I2C_isControllerEnabled</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga6a9c904bd34d9d9bd6988de91e50d3da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if controller is enabled.  <a href="#ga6a9c904bd34d9d9bd6988de91e50d3da">More...</a><br /></td></tr>
<tr class="separator:ga6a9c904bd34d9d9bd6988de91e50d3da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47ea567bcf579ddcd87135eb2c0d261a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga47ea567bcf579ddcd87135eb2c0d261a">DL_I2C_enableController</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga47ea567bcf579ddcd87135eb2c0d261a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable controller.  <a href="#ga47ea567bcf579ddcd87135eb2c0d261a">More...</a><br /></td></tr>
<tr class="separator:ga47ea567bcf579ddcd87135eb2c0d261a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c3b1d735442314ba89cff06125fcb55"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga0c3b1d735442314ba89cff06125fcb55">DL_I2C_disableControllerClockStretching</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga0c3b1d735442314ba89cff06125fcb55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable controller clock stretching.  <a href="#ga0c3b1d735442314ba89cff06125fcb55">More...</a><br /></td></tr>
<tr class="separator:ga0c3b1d735442314ba89cff06125fcb55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41da8d4578327ff630f61e1b3fa49f70"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga41da8d4578327ff630f61e1b3fa49f70">DL_I2C_isControllerClockStretchingEnabled</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga41da8d4578327ff630f61e1b3fa49f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if controller clock stretching is enabled.  <a href="#ga41da8d4578327ff630f61e1b3fa49f70">More...</a><br /></td></tr>
<tr class="separator:ga41da8d4578327ff630f61e1b3fa49f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefddc05c896cff0845b74c1be1bfd426"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaefddc05c896cff0845b74c1be1bfd426">DL_I2C_enableControllerClockStretching</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gaefddc05c896cff0845b74c1be1bfd426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable controller clock stretching.  <a href="#gaefddc05c896cff0845b74c1be1bfd426">More...</a><br /></td></tr>
<tr class="separator:gaefddc05c896cff0845b74c1be1bfd426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga340f870c1df3309fb534f2765de235d6"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___i2_c.html#gabc56f44666d64364128360ea3dfb4f8e">DL_I2C_CONTROLLER_SCL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga340f870c1df3309fb534f2765de235d6">DL_I2C_getSCLStatus</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga340f870c1df3309fb534f2765de235d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get SCL signal status.  <a href="#ga340f870c1df3309fb534f2765de235d6">More...</a><br /></td></tr>
<tr class="separator:ga340f870c1df3309fb534f2765de235d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7d231b1141931166c175bf5bd301922"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___i2_c.html#ga56a2070002c41b873cfddfa37f776caa">DL_I2C_CONTROLLER_SDA</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaf7d231b1141931166c175bf5bd301922">DL_I2C_getSDAStatus</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gaf7d231b1141931166c175bf5bd301922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get SDA signal status.  <a href="#gaf7d231b1141931166c175bf5bd301922">More...</a><br /></td></tr>
<tr class="separator:gaf7d231b1141931166c175bf5bd301922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0c5a8a6852f06ff4ab8eeff1a0c4572"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___i2_c.html#ga5f984a9185dfb1fde64fd3d8a9b3786c">DL_I2C_TX_FIFO_LEVEL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaf0c5a8a6852f06ff4ab8eeff1a0c4572">DL_I2C_getControllerTXFIFOThreshold</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gaf0c5a8a6852f06ff4ab8eeff1a0c4572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get controller TX FIFO threshold level.  <a href="#gaf0c5a8a6852f06ff4ab8eeff1a0c4572">More...</a><br /></td></tr>
<tr class="separator:gaf0c5a8a6852f06ff4ab8eeff1a0c4572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f8493a8ea64bba62e283f8ff762d989"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga4f8493a8ea64bba62e283f8ff762d989">DL_I2C_setControllerTXFIFOThreshold</a> (I2C_Regs *i2c, <a class="el" href="group___i2_c.html#ga5f984a9185dfb1fde64fd3d8a9b3786c">DL_I2C_TX_FIFO_LEVEL</a> level)</td></tr>
<tr class="memdesc:ga4f8493a8ea64bba62e283f8ff762d989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set controller TX FIFO threshold level.  <a href="#ga4f8493a8ea64bba62e283f8ff762d989">More...</a><br /></td></tr>
<tr class="separator:ga4f8493a8ea64bba62e283f8ff762d989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c4828889d17785e7017ca0016a36967"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga9c4828889d17785e7017ca0016a36967">DL_I2C_stopFlushControllerTXFIFO</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga9c4828889d17785e7017ca0016a36967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop controller TX FIFO flush.  <a href="#ga9c4828889d17785e7017ca0016a36967">More...</a><br /></td></tr>
<tr class="separator:ga9c4828889d17785e7017ca0016a36967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4da2889dc3dc98a1601edaa1aff03883"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga4da2889dc3dc98a1601edaa1aff03883">DL_I2C_startFlushControllerTXFIFO</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga4da2889dc3dc98a1601edaa1aff03883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start controller TX FIFO flush.  <a href="#ga4da2889dc3dc98a1601edaa1aff03883">More...</a><br /></td></tr>
<tr class="separator:ga4da2889dc3dc98a1601edaa1aff03883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8083141c4dc74605fdef38f266b13f3d"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___i2_c.html#ga57b2e0df2ed811c2f561b1d6157eded3">DL_I2C_RX_FIFO_LEVEL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga8083141c4dc74605fdef38f266b13f3d">DL_I2C_getControllerRXFIFOThreshold</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga8083141c4dc74605fdef38f266b13f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get controller RX FIFO threshold level.  <a href="#ga8083141c4dc74605fdef38f266b13f3d">More...</a><br /></td></tr>
<tr class="separator:ga8083141c4dc74605fdef38f266b13f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f648e01dcb0cecb1dc2e519c11425a7"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga9f648e01dcb0cecb1dc2e519c11425a7">DL_I2C_setControllerRXFIFOThreshold</a> (I2C_Regs *i2c, <a class="el" href="group___i2_c.html#ga57b2e0df2ed811c2f561b1d6157eded3">DL_I2C_RX_FIFO_LEVEL</a> level)</td></tr>
<tr class="memdesc:ga9f648e01dcb0cecb1dc2e519c11425a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set controller RX FIFO threshold level.  <a href="#ga9f648e01dcb0cecb1dc2e519c11425a7">More...</a><br /></td></tr>
<tr class="separator:ga9f648e01dcb0cecb1dc2e519c11425a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9185adab1f6baf35ea61595bdab36e4e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga9185adab1f6baf35ea61595bdab36e4e">DL_I2C_stopFlushControllerRXFIFO</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga9185adab1f6baf35ea61595bdab36e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop controller RX FIFO flush.  <a href="#ga9185adab1f6baf35ea61595bdab36e4e">More...</a><br /></td></tr>
<tr class="separator:ga9185adab1f6baf35ea61595bdab36e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf11c7abee8feb29f73c700fcd5b83ea3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaf11c7abee8feb29f73c700fcd5b83ea3">DL_I2C_startFlushControllerRXFIFO</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gaf11c7abee8feb29f73c700fcd5b83ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start controller RX FIFO flush.  <a href="#gaf11c7abee8feb29f73c700fcd5b83ea3">More...</a><br /></td></tr>
<tr class="separator:gaf11c7abee8feb29f73c700fcd5b83ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39d4762ca2ba7adc0865096c067e3832"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga39d4762ca2ba7adc0865096c067e3832">DL_I2C_getControllerRXFIFOCounter</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga39d4762ca2ba7adc0865096c067e3832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of bytes which can be read from RX FIFO.  <a href="#ga39d4762ca2ba7adc0865096c067e3832">More...</a><br /></td></tr>
<tr class="separator:ga39d4762ca2ba7adc0865096c067e3832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga194bf2a8c2569b8905570f901a650df8"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga194bf2a8c2569b8905570f901a650df8">DL_I2C_getControllerTXFIFOCounter</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga194bf2a8c2569b8905570f901a650df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of bytes which can be put into TX FIFO.  <a href="#ga194bf2a8c2569b8905570f901a650df8">More...</a><br /></td></tr>
<tr class="separator:ga194bf2a8c2569b8905570f901a650df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37ae65970559e9f0032d42253ea753d4"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga37ae65970559e9f0032d42253ea753d4">DL_I2C_isControllerRXFIFOFlushActive</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga37ae65970559e9f0032d42253ea753d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if controller RX FIFO flush is active.  <a href="#ga37ae65970559e9f0032d42253ea753d4">More...</a><br /></td></tr>
<tr class="separator:ga37ae65970559e9f0032d42253ea753d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3c6c7fcfc90bf1b43dc2e1104354e28"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaa3c6c7fcfc90bf1b43dc2e1104354e28">DL_I2C_isControllerTXFIFOFlushActive</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gaa3c6c7fcfc90bf1b43dc2e1104354e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if controller TX FIFO flush is active.  <a href="#gaa3c6c7fcfc90bf1b43dc2e1104354e28">More...</a><br /></td></tr>
<tr class="separator:gaa3c6c7fcfc90bf1b43dc2e1104354e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba4b63c11c2b74a92ab1d03943a507b7"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaba4b63c11c2b74a92ab1d03943a507b7">DL_I2C_setTargetOwnAddress</a> (I2C_Regs *i2c, uint32_t addr)</td></tr>
<tr class="memdesc:gaba4b63c11c2b74a92ab1d03943a507b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set target own address.  <a href="#gaba4b63c11c2b74a92ab1d03943a507b7">More...</a><br /></td></tr>
<tr class="separator:gaba4b63c11c2b74a92ab1d03943a507b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77f7fb234cc0cb1df01102ee4eb5f884"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga77f7fb234cc0cb1df01102ee4eb5f884">DL_I2C_getTargetOwnAddress</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga77f7fb234cc0cb1df01102ee4eb5f884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get target own address.  <a href="#ga77f7fb234cc0cb1df01102ee4eb5f884">More...</a><br /></td></tr>
<tr class="separator:ga77f7fb234cc0cb1df01102ee4eb5f884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77e39f9e0f854324e7676440bd33becf"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga77e39f9e0f854324e7676440bd33becf">DL_I2C_enableTargetOwnAddress</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga77e39f9e0f854324e7676440bd33becf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable target own address.  <a href="#ga77e39f9e0f854324e7676440bd33becf">More...</a><br /></td></tr>
<tr class="separator:ga77e39f9e0f854324e7676440bd33becf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ca9e51a1dff1d7b5ed77f4becf88852"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga8ca9e51a1dff1d7b5ed77f4becf88852">DL_I2C_disableTargetOwnAddress</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga8ca9e51a1dff1d7b5ed77f4becf88852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable target own address.  <a href="#ga8ca9e51a1dff1d7b5ed77f4becf88852">More...</a><br /></td></tr>
<tr class="separator:ga8ca9e51a1dff1d7b5ed77f4becf88852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd31710d395b17a034a36315d22d2c16"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gafd31710d395b17a034a36315d22d2c16">DL_I2C_isTargetOwnAddressEnabled</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gafd31710d395b17a034a36315d22d2c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if target own address is enabled.  <a href="#gafd31710d395b17a034a36315d22d2c16">More...</a><br /></td></tr>
<tr class="separator:gafd31710d395b17a034a36315d22d2c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4c20c5eac3bcbf9b8afda69c5fae504"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gac4c20c5eac3bcbf9b8afda69c5fae504">DL_I2C_setTargetAddressingMode</a> (I2C_Regs *i2c, <a class="el" href="group___i2_c.html#ga2ad6170a9004cf1b5296bde4da948661">DL_I2C_TARGET_ADDRESSING_MODE</a> mode)</td></tr>
<tr class="memdesc:gac4c20c5eac3bcbf9b8afda69c5fae504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set target addressing mode.  <a href="#gac4c20c5eac3bcbf9b8afda69c5fae504">More...</a><br /></td></tr>
<tr class="separator:gac4c20c5eac3bcbf9b8afda69c5fae504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1933bcabc755e7698dbd0308961e672a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___i2_c.html#ga2ad6170a9004cf1b5296bde4da948661">DL_I2C_TARGET_ADDRESSING_MODE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga1933bcabc755e7698dbd0308961e672a">DL_I2C_getTargetAddressingMode</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga1933bcabc755e7698dbd0308961e672a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get target addressing mode.  <a href="#ga1933bcabc755e7698dbd0308961e672a">More...</a><br /></td></tr>
<tr class="separator:ga1933bcabc755e7698dbd0308961e672a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fac7bd0083eeb7755cc839b6c990906"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga3fac7bd0083eeb7755cc839b6c990906">I2C_getTargetOwnAddressAlternate</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga3fac7bd0083eeb7755cc839b6c990906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get target own address alternate.  <a href="#ga3fac7bd0083eeb7755cc839b6c990906">More...</a><br /></td></tr>
<tr class="separator:ga3fac7bd0083eeb7755cc839b6c990906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab17d64b92d6cf53e00b7ddfb5350d5b0"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gab17d64b92d6cf53e00b7ddfb5350d5b0">DL_I2C_setTargetOwnAddressAlternate</a> (I2C_Regs *i2c, uint32_t addr)</td></tr>
<tr class="memdesc:gab17d64b92d6cf53e00b7ddfb5350d5b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set target own address alternate.  <a href="#gab17d64b92d6cf53e00b7ddfb5350d5b0">More...</a><br /></td></tr>
<tr class="separator:gab17d64b92d6cf53e00b7ddfb5350d5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad709a97f5cf0aa4aaba50405a980041"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaad709a97f5cf0aa4aaba50405a980041">I2C_getTargetOwnAddressAlternateMask</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gaad709a97f5cf0aa4aaba50405a980041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get target own address alternate mask.  <a href="#gaad709a97f5cf0aa4aaba50405a980041">More...</a><br /></td></tr>
<tr class="separator:gaad709a97f5cf0aa4aaba50405a980041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga419cd19263a8e6a9fd5f198cde723a2e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga419cd19263a8e6a9fd5f198cde723a2e">DL_I2C_setTargetOwnAddressAlternateMask</a> (I2C_Regs *i2c, uint32_t addressMask)</td></tr>
<tr class="memdesc:ga419cd19263a8e6a9fd5f198cde723a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set target own address alternate mask.  <a href="#ga419cd19263a8e6a9fd5f198cde723a2e">More...</a><br /></td></tr>
<tr class="separator:ga419cd19263a8e6a9fd5f198cde723a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19850d8f84ed95205e9fe17af7f1d422"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga19850d8f84ed95205e9fe17af7f1d422">DL_I2C_disableTargetOwnAddressAlternate</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga19850d8f84ed95205e9fe17af7f1d422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable usage of target own address alternate.  <a href="#ga19850d8f84ed95205e9fe17af7f1d422">More...</a><br /></td></tr>
<tr class="separator:ga19850d8f84ed95205e9fe17af7f1d422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fec3b4324a1169bc0300ef2275f0b23"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga6fec3b4324a1169bc0300ef2275f0b23">DL_I2C_isTargetOwnAddressAlternateEnabled</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga6fec3b4324a1169bc0300ef2275f0b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if target own address alternate is enabled.  <a href="#ga6fec3b4324a1169bc0300ef2275f0b23">More...</a><br /></td></tr>
<tr class="separator:ga6fec3b4324a1169bc0300ef2275f0b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5b3a4731490aa4368cc12f404a349b8"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gac5b3a4731490aa4368cc12f404a349b8">DL_I2C_enableTargetOwnAddressAlternate</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gac5b3a4731490aa4368cc12f404a349b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable usage of target own address alternate.  <a href="#gac5b3a4731490aa4368cc12f404a349b8">More...</a><br /></td></tr>
<tr class="separator:gac5b3a4731490aa4368cc12f404a349b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05afe3c7e59041073548de7b284bff15"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga05afe3c7e59041073548de7b284bff15">DL_I2C_getTargetAddressMatch</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga05afe3c7e59041073548de7b284bff15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the address for which address match happened.  <a href="#ga05afe3c7e59041073548de7b284bff15">More...</a><br /></td></tr>
<tr class="separator:ga05afe3c7e59041073548de7b284bff15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14f08672e11132685f0fe2ea6683e9c2"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga14f08672e11132685f0fe2ea6683e9c2">DL_I2C_disableTargetClockStretching</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga14f08672e11132685f0fe2ea6683e9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable target clock stretching.  <a href="#ga14f08672e11132685f0fe2ea6683e9c2">More...</a><br /></td></tr>
<tr class="separator:ga14f08672e11132685f0fe2ea6683e9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8af37270a44e4697064788dc872c91de"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga8af37270a44e4697064788dc872c91de">DL_I2C_isTargetClockStretchingEnabled</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga8af37270a44e4697064788dc872c91de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if target clock stretching is enabled.  <a href="#ga8af37270a44e4697064788dc872c91de">More...</a><br /></td></tr>
<tr class="separator:ga8af37270a44e4697064788dc872c91de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8abfdc0b52260539fe16106b43e75fa"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gad8abfdc0b52260539fe16106b43e75fa">DL_I2C_enableTargetClockStretching</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gad8abfdc0b52260539fe16106b43e75fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable target clock stretching.  <a href="#gad8abfdc0b52260539fe16106b43e75fa">More...</a><br /></td></tr>
<tr class="separator:gad8abfdc0b52260539fe16106b43e75fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadc76833e995d0a29ee6f10e151e6bdd"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaadc76833e995d0a29ee6f10e151e6bdd">DL_I2C_disableTargetTXEmptyOnTXRequest</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gaadc76833e995d0a29ee6f10e151e6bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable target TX empty interrupt on transmit request.  <a href="#gaadc76833e995d0a29ee6f10e151e6bdd">More...</a><br /></td></tr>
<tr class="separator:gaadc76833e995d0a29ee6f10e151e6bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ea6eee5ba77faaf1fbf75199a71eae0"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga6ea6eee5ba77faaf1fbf75199a71eae0">DL_I2C_isTargetTXEmptyOnTXRequestEnabled</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga6ea6eee5ba77faaf1fbf75199a71eae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if target TX empty interrupt on transmit request is enabled.  <a href="#ga6ea6eee5ba77faaf1fbf75199a71eae0">More...</a><br /></td></tr>
<tr class="separator:ga6ea6eee5ba77faaf1fbf75199a71eae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0068d7cbde72e566a25ccc06eda17e8c"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga0068d7cbde72e566a25ccc06eda17e8c">DL_I2C_enableTargetTXEmptyOnTXRequest</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga0068d7cbde72e566a25ccc06eda17e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable target TX empty interrupt on transmit request.  <a href="#ga0068d7cbde72e566a25ccc06eda17e8c">More...</a><br /></td></tr>
<tr class="separator:ga0068d7cbde72e566a25ccc06eda17e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0b8295bdf7924fc64bf2ce4a4d8f601"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaf0b8295bdf7924fc64bf2ce4a4d8f601">DL_I2C_disableTargetTXTriggerInTXMode</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gaf0b8295bdf7924fc64bf2ce4a4d8f601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable target TX trigger in TX mode.  <a href="#gaf0b8295bdf7924fc64bf2ce4a4d8f601">More...</a><br /></td></tr>
<tr class="separator:gaf0b8295bdf7924fc64bf2ce4a4d8f601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga253e4998853775fc0c65cafb06ad656e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga253e4998853775fc0c65cafb06ad656e">DL_I2C_isTargetTXTriggerInTXModeEnabled</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga253e4998853775fc0c65cafb06ad656e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if target TX trigger in TX mode is enabled.  <a href="#ga253e4998853775fc0c65cafb06ad656e">More...</a><br /></td></tr>
<tr class="separator:ga253e4998853775fc0c65cafb06ad656e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24b5b0c253dd6e48b5f5d22b79bd9347"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga24b5b0c253dd6e48b5f5d22b79bd9347">DL_I2C_enableTargetTXTriggerInTXMode</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga24b5b0c253dd6e48b5f5d22b79bd9347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable TX trigger when target is in TX mode.  <a href="#ga24b5b0c253dd6e48b5f5d22b79bd9347">More...</a><br /></td></tr>
<tr class="separator:ga24b5b0c253dd6e48b5f5d22b79bd9347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8ae7b1eba6cbe55e93ae22da245747f"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaf8ae7b1eba6cbe55e93ae22da245747f">DL_I2C_disableTargetTXWaitWhenTXFIFOStale</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gaf8ae7b1eba6cbe55e93ae22da245747f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable target TX transfer waits when stale data in TX FIFO.  <a href="#gaf8ae7b1eba6cbe55e93ae22da245747f">More...</a><br /></td></tr>
<tr class="separator:gaf8ae7b1eba6cbe55e93ae22da245747f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ae55bea8dd37ed7cafd220a8c1ce2c3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga3ae55bea8dd37ed7cafd220a8c1ce2c3">DL_I2C_isTargetTXWaitWhenTXFIFOStaleEnabled</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga3ae55bea8dd37ed7cafd220a8c1ce2c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if target TX transfer waits when stale data in TX FIFO is enabled.  <a href="#ga3ae55bea8dd37ed7cafd220a8c1ce2c3">More...</a><br /></td></tr>
<tr class="separator:ga3ae55bea8dd37ed7cafd220a8c1ce2c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2258097aeb3b94ebfb7f53ecacc461e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gac2258097aeb3b94ebfb7f53ecacc461e">DL_I2C_enableTargetTXWaitWhenTXFIFOStale</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gac2258097aeb3b94ebfb7f53ecacc461e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable target TX transfer waits when stale data in TX FIFO.  <a href="#gac2258097aeb3b94ebfb7f53ecacc461e">More...</a><br /></td></tr>
<tr class="separator:gac2258097aeb3b94ebfb7f53ecacc461e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3efd7f9ce45675162427d9460a7265c7"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga3efd7f9ce45675162427d9460a7265c7">DL_I2C_disableTargetRXFullOnRXRequest</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga3efd7f9ce45675162427d9460a7265c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable target RX full interrupt on receive request.  <a href="#ga3efd7f9ce45675162427d9460a7265c7">More...</a><br /></td></tr>
<tr class="separator:ga3efd7f9ce45675162427d9460a7265c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga814815a0b6d0f65acf4956f5d2206750"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga814815a0b6d0f65acf4956f5d2206750">DL_I2C_isTargetRXFullOnRXRequestEnabled</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga814815a0b6d0f65acf4956f5d2206750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if target RX full interrupt on receive request is enabled.  <a href="#ga814815a0b6d0f65acf4956f5d2206750">More...</a><br /></td></tr>
<tr class="separator:ga814815a0b6d0f65acf4956f5d2206750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga879f5c901f7baf53c2087200a89faa98"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga879f5c901f7baf53c2087200a89faa98">DL_I2C_enableTargetRXFullOnRXRequest</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga879f5c901f7baf53c2087200a89faa98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable target RX full interrupt on receive request.  <a href="#ga879f5c901f7baf53c2087200a89faa98">More...</a><br /></td></tr>
<tr class="separator:ga879f5c901f7baf53c2087200a89faa98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad67853056997b2155460255d059c1a82"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gad67853056997b2155460255d059c1a82">DL_I2C_disableDefaultHostAddress</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gad67853056997b2155460255d059c1a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable SMBus/PMBus default host address of 000 1000b.  <a href="#gad67853056997b2155460255d059c1a82">More...</a><br /></td></tr>
<tr class="separator:gad67853056997b2155460255d059c1a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d7f7d30627300da71312b55011b4b17"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga9d7f7d30627300da71312b55011b4b17">DL_I2C_isDefaultHostAddressEnabled</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga9d7f7d30627300da71312b55011b4b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if SMBus/PMBus default host address of 000 1000b is enabled.  <a href="#ga9d7f7d30627300da71312b55011b4b17">More...</a><br /></td></tr>
<tr class="separator:ga9d7f7d30627300da71312b55011b4b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9bc4dc06816be69896fa9662154d5b1"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gad9bc4dc06816be69896fa9662154d5b1">DL_I2C_enableDefaultHostAddress</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gad9bc4dc06816be69896fa9662154d5b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable SMBus/PMBus default host address of 000 1000b.  <a href="#gad9bc4dc06816be69896fa9662154d5b1">More...</a><br /></td></tr>
<tr class="separator:gad9bc4dc06816be69896fa9662154d5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39d10c8cf071438877967bfcbe52a476"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga39d10c8cf071438877967bfcbe52a476">DL_I2C_disableAlertResponseAddress</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga39d10c8cf071438877967bfcbe52a476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable SMBus/PMBus Alert response address (ARA) of 000 1100b.  <a href="#ga39d10c8cf071438877967bfcbe52a476">More...</a><br /></td></tr>
<tr class="separator:ga39d10c8cf071438877967bfcbe52a476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd9da3e2a55f105e34d5fe44577b26a3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gafd9da3e2a55f105e34d5fe44577b26a3">DL_I2C_isAlertResponseAddressEnabled</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gafd9da3e2a55f105e34d5fe44577b26a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if SMBus/PMBus Alert response address (ARA) of 000 1100b is enabled.  <a href="#gafd9da3e2a55f105e34d5fe44577b26a3">More...</a><br /></td></tr>
<tr class="separator:gafd9da3e2a55f105e34d5fe44577b26a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6212009690b9d8743c5cf7f69d6d700f"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga6212009690b9d8743c5cf7f69d6d700f">DL_I2C_enableAlertResponseAddress</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga6212009690b9d8743c5cf7f69d6d700f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable SMBus/PMBus Alert response address (ARA) of 000 1100b.  <a href="#ga6212009690b9d8743c5cf7f69d6d700f">More...</a><br /></td></tr>
<tr class="separator:ga6212009690b9d8743c5cf7f69d6d700f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44fedb11f59c29ab93da611950cba19e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga44fedb11f59c29ab93da611950cba19e">DL_I2C_disableDefaultDeviceAddress</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga44fedb11f59c29ab93da611950cba19e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable SMBus/PMBus default device address of 110 0001b.  <a href="#ga44fedb11f59c29ab93da611950cba19e">More...</a><br /></td></tr>
<tr class="separator:ga44fedb11f59c29ab93da611950cba19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedf788264841b8764abfb8a221227060"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaedf788264841b8764abfb8a221227060">DL_I2C_isDefaultDeviceAddressEnabled</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gaedf788264841b8764abfb8a221227060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks SMBus/PMBus default device address of 110 0001b is enabled.  <a href="#gaedf788264841b8764abfb8a221227060">More...</a><br /></td></tr>
<tr class="separator:gaedf788264841b8764abfb8a221227060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1facd6cb7a25e8f382bb56371dc22055"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga1facd6cb7a25e8f382bb56371dc22055">DL_I2C_enableDefaultDeviceAddress</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga1facd6cb7a25e8f382bb56371dc22055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable SMBus/PMBus default device address of 110 0001b.  <a href="#ga1facd6cb7a25e8f382bb56371dc22055">More...</a><br /></td></tr>
<tr class="separator:ga1facd6cb7a25e8f382bb56371dc22055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbd08609ef6043dec36f3a525247c292"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gacbd08609ef6043dec36f3a525247c292">DL_I2C_disableTargetWakeup</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gacbd08609ef6043dec36f3a525247c292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable target wakeup.  <a href="#gacbd08609ef6043dec36f3a525247c292">More...</a><br /></td></tr>
<tr class="separator:gacbd08609ef6043dec36f3a525247c292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a52d6450a42879b41e6c6bbc04c7446"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga1a52d6450a42879b41e6c6bbc04c7446">DL_I2C_isTargetWakeupEnabled</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga1a52d6450a42879b41e6c6bbc04c7446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if target wakeup is enabled.  <a href="#ga1a52d6450a42879b41e6c6bbc04c7446">More...</a><br /></td></tr>
<tr class="separator:ga1a52d6450a42879b41e6c6bbc04c7446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ccc7e3abb0c66d964e89dfa350ee433"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga7ccc7e3abb0c66d964e89dfa350ee433">DL_I2C_enableTargetWakeup</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga7ccc7e3abb0c66d964e89dfa350ee433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable target wakeup.  <a href="#ga7ccc7e3abb0c66d964e89dfa350ee433">More...</a><br /></td></tr>
<tr class="separator:ga7ccc7e3abb0c66d964e89dfa350ee433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga608d56e932f29e8dd5b3dec537213faa"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga608d56e932f29e8dd5b3dec537213faa">DL_I2C_disableTarget</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga608d56e932f29e8dd5b3dec537213faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable target functionality.  <a href="#ga608d56e932f29e8dd5b3dec537213faa">More...</a><br /></td></tr>
<tr class="separator:ga608d56e932f29e8dd5b3dec537213faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88fb29a1e63adda45e424835248eb74c"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga88fb29a1e63adda45e424835248eb74c">DL_I2C_isTargetEnabled</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga88fb29a1e63adda45e424835248eb74c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if target functionality is enabled.  <a href="#ga88fb29a1e63adda45e424835248eb74c">More...</a><br /></td></tr>
<tr class="separator:ga88fb29a1e63adda45e424835248eb74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7169da8c74ecf0b3c12b90d7bde2442"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gae7169da8c74ecf0b3c12b90d7bde2442">DL_I2C_enableTarget</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gae7169da8c74ecf0b3c12b90d7bde2442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable usage of target functionality.  <a href="#gae7169da8c74ecf0b3c12b90d7bde2442">More...</a><br /></td></tr>
<tr class="separator:gae7169da8c74ecf0b3c12b90d7bde2442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0712ceea9a8e6e88387f22131e1a56b"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gad0712ceea9a8e6e88387f22131e1a56b">DL_I2C_disableGeneralCall</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gad0712ceea9a8e6e88387f22131e1a56b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable general call address of 000 0000b.  <a href="#gad0712ceea9a8e6e88387f22131e1a56b">More...</a><br /></td></tr>
<tr class="separator:gad0712ceea9a8e6e88387f22131e1a56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b24e00ea8c6c1907de2bff1634d0957"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga8b24e00ea8c6c1907de2bff1634d0957">DL_I2C_isGeneralCallEnabled</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga8b24e00ea8c6c1907de2bff1634d0957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if general call address of 000 0000b is enabled.  <a href="#ga8b24e00ea8c6c1907de2bff1634d0957">More...</a><br /></td></tr>
<tr class="separator:ga8b24e00ea8c6c1907de2bff1634d0957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae498e2c7e285730b1f7b64b940913256"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gae498e2c7e285730b1f7b64b940913256">DL_I2C_enableGeneralCall</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gae498e2c7e285730b1f7b64b940913256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable usage of general call address of 000 0000b.  <a href="#gae498e2c7e285730b1f7b64b940913256">More...</a><br /></td></tr>
<tr class="separator:gae498e2c7e285730b1f7b64b940913256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga180a1855c14f4b6fbcfe6c6ce20a3508"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga180a1855c14f4b6fbcfe6c6ce20a3508">DL_I2C_getTargetStatus</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga180a1855c14f4b6fbcfe6c6ce20a3508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get status of I2C bus controller for target.  <a href="#ga180a1855c14f4b6fbcfe6c6ce20a3508">More...</a><br /></td></tr>
<tr class="separator:ga180a1855c14f4b6fbcfe6c6ce20a3508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeff02beed19580007ebea00afc537582"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaeff02beed19580007ebea00afc537582">DL_I2C_receiveTargetData</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gaeff02beed19580007ebea00afc537582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get byte of data from I2C target.  <a href="#gaeff02beed19580007ebea00afc537582">More...</a><br /></td></tr>
<tr class="separator:gaeff02beed19580007ebea00afc537582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga728a32502314c00aea65405242768b72"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga728a32502314c00aea65405242768b72">DL_I2C_transmitTargetData</a> (I2C_Regs *i2c, uint8_t data)</td></tr>
<tr class="memdesc:ga728a32502314c00aea65405242768b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set next byte to be transferred during the next transaction.  <a href="#ga728a32502314c00aea65405242768b72">More...</a><br /></td></tr>
<tr class="separator:ga728a32502314c00aea65405242768b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60fedbcf080709cbc9397f4c0acbf9a5"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga60fedbcf080709cbc9397f4c0acbf9a5">DL_I2C_disableTargetACKOverride</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga60fedbcf080709cbc9397f4c0acbf9a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable target ACK override.  <a href="#ga60fedbcf080709cbc9397f4c0acbf9a5">More...</a><br /></td></tr>
<tr class="separator:ga60fedbcf080709cbc9397f4c0acbf9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga374c432adec549d0b933488e72386d40"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga374c432adec549d0b933488e72386d40">DL_I2C_isTargetACKOverrideEnabled</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga374c432adec549d0b933488e72386d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if target ACK override is enabled.  <a href="#ga374c432adec549d0b933488e72386d40">More...</a><br /></td></tr>
<tr class="separator:ga374c432adec549d0b933488e72386d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5de9af9e0aabca3407b1d09e629bf4d"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaf5de9af9e0aabca3407b1d09e629bf4d">DL_I2C_enableTargetACKOverride</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gaf5de9af9e0aabca3407b1d09e629bf4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable target ACK override.  <a href="#gaf5de9af9e0aabca3407b1d09e629bf4d">More...</a><br /></td></tr>
<tr class="separator:gaf5de9af9e0aabca3407b1d09e629bf4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a7074fa0ca84709b7e83998db121469"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___i2_c.html#ga3585e512aa5c37880960b13fe6cc212e">DL_I2C_TARGET_RESPONSE_OVERRIDE_VALUE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga0a7074fa0ca84709b7e83998db121469">DL_I2C_getTargetACKOverrideValue</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga0a7074fa0ca84709b7e83998db121469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get target acknowledge override value.  <a href="#ga0a7074fa0ca84709b7e83998db121469">More...</a><br /></td></tr>
<tr class="separator:ga0a7074fa0ca84709b7e83998db121469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18a52fd6ef504bb29a284e2400adc6d3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga18a52fd6ef504bb29a284e2400adc6d3">DL_I2C_setTargetACKOverrideValue</a> (I2C_Regs *i2c, <a class="el" href="group___i2_c.html#ga3585e512aa5c37880960b13fe6cc212e">DL_I2C_TARGET_RESPONSE_OVERRIDE_VALUE</a> value)</td></tr>
<tr class="memdesc:ga18a52fd6ef504bb29a284e2400adc6d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set target acknowledge override value.  <a href="#ga18a52fd6ef504bb29a284e2400adc6d3">More...</a><br /></td></tr>
<tr class="separator:ga18a52fd6ef504bb29a284e2400adc6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga460e5de0dbc69c6d77d2733c22a6eccc"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga460e5de0dbc69c6d77d2733c22a6eccc">DL_I2C_disableACKOverrideOnStart</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga460e5de0dbc69c6d77d2733c22a6eccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable target ACK override on Start Condition.  <a href="#ga460e5de0dbc69c6d77d2733c22a6eccc">More...</a><br /></td></tr>
<tr class="separator:ga460e5de0dbc69c6d77d2733c22a6eccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad91bdc379a977295260379b721c8ba30"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gad91bdc379a977295260379b721c8ba30">DL_I2C_isACKOverrideOnStartEnabled</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gad91bdc379a977295260379b721c8ba30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if target ACK override on Start condition is enabled.  <a href="#gad91bdc379a977295260379b721c8ba30">More...</a><br /></td></tr>
<tr class="separator:gad91bdc379a977295260379b721c8ba30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga478898c30a01d0bfa871849edce8fafa"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga478898c30a01d0bfa871849edce8fafa">DL_I2C_enableACKOverrideOnStart</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga478898c30a01d0bfa871849edce8fafa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable target ACK override on Start condition.  <a href="#ga478898c30a01d0bfa871849edce8fafa">More...</a><br /></td></tr>
<tr class="separator:ga478898c30a01d0bfa871849edce8fafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga455a753967c8ac89b5b6a4ea8e29e05a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga455a753967c8ac89b5b6a4ea8e29e05a">DL_I2C_disableACKOverrideOnPECNext</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga455a753967c8ac89b5b6a4ea8e29e05a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable target ACK override when SMBus/PMBus PEC is next byte.  <a href="#ga455a753967c8ac89b5b6a4ea8e29e05a">More...</a><br /></td></tr>
<tr class="separator:ga455a753967c8ac89b5b6a4ea8e29e05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac38423aef2f1d75aac815587414b7aed"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gac38423aef2f1d75aac815587414b7aed">DL_I2C_isACKOverrideOnPECNextEnabled</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gac38423aef2f1d75aac815587414b7aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if target ACK override when SMBus/PMBus PEC is next byte is enabled.  <a href="#gac38423aef2f1d75aac815587414b7aed">More...</a><br /></td></tr>
<tr class="separator:gac38423aef2f1d75aac815587414b7aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga079b44eaa37b822c6686817cf0ed0659"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga079b44eaa37b822c6686817cf0ed0659">DL_I2C_enableACKOverrideOnPECNext</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga079b44eaa37b822c6686817cf0ed0659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable target ACK override when SMBus/PMBus PEC is next byte.  <a href="#ga079b44eaa37b822c6686817cf0ed0659">More...</a><br /></td></tr>
<tr class="separator:ga079b44eaa37b822c6686817cf0ed0659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23b56f7972f717d513f1052f94e77588"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga23b56f7972f717d513f1052f94e77588">DL_I2C_disableACKOverrideOnPECDone</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga23b56f7972f717d513f1052f94e77588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable target ACK override when SMBus/PMBus PEC is next byte.  <a href="#ga23b56f7972f717d513f1052f94e77588">More...</a><br /></td></tr>
<tr class="separator:ga23b56f7972f717d513f1052f94e77588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf46ef6bf50ec1af4e8e92df5f6864bb9"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaf46ef6bf50ec1af4e8e92df5f6864bb9">DL_I2C_isACKOverrideOnPECDoneEnabled</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gaf46ef6bf50ec1af4e8e92df5f6864bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if target ACK override when SMBus/PMBus PEC is next byte is enabled.  <a href="#gaf46ef6bf50ec1af4e8e92df5f6864bb9">More...</a><br /></td></tr>
<tr class="separator:gaf46ef6bf50ec1af4e8e92df5f6864bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa176c415a602e25c2522af69834fb22e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaa176c415a602e25c2522af69834fb22e">DL_I2C_enableACKOverrideOnPECDone</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gaa176c415a602e25c2522af69834fb22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable target ACK override when SMBus/PMBus PEC is done.  <a href="#gaa176c415a602e25c2522af69834fb22e">More...</a><br /></td></tr>
<tr class="separator:gaa176c415a602e25c2522af69834fb22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92d7de45cbd9952e88b4a501d3f32060"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga92d7de45cbd9952e88b4a501d3f32060">DL_I2C_getTargetPECCountValue</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga92d7de45cbd9952e88b4a501d3f32060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the target SMBus/PMBus Packet Error Checking (PEC) count value.  <a href="#ga92d7de45cbd9952e88b4a501d3f32060">More...</a><br /></td></tr>
<tr class="separator:ga92d7de45cbd9952e88b4a501d3f32060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf819b5cf2cb96615245fd6afc45c7fc8"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaf819b5cf2cb96615245fd6afc45c7fc8">DL_I2C_setTargetPECCountValue</a> (I2C_Regs *i2c, uint32_t count)</td></tr>
<tr class="memdesc:gaf819b5cf2cb96615245fd6afc45c7fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the target SMBus/PMBus Packet Error Checking (PEC) count value.  <a href="#gaf819b5cf2cb96615245fd6afc45c7fc8">More...</a><br /></td></tr>
<tr class="separator:gaf819b5cf2cb96615245fd6afc45c7fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68022524b977b63a17465eb61af41e8c"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga68022524b977b63a17465eb61af41e8c">DL_I2C_disableTargetPEC</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga68022524b977b63a17465eb61af41e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable target SMBus/PMBus Packet Error Checking (PEC)  <a href="#ga68022524b977b63a17465eb61af41e8c">More...</a><br /></td></tr>
<tr class="separator:ga68022524b977b63a17465eb61af41e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c12139825d0d12931fdd1587bac33a8"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga8c12139825d0d12931fdd1587bac33a8">DL_I2C_isTargetPECEnabled</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga8c12139825d0d12931fdd1587bac33a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if target SMBus/PMBus Packet Error Checking (PEC) is enabled.  <a href="#ga8c12139825d0d12931fdd1587bac33a8">More...</a><br /></td></tr>
<tr class="separator:ga8c12139825d0d12931fdd1587bac33a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4315266fccc9844113c697f27ec97e8e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga4315266fccc9844113c697f27ec97e8e">DL_I2C_enableTargetPEC</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga4315266fccc9844113c697f27ec97e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable target SMBus/PMBus Packet Error Checking (PEC)  <a href="#ga4315266fccc9844113c697f27ec97e8e">More...</a><br /></td></tr>
<tr class="separator:ga4315266fccc9844113c697f27ec97e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86d927b9e402e4eb3a7d2baca68eed68"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga86d927b9e402e4eb3a7d2baca68eed68">DL_I2C_getTargetCurrentPECCount</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga86d927b9e402e4eb3a7d2baca68eed68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current SMBus/PMBus PEC byte count of the Target state machine.  <a href="#ga86d927b9e402e4eb3a7d2baca68eed68">More...</a><br /></td></tr>
<tr class="separator:ga86d927b9e402e4eb3a7d2baca68eed68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c363ffd7432837e627eff1ce2dddb22"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___i2_c.html#gafb5095cf27ba13dbca5226da84dbbf18">DL_I2C_TARGET_PEC_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga5c363ffd7432837e627eff1ce2dddb22">DL_I2C_getTargetPECCheckedStatus</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga5c363ffd7432837e627eff1ce2dddb22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get status if SMBus/PMBus target PEC was checked in last transaction.  <a href="#ga5c363ffd7432837e627eff1ce2dddb22">More...</a><br /></td></tr>
<tr class="separator:ga5c363ffd7432837e627eff1ce2dddb22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4bd5e409f70b3580c98ded22075d28b"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___i2_c.html#ga96c525c4ee883f347cf21e8676d7c32e">DL_I2C_TARGET_PEC_CHECK_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gad4bd5e409f70b3580c98ded22075d28b">DL_I2C_getTargetPECCheckError</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gad4bd5e409f70b3580c98ded22075d28b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get status if SMBus/PMBus target PEC had an error.  <a href="#gad4bd5e409f70b3580c98ded22075d28b">More...</a><br /></td></tr>
<tr class="separator:gad4bd5e409f70b3580c98ded22075d28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada7f75d8e5d94055d89d7de1194ef420"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___i2_c.html#ga5f984a9185dfb1fde64fd3d8a9b3786c">DL_I2C_TX_FIFO_LEVEL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gada7f75d8e5d94055d89d7de1194ef420">DL_I2C_getTargetTXFIFOThreshold</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gada7f75d8e5d94055d89d7de1194ef420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get target TX FIFO threshold level.  <a href="#gada7f75d8e5d94055d89d7de1194ef420">More...</a><br /></td></tr>
<tr class="separator:gada7f75d8e5d94055d89d7de1194ef420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf24be7bed7d0f0b9a23de1da777bdec"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaaf24be7bed7d0f0b9a23de1da777bdec">DL_I2C_setTargetTXFIFOThreshold</a> (I2C_Regs *i2c, <a class="el" href="group___i2_c.html#ga5f984a9185dfb1fde64fd3d8a9b3786c">DL_I2C_TX_FIFO_LEVEL</a> level)</td></tr>
<tr class="memdesc:gaaf24be7bed7d0f0b9a23de1da777bdec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set target TX FIFO threshold level.  <a href="#gaaf24be7bed7d0f0b9a23de1da777bdec">More...</a><br /></td></tr>
<tr class="separator:gaaf24be7bed7d0f0b9a23de1da777bdec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae11c2c0e16d80798b2038cef33d75ca7"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gae11c2c0e16d80798b2038cef33d75ca7">DL_I2C_stopFlushTargetTXFIFO</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gae11c2c0e16d80798b2038cef33d75ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop target TX FIFO flush.  <a href="#gae11c2c0e16d80798b2038cef33d75ca7">More...</a><br /></td></tr>
<tr class="separator:gae11c2c0e16d80798b2038cef33d75ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60819784021a8fa3aad6b90195f18aea"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga60819784021a8fa3aad6b90195f18aea">DL_I2C_startFlushTargetTXFIFO</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga60819784021a8fa3aad6b90195f18aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start target TX FIFO flush.  <a href="#ga60819784021a8fa3aad6b90195f18aea">More...</a><br /></td></tr>
<tr class="separator:ga60819784021a8fa3aad6b90195f18aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga117c9355118f61af0ed348d559b2bd04"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga117c9355118f61af0ed348d559b2bd04">DL_I2C_stopFlushTargetRXFIFO</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga117c9355118f61af0ed348d559b2bd04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop target RX FIFO flush.  <a href="#ga117c9355118f61af0ed348d559b2bd04">More...</a><br /></td></tr>
<tr class="separator:ga117c9355118f61af0ed348d559b2bd04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga303bb2ac9c7ddb984e9ecf8b065adff7"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga303bb2ac9c7ddb984e9ecf8b065adff7">DL_I2C_startFlushTargetRXFIFO</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga303bb2ac9c7ddb984e9ecf8b065adff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start target RX FIFO flush.  <a href="#ga303bb2ac9c7ddb984e9ecf8b065adff7">More...</a><br /></td></tr>
<tr class="separator:ga303bb2ac9c7ddb984e9ecf8b065adff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga150e0338c2e79c4d42cb3829c732e369"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___i2_c.html#ga57b2e0df2ed811c2f561b1d6157eded3">DL_I2C_RX_FIFO_LEVEL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga150e0338c2e79c4d42cb3829c732e369">DL_I2C_getTargetRXFIFOThreshold</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga150e0338c2e79c4d42cb3829c732e369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get target RX FIFO threshold level.  <a href="#ga150e0338c2e79c4d42cb3829c732e369">More...</a><br /></td></tr>
<tr class="separator:ga150e0338c2e79c4d42cb3829c732e369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0b07311584a20629ed7659a48e9c398"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gae0b07311584a20629ed7659a48e9c398">DL_I2C_setTargetRXFIFOThreshold</a> (I2C_Regs *i2c, <a class="el" href="group___i2_c.html#ga57b2e0df2ed811c2f561b1d6157eded3">DL_I2C_RX_FIFO_LEVEL</a> level)</td></tr>
<tr class="memdesc:gae0b07311584a20629ed7659a48e9c398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set target RX FIFO threshold level.  <a href="#gae0b07311584a20629ed7659a48e9c398">More...</a><br /></td></tr>
<tr class="separator:gae0b07311584a20629ed7659a48e9c398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9469148d774eff8154ccd6b6b425cefd"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga9469148d774eff8154ccd6b6b425cefd">DL_I2C_getTargetRXFIFOCounter</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga9469148d774eff8154ccd6b6b425cefd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of bytes which can be read from RX FIFO.  <a href="#ga9469148d774eff8154ccd6b6b425cefd">More...</a><br /></td></tr>
<tr class="separator:ga9469148d774eff8154ccd6b6b425cefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2586b9de92b58128befa744ea4e34e0"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gac2586b9de92b58128befa744ea4e34e0">DL_I2C_getTargetTXFIFOCounter</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gac2586b9de92b58128befa744ea4e34e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of bytes which can be put into TX FIFO.  <a href="#gac2586b9de92b58128befa744ea4e34e0">More...</a><br /></td></tr>
<tr class="separator:gac2586b9de92b58128befa744ea4e34e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27edb7f9f5b76a0bbbea7265fbeb52b0"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga27edb7f9f5b76a0bbbea7265fbeb52b0">DL_I2C_isTargetRXFIFOFlushActive</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga27edb7f9f5b76a0bbbea7265fbeb52b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if target RX FIFO flush is active.  <a href="#ga27edb7f9f5b76a0bbbea7265fbeb52b0">More...</a><br /></td></tr>
<tr class="separator:ga27edb7f9f5b76a0bbbea7265fbeb52b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc94c89964d04121578b77feae799a28"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gadc94c89964d04121578b77feae799a28">DL_I2C_isTargetTXFIFOFlushActive</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gadc94c89964d04121578b77feae799a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if target TX FIFO flush is active.  <a href="#gadc94c89964d04121578b77feae799a28">More...</a><br /></td></tr>
<tr class="separator:gadc94c89964d04121578b77feae799a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf840137a80d61bcb583b8cd702207af4"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaf840137a80d61bcb583b8cd702207af4">DL_I2C_enableInterrupt</a> (I2C_Regs *i2c, uint32_t interruptMask)</td></tr>
<tr class="memdesc:gaf840137a80d61bcb583b8cd702207af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable I2C interrupts.  <a href="#gaf840137a80d61bcb583b8cd702207af4">More...</a><br /></td></tr>
<tr class="separator:gaf840137a80d61bcb583b8cd702207af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e5c0bb9422da32efc733282061ad2b2"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga1e5c0bb9422da32efc733282061ad2b2">DL_I2C_disableInterrupt</a> (I2C_Regs *i2c, uint32_t interruptMask)</td></tr>
<tr class="memdesc:ga1e5c0bb9422da32efc733282061ad2b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable I2C interrupts.  <a href="#ga1e5c0bb9422da32efc733282061ad2b2">More...</a><br /></td></tr>
<tr class="separator:ga1e5c0bb9422da32efc733282061ad2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e5530b9fc68545bebd0a5718ec916ca"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga5e5530b9fc68545bebd0a5718ec916ca">DL_I2C_getEnabledInterrupts</a> (const I2C_Regs *i2c, uint32_t interruptMask)</td></tr>
<tr class="memdesc:ga5e5530b9fc68545bebd0a5718ec916ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check which I2C interrupts are enabled.  <a href="#ga5e5530b9fc68545bebd0a5718ec916ca">More...</a><br /></td></tr>
<tr class="separator:ga5e5530b9fc68545bebd0a5718ec916ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93698aae874d9520a3f051e080a78021"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga93698aae874d9520a3f051e080a78021">DL_I2C_getEnabledInterruptStatus</a> (const I2C_Regs *i2c, uint32_t interruptMask)</td></tr>
<tr class="memdesc:ga93698aae874d9520a3f051e080a78021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check interrupt flag of enabled I2C interrupts.  <a href="#ga93698aae874d9520a3f051e080a78021">More...</a><br /></td></tr>
<tr class="separator:ga93698aae874d9520a3f051e080a78021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0221bb94f08a499b8e184162c65290fb"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga0221bb94f08a499b8e184162c65290fb">DL_I2C_getRawInterruptStatus</a> (const I2C_Regs *i2c, uint32_t interruptMask)</td></tr>
<tr class="memdesc:ga0221bb94f08a499b8e184162c65290fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check interrupt flag of any I2C interrupt.  <a href="#ga0221bb94f08a499b8e184162c65290fb">More...</a><br /></td></tr>
<tr class="separator:ga0221bb94f08a499b8e184162c65290fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5db07afae50024c8e5abd69d3b7d1d20"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___i2_c.html#ga2aee910b31c80683b76ded8e3c15776a">DL_I2C_IIDX</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga5db07afae50024c8e5abd69d3b7d1d20">DL_I2C_getPendingInterrupt</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga5db07afae50024c8e5abd69d3b7d1d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get highest priority pending I2C interrupt.  <a href="#ga5db07afae50024c8e5abd69d3b7d1d20">More...</a><br /></td></tr>
<tr class="separator:ga5db07afae50024c8e5abd69d3b7d1d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1a0b850948a25fc7dce6dbb31b60a6c"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gad1a0b850948a25fc7dce6dbb31b60a6c">DL_I2C_clearInterruptStatus</a> (I2C_Regs *i2c, uint32_t interruptMask)</td></tr>
<tr class="memdesc:gad1a0b850948a25fc7dce6dbb31b60a6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear pending I2C interrupts.  <a href="#gad1a0b850948a25fc7dce6dbb31b60a6c">More...</a><br /></td></tr>
<tr class="separator:gad1a0b850948a25fc7dce6dbb31b60a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad066af4645cd9da4d7a1188af1c13a2d"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gad066af4645cd9da4d7a1188af1c13a2d">DL_I2C_enableDMAEvent</a> (I2C_Regs *i2c, <a class="el" href="group___i2_c.html#ga5d85e40e4e1b371a6958921cb4d2369f">DL_I2C_EVENT_ROUTE</a> index, uint32_t interrupt)</td></tr>
<tr class="memdesc:gad066af4645cd9da4d7a1188af1c13a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables I2C interrupt for triggering DMA events.  <a href="#gad066af4645cd9da4d7a1188af1c13a2d">More...</a><br /></td></tr>
<tr class="separator:gad066af4645cd9da4d7a1188af1c13a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabccb980ab71fa7c9020485e561307f83"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gabccb980ab71fa7c9020485e561307f83">DL_I2C_disableDMAEvent</a> (I2C_Regs *i2c, <a class="el" href="group___i2_c.html#ga5d85e40e4e1b371a6958921cb4d2369f">DL_I2C_EVENT_ROUTE</a> index, uint32_t interrupt)</td></tr>
<tr class="memdesc:gabccb980ab71fa7c9020485e561307f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables I2C interrupt from triggering DMA events.  <a href="#gabccb980ab71fa7c9020485e561307f83">More...</a><br /></td></tr>
<tr class="separator:gabccb980ab71fa7c9020485e561307f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41b2ea39e0e5d3e47bd4e9a19a6b3741"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga41b2ea39e0e5d3e47bd4e9a19a6b3741">DL_I2C_getEnabledDMAEvents</a> (I2C_Regs *i2c, <a class="el" href="group___i2_c.html#ga5d85e40e4e1b371a6958921cb4d2369f">DL_I2C_EVENT_ROUTE</a> index, uint32_t interruptMask)</td></tr>
<tr class="memdesc:ga41b2ea39e0e5d3e47bd4e9a19a6b3741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check which I2C interrupt for DMA receive events is enabled.  <a href="#ga41b2ea39e0e5d3e47bd4e9a19a6b3741">More...</a><br /></td></tr>
<tr class="separator:ga41b2ea39e0e5d3e47bd4e9a19a6b3741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d53a14e6aca31dc4ff06be1a048df87"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga9d53a14e6aca31dc4ff06be1a048df87">DL_I2C_getEnabledDMAEventStatus</a> (const I2C_Regs *i2c, <a class="el" href="group___i2_c.html#ga5d85e40e4e1b371a6958921cb4d2369f">DL_I2C_EVENT_ROUTE</a> index, uint32_t interruptMask)</td></tr>
<tr class="memdesc:ga9d53a14e6aca31dc4ff06be1a048df87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check interrupt flag of enabled I2C interrupt for DMA event.  <a href="#ga9d53a14e6aca31dc4ff06be1a048df87">More...</a><br /></td></tr>
<tr class="separator:ga9d53a14e6aca31dc4ff06be1a048df87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bbd769481b83644b92c94fe7907f46f"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga4bbd769481b83644b92c94fe7907f46f">DL_I2C_getRawDMAEventStatus</a> (const I2C_Regs *i2c, <a class="el" href="group___i2_c.html#ga5d85e40e4e1b371a6958921cb4d2369f">DL_I2C_EVENT_ROUTE</a> index, uint32_t interruptMask)</td></tr>
<tr class="memdesc:ga4bbd769481b83644b92c94fe7907f46f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check interrupt flag of any I2C interrupt for DMA event.  <a href="#ga4bbd769481b83644b92c94fe7907f46f">More...</a><br /></td></tr>
<tr class="separator:ga4bbd769481b83644b92c94fe7907f46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa045fdc0b265088f55098cd6bac045ee"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___i2_c.html#gaed43e22303286e1d4d9490c2b6ddf9bd">DL_I2C_DMA_IIDX</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaa045fdc0b265088f55098cd6bac045ee">DL_I2C_getPendingDMAEvent</a> (const I2C_Regs *i2c, <a class="el" href="group___i2_c.html#ga5d85e40e4e1b371a6958921cb4d2369f">DL_I2C_EVENT_ROUTE</a> index)</td></tr>
<tr class="memdesc:gaa045fdc0b265088f55098cd6bac045ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get highest priority pending I2C interrupt for DMA event.  <a href="#gaa045fdc0b265088f55098cd6bac045ee">More...</a><br /></td></tr>
<tr class="separator:gaa045fdc0b265088f55098cd6bac045ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefed7d1c29cd85d5b14a307214dfd29e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaefed7d1c29cd85d5b14a307214dfd29e">DL_I2C_clearDMAEvent</a> (I2C_Regs *i2c, <a class="el" href="group___i2_c.html#ga5d85e40e4e1b371a6958921cb4d2369f">DL_I2C_EVENT_ROUTE</a> index, uint32_t interrupt)</td></tr>
<tr class="memdesc:gaefed7d1c29cd85d5b14a307214dfd29e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear pending SPI interrupts for DMA events.  <a href="#gaefed7d1c29cd85d5b14a307214dfd29e">More...</a><br /></td></tr>
<tr class="separator:gaefed7d1c29cd85d5b14a307214dfd29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga590305a92aef5550d6888806524ff21f"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga590305a92aef5550d6888806524ff21f">DL_I2C_disableGlitchFilterChaining</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga590305a92aef5550d6888806524ff21f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable analog and digital glitch filter chaining.  <a href="#ga590305a92aef5550d6888806524ff21f">More...</a><br /></td></tr>
<tr class="separator:ga590305a92aef5550d6888806524ff21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cb2fa42e4d52ac0b5510bdeac1fbc50"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga5cb2fa42e4d52ac0b5510bdeac1fbc50">DL_I2C_isGlitchFilterChainingEnabled</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga5cb2fa42e4d52ac0b5510bdeac1fbc50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if analog and digital glitch filter chaining is enabled.  <a href="#ga5cb2fa42e4d52ac0b5510bdeac1fbc50">More...</a><br /></td></tr>
<tr class="separator:ga5cb2fa42e4d52ac0b5510bdeac1fbc50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4368b5e37313864f4aac0649ad6c27aa"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga4368b5e37313864f4aac0649ad6c27aa">DL_I2C_enableGlitchFilterChaining</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga4368b5e37313864f4aac0649ad6c27aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable analog and digitial glitch filter chaining.  <a href="#ga4368b5e37313864f4aac0649ad6c27aa">More...</a><br /></td></tr>
<tr class="separator:ga4368b5e37313864f4aac0649ad6c27aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga130d812bf54576203bd73a6e2ea4c994"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga130d812bf54576203bd73a6e2ea4c994">DL_I2C_getTimeoutACount</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga130d812bf54576203bd73a6e2ea4c994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Timeout Counter A value.  <a href="#ga130d812bf54576203bd73a6e2ea4c994">More...</a><br /></td></tr>
<tr class="separator:ga130d812bf54576203bd73a6e2ea4c994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab933bbcbe7466b33a194d239068ce2a6"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gab933bbcbe7466b33a194d239068ce2a6">DL_I2C_setTimeoutACount</a> (I2C_Regs *i2c, uint32_t count)</td></tr>
<tr class="memdesc:gab933bbcbe7466b33a194d239068ce2a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Timeout Counter A value.  <a href="#gab933bbcbe7466b33a194d239068ce2a6">More...</a><br /></td></tr>
<tr class="separator:gab933bbcbe7466b33a194d239068ce2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d1ab6b0cfc24086c8eb3d0e6d63b93c"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga5d1ab6b0cfc24086c8eb3d0e6d63b93c">DL_I2C_disableTimeoutA</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga5d1ab6b0cfc24086c8eb3d0e6d63b93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable Timeout Counter A.  <a href="#ga5d1ab6b0cfc24086c8eb3d0e6d63b93c">More...</a><br /></td></tr>
<tr class="separator:ga5d1ab6b0cfc24086c8eb3d0e6d63b93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04fb9d2a7ff06a3783e784088b2a85f3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga04fb9d2a7ff06a3783e784088b2a85f3">DL_I2C_isTimeoutAEnabled</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga04fb9d2a7ff06a3783e784088b2a85f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if Timeout Counter A is enabled.  <a href="#ga04fb9d2a7ff06a3783e784088b2a85f3">More...</a><br /></td></tr>
<tr class="separator:ga04fb9d2a7ff06a3783e784088b2a85f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8a0c4ba2d330856108bb8e49cd3398a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gae8a0c4ba2d330856108bb8e49cd3398a">DL_I2C_enableTimeoutA</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:gae8a0c4ba2d330856108bb8e49cd3398a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable Timeout Counter A.  <a href="#gae8a0c4ba2d330856108bb8e49cd3398a">More...</a><br /></td></tr>
<tr class="separator:gae8a0c4ba2d330856108bb8e49cd3398a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b0d8a559a6dbf2d13c16eefd88bf2e8"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga3b0d8a559a6dbf2d13c16eefd88bf2e8">DL_I2C_getCurrentTimeoutACounter</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga3b0d8a559a6dbf2d13c16eefd88bf2e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current Timer Counter A value.  <a href="#ga3b0d8a559a6dbf2d13c16eefd88bf2e8">More...</a><br /></td></tr>
<tr class="separator:ga3b0d8a559a6dbf2d13c16eefd88bf2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65bee72f5f6ded73bea7a7dd3b279281"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga65bee72f5f6ded73bea7a7dd3b279281">DL_I2C_getTimeoutBCount</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga65bee72f5f6ded73bea7a7dd3b279281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Timeout Counter B value.  <a href="#ga65bee72f5f6ded73bea7a7dd3b279281">More...</a><br /></td></tr>
<tr class="separator:ga65bee72f5f6ded73bea7a7dd3b279281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11b21acce041e3f67cde3e6350a5beb7"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga11b21acce041e3f67cde3e6350a5beb7">DL_I2C_setTimeoutBCount</a> (I2C_Regs *i2c, uint32_t count)</td></tr>
<tr class="memdesc:ga11b21acce041e3f67cde3e6350a5beb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Timeout Counter B value.  <a href="#ga11b21acce041e3f67cde3e6350a5beb7">More...</a><br /></td></tr>
<tr class="separator:ga11b21acce041e3f67cde3e6350a5beb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bf4e8e54f57892ff43afab634c4c302"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga1bf4e8e54f57892ff43afab634c4c302">DL_I2C_disableTimeoutB</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga1bf4e8e54f57892ff43afab634c4c302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable Timeout Counter B.  <a href="#ga1bf4e8e54f57892ff43afab634c4c302">More...</a><br /></td></tr>
<tr class="separator:ga1bf4e8e54f57892ff43afab634c4c302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0651282f1aaa9514b9faa0f4ff0c8ced"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga0651282f1aaa9514b9faa0f4ff0c8ced">DL_I2C_isTimeoutBEnabled</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga0651282f1aaa9514b9faa0f4ff0c8ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if Timeout Counter B is enabled.  <a href="#ga0651282f1aaa9514b9faa0f4ff0c8ced">More...</a><br /></td></tr>
<tr class="separator:ga0651282f1aaa9514b9faa0f4ff0c8ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53dba946d2a45ecee74b2a440fc7f087"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga53dba946d2a45ecee74b2a440fc7f087">DL_I2C_enableTimeoutB</a> (I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga53dba946d2a45ecee74b2a440fc7f087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable Timeout Counter B.  <a href="#ga53dba946d2a45ecee74b2a440fc7f087">More...</a><br /></td></tr>
<tr class="separator:ga53dba946d2a45ecee74b2a440fc7f087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fffbc0549c789af9f3c6c19ec1de436"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga9fffbc0549c789af9f3c6c19ec1de436">DL_I2C_getCurrentTimeoutBCounter</a> (const I2C_Regs *i2c)</td></tr>
<tr class="memdesc:ga9fffbc0549c789af9f3c6c19ec1de436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current Timer Counter B value.  <a href="#ga9fffbc0549c789af9f3c6c19ec1de436">More...</a><br /></td></tr>
<tr class="separator:ga9fffbc0549c789af9f3c6c19ec1de436"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><a class="anchor" id="ti_dl_dl_i2c_Overview"></a></p><h1>Overview</h1>
<p>The I2C Library allows full configuration of the MSPM0 I2C module. The I2C module provides a standardized serial interface to transfer data between MSP devices and other external I2C devices (such as a sensors, memory, or DACs).</p>
<hr/>
 <h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gadc068c6d6df6e875e4ea73d14b420e7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc068c6d6df6e875e4ea73d14b420e7e">&sect;&nbsp;</a></span>DL_I2C_TX_FIFO_COUNT_MAXIMUM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DL_I2C_TX_FIFO_COUNT_MAXIMUM&#160;&#160;&#160;((uint32_t)I2C_SYS_FENTRIES &lt;&lt; 8)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C number of bytes which could be put into the TX FIFO. </p>
<p>This variable is device specific and is calculated using the system parameter I2C_SYS_FENTRIES defined in each devices header file. </p>

<p>Referenced by <a class="el" href="group___i2_c.html#gaea6e1d20664eb58d38d090132ff759a7">DL_I2C_isControllerTXFIFOEmpty()</a>, and <a class="el" href="group___i2_c.html#ga9d724998617836aaf2aa74587ef6bee8">DL_I2C_isTargetTXFIFOEmpty()</a>.</p>

</div>
</div>
<a id="ga2031ae56b0ebaf369e94df7f98fb9222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2031ae56b0ebaf369e94df7f98fb9222">&sect;&nbsp;</a></span>DL_I2C_RX_FIFO_COUNT_MAXIMUM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DL_I2C_RX_FIFO_COUNT_MAXIMUM&#160;&#160;&#160;((uint32_t)I2C_SYS_FENTRIES)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C number of bytes which could be put into the RX FIFO. </p>
<p>This variable is device specific and is calculated using the system parameter I2C_SYS_FENTRIES defined in each devices header file. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaed43e22303286e1d4d9490c2b6ddf9bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed43e22303286e1d4d9490c2b6ddf9bd">&sect;&nbsp;</a></span>DL_I2C_DMA_IIDX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#gaed43e22303286e1d4d9490c2b6ddf9bd">DL_I2C_DMA_IIDX</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaed43e22303286e1d4d9490c2b6ddf9bda765e3a6413b62d19764dc17090371f4f"></a>DL_I2C_DMA_IIDX_TARGET_TXFIFO_TRIGGER&#160;</td><td class="fielddoc"><p>I2C interrupt index for enabling I2C Target Transmit FIFO Trigger as DMA trigger </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaed43e22303286e1d4d9490c2b6ddf9bda2fc3cd509080efe4196a8ac7c439b43a"></a>DL_I2C_DMA_IIDX_TARGET_RXFIFO_TRIGGER&#160;</td><td class="fielddoc"><p>I2C interrupt index for enabling I2C Target Receive FIFO Trigger as DMA trigger </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaed43e22303286e1d4d9490c2b6ddf9bdad0a20190e3e9f65b9e3957b7ad938611"></a>DL_I2C_DMA_IIDX_CONTROLLER_TXFIFO_TRIGGER&#160;</td><td class="fielddoc"><p>I2C interrupt index for enabling I2C Controller Transmit FIFO Trigger as DMA trigger </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaed43e22303286e1d4d9490c2b6ddf9bdac29ea194e952e5335386c496640b50d6"></a>DL_I2C_DMA_IIDX_CONTROLLER_RXFIFO_TRIGGER&#160;</td><td class="fielddoc"><p>I2C interrupt index for enabling I2C Controller Receive FIFO Trigger as DMA trigger </p>
</td></tr>
</table>

</div>
</div>
<a id="ga5d85e40e4e1b371a6958921cb4d2369f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d85e40e4e1b371a6958921cb4d2369f">&sect;&nbsp;</a></span>DL_I2C_EVENT_ROUTE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#ga5d85e40e4e1b371a6958921cb4d2369f">DL_I2C_EVENT_ROUTE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga5d85e40e4e1b371a6958921cb4d2369fa191a6c43cb5070513da653e40459a707"></a>DL_I2C_EVENT_ROUTE_1&#160;</td><td class="fielddoc"><p>I2C event route 1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5d85e40e4e1b371a6958921cb4d2369faa271de21d766a1ada248b4e85db9df80"></a>DL_I2C_EVENT_ROUTE_2&#160;</td><td class="fielddoc"><p>I2C event route 2 </p>
</td></tr>
</table>

</div>
</div>
<a id="gad912db0203e9bb0e55bb0ddbc0ddcfcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad912db0203e9bb0e55bb0ddbc0ddcfcc">&sect;&nbsp;</a></span>DL_I2C_CLOCK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#gad912db0203e9bb0e55bb0ddbc0ddcfcc">DL_I2C_CLOCK</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad912db0203e9bb0e55bb0ddbc0ddcfccad6d5055d0035f33da71821c1ff686452"></a>DL_I2C_CLOCK_BUSCLK&#160;</td><td class="fielddoc"><p>BUSCLK enabled as I2C clock source </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad912db0203e9bb0e55bb0ddbc0ddcfcca38fef132dae64de3e08b7d323d72d86e"></a>DL_I2C_CLOCK_MFCLK&#160;</td><td class="fielddoc"><p>MFCLK enabled as I2C clock source </p>
</td></tr>
</table>

</div>
</div>
<a id="ga03737f74607dfbe4048cff93862c9faa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03737f74607dfbe4048cff93862c9faa">&sect;&nbsp;</a></span>DL_I2C_CLOCK_DIVIDE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#ga03737f74607dfbe4048cff93862c9faa">DL_I2C_CLOCK_DIVIDE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga03737f74607dfbe4048cff93862c9faaa03cb2520917670ad5a8e72a9590e0d25"></a>DL_I2C_CLOCK_DIVIDE_1&#160;</td><td class="fielddoc"><p>I2C Clock Divided by 1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga03737f74607dfbe4048cff93862c9faaadc3b13b2c0059a4cf1f257603f6416bc"></a>DL_I2C_CLOCK_DIVIDE_2&#160;</td><td class="fielddoc"><p>I2C Clock Divided by 2 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga03737f74607dfbe4048cff93862c9faaae0d53a45d337662928344059f72b0aa9"></a>DL_I2C_CLOCK_DIVIDE_3&#160;</td><td class="fielddoc"><p>I2C Clock Divided by 3 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga03737f74607dfbe4048cff93862c9faaa4a12832b1d69e2c75bb71048f40fc843"></a>DL_I2C_CLOCK_DIVIDE_4&#160;</td><td class="fielddoc"><p>I2C Clock Divided by 4 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga03737f74607dfbe4048cff93862c9faaaed0431c060281cf244429f3941da24d4"></a>DL_I2C_CLOCK_DIVIDE_5&#160;</td><td class="fielddoc"><p>I2C Clock Divided by 5 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga03737f74607dfbe4048cff93862c9faaa9b8ae5d4144ff65d753c7dd232433f29"></a>DL_I2C_CLOCK_DIVIDE_6&#160;</td><td class="fielddoc"><p>I2C Clock Divided by 6 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga03737f74607dfbe4048cff93862c9faaae406db08b149041a41cfa76abdfcf5ad"></a>DL_I2C_CLOCK_DIVIDE_7&#160;</td><td class="fielddoc"><p>I2C Clock Divided by 7 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga03737f74607dfbe4048cff93862c9faaadb3c2e813fffaf2625eee4678191610f"></a>DL_I2C_CLOCK_DIVIDE_8&#160;</td><td class="fielddoc"><p>I2C Clock Divided by 8 </p>
</td></tr>
</table>

</div>
</div>
<a id="ga2ad6170a9004cf1b5296bde4da948661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ad6170a9004cf1b5296bde4da948661">&sect;&nbsp;</a></span>DL_I2C_TARGET_ADDRESSING_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#ga2ad6170a9004cf1b5296bde4da948661">DL_I2C_TARGET_ADDRESSING_MODE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga2ad6170a9004cf1b5296bde4da948661aa06eaaa6ab08211ba70e138991e76add"></a>DL_I2C_TARGET_ADDRESSING_MODE_7_BIT&#160;</td><td class="fielddoc"><p>Enable Target in 7-bit addressing mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2ad6170a9004cf1b5296bde4da948661ab3ea325a9f99efafd970924dcda8ef73"></a>DL_I2C_TARGET_ADDRESSING_MODE_10_BIT&#160;</td><td class="fielddoc"><p>Enable Target in 10-bit addressing mode </p>
</td></tr>
</table>

</div>
</div>
<a id="gafb5095cf27ba13dbca5226da84dbbf18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb5095cf27ba13dbca5226da84dbbf18">&sect;&nbsp;</a></span>DL_I2C_TARGET_PEC_STATUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#gafb5095cf27ba13dbca5226da84dbbf18">DL_I2C_TARGET_PEC_STATUS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggafb5095cf27ba13dbca5226da84dbbf18a621e97a1d5400f1fcb2f7b0a242a0dfe"></a>DL_I2C_TARGET_PEC_STATUS_CHECKED&#160;</td><td class="fielddoc"><p>I2C Target SMBus/PMBus PEC was checked in the transaction that occurred before the last Stop </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafb5095cf27ba13dbca5226da84dbbf18a6381d0639c0d81a547fe93f737324ea4"></a>DL_I2C_TARGET_PEC_STATUS_NOT_CHECKED&#160;</td><td class="fielddoc"><p>I2C Target SMBus/PMBus PEC was not checked in the transaction that occurred before the last Stop </p>
</td></tr>
</table>

</div>
</div>
<a id="ga96c525c4ee883f347cf21e8676d7c32e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96c525c4ee883f347cf21e8676d7c32e">&sect;&nbsp;</a></span>DL_I2C_TARGET_PEC_CHECK_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#ga96c525c4ee883f347cf21e8676d7c32e">DL_I2C_TARGET_PEC_CHECK_ERROR</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga96c525c4ee883f347cf21e8676d7c32ea72ff826ecd7fcdaac021b0f787356eae"></a>DL_I2C_TARGET_PEC_CHECK_ERROR_CLEARED&#160;</td><td class="fielddoc"><p>Indicates PEC check error did not occurr in the transaction that occurred before the last Stop </p>
</td></tr>
<tr><td class="fieldname"><a id="gga96c525c4ee883f347cf21e8676d7c32eaa6767e7f503cda619aa26c7210e75fac"></a>DL_I2C_TARGET_PEC_CHECK_ERROR_SET&#160;</td><td class="fielddoc"><p>Indicates PEC check error occurred in the transaction that occurred before the last Stop </p>
</td></tr>
</table>

</div>
</div>
<a id="ga031f0b093a1d7448b0ba89a6ecc0a32a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga031f0b093a1d7448b0ba89a6ecc0a32a">&sect;&nbsp;</a></span>DL_I2C_ANALOG_GLITCH_FILTER_WIDTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#ga031f0b093a1d7448b0ba89a6ecc0a32a">DL_I2C_ANALOG_GLITCH_FILTER_WIDTH</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga031f0b093a1d7448b0ba89a6ecc0a32aab775e2e3cf0f0c919a44a5e5f43f8b87"></a>DL_I2C_ANALOG_GLITCH_FILTER_WIDTH_5NS&#160;</td><td class="fielddoc"><p>Pulses shorter than 5ns in length are filtered. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga031f0b093a1d7448b0ba89a6ecc0a32aa459f9759f5f9dea0e111e09dc0cfd161"></a>DL_I2C_ANALOG_GLITCH_FILTER_WIDTH_10NS&#160;</td><td class="fielddoc"><p>Pulses shorter than 10ns in length are filtered. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga031f0b093a1d7448b0ba89a6ecc0a32aa884f120236ff2979011b8836e4d37da2"></a>DL_I2C_ANALOG_GLITCH_FILTER_WIDTH_25NS&#160;</td><td class="fielddoc"><p>Pulses shorter than 25ns in length are filtered. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga031f0b093a1d7448b0ba89a6ecc0a32aa2244c58b0085f4edcf75220f2f3db3b1"></a>DL_I2C_ANALOG_GLITCH_FILTER_WIDTH_50NS&#160;</td><td class="fielddoc"><p>Pulses shorter than 50ns in length are filtered. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga9f42d16d0c14219c0ce8e45016bed5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f42d16d0c14219c0ce8e45016bed5e4">&sect;&nbsp;</a></span>DL_I2C_DIGITAL_GLITCH_FILTER_WIDTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#ga9f42d16d0c14219c0ce8e45016bed5e4">DL_I2C_DIGITAL_GLITCH_FILTER_WIDTH</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9f42d16d0c14219c0ce8e45016bed5e4a7d88539b627ff2a6d5161217ba41e4e7"></a>DL_I2C_DIGITAL_GLITCH_FILTER_WIDTH_DISABLED&#160;</td><td class="fielddoc"><p>Pulses filtering disabled. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9f42d16d0c14219c0ce8e45016bed5e4a94b3c8ef94dc6e42f8de9ce54a0e9bd3"></a>DL_I2C_DIGITAL_GLITCH_FILTER_WIDTH_CLOCKS_1&#160;</td><td class="fielddoc"><p>Pulses shorter than 1 functional clock tick in length are filtered. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9f42d16d0c14219c0ce8e45016bed5e4a368f4bd84a917a0702a579baf40a5739"></a>DL_I2C_DIGITAL_GLITCH_FILTER_WIDTH_CLOCKS_2&#160;</td><td class="fielddoc"><p>Pulses shorter than 2 functional clock ticks in length are filtered. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9f42d16d0c14219c0ce8e45016bed5e4a1b15c0cf6eb6ea3361b0323cde7e465b"></a>DL_I2C_DIGITAL_GLITCH_FILTER_WIDTH_CLOCKS_3&#160;</td><td class="fielddoc"><p>Pulses shorter than 3 functional clock ticks in length are filtered. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9f42d16d0c14219c0ce8e45016bed5e4a2e59906228bf66af6733bf5aa5aff16e"></a>DL_I2C_DIGITAL_GLITCH_FILTER_WIDTH_CLOCKS_4&#160;</td><td class="fielddoc"><p>Pulses shorter than 4 functional clock ticks in length are filtered. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9f42d16d0c14219c0ce8e45016bed5e4af255619ace040812fb6203a3030c49e9"></a>DL_I2C_DIGITAL_GLITCH_FILTER_WIDTH_CLOCKS_8&#160;</td><td class="fielddoc"><p>Pulses shorter than 8 functional clock ticks in length are filtered. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9f42d16d0c14219c0ce8e45016bed5e4a45cd0f0f9b1464905d3e8ee41c19b476"></a>DL_I2C_DIGITAL_GLITCH_FILTER_WIDTH_CLOCKS_16&#160;</td><td class="fielddoc"><p>Pulses shorter than 16 functional clock ticks in length are filtered. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9f42d16d0c14219c0ce8e45016bed5e4ab540667df6dc47b8a8b3f8417982adcf"></a>DL_I2C_DIGITAL_GLITCH_FILTER_WIDTH_CLOCKS_31&#160;</td><td class="fielddoc"><p>Pulses shorter than 31 functional clock ticks in length are filtered. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga4e5bff33e69ea760e7f8364b2f1cf259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e5bff33e69ea760e7f8364b2f1cf259">&sect;&nbsp;</a></span>DL_I2C_CONTROLLER_DIRECTION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#ga4e5bff33e69ea760e7f8364b2f1cf259">DL_I2C_CONTROLLER_DIRECTION</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga4e5bff33e69ea760e7f8364b2f1cf259a79ef2507cfb08c2fde3acdba7b80b125"></a>DL_I2C_CONTROLLER_DIRECTION_TX&#160;</td><td class="fielddoc"><p>Set direction to controller transmitting to target </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4e5bff33e69ea760e7f8364b2f1cf259aa8f2ea2136ff8e671803b31399f41e3a"></a>DL_I2C_CONTROLLER_DIRECTION_RX&#160;</td><td class="fielddoc"><p>Set direction to controller receiving from target </p>
</td></tr>
</table>

</div>
</div>
<a id="ga286008e7442aee9279befbb3cace3d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga286008e7442aee9279befbb3cace3d47">&sect;&nbsp;</a></span>DL_I2C_CONTROLLER_ADDRESSING_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#ga286008e7442aee9279befbb3cace3d47">DL_I2C_CONTROLLER_ADDRESSING_MODE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga286008e7442aee9279befbb3cace3d47a61a007a02e62f515679d621ea2d8c925"></a>DL_I2C_CONTROLLER_ADDRESSING_MODE_7_BIT&#160;</td><td class="fielddoc"><p>Enable Controller in 7-bit addressing mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga286008e7442aee9279befbb3cace3d47a8e00692656fafe882df26f836df967bc"></a>DL_I2C_CONTROLLER_ADDRESSING_MODE_10_BIT&#160;</td><td class="fielddoc"><p>Enable Controller in 10-bit addressing mode </p>
</td></tr>
</table>

</div>
</div>
<a id="gae90754611bdbab4885bc634bcddadca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae90754611bdbab4885bc634bcddadca4">&sect;&nbsp;</a></span>DL_I2C_CONTROLLER_PEC_STATUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#gae90754611bdbab4885bc634bcddadca4">DL_I2C_CONTROLLER_PEC_STATUS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae90754611bdbab4885bc634bcddadca4a2d495a76cb3d80604560302009ef0b72"></a>DL_I2C_CONTROLLER_PEC_STATUS_CHECKED&#160;</td><td class="fielddoc"><p>I2C Controller SMBus/PMBus PEC was checked in the transaction that occurred before the last Stop </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae90754611bdbab4885bc634bcddadca4afe75d521f85cabbe99bf4468260459e4"></a>DL_I2C_CONTROLLER_PEC_STATUS_NOT_CHECKED&#160;</td><td class="fielddoc"><p>I2C Controller SMBus/PMBus PEC was not checked in the transaction that occurred the last Stop </p>
</td></tr>
</table>

</div>
</div>
<a id="ga560b453b65c64ad5bffb37ae05c88553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga560b453b65c64ad5bffb37ae05c88553">&sect;&nbsp;</a></span>DL_I2C_CONTROLLER_PEC_CHECK_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#ga560b453b65c64ad5bffb37ae05c88553">DL_I2C_CONTROLLER_PEC_CHECK_ERROR</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga560b453b65c64ad5bffb37ae05c88553a97981a23a99255f71228d844c8c568f4"></a>DL_I2C_CONTROLLER_PEC_CHECK_ERROR_SET&#160;</td><td class="fielddoc"><p>I2C Controller SMBus/PMBus PEC check error occurred in the transaction before the last stop </p>
</td></tr>
<tr><td class="fieldname"><a id="gga560b453b65c64ad5bffb37ae05c88553a5504faa3459c73d2ad7146e25ace0bc2"></a>DL_I2C_CONTROLLER_PEC_CHECK_ERROR_CLEARED&#160;</td><td class="fielddoc"><p>I2C Controller SMBus/PMBus PEC check error did not occur in the transaction before the last stop </p>
</td></tr>
</table>

</div>
</div>
<a id="gabc56f44666d64364128360ea3dfb4f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc56f44666d64364128360ea3dfb4f8e">&sect;&nbsp;</a></span>DL_I2C_CONTROLLER_SCL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#gabc56f44666d64364128360ea3dfb4f8e">DL_I2C_CONTROLLER_SCL</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggabc56f44666d64364128360ea3dfb4f8ea21c7f6c2b39849462ee3918bbbe9707a"></a>DL_I2C_CONTROLLER_SCL_HIGH&#160;</td><td class="fielddoc"><p>I2C SCL signal high </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabc56f44666d64364128360ea3dfb4f8ea732fdcfdcd867619bb301ec6059ce59b"></a>DL_I2C_CONTROLLER_SCL_LOW&#160;</td><td class="fielddoc"><p>I2C SCL signal low </p>
</td></tr>
</table>

</div>
</div>
<a id="ga56a2070002c41b873cfddfa37f776caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56a2070002c41b873cfddfa37f776caa">&sect;&nbsp;</a></span>DL_I2C_CONTROLLER_SDA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#ga56a2070002c41b873cfddfa37f776caa">DL_I2C_CONTROLLER_SDA</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga56a2070002c41b873cfddfa37f776caaa100b9d2e4e5dc9aec9d7be22c75afb2e"></a>DL_I2C_CONTROLLER_SDA_HIGH&#160;</td><td class="fielddoc"><p>I2C SDA signal high </p>
</td></tr>
<tr><td class="fieldname"><a id="gga56a2070002c41b873cfddfa37f776caaa4751ecc4f98be98d10ebb1ed40877b4e"></a>DL_I2C_CONTROLLER_SDA_LOW&#160;</td><td class="fielddoc"><p>I2C SDA signal low </p>
</td></tr>
</table>

</div>
</div>
<a id="ga5722df24b0d57c0b2bf18c1068a36ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5722df24b0d57c0b2bf18c1068a36ca1">&sect;&nbsp;</a></span>DL_I2C_CONTROLLER_START</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#ga5722df24b0d57c0b2bf18c1068a36ca1">DL_I2C_CONTROLLER_START</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga5722df24b0d57c0b2bf18c1068a36ca1a766659f96b6bbc497047ff2bed0b3db1"></a>DL_I2C_CONTROLLER_START_ENABLE&#160;</td><td class="fielddoc"><p>Controller generates START condition </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5722df24b0d57c0b2bf18c1068a36ca1a9095d4e5634ba52a1b5219737dfb7641"></a>DL_I2C_CONTROLLER_START_DISABLE&#160;</td><td class="fielddoc"><p>Controller doesn't generate START condition </p>
</td></tr>
</table>

</div>
</div>
<a id="ga8996cddfa139bd7118880aa51e32f0f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8996cddfa139bd7118880aa51e32f0f7">&sect;&nbsp;</a></span>DL_I2C_CONTROLLER_STOP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#ga8996cddfa139bd7118880aa51e32f0f7">DL_I2C_CONTROLLER_STOP</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga8996cddfa139bd7118880aa51e32f0f7a324783fff416f86fa19dc9fa6d3258a5"></a>DL_I2C_CONTROLLER_STOP_ENABLE&#160;</td><td class="fielddoc"><p>Controller generates STOP condition </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8996cddfa139bd7118880aa51e32f0f7a084bde99c4b726f824eff942b4f18546"></a>DL_I2C_CONTROLLER_STOP_DISABLE&#160;</td><td class="fielddoc"><p>Controller doesn't generate STOP condition </p>
</td></tr>
</table>

</div>
</div>
<a id="gaab55947b23ba571c233ab80d34bf7182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab55947b23ba571c233ab80d34bf7182">&sect;&nbsp;</a></span>DL_I2C_CONTROLLER_ACK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#gaab55947b23ba571c233ab80d34bf7182">DL_I2C_CONTROLLER_ACK</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaab55947b23ba571c233ab80d34bf7182a0c8efe9fc42d1630dd9ad4bd50019928"></a>DL_I2C_CONTROLLER_ACK_ENABLE&#160;</td><td class="fielddoc"><p>Last received data byte of a transaction is not ACKed automatically </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaab55947b23ba571c233ab80d34bf7182a8853d7564e6178fc719ac8276a4110f6"></a>DL_I2C_CONTROLLER_ACK_DISABLE&#160;</td><td class="fielddoc"><p>Last received data byte of a transaction is ACKed automatically </p>
</td></tr>
</table>

</div>
</div>
<a id="ga5f984a9185dfb1fde64fd3d8a9b3786c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f984a9185dfb1fde64fd3d8a9b3786c">&sect;&nbsp;</a></span>DL_I2C_TX_FIFO_LEVEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#ga5f984a9185dfb1fde64fd3d8a9b3786c">DL_I2C_TX_FIFO_LEVEL</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga5f984a9185dfb1fde64fd3d8a9b3786ca89c9092c250e869ae2377841682ae60e"></a>DL_I2C_TX_FIFO_LEVEL_EMPTY&#160;</td><td class="fielddoc"><p>Trigger when the TX FIFO is empty </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5f984a9185dfb1fde64fd3d8a9b3786ca86332753d599c5d77d5d9d3ee79b08c0"></a>DL_I2C_TX_FIFO_LEVEL_BYTES_1&#160;</td><td class="fielddoc"><p>Trigger when TX FIFO contains 1 byte </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5f984a9185dfb1fde64fd3d8a9b3786ca0692bc55e1aaa32deb5c3bf0c800d0c1"></a>DL_I2C_TX_FIFO_LEVEL_BYTES_2&#160;</td><td class="fielddoc"><p>Trigger when TX FIFO contains 2 bytes </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5f984a9185dfb1fde64fd3d8a9b3786cae1d705529bdc53209ce03dffd374da59"></a>DL_I2C_TX_FIFO_LEVEL_BYTES_3&#160;</td><td class="fielddoc"><p>Trigger when TX FIFO contains 3 bytes </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5f984a9185dfb1fde64fd3d8a9b3786ca791cff1548acfae5f8400b760f137976"></a>DL_I2C_TX_FIFO_LEVEL_BYTES_4&#160;</td><td class="fielddoc"><p>Trigger when TX FIFO contains 4 bytes </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5f984a9185dfb1fde64fd3d8a9b3786ca0cefb453ccff2083124f1a77a74d0cb2"></a>DL_I2C_TX_FIFO_LEVEL_BYTES_5&#160;</td><td class="fielddoc"><p>Trigger when TX FIFO contains 5 bytes </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5f984a9185dfb1fde64fd3d8a9b3786ca91fb0e513d65d89bbe26cb787e58de55"></a>DL_I2C_TX_FIFO_LEVEL_BYTES_6&#160;</td><td class="fielddoc"><p>Trigger when TX FIFO contains 6 bytes </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5f984a9185dfb1fde64fd3d8a9b3786cadb66b796a51a2c1be0f0ca44682df9c4"></a>DL_I2C_TX_FIFO_LEVEL_BYTES_7&#160;</td><td class="fielddoc"><p>Trigger when TX FIFO contains 7 bytes </p>
</td></tr>
</table>

</div>
</div>
<a id="ga57b2e0df2ed811c2f561b1d6157eded3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57b2e0df2ed811c2f561b1d6157eded3">&sect;&nbsp;</a></span>DL_I2C_RX_FIFO_LEVEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#ga57b2e0df2ed811c2f561b1d6157eded3">DL_I2C_RX_FIFO_LEVEL</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga57b2e0df2ed811c2f561b1d6157eded3ad39a247d5692a58771cff1fecc860162"></a>DL_I2C_RX_FIFO_LEVEL_BYTES_1&#160;</td><td class="fielddoc"><p>Trigger when RX FIFO contains at least 1 byte </p>
</td></tr>
<tr><td class="fieldname"><a id="gga57b2e0df2ed811c2f561b1d6157eded3ad5a31e8395385c4f72bd8d670dce3274"></a>DL_I2C_RX_FIFO_LEVEL_BYTES_2&#160;</td><td class="fielddoc"><p>Trigger when RX FIFO contains at least 2 bytes </p>
</td></tr>
<tr><td class="fieldname"><a id="gga57b2e0df2ed811c2f561b1d6157eded3a37436ed98e74e619ed332f9a3cbc27ab"></a>DL_I2C_RX_FIFO_LEVEL_BYTES_3&#160;</td><td class="fielddoc"><p>Trigger when RX FIFO contains at least 3 bytes </p>
</td></tr>
<tr><td class="fieldname"><a id="gga57b2e0df2ed811c2f561b1d6157eded3aba72e73e9fcb175a54536598df08f1b1"></a>DL_I2C_RX_FIFO_LEVEL_BYTES_4&#160;</td><td class="fielddoc"><p>Trigger when RX FIFO contains at least 4 bytes </p>
</td></tr>
<tr><td class="fieldname"><a id="gga57b2e0df2ed811c2f561b1d6157eded3a6f1adbb5dd8b773e548037b0be589bc4"></a>DL_I2C_RX_FIFO_LEVEL_BYTES_5&#160;</td><td class="fielddoc"><p>Trigger when RX FIFO contains at least 5 bytes </p>
</td></tr>
<tr><td class="fieldname"><a id="gga57b2e0df2ed811c2f561b1d6157eded3a1ec5c383ff0076b5b7f7dbcdff26761c"></a>DL_I2C_RX_FIFO_LEVEL_BYTES_6&#160;</td><td class="fielddoc"><p>Trigger when RX FIFO contains at least 6 bytes </p>
</td></tr>
<tr><td class="fieldname"><a id="gga57b2e0df2ed811c2f561b1d6157eded3a0c713c92ed3d196b86cb21aa211bf06b"></a>DL_I2C_RX_FIFO_LEVEL_BYTES_7&#160;</td><td class="fielddoc"><p>Trigger when RX FIFO contains at least 7 bytes </p>
</td></tr>
<tr><td class="fieldname"><a id="gga57b2e0df2ed811c2f561b1d6157eded3adff98ce928d23fdb8a50f1295bf05254"></a>DL_I2C_RX_FIFO_LEVEL_BYTES_8&#160;</td><td class="fielddoc"><p>Trigger when RX FIFO contains at least 8 bytes </p>
</td></tr>
</table>

</div>
</div>
<a id="ga3585e512aa5c37880960b13fe6cc212e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3585e512aa5c37880960b13fe6cc212e">&sect;&nbsp;</a></span>DL_I2C_TARGET_RESPONSE_OVERRIDE_VALUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#ga3585e512aa5c37880960b13fe6cc212e">DL_I2C_TARGET_RESPONSE_OVERRIDE_VALUE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga3585e512aa5c37880960b13fe6cc212ea0d4745e13efb92a569742097f8b85302"></a>DL_I2C_TARGET_RESPONSE_OVERRIDE_VALUE_ACK&#160;</td><td class="fielddoc"><p>Target manual ACK for valid data or command. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3585e512aa5c37880960b13fe6cc212eabd4a970773bb4720ff2f44c1e213a36a"></a>DL_I2C_TARGET_RESPONSE_OVERRIDE_VALUE_NACK&#160;</td><td class="fielddoc"><p>Target manual NACK for invalid data or command. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga2aee910b31c80683b76ded8e3c15776a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2aee910b31c80683b76ded8e3c15776a">&sect;&nbsp;</a></span>DL_I2C_IIDX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#ga2aee910b31c80683b76ded8e3c15776a">DL_I2C_IIDX</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga2aee910b31c80683b76ded8e3c15776aabaac69c1dbcfed9ae03236dfd69b64bf"></a>DL_I2C_IIDX_NO_INT&#160;</td><td class="fielddoc"><p>Interrupt index for I2C if no interrupt is pending </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2aee910b31c80683b76ded8e3c15776aa53a79e9b4f24f759bdbd461c06456626"></a>DL_I2C_IIDX_CONTROLLER_RX_DONE&#160;</td><td class="fielddoc"><p>Interrupt index for I2C Controller Receive Transaction completed </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2aee910b31c80683b76ded8e3c15776aaa97a6de057b0079d3a6cadb0704733d5"></a>DL_I2C_IIDX_CONTROLLER_TX_DONE&#160;</td><td class="fielddoc"><p>Interrupt index for Controller Transmit Transaction completed </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2aee910b31c80683b76ded8e3c15776aa1e461b17ec7097e88a6048f5578ca3f9"></a>DL_I2C_IIDX_CONTROLLER_RXFIFO_TRIGGER&#160;</td><td class="fielddoc"><p>Interrupt index for I2C Controller Receive FIFO Trigger </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2aee910b31c80683b76ded8e3c15776aab5ffb8e0819510fb0e3e29ce75a22d5d"></a>DL_I2C_IIDX_CONTROLLER_TXFIFO_TRIGGER&#160;</td><td class="fielddoc"><p>Interrupt index for I2C Controller Transmit FIFO Trigger </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2aee910b31c80683b76ded8e3c15776aa1c98cd984480ee0b6637f6ddb94c9286"></a>DL_I2C_IIDX_CONTROLLER_RXFIFO_FULL&#160;</td><td class="fielddoc"><p>Interrupt index for I2C Controller Receive when FIFO is full </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2aee910b31c80683b76ded8e3c15776aaeb8db42d16a0987b6a33d4861a534d38"></a>DL_I2C_IIDX_CONTROLLER_TXFIFO_EMPTY&#160;</td><td class="fielddoc"><p>Interrupt index for I2C Controller when Transmit FIFO is empty </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2aee910b31c80683b76ded8e3c15776aa37cadf329e082f4d0854d5021ea78884"></a>DL_I2C_IIDX_CONTROLLER_NACK&#160;</td><td class="fielddoc"><p>Interrupt index for Address/Data NACK </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2aee910b31c80683b76ded8e3c15776aadb51ac2466168e965fd9ccd0c9b28591"></a>DL_I2C_IIDX_CONTROLLER_START&#160;</td><td class="fielddoc"><p>Interrupt index for I2C controller START Detection </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2aee910b31c80683b76ded8e3c15776aaed7e9651767195f6cc317118c5e0ac5c"></a>DL_I2C_IIDX_CONTROLLER_STOP&#160;</td><td class="fielddoc"><p>Interrupt index for I2C controller STOP Detection </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2aee910b31c80683b76ded8e3c15776aa23036b1d02737ac60404d4d539dfc2c8"></a>DL_I2C_IIDX_CONTROLLER_ARBITRATION_LOST&#160;</td><td class="fielddoc"><p>Interrupt index for I2C controller Arbitration Lost </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2aee910b31c80683b76ded8e3c15776aafbaaabec72df5a965072fb99253ff598"></a>DL_I2C_IIDX_CONTROLLER_EVENT1_DMA_DONE&#160;</td><td class="fielddoc"><p>Interrupt index for I2C controller Event 1 DMA Done </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2aee910b31c80683b76ded8e3c15776aa2f271d19734a375d941bf722305945a7"></a>DL_I2C_IIDX_CONTROLLER_EVENT2_DMA_DONE&#160;</td><td class="fielddoc"><p>Interrupt index for I2C controller Event 2 DMA Done </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2aee910b31c80683b76ded8e3c15776aae4bba5be1b4f22fcf3019d6a41dcb885"></a>DL_I2C_IIDX_CONTROLLER_PEC_RX_ERROR&#160;</td><td class="fielddoc"><p>Interrupt index for I2C controller SMBus/PMBus PEC Receive Error Event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2aee910b31c80683b76ded8e3c15776aad06e89020af15b386e952907f79baa87"></a>DL_I2C_IIDX_TIMEOUT_A&#160;</td><td class="fielddoc"><p>Interrupt index for I2C Timeout A Event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2aee910b31c80683b76ded8e3c15776aad55bfb7e578da4c59e9b9295a6703aaa"></a>DL_I2C_IIDX_TIMEOUT_B&#160;</td><td class="fielddoc"><p>Interrupt index for I2C Timeout B Event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2aee910b31c80683b76ded8e3c15776aa9e38ffb5f14ef92ce140166f1b0414b9"></a>DL_I2C_IIDX_TARGET_RX_DONE&#160;</td><td class="fielddoc"><p>Interrupt index for I2C Target Receive Data </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2aee910b31c80683b76ded8e3c15776aaadbacccbc1ce87d39d584321bf22d595"></a>DL_I2C_IIDX_TARGET_TX_DONE&#160;</td><td class="fielddoc"><p>Interrupt index for I2C Target Transmit Transaction completed </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2aee910b31c80683b76ded8e3c15776aa5e884776b04ae240fe09d9c9cd339753"></a>DL_I2C_IIDX_TARGET_RXFIFO_TRIGGER&#160;</td><td class="fielddoc"><p>Interrupt index for I2C Target Receive FIFO Trigger </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2aee910b31c80683b76ded8e3c15776aac51a2851387a2a6bcf571524b84701fd"></a>DL_I2C_IIDX_TARGET_TXFIFO_TRIGGER&#160;</td><td class="fielddoc"><p>Interrupt index for I2C Target Transmit FIFO Trigger </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2aee910b31c80683b76ded8e3c15776aac764349084de3b39053b6c9518b4337e"></a>DL_I2C_IIDX_TARGET_RXFIFO_FULL&#160;</td><td class="fielddoc"><p>Interrupt index for I2C Target RX FIFO full </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2aee910b31c80683b76ded8e3c15776aa4ac338feb7a05e95489e5cfbdc3c1c54"></a>DL_I2C_IIDX_TARGET_TXFIFO_EMPTY&#160;</td><td class="fielddoc"><p>Interrupt index for I2C Target TX FIFO empty. All data in Transmit FIFO shifted out and transmit goes into idle mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2aee910b31c80683b76ded8e3c15776aa3308692293435721f802db2a3546f060"></a>DL_I2C_IIDX_TARGET_START&#160;</td><td class="fielddoc"><p>Interrupt index for I2C Target Start Condition detected </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2aee910b31c80683b76ded8e3c15776aa22ec6271aa34f6a57039f8184558deb5"></a>DL_I2C_IIDX_TARGET_STOP&#160;</td><td class="fielddoc"><p>Interrupt index for I2C Target Stop Condition detected </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2aee910b31c80683b76ded8e3c15776aa1988192e4e647c9d2615e4d5c9530e79"></a>DL_I2C_IIDX_TARGET_GENERAL_CALL&#160;</td><td class="fielddoc"><p>Interrupt index for I2C General Call </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2aee910b31c80683b76ded8e3c15776aa4b1dfecfbc62ea40e6be2b8c3f88b2f0"></a>DL_I2C_IIDX_TARGET_EVENT1_DMA_DONE&#160;</td><td class="fielddoc"><p>Interrupt index for I2C Target Event 1 DMA Done </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2aee910b31c80683b76ded8e3c15776aa59e3ffff56c8204214d9b392b5b571ac"></a>DL_I2C_IIDX_TARGET_EVENT2_DMA_DONE&#160;</td><td class="fielddoc"><p>Interrupt index for I2C Target Event 2 DMA Done </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2aee910b31c80683b76ded8e3c15776aae3c2b65db30bcaaec287321afe49361a"></a>DL_I2C_IIDX_TARGET_PEC_RX_ERROR&#160;</td><td class="fielddoc"><p>Interrupt index for I2C Target SMBus/PMBus PEC Receive Error Event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2aee910b31c80683b76ded8e3c15776aa9b99580bd73995620ec2fa814370cd14"></a>DL_I2C_IIDX_TARGET_TXFIFO_UNDERFLOW&#160;</td><td class="fielddoc"><p>Interrupt index for I2C Target TX FIFO underflow event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2aee910b31c80683b76ded8e3c15776aa4465940455ef0a0b8d3e82160267c946"></a>DL_I2C_IIDX_TARGET_RXFIFO_OVERFLOW&#160;</td><td class="fielddoc"><p>Interrupt index for I2C Target RX FIFO overflow event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2aee910b31c80683b76ded8e3c15776aaa746057d76d8bb9195b50b599cd4ef57"></a>DL_I2C_IIDX_TARGET_ARBITRATION_LOST&#160;</td><td class="fielddoc"><p>Interrupt index for I2C Target arbitration lost event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2aee910b31c80683b76ded8e3c15776aaccaab921ddd8e5d2dd78bc41449e72df"></a>DL_I2C_IIDX_INTERRUPT_OVERFLOW&#160;</td><td class="fielddoc"><p>Interrupt index for I2C interrupt overflow event </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gafe52f423d12f219571380491a7ad95d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe52f423d12f219571380491a7ad95d1">&sect;&nbsp;</a></span>DL_I2C_setClockConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_I2C_setClockConfig </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_d_l___i2_c___clock_config.html">DL_I2C_ClockConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure I2C source clock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Pointer to the clock configuration struct <a class="el" href="struct_d_l___i2_c___clock_config.html">DL_I2C_ClockConfig</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9082406188ca55be3d9ca009517797fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9082406188ca55be3d9ca009517797fa">&sect;&nbsp;</a></span>DL_I2C_getClockConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_I2C_getClockConfig </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_d_l___i2_c___clock_config.html">DL_I2C_ClockConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get I2C source clock configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Pointer to the clock configuration struct <a class="el" href="struct_d_l___i2_c___clock_config.html">DL_I2C_ClockConfig</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabeeb1670ab63e9656da06c5148b80153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabeeb1670ab63e9656da06c5148b80153">&sect;&nbsp;</a></span>DL_I2C_fillControllerTXFIFO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t DL_I2C_fillControllerTXFIFO </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the controller TX FIFO with data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to buffer of bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of bytes to fill controller TX FIFO from buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes that were successfully written </dd></dl>

</div>
</div>
<a id="gacfcb7a745c177c5ec8a9291f7a77c5e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfcb7a745c177c5ec8a9291f7a77c5e8">&sect;&nbsp;</a></span>DL_I2C_flushControllerTXFIFO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_I2C_flushControllerTXFIFO </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes/removes all elements in the controller TX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga96a1251b84773ba8018e28e217288021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96a1251b84773ba8018e28e217288021">&sect;&nbsp;</a></span>DL_I2C_flushControllerRXFIFO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_I2C_flushControllerRXFIFO </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes/removes all elements in the controller RX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga413f826364f588a18ead8ae2816ed9f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga413f826364f588a18ead8ae2816ed9f4">&sect;&nbsp;</a></span>DL_I2C_isControllerTXFIFOFull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isControllerTXFIFOFull </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if controller TX FIFO is full. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If controller TX FIFO is full</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if controller TX FIFO is full </td></tr>
    <tr><td class="paramname">false</td><td>if controller TX FIFO is not full </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaea6e1d20664eb58d38d090132ff759a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea6e1d20664eb58d38d090132ff759a7">&sect;&nbsp;</a></span>DL_I2C_isControllerTXFIFOEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isControllerTXFIFOEmpty </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if controller TX FIFO is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If controller TX FIFO is empty</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if controller TX FIFO is empty </td></tr>
    <tr><td class="paramname">false</td><td>if controller TX FIFO is not empty </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___i2_c.html#gadc068c6d6df6e875e4ea73d14b420e7e">DL_I2C_TX_FIFO_COUNT_MAXIMUM</a>.</p>

</div>
</div>
<a id="ga53f6a562cdc3ade95d3f9602c6144bcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53f6a562cdc3ade95d3f9602c6144bcb">&sect;&nbsp;</a></span>DL_I2C_isControllerRXFIFOEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isControllerRXFIFOEmpty </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if controller RX FIFO is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If controller RX FIFO is empty</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if controller RX FIFO is empty </td></tr>
    <tr><td class="paramname">false</td><td>if controller RX FIFO is not empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8d7bd1eb2fbbb0b5144962458d1d1c5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d7bd1eb2fbbb0b5144962458d1d1c5c">&sect;&nbsp;</a></span>DL_I2C_resetControllerTransfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_resetControllerTransfer </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset transfers from from I2C controller. </p>
<p>Resets transfer register to initialize I2C</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabc914d02e83818035b69347376dd1fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc914d02e83818035b69347376dd1fae">&sect;&nbsp;</a></span>DL_I2C_startControllerTransfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_startControllerTransfer </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>targetAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga4e5bff33e69ea760e7f8364b2f1cf259">DL_I2C_CONTROLLER_DIRECTION</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up a transfer from I2C controller. </p>
<p>Set target address, transfer direction, burst length, START+STOP generation. </p><dl class="section note"><dt>Note</dt><dd>Reading/writing data must be done separately.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetAddr</td><td>Target address [0x00, 0x3FF] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">direction</td><td>One of <a class="el" href="group___i2_c.html#ga4e5bff33e69ea760e7f8364b2f1cf259">DL_I2C_CONTROLLER_DIRECTION</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Intended burst length in number of bytes </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="gaa0d5a085c2e5ea50f61960a4e18be424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0d5a085c2e5ea50f61960a4e18be424">&sect;&nbsp;</a></span>DL_I2C_startControllerTransferAdvanced()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_startControllerTransferAdvanced </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>targetAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga4e5bff33e69ea760e7f8364b2f1cf259">DL_I2C_CONTROLLER_DIRECTION</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga5722df24b0d57c0b2bf18c1068a36ca1">DL_I2C_CONTROLLER_START</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga8996cddfa139bd7118880aa51e32f0f7">DL_I2C_CONTROLLER_STOP</a>&#160;</td>
          <td class="paramname"><em>stop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#gaab55947b23ba571c233ab80d34bf7182">DL_I2C_CONTROLLER_ACK</a>&#160;</td>
          <td class="paramname"><em>ack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up a transfer from I2C controller with control of START, STOP and ACK. </p>
<dl class="section note"><dt>Note</dt><dd>Reading/writing data must be done separately.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetAddr</td><td>7-bit target address [0x00, 0x7f] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">direction</td><td>One of <a class="el" href="group___i2_c.html#ga4e5bff33e69ea760e7f8364b2f1cf259">DL_I2C_CONTROLLER_DIRECTION</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Intended burst length in number of bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>One of <a class="el" href="group___i2_c.html#ga5722df24b0d57c0b2bf18c1068a36ca1">DL_I2C_CONTROLLER_START</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stop</td><td>One of <a class="el" href="group___i2_c.html#ga8996cddfa139bd7118880aa51e32f0f7">DL_I2C_CONTROLLER_STOP</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ack</td><td>One of <a class="el" href="group___i2_c.html#gaab55947b23ba571c233ab80d34bf7182">DL_I2C_CONTROLLER_ACK</a> </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga3ce06770ca54c22ed184318514fa3050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ce06770ca54c22ed184318514fa3050">&sect;&nbsp;</a></span>DL_I2C_isTargetTXFIFOFull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isTargetTXFIFOFull </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if target TX FIFO is full. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If target TX FIFO is full</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if target TX FIFO is full </td></tr>
    <tr><td class="paramname">false</td><td>if target TX FIFO is not full </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9d724998617836aaf2aa74587ef6bee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d724998617836aaf2aa74587ef6bee8">&sect;&nbsp;</a></span>DL_I2C_isTargetTXFIFOEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isTargetTXFIFOEmpty </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if target TX FIFO is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If target TX FIFO is empty</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if target TX FIFO is empty </td></tr>
    <tr><td class="paramname">false</td><td>if target TX FIFO is not empty </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___i2_c.html#gadc068c6d6df6e875e4ea73d14b420e7e">DL_I2C_TX_FIFO_COUNT_MAXIMUM</a>.</p>

</div>
</div>
<a id="ga285819b2a1c642fd3559b40578bab94d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga285819b2a1c642fd3559b40578bab94d">&sect;&nbsp;</a></span>DL_I2C_isTargetRXFIFOEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isTargetRXFIFOEmpty </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if target RX FIFO is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If target RX FIFO is empty</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if target RX FIFO is empty </td></tr>
    <tr><td class="paramname">false</td><td>if target RX FIFO is not empty </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___i2_c.html#ga64db37623fb55d78aa168c45f0bf533e">DL_I2C_fillTargetTXFIFO()</a>, <a class="el" href="group___i2_c.html#ga8f332a1d9f230510571654708d638816">DL_I2C_flushTargetRXFIFO()</a>, <a class="el" href="group___i2_c.html#ga65d96af5bd435f74a4aab60ae33f0156">DL_I2C_flushTargetTXFIFO()</a>, <a class="el" href="group___i2_c.html#ga47c34bc2633f8923165358d3c31d12e2">DL_I2C_receiveTargetDataBlocking()</a>, <a class="el" href="group___i2_c.html#ga66a302555ef7477d023f506cdb7354c0">DL_I2C_receiveTargetDataCheck()</a>, <a class="el" href="group___i2_c.html#ga5f56db4764b0e7acc0ef47e8439d79be">DL_I2C_transmitTargetDataBlocking()</a>, and <a class="el" href="group___i2_c.html#ga1568de96bfa23a32f14989f5596b9ade">DL_I2C_transmitTargetDataCheck()</a>.</p>

</div>
</div>
<a id="ga64db37623fb55d78aa168c45f0bf533e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64db37623fb55d78aa168c45f0bf533e">&sect;&nbsp;</a></span>DL_I2C_fillTargetTXFIFO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t DL_I2C_fillTargetTXFIFO </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the target TX FIFO with data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to buffer of bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of bytes to fill target TX FIFO from buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes that were successfully written </dd></dl>

<p>Referenced by <a class="el" href="group___i2_c.html#ga285819b2a1c642fd3559b40578bab94d">DL_I2C_isTargetRXFIFOEmpty()</a>.</p>

</div>
</div>
<a id="ga65d96af5bd435f74a4aab60ae33f0156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65d96af5bd435f74a4aab60ae33f0156">&sect;&nbsp;</a></span>DL_I2C_flushTargetTXFIFO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_I2C_flushTargetTXFIFO </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes/removes all elements in the target TX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___i2_c.html#ga285819b2a1c642fd3559b40578bab94d">DL_I2C_isTargetRXFIFOEmpty()</a>.</p>

</div>
</div>
<a id="ga8f332a1d9f230510571654708d638816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f332a1d9f230510571654708d638816">&sect;&nbsp;</a></span>DL_I2C_flushTargetRXFIFO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_I2C_flushTargetRXFIFO </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes/removes all elements in the target RX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___i2_c.html#ga285819b2a1c642fd3559b40578bab94d">DL_I2C_isTargetRXFIFOEmpty()</a>.</p>

</div>
</div>
<a id="ga5f56db4764b0e7acc0ef47e8439d79be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f56db4764b0e7acc0ef47e8439d79be">&sect;&nbsp;</a></span>DL_I2C_transmitTargetDataBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_I2C_transmitTargetDataBlocking </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit target data, waiting until transmit request. </p>
<dl class="section note"><dt>Note</dt><dd>Setting own target addresses and enabling target should be done separately.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Byte of data to transmit </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___i2_c.html#ga285819b2a1c642fd3559b40578bab94d">DL_I2C_isTargetRXFIFOEmpty()</a>.</p>

</div>
</div>
<a id="ga1568de96bfa23a32f14989f5596b9ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1568de96bfa23a32f14989f5596b9ade">&sect;&nbsp;</a></span>DL_I2C_transmitTargetDataCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DL_I2C_transmitTargetDataCheck </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit target data. </p>
<dl class="section note"><dt>Note</dt><dd>Setting own target addresses and enabling target should be done separately.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Byte of data to transmit</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether data could be transmitted or not </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if data could be transmitted </td></tr>
    <tr><td class="paramname">false</td><td>if data could not be transmitted </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___i2_c.html#ga285819b2a1c642fd3559b40578bab94d">DL_I2C_isTargetRXFIFOEmpty()</a>.</p>

</div>
</div>
<a id="ga47c34bc2633f8923165358d3c31d12e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47c34bc2633f8923165358d3c31d12e2">&sect;&nbsp;</a></span>DL_I2C_receiveTargetDataBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t DL_I2C_receiveTargetDataBlocking </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive target data, waiting until receive request. </p>
<dl class="section note"><dt>Note</dt><dd>Setting own target addresses and enabling target should be done separately.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Data received from target </dd></dl>

<p>Referenced by <a class="el" href="group___i2_c.html#ga285819b2a1c642fd3559b40578bab94d">DL_I2C_isTargetRXFIFOEmpty()</a>.</p>

</div>
</div>
<a id="ga66a302555ef7477d023f506cdb7354c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66a302555ef7477d023f506cdb7354c0">&sect;&nbsp;</a></span>DL_I2C_receiveTargetDataCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DL_I2C_receiveTargetDataCheck </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive target data. </p>
<dl class="section note"><dt>Note</dt><dd>Setting own target addresses and enabling target should be done separately.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to where byte of received data should be stored</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether data could be received or not </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if data could be received </td></tr>
    <tr><td class="paramname">false</td><td>if data could not be received </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___i2_c.html#ga285819b2a1c642fd3559b40578bab94d">DL_I2C_isTargetRXFIFOEmpty()</a>.</p>

</div>
</div>
<a id="ga040aa421dee03e9cd4adb3777e8147e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga040aa421dee03e9cd4adb3777e8147e0">&sect;&nbsp;</a></span>DL_I2C_enablePower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_enablePower </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the Peripheral Write Enable (PWREN) register for the I2C. </p>
<p>Before any peripheral registers can be configured by software, the peripheral itself must be enabled by writing the ENABLE bit together with the appropriate KEY value to the peripheral's PWREN register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6ea9a4a26ffbdf4c4c0f2ae615c9c195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ea9a4a26ffbdf4c4c0f2ae615c9c195">&sect;&nbsp;</a></span>DL_I2C_disablePower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_disablePower </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the Peripheral Write Enable (PWREN) register for the I2C. </p>
<p>When the PWREN.ENABLE bit is cleared, the peripheral's registers are not accessible for read/write operations.</p>
<dl class="section note"><dt>Note</dt><dd>This API does not provide large power savings.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4d0c945b48c12ef15437f68437499f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d0c945b48c12ef15437f68437499f5c">&sect;&nbsp;</a></span>DL_I2C_isPowerEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isPowerEnabled </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if the Peripheral Write Enable (PWREN) register for the I2C is enabled. </p>
<p>Before any peripheral registers can be configured by software, the peripheral itself must be enabled by writing the ENABLE bit together with the appropriate KEY value to the peripheral's PWREN register.</p>
<p>When the PWREN.ENABLE bit is cleared, the peripheral's registers are not accessible for read/write operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if peripheral register access is enabled </dd>
<dd>
false if peripheral register access is disabled </dd></dl>

</div>
</div>
<a id="gaf5d5c92ce48214c4f933da1ff95ea859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5d5c92ce48214c4f933da1ff95ea859">&sect;&nbsp;</a></span>DL_I2C_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_reset </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets i2c peripheral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7be75e95c5c2f58cbcd1ed27cd851f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7be75e95c5c2f58cbcd1ed27cd851f46">&sect;&nbsp;</a></span>DL_I2C_isReset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isReset </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if i2c peripheral was reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if peripheral was reset </dd>
<dd>
false if peripheral wasn't reset </dd></dl>

</div>
</div>
<a id="ga083d8a13d9928b213eeaf84401379ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga083d8a13d9928b213eeaf84401379ab3">&sect;&nbsp;</a></span>DL_I2C_selectClockSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_selectClockSource </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#gad912db0203e9bb0e55bb0ddbc0ddcfcc">DL_I2C_CLOCK</a>&#160;</td>
          <td class="paramname"><em>clockSource</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Clock Source. </p>
<p>Clock sources depend on device and clock should be enabled</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clockSource</td><td>One of <a class="el" href="group___i2_c.html#gad912db0203e9bb0e55bb0ddbc0ddcfcc">DL_I2C_CLOCK</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga809ad478e82c04c4e05a1620492ce89f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga809ad478e82c04c4e05a1620492ce89f">&sect;&nbsp;</a></span>DL_I2C_selectClockDivider()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_selectClockDivider </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga03737f74607dfbe4048cff93862c9faa">DL_I2C_CLOCK_DIVIDE</a>&#160;</td>
          <td class="paramname"><em>clockDivider</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Clock Divider. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clockDivider</td><td>One of <a class="el" href="group___i2_c.html#ga03737f74607dfbe4048cff93862c9faa">DL_I2C_CLOCK_DIVIDE</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga6f9d183ec3a668b26763246e0c9561ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f9d183ec3a668b26763246e0c9561ca">&sect;&nbsp;</a></span>DL_I2C_getAnalogGlitchFilterPulseWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___i2_c.html#ga031f0b093a1d7448b0ba89a6ecc0a32a">DL_I2C_ANALOG_GLITCH_FILTER_WIDTH</a> DL_I2C_getAnalogGlitchFilterPulseWidth </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Analog Glitch Suppression Pulse Width. </p>
<p>Pulse width for the analog glitch suppression on SCL/SDA lines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Analog glitch suppression pulse width</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___i2_c.html#ga031f0b093a1d7448b0ba89a6ecc0a32a">DL_I2C_ANALOG_GLITCH_FILTER_WIDTH</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaaf73e16477c0bf6b0c7485ce9160814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaaf73e16477c0bf6b0c7485ce9160814">&sect;&nbsp;</a></span>DL_I2C_setAnalogGlitchFilterPulseWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_setAnalogGlitchFilterPulseWidth </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga031f0b093a1d7448b0ba89a6ecc0a32a">DL_I2C_ANALOG_GLITCH_FILTER_WIDTH</a>&#160;</td>
          <td class="paramname"><em>filterWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Analog Glitch Suppression Pulse Width. </p>
<p>Pulse width for the analog glitch suppression on SCL/SDA lines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filterWidth</td><td>One of <a class="el" href="group___i2_c.html#ga031f0b093a1d7448b0ba89a6ecc0a32a">DL_I2C_ANALOG_GLITCH_FILTER_WIDTH</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga1da7a0e2083d9f43223b41f2589d4d78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1da7a0e2083d9f43223b41f2589d4d78">&sect;&nbsp;</a></span>DL_I2C_getDigitalGlitchFilterPulseWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___i2_c.html#ga9f42d16d0c14219c0ce8e45016bed5e4">DL_I2C_DIGITAL_GLITCH_FILTER_WIDTH</a> DL_I2C_getDigitalGlitchFilterPulseWidth </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Digital Glitch Suppression Pulse Width. </p>
<p>Pulse width for the digital glitch suppression on SCL/SDA lines. Values are in terms of functional clock ticks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Digital glitch suppression pulse width</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___i2_c.html#ga9f42d16d0c14219c0ce8e45016bed5e4">DL_I2C_DIGITAL_GLITCH_FILTER_WIDTH</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9b57b523f7e35273532ad4d6411fd8ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b57b523f7e35273532ad4d6411fd8ca">&sect;&nbsp;</a></span>DL_I2C_setDigitalGlitchFilterPulseWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_setDigitalGlitchFilterPulseWidth </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga9f42d16d0c14219c0ce8e45016bed5e4">DL_I2C_DIGITAL_GLITCH_FILTER_WIDTH</a>&#160;</td>
          <td class="paramname"><em>filterWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Digital Glitch Suppression Pulse Width. </p>
<p>Pulse width for the digital glitch suppression on SCL/SDA lines. Values are in terms of functional clock ticks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filterWidth</td><td>One of <a class="el" href="group___i2_c.html#ga9f42d16d0c14219c0ce8e45016bed5e4">DL_I2C_DIGITAL_GLITCH_FILTER_WIDTH</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga60638213fd307de071f25fb94ba4e3d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60638213fd307de071f25fb94ba4e3d7">&sect;&nbsp;</a></span>DL_I2C_disableAnalogGlitchFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_disableAnalogGlitchFilter </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable Analog Glitch Suppression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadf88b49609149e01a74a40ab4fb0a459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf88b49609149e01a74a40ab4fb0a459">&sect;&nbsp;</a></span>DL_I2C_isAnalogGlitchFilterEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isAnalogGlitchFilterEnabled </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if analog glitch suppression is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If analog glitch suppression is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if analog glitch suppression is enabled </td></tr>
    <tr><td class="paramname">false</td><td>if analog glitch suppression is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga140a6bf809d3a3cfa3260a458acd2d05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga140a6bf809d3a3cfa3260a458acd2d05">&sect;&nbsp;</a></span>DL_I2C_enableAnalogGlitchFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_enableAnalogGlitchFilter </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable Analog Glitch Suppression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga81abbad2d469957cd3495748f6b2e948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81abbad2d469957cd3495748f6b2e948">&sect;&nbsp;</a></span>DL_I2C_getControllerDirection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___i2_c.html#ga4e5bff33e69ea760e7f8364b2f1cf259">DL_I2C_CONTROLLER_DIRECTION</a> DL_I2C_getControllerDirection </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get direction of next controller operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Direction of next controller operation</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___i2_c.html#ga4e5bff33e69ea760e7f8364b2f1cf259">DL_I2C_CONTROLLER_DIRECTION</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa7114948c22ab198aaa5202c02c982c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7114948c22ab198aaa5202c02c982c3">&sect;&nbsp;</a></span>DL_I2C_setControllerDirection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_setControllerDirection </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga4e5bff33e69ea760e7f8364b2f1cf259">DL_I2C_CONTROLLER_DIRECTION</a>&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set direction of next controller operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">direction</td><td>Direction of next controller operation. One of <a class="el" href="group___i2_c.html#ga4e5bff33e69ea760e7f8364b2f1cf259">DL_I2C_CONTROLLER_DIRECTION</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga2eb3a9d4dc0b98fb388aadf5628039a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2eb3a9d4dc0b98fb388aadf5628039a7">&sect;&nbsp;</a></span>DL_I2C_getTargetAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_I2C_getTargetAddress </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the address of the target being addressed when configured as an I2C controller. </p>
<p>Specifies bits A9 through A0 of the target address. In 7-bit addressing mode as selected by <a class="el" href="group___i2_c.html#gac4c20c5eac3bcbf9b8afda69c5fae504">DL_I2C_setTargetAddressingMode</a>, the top 3 bits are don't care.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The target address</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">[0x00,0x07FE]</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#gac4c20c5eac3bcbf9b8afda69c5fae504" title="Set target addressing mode. ">DL_I2C_setTargetAddressingMode</a> </dd></dl>

</div>
</div>
<a id="ga6fe60c04fa69e0aa0036751c7572b8fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fe60c04fa69e0aa0036751c7572b8fd">&sect;&nbsp;</a></span>DL_I2C_setTargetAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_setTargetAddress </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>targetAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the address of the target being addressed when configured as an I2C controller. </p>
<p>Specifies bits A9 through A0 of the target address. In 7-bit addressing mode as selected by <a class="el" href="group___i2_c.html#gac4c20c5eac3bcbf9b8afda69c5fae504">DL_I2C_setTargetAddressingMode</a>, the top 3 bits are don't care.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetAddress</td><td>Target address to set [0x00, 0x07FE]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#gac4c20c5eac3bcbf9b8afda69c5fae504" title="Set target addressing mode. ">DL_I2C_setTargetAddressingMode</a> </dd></dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga255deb2c3288221ad037acc13fc94147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga255deb2c3288221ad037acc13fc94147">&sect;&nbsp;</a></span>DL_I2C_getControllerAddressingMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___i2_c.html#ga286008e7442aee9279befbb3cace3d47">DL_I2C_CONTROLLER_ADDRESSING_MODE</a> DL_I2C_getControllerAddressingMode </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get controller addressing mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Addressing mode the controller is set to</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___i2_c.html#ga286008e7442aee9279befbb3cace3d47">DL_I2C_CONTROLLER_ADDRESSING_MODE</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1fb3012c627a5ef35d2b84f6a1e126b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fb3012c627a5ef35d2b84f6a1e126b3">&sect;&nbsp;</a></span>DL_I2C_setControllerAddressingMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_setControllerAddressingMode </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga286008e7442aee9279befbb3cace3d47">DL_I2C_CONTROLLER_ADDRESSING_MODE</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set controller addressing mode between 7-bit and 10-bit mode. </p>
<p>Selects the addressing mode between 7-bit and 10-bit mode to be used when device is configured as a controller</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Addressing mode to set the target to. One of <a class="el" href="group___i2_c.html#ga286008e7442aee9279befbb3cace3d47">DL_I2C_CONTROLLER_ADDRESSING_MODE</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga002a1ad899ae9981211a2e1ceb45d55f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga002a1ad899ae9981211a2e1ceb45d55f">&sect;&nbsp;</a></span>DL_I2C_disableControllerACKOverride()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_disableControllerACKOverride </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable controller ACK override. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae017801cc456ba6f3a0c496755c1e38c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae017801cc456ba6f3a0c496755c1e38c">&sect;&nbsp;</a></span>DL_I2C_isControllerACKOverrideEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isControllerACKOverrideEnabled </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if controller ACK override is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If controller ACK override is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if controller ACK override is enabled </td></tr>
    <tr><td class="paramname">false</td><td>if controller ACK override is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga267b63be2893efd4ab6b4e48fdd595cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga267b63be2893efd4ab6b4e48fdd595cd">&sect;&nbsp;</a></span>DL_I2C_enableControllerACKOverride()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_enableControllerACKOverride </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable controller ACK override. </p>
<p>When enabled and the controller is receiving data and the number of bytes indicated in MCTR.MBLEN have been received, the state machine will generate an RXDONE interrupt and wait at the start of the ACK for FW to indicate if an ACK or NACK should be sent. The ACK or NACK is selected by writing the MCTR register and setting ACK accordingly. The other fields in this register can also be written at this time to continue on with the transaction. If a NACK is sent the state machine will automatically send a Stop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#gad614a1764f251d9fcbe0669b97c6cec2" title="Set transaction length in bytes. ">DL_I2C_setTransactionLength</a> </dd></dl>

</div>
</div>
<a id="ga8ce108fc849d8973615a4be0804a28b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ce108fc849d8973615a4be0804a28b5">&sect;&nbsp;</a></span>DL_I2C_disableControllerReadOnTXEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_disableControllerReadOnTXEmpty </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable controller read on TX empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadbc1cc912d0ae4af531cde7a493ec8bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbc1cc912d0ae4af531cde7a493ec8bf">&sect;&nbsp;</a></span>DL_I2C_isControllerReadOnTXEmptyEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isControllerReadOnTXEmptyEnabled </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if controller read on TX empty is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If controller read on TX empty is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if controller read on TX empty is enabled </td></tr>
    <tr><td class="paramname">false</td><td>if controller read on TX empty is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga345ce0bec611dbc4552f8770de13f47c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga345ce0bec611dbc4552f8770de13f47c">&sect;&nbsp;</a></span>DL_I2C_enableControllerReadOnTXEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_enableControllerReadOnTXEmpty </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable controller read on TX empty. </p>
<p>When enabled, the controller will transmit all bytes from the TX FIFO before continuing with the programmed Burst Run Read. If the DIR is not set to Read in the MSA then this bit is ignored. The Start must be set in the MCTR for proper I2C protocol. The controller will first send the Start Condition, I2C Address with R/W bit set to write, before sending the bytes in the TX FIFO. When the TX FIFO is empty, the I2C transaction will continue as programmed in MTCR and MSA without sending a Stop Condition. This is intended to be used to perform simple I2C command based reads transition that will complete after initiating them without having to get an interrupt to turn the bus around.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6e31e3aea1af4a8acecd8db4aac97648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e31e3aea1af4a8acecd8db4aac97648">&sect;&nbsp;</a></span>DL_I2C_getControllerPECCountValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_I2C_getControllerPECCountValue </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the SMBus/PMBus Packet Error Checking (PEC) count value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value the PEC count is set to</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>between [0x0, 0x01FF] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaae6c467bc9b77f37d82a135b489826e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae6c467bc9b77f37d82a135b489826e3">&sect;&nbsp;</a></span>DL_I2C_setControllerPECCountValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_setControllerPECCountValue </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the SMBus/PMBus Packet Error Checking (PEC) count value. </p>
<p>When this field is non zero, the number of I2C data bytes are counted. Refer to the device TRM for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The value to set the PEC count to. Value between [0x0, 0x01FF] </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="gaa4c387ec78dae0360077a6e60db5081f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4c387ec78dae0360077a6e60db5081f">&sect;&nbsp;</a></span>DL_I2C_disableControllerPEC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_disableControllerPEC </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable controller SMBus/PMBus Packet Error Checking (PEC) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa96c29ab403c501dba7738963f42d4b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa96c29ab403c501dba7738963f42d4b7">&sect;&nbsp;</a></span>DL_I2C_isControllerPECEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isControllerPECEnabled </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if controller SMBus/PMBus Packet Error Checking (PEC) is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If controller PEC is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if controller PEC is enabled </td></tr>
    <tr><td class="paramname">false</td><td>if controller PEC is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5e45ed6ab0c41eb3362db7f113423349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e45ed6ab0c41eb3362db7f113423349">&sect;&nbsp;</a></span>DL_I2C_enableControllerPEC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_enableControllerPEC </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable controller SMBus/PMBus Packet Error Checking (PEC) </p>
<p>When enabled, the PEC is calculated on all bits accept the Start, Stop, ACK and NACK. The PEC LSFR and the Byte Counter is set to 0 when the State Machine is in the IDLE state, which occurs following a Stop or when a timeout occurs. The Counter is also set to 0 after the PEC byte is sent or received. Note that the NACK is automatically sent following a PEC byte that results in a PEC error. The PEC Polynomial is x^8 + x^2 + x^1 + 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2a599911eaac7007428277f0732a2a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a599911eaac7007428277f0732a2a15">&sect;&nbsp;</a></span>DL_I2C_getControllerCurrentPECCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_I2C_getControllerCurrentPECCount </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current SMBus/PMBus PEC byte count of the controller state machine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current PEC byte count of the controller state machine</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>between [0x0, 0x01FF] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga88bb3a8a69f297d2e911c58f6b8d65fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88bb3a8a69f297d2e911c58f6b8d65fb">&sect;&nbsp;</a></span>DL_I2C_getControllerPECCheckedStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___i2_c.html#gae90754611bdbab4885bc634bcddadca4">DL_I2C_CONTROLLER_PEC_STATUS</a> DL_I2C_getControllerPECCheckedStatus </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If controller SMBus/PMBus PEC was checked in last transaction. </p>
<p>The status of if the controller PEC was checked in the transaction that occurred before the last Stop. Latched on Stop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of controller PEC checked in last transaction</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___i2_c.html#gae90754611bdbab4885bc634bcddadca4">DL_I2C_CONTROLLER_PEC_STATUS</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6a64b995755cd0c236b983d09216e9d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a64b995755cd0c236b983d09216e9d1">&sect;&nbsp;</a></span>DL_I2C_getControllerPECCheckError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___i2_c.html#ga560b453b65c64ad5bffb37ae05c88553">DL_I2C_CONTROLLER_PEC_CHECK_ERROR</a> DL_I2C_getControllerPECCheckError </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the status of the controller SMBus/PMBus PEC Check error. </p>
<p>The status of if a PEC check error occurred in the transaction that occurred before the last Stop. Latched on Stop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of controller PEC check error</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___i2_c.html#ga560b453b65c64ad5bffb37ae05c88553">DL_I2C_CONTROLLER_PEC_CHECK_ERROR</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga94e0be0a87e33bf66741c164c0b41052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94e0be0a87e33bf66741c164c0b41052">&sect;&nbsp;</a></span>DL_I2C_disableControllerBurst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_disableControllerBurst </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable I2C controller burst mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga646b281a6094b9d0f6577e388f893386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga646b281a6094b9d0f6577e388f893386">&sect;&nbsp;</a></span>DL_I2C_isControllerBurstEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isControllerBurstEnabled </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if I2C controller burst mode is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If I2C controller burst mode is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if I2C controller burst mode is enabled </td></tr>
    <tr><td class="paramname">false</td><td>if I2C controller burst mode is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7609e2a1ea220f277b8fca9df941216f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7609e2a1ea220f277b8fca9df941216f">&sect;&nbsp;</a></span>DL_I2C_enableControllerBurst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_enableControllerBurst </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable I2C controller burst mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6ece43f6cfcc48eb08dbe583441c3525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ece43f6cfcc48eb08dbe583441c3525">&sect;&nbsp;</a></span>DL_I2C_disableStartCondition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_disableStartCondition </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable I2C START generation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf434454eb54f8e75dd560f43af485a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf434454eb54f8e75dd560f43af485a2d">&sect;&nbsp;</a></span>DL_I2C_isStartConditionEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isStartConditionEnabled </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if I2C START generation is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If I2C START generation is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if I2C START generation is enabled </td></tr>
    <tr><td class="paramname">false</td><td>if I2C START generation is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga58dec8789bcfb77143d263dfa4f316a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58dec8789bcfb77143d263dfa4f316a2">&sect;&nbsp;</a></span>DL_I2C_enableStartCondition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_enableStartCondition </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable I2C START generation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab78daabc26c563ede833407e0d9be983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab78daabc26c563ede833407e0d9be983">&sect;&nbsp;</a></span>DL_I2C_disableStopCondition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_disableStopCondition </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable I2C STOP generation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gada93982a93156ce61b029bd54bd370c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada93982a93156ce61b029bd54bd370c2">&sect;&nbsp;</a></span>DL_I2C_isStopConditionEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isStopConditionEnabled </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if I2C STOP generation is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If I2C STOP generation is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if I2C STOP generation is enabled </td></tr>
    <tr><td class="paramname">false</td><td>if I2C STOP generation is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga205da6ec66f7438a2f2852055d0a7c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga205da6ec66f7438a2f2852055d0a7c5f">&sect;&nbsp;</a></span>DL_I2C_enableStopCondition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_enableStopCondition </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable I2C STOP generation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5d6b9750470cfda31aace0db785c6479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d6b9750470cfda31aace0db785c6479">&sect;&nbsp;</a></span>DL_I2C_disableControllerACK()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_disableControllerACK </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable I2C controller data acknowledge (ACK or NACK) </p>
<p>When the I2C module operates in Controller receiver mode, the ACK bit can be cleared when no further data needs to be received from the target transmitter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga598b72a9ead67479156ee41bd8e4eaf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga598b72a9ead67479156ee41bd8e4eaf8">&sect;&nbsp;</a></span>DL_I2C_isControllerACKEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isControllerACKEnabled </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if I2C controller data acknowledge (ACK or NACK) is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If I2C controller data acknowledge is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if I2C controller data acknowledge is enabled </td></tr>
    <tr><td class="paramname">false</td><td>if I2C controller data acknowledge is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5b8ac2f0d12315c7bb98562b6f6e0b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b8ac2f0d12315c7bb98562b6f6e0b61">&sect;&nbsp;</a></span>DL_I2C_enableControllerACK()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_enableControllerACK </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable I2C controller data acknowledge (ACK or NACK) </p>
<p>When the I2C module operates in Controller receiver mode, the ACK bit is normally set causing the I2C bus controller to transmit an acknowledge automatically after each byte.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7b70c82454879281797d5de0231af669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b70c82454879281797d5de0231af669">&sect;&nbsp;</a></span>DL_I2C_getTransactionLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_I2C_getTransactionLength </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get transaction length in bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of I2C transaction in bytes</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">[0x000,0xfff]</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad614a1764f251d9fcbe0669b97c6cec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad614a1764f251d9fcbe0669b97c6cec2">&sect;&nbsp;</a></span>DL_I2C_setTransactionLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_setTransactionLength </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set transaction length in bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of I2C transaction in bytes [0x000, 0xfff] </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga50097248e2a4fa0f790437d817315572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50097248e2a4fa0f790437d817315572">&sect;&nbsp;</a></span>DL_I2C_getControllerStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_I2C_getControllerStatus </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get status of I2C bus controller for controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of I2C bus controller for controller</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Bitwise</td><td>OR of <a class="el" href="group___d_l___i2_c___c_o_n_t_r_o_l_l_e_r___s_t_a_t_u_s.html">DL_I2C_CONTROLLER_STATUS</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaa33116abdeaab5e853474ec72f350cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa33116abdeaab5e853474ec72f350cf">&sect;&nbsp;</a></span>DL_I2C_getTransactionCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint16_t DL_I2C_getTransactionCount </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get transaction count in bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current 12-bit countdown value of the transaction</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">[0x000,0xfff]</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga57b87c5b3bc52f16b76aede1947c7440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57b87c5b3bc52f16b76aede1947c7440">&sect;&nbsp;</a></span>DL_I2C_receiveControllerData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint8_t DL_I2C_receiveControllerData </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get byte of data from I2C controller. </p>
<p>If using FIFO, it is first byte from the RX FIFO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Last received byte of data</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">[0x00,0xff]</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8c86dbbeacddba4fe315cf7204bdf80a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c86dbbeacddba4fe315cf7204bdf80a">&sect;&nbsp;</a></span>DL_I2C_transmitControllerData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_transmitControllerData </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set next byte to be transferred during the next transaction. </p>
<p>Does not transmit data until <a class="el" href="group___i2_c.html#gabc914d02e83818035b69347376dd1fae">DL_I2C_startControllerTransfer</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data to be transferred during the next transaction. [0x00, 0xff] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga056b90edad93a16b0e0acf09d00d8a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga056b90edad93a16b0e0acf09d00d8a37">&sect;&nbsp;</a></span>DL_I2C_getTimerPeriod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint8_t DL_I2C_getTimerPeriod </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get timer period This field is used in the equation to configure SCL_PERIOD: </p>
<p>SCL_PERIOD = (1 + TPR) * (SCL_LP + SCL_HP) * INT_CLK_PRD</p>
<p>where: SCL_PRD is the SCL line period (I2C clock)</p>
<p>TPR is the Timer Period register value (range of 1 to 127)</p>
<p>SCL_LP is the SCL Low period (fixed at 6) SCL_HP is the SCL High period (fixed at 4)</p>
<p>CLK_PRD is the functional clock period in ns</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Timer period</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">[0x00,0x7f]</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5757bad74706a15ce16f99664ee44994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5757bad74706a15ce16f99664ee44994">&sect;&nbsp;</a></span>DL_I2C_setTimerPeriod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_setTimerPeriod </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set timer period This field is used in the equation to configure SCL_PERIOD: </p>
<p>SCL_PERIOD = (1 + TPR) * (SCL_LP + SCL_HP) * INT_CLK_PRD</p>
<p>where: SCL_PRD is the SCL line period (I2C clock)</p>
<p>TPR is the Timer Period register value (range of 1 to 127)</p>
<p>SCL_LP is the SCL Low period (fixed at 6) SCL_HP is the SCL High period (fixed at 4)</p>
<p>CLK_PRD is the functional clock period in ns</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">period</td><td>Timer period [0x00, 0x7f] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga30395d7966646002a905dc4e9bd8db95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30395d7966646002a905dc4e9bd8db95">&sect;&nbsp;</a></span>DL_I2C_disableLoopbackMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_disableLoopbackMode </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable loopback mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac479032a9028dcce993ed47c333bcca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac479032a9028dcce993ed47c333bcca7">&sect;&nbsp;</a></span>DL_I2C_isLoopbackModeEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isLoopbackModeEnabled </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if loopback mode is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If loopback mode is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if loopback mode is enabled </td></tr>
    <tr><td class="paramname">false</td><td>if loopback mode is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacbdbeaa1079afc2d296dcd182df3b4fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbdbeaa1079afc2d296dcd182df3b4fd">&sect;&nbsp;</a></span>DL_I2C_enableLoopbackMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_enableLoopbackMode </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable loopback mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabaa42910112a6f1d77f47082922a71a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabaa42910112a6f1d77f47082922a71a7">&sect;&nbsp;</a></span>DL_I2C_disableMultiControllerMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_disableMultiControllerMode </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable multicontroller mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacf56279efb8dabe4aa7bc201485d8b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf56279efb8dabe4aa7bc201485d8b75">&sect;&nbsp;</a></span>DL_I2C_isMultiControllerModeEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isMultiControllerModeEnabled </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if multicontroller mode is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If multicontroller mode is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if multicontroller mode is enabled </td></tr>
    <tr><td class="paramname">false</td><td>if multicontroller mode is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga810d83f60b2fb4c199da9ae6d104fdfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga810d83f60b2fb4c199da9ae6d104fdfb">&sect;&nbsp;</a></span>DL_I2C_enableMultiControllerMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_enableMultiControllerMode </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable multicontroller mode. </p>
<p>In multicontroller mode, the SCL high time counts once the SCL line has been detected high. If this is not enabled, the high time counts as soon as the SCL line has been set high by the I2C controller</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga20a60d19c852bd5211b1bb22159eddd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20a60d19c852bd5211b1bb22159eddd3">&sect;&nbsp;</a></span>DL_I2C_disableController()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_disableController </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6a9c904bd34d9d9bd6988de91e50d3da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a9c904bd34d9d9bd6988de91e50d3da">&sect;&nbsp;</a></span>DL_I2C_isControllerEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isControllerEnabled </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if controller is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If controller is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if controller is enabled </td></tr>
    <tr><td class="paramname">false</td><td>if controller is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga47ea567bcf579ddcd87135eb2c0d261a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47ea567bcf579ddcd87135eb2c0d261a">&sect;&nbsp;</a></span>DL_I2C_enableController()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_enableController </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable controller. </p>
<p>After controller has enabled, it should not be re-enabled unless it has been disabled or by a reset, otherwise transfer failures may occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0c3b1d735442314ba89cff06125fcb55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c3b1d735442314ba89cff06125fcb55">&sect;&nbsp;</a></span>DL_I2C_disableControllerClockStretching()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_disableControllerClockStretching </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable controller clock stretching. </p>
<p>Clock stretching can be disabled if no target on the bus supports clock stretching; however, it should be typically enabled to be compliant with I2C specification.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga41da8d4578327ff630f61e1b3fa49f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41da8d4578327ff630f61e1b3fa49f70">&sect;&nbsp;</a></span>DL_I2C_isControllerClockStretchingEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isControllerClockStretchingEnabled </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if controller clock stretching is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If controller clock stretching is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if controller clock stretching is enabled </td></tr>
    <tr><td class="paramname">false</td><td>if controller clock stretching is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaefddc05c896cff0845b74c1be1bfd426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefddc05c896cff0845b74c1be1bfd426">&sect;&nbsp;</a></span>DL_I2C_enableControllerClockStretching()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_enableControllerClockStretching </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable controller clock stretching. </p>
<p>Clock stretching can be disabled if no target on the bus supports clock stretching; however, it should be typically enabled to be compliant with I2C specification.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga340f870c1df3309fb534f2765de235d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga340f870c1df3309fb534f2765de235d6">&sect;&nbsp;</a></span>DL_I2C_getSCLStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___i2_c.html#gabc56f44666d64364128360ea3dfb4f8e">DL_I2C_CONTROLLER_SCL</a> DL_I2C_getSCLStatus </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get SCL signal status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of SCL signal</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___i2_c.html#gabc56f44666d64364128360ea3dfb4f8e">DL_I2C_CONTROLLER_SCL</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf7d231b1141931166c175bf5bd301922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7d231b1141931166c175bf5bd301922">&sect;&nbsp;</a></span>DL_I2C_getSDAStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___i2_c.html#ga56a2070002c41b873cfddfa37f776caa">DL_I2C_CONTROLLER_SDA</a> DL_I2C_getSDAStatus </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get SDA signal status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of SDA signal</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___i2_c.html#ga56a2070002c41b873cfddfa37f776caa">DL_I2C_CONTROLLER_SDA</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf0c5a8a6852f06ff4ab8eeff1a0c4572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0c5a8a6852f06ff4ab8eeff1a0c4572">&sect;&nbsp;</a></span>DL_I2C_getControllerTXFIFOThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___i2_c.html#ga5f984a9185dfb1fde64fd3d8a9b3786c">DL_I2C_TX_FIFO_LEVEL</a> DL_I2C_getControllerTXFIFOThreshold </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get controller TX FIFO threshold level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indicates at what fill level in the TX FIFO a threshold will be generated</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___i2_c.html#ga5f984a9185dfb1fde64fd3d8a9b3786c">DL_I2C_TX_FIFO_LEVEL</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4f8493a8ea64bba62e283f8ff762d989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f8493a8ea64bba62e283f8ff762d989">&sect;&nbsp;</a></span>DL_I2C_setControllerTXFIFOThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_setControllerTXFIFOThreshold </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga5f984a9185dfb1fde64fd3d8a9b3786c">DL_I2C_TX_FIFO_LEVEL</a>&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set controller TX FIFO threshold level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Indicates at what fill level in the TX FIFO a threshold will be generated. One of <a class="el" href="group___i2_c.html#ga5f984a9185dfb1fde64fd3d8a9b3786c">DL_I2C_TX_FIFO_LEVEL</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga9c4828889d17785e7017ca0016a36967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c4828889d17785e7017ca0016a36967">&sect;&nbsp;</a></span>DL_I2C_stopFlushControllerTXFIFO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_stopFlushControllerTXFIFO </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop controller TX FIFO flush. </p>
<p>Before stopping the flush, check if <a class="el" href="group___i2_c.html#gaea6e1d20664eb58d38d090132ff759a7">DL_I2C_isControllerTXFIFOEmpty</a>, indicating flush is complete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4da2889dc3dc98a1601edaa1aff03883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4da2889dc3dc98a1601edaa1aff03883">&sect;&nbsp;</a></span>DL_I2C_startFlushControllerTXFIFO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_startFlushControllerTXFIFO </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start controller TX FIFO flush. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8083141c4dc74605fdef38f266b13f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8083141c4dc74605fdef38f266b13f3d">&sect;&nbsp;</a></span>DL_I2C_getControllerRXFIFOThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___i2_c.html#ga57b2e0df2ed811c2f561b1d6157eded3">DL_I2C_RX_FIFO_LEVEL</a> DL_I2C_getControllerRXFIFOThreshold </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get controller RX FIFO threshold level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indicates at what fill level in the RX FIFO a threshold will be generated</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___i2_c.html#ga57b2e0df2ed811c2f561b1d6157eded3">DL_I2C_RX_FIFO_LEVEL</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9f648e01dcb0cecb1dc2e519c11425a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f648e01dcb0cecb1dc2e519c11425a7">&sect;&nbsp;</a></span>DL_I2C_setControllerRXFIFOThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_setControllerRXFIFOThreshold </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga57b2e0df2ed811c2f561b1d6157eded3">DL_I2C_RX_FIFO_LEVEL</a>&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set controller RX FIFO threshold level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Indicates at what fill level in the RX FIFO a threshold will be generated. One of <a class="el" href="group___i2_c.html#ga57b2e0df2ed811c2f561b1d6157eded3">DL_I2C_RX_FIFO_LEVEL</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga9185adab1f6baf35ea61595bdab36e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9185adab1f6baf35ea61595bdab36e4e">&sect;&nbsp;</a></span>DL_I2C_stopFlushControllerRXFIFO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_stopFlushControllerRXFIFO </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop controller RX FIFO flush. </p>
<p>Before stopping the flush, check if <a class="el" href="group___i2_c.html#ga53f6a562cdc3ade95d3f9602c6144bcb">DL_I2C_isControllerRXFIFOEmpty</a>, indicating flush is complete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf11c7abee8feb29f73c700fcd5b83ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf11c7abee8feb29f73c700fcd5b83ea3">&sect;&nbsp;</a></span>DL_I2C_startFlushControllerRXFIFO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_startFlushControllerRXFIFO </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start controller RX FIFO flush. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga39d4762ca2ba7adc0865096c067e3832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39d4762ca2ba7adc0865096c067e3832">&sect;&nbsp;</a></span>DL_I2C_getControllerRXFIFOCounter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_I2C_getControllerRXFIFOCounter </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get number of bytes which can be read from RX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes which can be read from RX FIFO</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">[0x0,0x8]</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga194bf2a8c2569b8905570f901a650df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga194bf2a8c2569b8905570f901a650df8">&sect;&nbsp;</a></span>DL_I2C_getControllerTXFIFOCounter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_I2C_getControllerTXFIFOCounter </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get number of bytes which can be put into TX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes which can be put into TX FIFO</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">[0x0,0x8]</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga37ae65970559e9f0032d42253ea753d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37ae65970559e9f0032d42253ea753d4">&sect;&nbsp;</a></span>DL_I2C_isControllerRXFIFOFlushActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isControllerRXFIFOFlushActive </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if controller RX FIFO flush is active. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If controller RX FIFO flush is active</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if controller RX FIFO flush is active </td></tr>
    <tr><td class="paramname">false</td><td>if controller RX FIFO flush is not active </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa3c6c7fcfc90bf1b43dc2e1104354e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3c6c7fcfc90bf1b43dc2e1104354e28">&sect;&nbsp;</a></span>DL_I2C_isControllerTXFIFOFlushActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isControllerTXFIFOFlushActive </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if controller TX FIFO flush is active. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If controller TX FIFO flush is active</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if controller TX FIFO flush is active </td></tr>
    <tr><td class="paramname">false</td><td>if controller TX FIFO flush is not active </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaba4b63c11c2b74a92ab1d03943a507b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba4b63c11c2b74a92ab1d03943a507b7">&sect;&nbsp;</a></span>DL_I2C_setTargetOwnAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_setTargetOwnAddress </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set target own address. </p>
<p>This field specifies bits A9 through A0 of the target own address.</p>
<p>In 7-bit addressing mode as selected by <a class="el" href="group___i2_c.html#gac4c20c5eac3bcbf9b8afda69c5fae504">DL_I2C_setTargetAddressingMode</a>, the top 3 bits are don't care</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Value of target own address [0x00, 0x3FF] </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga77f7fb234cc0cb1df01102ee4eb5f884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77f7fb234cc0cb1df01102ee4eb5f884">&sect;&nbsp;</a></span>DL_I2C_getTargetOwnAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_I2C_getTargetOwnAddress </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get target own address. </p>
<p>Get bits A9 through A0 of the target own address.</p>
<p>In 7-bit addressing mode as selected by <a class="el" href="group___i2_c.html#gac4c20c5eac3bcbf9b8afda69c5fae504">DL_I2C_setTargetAddressingMode</a>, the top 3 bits are don't care</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Target own address</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">[0x00,0x3FF]</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga77e39f9e0f854324e7676440bd33becf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77e39f9e0f854324e7676440bd33becf">&sect;&nbsp;</a></span>DL_I2C_enableTargetOwnAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_enableTargetOwnAddress </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable target own address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#gaba4b63c11c2b74a92ab1d03943a507b7" title="Set target own address. ">DL_I2C_setTargetOwnAddress</a> </dd></dl>

</div>
</div>
<a id="ga8ca9e51a1dff1d7b5ed77f4becf88852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ca9e51a1dff1d7b5ed77f4becf88852">&sect;&nbsp;</a></span>DL_I2C_disableTargetOwnAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_disableTargetOwnAddress </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable target own address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafd31710d395b17a034a36315d22d2c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd31710d395b17a034a36315d22d2c16">&sect;&nbsp;</a></span>DL_I2C_isTargetOwnAddressEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isTargetOwnAddressEnabled </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if target own address is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If target own address is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if target own address is enabled </td></tr>
    <tr><td class="paramname">false</td><td>if target own address is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac4c20c5eac3bcbf9b8afda69c5fae504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4c20c5eac3bcbf9b8afda69c5fae504">&sect;&nbsp;</a></span>DL_I2C_setTargetAddressingMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_setTargetAddressingMode </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga2ad6170a9004cf1b5296bde4da948661">DL_I2C_TARGET_ADDRESSING_MODE</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set target addressing mode. </p>
<p>Selects the addressing mode to be used when device is configured as a target</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Addressing mode to set the target to. One of <a class="el" href="group___i2_c.html#ga2ad6170a9004cf1b5296bde4da948661">DL_I2C_TARGET_ADDRESSING_MODE</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga1933bcabc755e7698dbd0308961e672a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1933bcabc755e7698dbd0308961e672a">&sect;&nbsp;</a></span>DL_I2C_getTargetAddressingMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___i2_c.html#ga2ad6170a9004cf1b5296bde4da948661">DL_I2C_TARGET_ADDRESSING_MODE</a> DL_I2C_getTargetAddressingMode </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get target addressing mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Addressing mode the target is set to</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___i2_c.html#ga2ad6170a9004cf1b5296bde4da948661">DL_I2C_TARGET_ADDRESSING_MODE</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3fac7bd0083eeb7755cc839b6c990906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fac7bd0083eeb7755cc839b6c990906">&sect;&nbsp;</a></span>I2C_getTargetOwnAddressAlternate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t I2C_getTargetOwnAddressAlternate </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get target own address alternate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Target own address alternate</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">[0x00,0x7f]</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab17d64b92d6cf53e00b7ddfb5350d5b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab17d64b92d6cf53e00b7ddfb5350d5b0">&sect;&nbsp;</a></span>DL_I2C_setTargetOwnAddressAlternate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_setTargetOwnAddressAlternate </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set target own address alternate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Value of target own address alternate [0x00, 0x7f] </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="gaad709a97f5cf0aa4aaba50405a980041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad709a97f5cf0aa4aaba50405a980041">&sect;&nbsp;</a></span>I2C_getTargetOwnAddressAlternateMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t I2C_getTargetOwnAddressAlternateMask </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get target own address alternate mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Which bits of the target address are matched</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Bit</td><td>mask with each bit corresponding to bits A6 through A0 of the target address. Value between [0x00, 0x7F] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga419cd19263a8e6a9fd5f198cde723a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga419cd19263a8e6a9fd5f198cde723a2e">&sect;&nbsp;</a></span>DL_I2C_setTargetOwnAddressAlternateMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_setTargetOwnAddressAlternateMask </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addressMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set target own address alternate mask. </p>
<p>This field specifies bits A6 through A0 of the target address. The bits with a value of 1 in the SOAR2.OAR2_MASK field will make the corresponding incoming address bits to match by default regardless of the value inside SOAR2.OAR2 i.e. corresponding SOAR2.OAR2 bit is a don't care.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addressMask</td><td>Bit mask of address bits to match. Value between [0x00, 0x7F] </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga19850d8f84ed95205e9fe17af7f1d422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19850d8f84ed95205e9fe17af7f1d422">&sect;&nbsp;</a></span>DL_I2C_disableTargetOwnAddressAlternate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_disableTargetOwnAddressAlternate </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable usage of target own address alternate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6fec3b4324a1169bc0300ef2275f0b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fec3b4324a1169bc0300ef2275f0b23">&sect;&nbsp;</a></span>DL_I2C_isTargetOwnAddressAlternateEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isTargetOwnAddressAlternateEnabled </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if target own address alternate is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If target own address alternate is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if target own address alternate is enabled </td></tr>
    <tr><td class="paramname">false</td><td>if target own address alternate is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac5b3a4731490aa4368cc12f404a349b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5b3a4731490aa4368cc12f404a349b8">&sect;&nbsp;</a></span>DL_I2C_enableTargetOwnAddressAlternate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_enableTargetOwnAddressAlternate </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable usage of target own address alternate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga05afe3c7e59041073548de7b284bff15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05afe3c7e59041073548de7b284bff15">&sect;&nbsp;</a></span>DL_I2C_getTargetAddressMatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_I2C_getTargetAddressMatch </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the address for which address match happened. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matched Target address</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Bit</td><td>mask with each bit corresponding to the target address. Value between [0x00, 0x7F] in 7-bit mode, or [0x00, 0x3FF] in 10-bit mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga14f08672e11132685f0fe2ea6683e9c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14f08672e11132685f0fe2ea6683e9c2">&sect;&nbsp;</a></span>DL_I2C_disableTargetClockStretching()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_disableTargetClockStretching </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable target clock stretching. </p>
<p>Clock stretching should be enabled to be compliant with I2C specification and the SCL will be stretched when data must be read or written from the FIFO. It can optionally be disabled if a controller does not support it or to achieve maximum I2C frequency; however the developer should ensure that the FIFO is written or read on time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8af37270a44e4697064788dc872c91de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8af37270a44e4697064788dc872c91de">&sect;&nbsp;</a></span>DL_I2C_isTargetClockStretchingEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isTargetClockStretchingEnabled </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if target clock stretching is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If target clock stretching is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if target clock stretching is enabled </td></tr>
    <tr><td class="paramname">false</td><td>if target clock stretching is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad8abfdc0b52260539fe16106b43e75fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8abfdc0b52260539fe16106b43e75fa">&sect;&nbsp;</a></span>DL_I2C_enableTargetClockStretching()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_enableTargetClockStretching </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable target clock stretching. </p>
<p>Clock stretching should be enabled to be compliant with I2C specification and the SCL will be stretched when data must be read or written from the FIFO. It can optionally be disabled if a controller does not support it or to achieve maximum I2C frequency; however the developer should ensure that the FIFO is written or read on time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaadc76833e995d0a29ee6f10e151e6bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadc76833e995d0a29ee6f10e151e6bdd">&sect;&nbsp;</a></span>DL_I2C_disableTargetTXEmptyOnTXRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_disableTargetTXEmptyOnTXRequest </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable target TX empty interrupt on transmit request. </p>
<p>When disabled, RIS.STXEMPTY will be set when only the Target TX FIFO is empty. This allows the STXEMPTY interrupt to be used to indicate that the I2C bus is being clock stretched and that Target TX data is required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>DL_I2C_isTargetClockStretchEnabled </dd></dl>

</div>
</div>
<a id="ga6ea6eee5ba77faaf1fbf75199a71eae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ea6eee5ba77faaf1fbf75199a71eae0">&sect;&nbsp;</a></span>DL_I2C_isTargetTXEmptyOnTXRequestEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isTargetTXEmptyOnTXRequestEnabled </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if target TX empty interrupt on transmit request is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If TX empty interrupt on transmit request is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if TX empty interrupt on transmit request is enabled </td></tr>
    <tr><td class="paramname">false</td><td>if TX empty interrupt on transmit request disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0068d7cbde72e566a25ccc06eda17e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0068d7cbde72e566a25ccc06eda17e8c">&sect;&nbsp;</a></span>DL_I2C_enableTargetTXEmptyOnTXRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_enableTargetTXEmptyOnTXRequest </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable target TX empty interrupt on transmit request. </p>
<p>When enabled, RIS.STXEMPTY will be set when the Target state machine is in the TX_WAIT state which occurs when the TX FIFO is empty AND the I2C transaction is clock stretched waiting for the FIFO to receive data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf0b8295bdf7924fc64bf2ce4a4d8f601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0b8295bdf7924fc64bf2ce4a4d8f601">&sect;&nbsp;</a></span>DL_I2C_disableTargetTXTriggerInTXMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_disableTargetTXTriggerInTXMode </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable target TX trigger in TX mode. </p>
<p>When disabled, RIS.TXFIFOTRG will only be set when the Target TX FIFO is at or above the trigger level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga253e4998853775fc0c65cafb06ad656e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga253e4998853775fc0c65cafb06ad656e">&sect;&nbsp;</a></span>DL_I2C_isTargetTXTriggerInTXModeEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isTargetTXTriggerInTXModeEnabled </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if target TX trigger in TX mode is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If target TX trigger in TX mode is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if target TX trigger in TX mode is enabled </td></tr>
    <tr><td class="paramname">false</td><td>if target TX trigger in TX mode is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga24b5b0c253dd6e48b5f5d22b79bd9347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24b5b0c253dd6e48b5f5d22b79bd9347">&sect;&nbsp;</a></span>DL_I2C_enableTargetTXTriggerInTXMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_enableTargetTXTriggerInTXMode </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable TX trigger when target is in TX mode. </p>
<p>When enabled, RIS.TXFIFOTRG will be set when the Target TX FIFO has reached the trigger level AND the Target state machine is in the TXMODE as defined in the SSR register. When cleared RIS.TXFIFOTRG will be set when the Target TX FIFO is at or above the trigger level. This setting can be used to hold off the TX DMA until a transaction starts. This allows the DMA to be configured when the I2C is idle but have it wait till the transaction starts to load the Target TX FIFO, so it can load from a memory buffer that might be changing over time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___d_l___i2_c___i_n_t_e_r_r_u_p_t.html#ga1cf03fd89882fcfeea597611548f623e" title="Controller Transmit FIFO Trigger when &lt;= defined bytes. ">DL_I2C_INTERRUPT_CONTROLLER_TXFIFO_TRIGGER</a> </dd></dl>

</div>
</div>
<a id="gaf8ae7b1eba6cbe55e93ae22da245747f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8ae7b1eba6cbe55e93ae22da245747f">&sect;&nbsp;</a></span>DL_I2C_disableTargetTXWaitWhenTXFIFOStale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_disableTargetTXWaitWhenTXFIFOStale </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable target TX transfer waits when stale data in TX FIFO. </p>
<p>When disabled, the TX FIFO empty signal to the Target state machine indicates that the TX FIFO is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3ae55bea8dd37ed7cafd220a8c1ce2c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ae55bea8dd37ed7cafd220a8c1ce2c3">&sect;&nbsp;</a></span>DL_I2C_isTargetTXWaitWhenTXFIFOStaleEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isTargetTXWaitWhenTXFIFOStaleEnabled </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if target TX transfer waits when stale data in TX FIFO is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If target TX transfer waits when stale data in TX FIFO is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if target TX transfer waits when stale data in TX FIFO is enabled </td></tr>
    <tr><td class="paramname">false</td><td>if target TX transfer waits when stale data in TX FIFO is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac2258097aeb3b94ebfb7f53ecacc461e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2258097aeb3b94ebfb7f53ecacc461e">&sect;&nbsp;</a></span>DL_I2C_enableTargetTXWaitWhenTXFIFOStale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_enableTargetTXWaitWhenTXFIFOStale </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable target TX transfer waits when stale data in TX FIFO. </p>
<p>When enabled, the TX FIFO empty signal to the Target state machine will indicate that the TX FIFO is empty or that the TX FIFO data is stale. The TX FIFO data is determined to be stale when there is data in the TX FIFO when the Target state machine leaves the TXMODE as defined in the SSR register. This can occur is a Stop or timeout occur when there are bytes left in the TX FIFO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3efd7f9ce45675162427d9460a7265c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3efd7f9ce45675162427d9460a7265c7">&sect;&nbsp;</a></span>DL_I2C_disableTargetRXFullOnRXRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_disableTargetRXFullOnRXRequest </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable target RX full interrupt on receive request. </p>
<p>When disabled, RIS.SRXFULL will be set when only the Target RX FIFO is full. This allows the SRXFULL interrupt to be used to indicate that the I2C bus is being clock stretched and that the FW must either read the RX FIFO or ACK/NACK the current RX byte.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>DL_I2C_isTargetClockStretchEnabled </dd></dl>

</div>
</div>
<a id="ga814815a0b6d0f65acf4956f5d2206750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga814815a0b6d0f65acf4956f5d2206750">&sect;&nbsp;</a></span>DL_I2C_isTargetRXFullOnRXRequestEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isTargetRXFullOnRXRequestEnabled </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if target RX full interrupt on receive request is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If target RX full interrupt on receive request enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if target RX full interrupt on receive request enabled </td></tr>
    <tr><td class="paramname">false</td><td>if target RX full interrupt on receive request disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga879f5c901f7baf53c2087200a89faa98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga879f5c901f7baf53c2087200a89faa98">&sect;&nbsp;</a></span>DL_I2C_enableTargetRXFullOnRXRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_enableTargetRXFullOnRXRequest </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable target RX full interrupt on receive request. </p>
<p>When enabled, RIS.SRXFULL will be set when the Target state machine is in the RX_WAIT or RX_ACK_WAIT states which occurs when the I2C transaction is clock stretched because the RX FIFO is full or the ACKOEN has been set and the state machine is waiting for FW to ACK/NACK the current byte.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad67853056997b2155460255d059c1a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad67853056997b2155460255d059c1a82">&sect;&nbsp;</a></span>DL_I2C_disableDefaultHostAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_disableDefaultHostAddress </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable SMBus/PMBus default host address of 000 1000b. </p>
<p>When disabled, the default host address is not matched. NOTE: The host address may still be matched if programmed as an own address. The I2C module can still be addressed as a target if enabled and own address match is enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9d7f7d30627300da71312b55011b4b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d7f7d30627300da71312b55011b4b17">&sect;&nbsp;</a></span>DL_I2C_isDefaultHostAddressEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isDefaultHostAddressEnabled </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if SMBus/PMBus default host address of 000 1000b is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If default host address is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if default host address is enabled </td></tr>
    <tr><td class="paramname">false</td><td>if default host address disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad9bc4dc06816be69896fa9662154d5b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9bc4dc06816be69896fa9662154d5b1">&sect;&nbsp;</a></span>DL_I2C_enableDefaultHostAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_enableDefaultHostAddress </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable SMBus/PMBus default host address of 000 1000b. </p>
<p>When enabled, default host address of 0x0001000 is always matched by the target address match logic</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga39d10c8cf071438877967bfcbe52a476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39d10c8cf071438877967bfcbe52a476">&sect;&nbsp;</a></span>DL_I2C_disableAlertResponseAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_disableAlertResponseAddress </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable SMBus/PMBus Alert response address (ARA) of 000 1100b. </p>
<p>When disabled, the alert response address 0x0001100 is not matched. NOTE: The alert response address may still be matched if programmed as an own address. The I2C module can still be addressed as a target if enabled and own address match is enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafd9da3e2a55f105e34d5fe44577b26a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd9da3e2a55f105e34d5fe44577b26a3">&sect;&nbsp;</a></span>DL_I2C_isAlertResponseAddressEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isAlertResponseAddressEnabled </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if SMBus/PMBus Alert response address (ARA) of 000 1100b is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If alert response address is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if alert response address is enabled </td></tr>
    <tr><td class="paramname">false</td><td>if alert response address disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6212009690b9d8743c5cf7f69d6d700f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6212009690b9d8743c5cf7f69d6d700f">&sect;&nbsp;</a></span>DL_I2C_enableAlertResponseAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_enableAlertResponseAddress </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable SMBus/PMBus Alert response address (ARA) of 000 1100b. </p>
<p>When enabled, default alert response address of 0x0001100 is always matched by the target address match logic</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga44fedb11f59c29ab93da611950cba19e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44fedb11f59c29ab93da611950cba19e">&sect;&nbsp;</a></span>DL_I2C_disableDefaultDeviceAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_disableDefaultDeviceAddress </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable SMBus/PMBus default device address of 110 0001b. </p>
<p>Used for Address Resolution Protocol. When disabled, the default device address is not matched. NOTE: The host address may still be matched if programmed as an own address. The I2C module can still be addressed as a target if enabled and own address match is enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaedf788264841b8764abfb8a221227060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedf788264841b8764abfb8a221227060">&sect;&nbsp;</a></span>DL_I2C_isDefaultDeviceAddressEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isDefaultDeviceAddressEnabled </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks SMBus/PMBus default device address of 110 0001b is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If default device address is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if default device address is enabled </td></tr>
    <tr><td class="paramname">false</td><td>if default device address disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1facd6cb7a25e8f382bb56371dc22055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1facd6cb7a25e8f382bb56371dc22055">&sect;&nbsp;</a></span>DL_I2C_enableDefaultDeviceAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_enableDefaultDeviceAddress </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable SMBus/PMBus default device address of 110 0001b. </p>
<p>Used for Address Resolution Protocol. When enabled, default device address of 110 0001b is always matched by the target address match logic.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacbd08609ef6043dec36f3a525247c292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbd08609ef6043dec36f3a525247c292">&sect;&nbsp;</a></span>DL_I2C_disableTargetWakeup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_disableTargetWakeup </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable target wakeup. </p>
<p>When disabled, the target is not allowed to clock stretch on START detection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1a52d6450a42879b41e6c6bbc04c7446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a52d6450a42879b41e6c6bbc04c7446">&sect;&nbsp;</a></span>DL_I2C_isTargetWakeupEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isTargetWakeupEnabled </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if target wakeup is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If target wakeup is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if target wakeup is enabled </td></tr>
    <tr><td class="paramname">false</td><td>if target wakeup disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7ccc7e3abb0c66d964e89dfa350ee433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ccc7e3abb0c66d964e89dfa350ee433">&sect;&nbsp;</a></span>DL_I2C_enableTargetWakeup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_enableTargetWakeup </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable target wakeup. </p>
<p>Enables low-power wake-up, however it is recommended to enable target clock stretching to stretch the clock while the module is waking up.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#gad8abfdc0b52260539fe16106b43e75fa" title="Enable target clock stretching. ">DL_I2C_enableTargetClockStretching</a> </dd></dl>

</div>
</div>
<a id="ga608d56e932f29e8dd5b3dec537213faa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga608d56e932f29e8dd5b3dec537213faa">&sect;&nbsp;</a></span>DL_I2C_disableTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_disableTarget </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable target functionality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga88fb29a1e63adda45e424835248eb74c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88fb29a1e63adda45e424835248eb74c">&sect;&nbsp;</a></span>DL_I2C_isTargetEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isTargetEnabled </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if target functionality is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If target functionality is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if target functionality is enabled </td></tr>
    <tr><td class="paramname">false</td><td>if target functionality is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae7169da8c74ecf0b3c12b90d7bde2442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7169da8c74ecf0b3c12b90d7bde2442">&sect;&nbsp;</a></span>DL_I2C_enableTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_enableTarget </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable usage of target functionality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad0712ceea9a8e6e88387f22131e1a56b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0712ceea9a8e6e88387f22131e1a56b">&sect;&nbsp;</a></span>DL_I2C_disableGeneralCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_disableGeneralCall </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable general call address of 000 0000b. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8b24e00ea8c6c1907de2bff1634d0957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b24e00ea8c6c1907de2bff1634d0957">&sect;&nbsp;</a></span>DL_I2C_isGeneralCallEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isGeneralCallEnabled </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if general call address of 000 0000b is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If general call is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if general call is enabled </td></tr>
    <tr><td class="paramname">false</td><td>if general call is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae498e2c7e285730b1f7b64b940913256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae498e2c7e285730b1f7b64b940913256">&sect;&nbsp;</a></span>DL_I2C_enableGeneralCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_enableGeneralCall </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable usage of general call address of 000 0000b. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga180a1855c14f4b6fbcfe6c6ce20a3508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga180a1855c14f4b6fbcfe6c6ce20a3508">&sect;&nbsp;</a></span>DL_I2C_getTargetStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_I2C_getTargetStatus </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get status of I2C bus controller for target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of I2C bus controller for target</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Bitwise</td><td>OR of <a class="el" href="group___d_l___i2_c___t_a_r_g_e_t___s_t_a_t_u_s.html">DL_I2C_TARGET_STATUS</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeff02beed19580007ebea00afc537582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeff02beed19580007ebea00afc537582">&sect;&nbsp;</a></span>DL_I2C_receiveTargetData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint8_t DL_I2C_receiveTargetData </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get byte of data from I2C target. </p>
<p>If using FIFO, it is first byte from the RX FIFO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Last received byte of data</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">[0x00,0xff]</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga728a32502314c00aea65405242768b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga728a32502314c00aea65405242768b72">&sect;&nbsp;</a></span>DL_I2C_transmitTargetData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_transmitTargetData </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set next byte to be transferred during the next transaction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Byte of data to be transferred during the next transaction. [0x00, 0xff] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga60fedbcf080709cbc9397f4c0acbf9a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60fedbcf080709cbc9397f4c0acbf9a5">&sect;&nbsp;</a></span>DL_I2C_disableTargetACKOverride()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_disableTargetACKOverride </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable target ACK override. </p>
<p>Disable manual ACK override to automatically ACK all received bytes until the RX FIFO is full.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga374c432adec549d0b933488e72386d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga374c432adec549d0b933488e72386d40">&sect;&nbsp;</a></span>DL_I2C_isTargetACKOverrideEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isTargetACKOverrideEnabled </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if target ACK override is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If target ACK override is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if target ACK override is enabled </td></tr>
    <tr><td class="paramname">false</td><td>if target ACK override is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf5de9af9e0aabca3407b1d09e629bf4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5de9af9e0aabca3407b1d09e629bf4d">&sect;&nbsp;</a></span>DL_I2C_enableTargetACKOverride()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_enableTargetACKOverride </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable target ACK override. </p>
<p>When manual ACK override is enabled, the I2C target SCL is pulled low after the last data is received until the ACK override value (through <a class="el" href="group___i2_c.html#ga18a52fd6ef504bb29a284e2400adc6d3">DL_I2C_setTargetACKOverrideValue</a>) is written. Disable manual ACK override to automatically ACK all received bytes until the RX FIFO is full.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0a7074fa0ca84709b7e83998db121469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a7074fa0ca84709b7e83998db121469">&sect;&nbsp;</a></span>DL_I2C_getTargetACKOverrideValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___i2_c.html#ga3585e512aa5c37880960b13fe6cc212e">DL_I2C_TARGET_RESPONSE_OVERRIDE_VALUE</a> DL_I2C_getTargetACKOverrideValue </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get target acknowledge override value. </p>
<dl class="section note"><dt>Note</dt><dd>for General Call this bit will be ignored if set to NACK and target continues to receive data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>What type of response will be generated</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___i2_c.html#ga3585e512aa5c37880960b13fe6cc212e">DL_I2C_TARGET_RESPONSE_OVERRIDE_VALUE</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga18a52fd6ef504bb29a284e2400adc6d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18a52fd6ef504bb29a284e2400adc6d3">&sect;&nbsp;</a></span>DL_I2C_setTargetACKOverrideValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_setTargetACKOverrideValue </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga3585e512aa5c37880960b13fe6cc212e">DL_I2C_TARGET_RESPONSE_OVERRIDE_VALUE</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set target acknowledge override value. </p>
<dl class="section note"><dt>Note</dt><dd>for General Call this bit will be ignored if set to NACK and target continues to receive data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Indicates what type of response will be generated. One of <a class="el" href="group___i2_c.html#ga3585e512aa5c37880960b13fe6cc212e">DL_I2C_TARGET_RESPONSE_OVERRIDE_VALUE</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#gaf5de9af9e0aabca3407b1d09e629bf4d" title="Enable target ACK override. ">DL_I2C_enableTargetACKOverride</a> </dd></dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga460e5de0dbc69c6d77d2733c22a6eccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga460e5de0dbc69c6d77d2733c22a6eccc">&sect;&nbsp;</a></span>DL_I2C_disableACKOverrideOnStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_disableACKOverrideOnStart </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable target ACK override on Start Condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad91bdc379a977295260379b721c8ba30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad91bdc379a977295260379b721c8ba30">&sect;&nbsp;</a></span>DL_I2C_isACKOverrideOnStartEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isACKOverrideOnStartEnabled </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if target ACK override on Start condition is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If target ACK override on Start condition is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if target ACK override on Start condition is enabled </td></tr>
    <tr><td class="paramname">false</td><td>if target ACK override on Start condition is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga478898c30a01d0bfa871849edce8fafa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga478898c30a01d0bfa871849edce8fafa">&sect;&nbsp;</a></span>DL_I2C_enableACKOverrideOnStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_enableACKOverrideOnStart </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable target ACK override on Start condition. </p>
<p>When enabled, this bit will automatically turn on the Target ACKOEN field following a Start condition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#gaf5de9af9e0aabca3407b1d09e629bf4d" title="Enable target ACK override. ">DL_I2C_enableTargetACKOverride</a> </dd></dl>

</div>
</div>
<a id="ga455a753967c8ac89b5b6a4ea8e29e05a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga455a753967c8ac89b5b6a4ea8e29e05a">&sect;&nbsp;</a></span>DL_I2C_disableACKOverrideOnPECNext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_disableACKOverrideOnPECNext </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable target ACK override when SMBus/PMBus PEC is next byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac38423aef2f1d75aac815587414b7aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac38423aef2f1d75aac815587414b7aed">&sect;&nbsp;</a></span>DL_I2C_isACKOverrideOnPECNextEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isACKOverrideOnPECNextEnabled </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if target ACK override when SMBus/PMBus PEC is next byte is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If target ACK override when PEC is next byte is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if target ACK override when PEC is next byte is enabled </td></tr>
    <tr><td class="paramname">false</td><td>if target ACK override when PEC is next byte is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga079b44eaa37b822c6686817cf0ed0659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga079b44eaa37b822c6686817cf0ed0659">&sect;&nbsp;</a></span>DL_I2C_enableACKOverrideOnPECNext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_enableACKOverrideOnPECNext </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable target ACK override when SMBus/PMBus PEC is next byte. </p>
<p>When enabled, this bit will automatically turn on the Target ACKOEN field following the ACK/NACK of the byte received just prior to the PEC byte. Note that when ACKOEN is set, the PEC byte will not automatically be ACKed/NACKed by the state machine and FW must perform this function by writing SLAVE_SACKCTL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#gaf5de9af9e0aabca3407b1d09e629bf4d" title="Enable target ACK override. ">DL_I2C_enableTargetACKOverride</a> </dd></dl>

</div>
</div>
<a id="ga23b56f7972f717d513f1052f94e77588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23b56f7972f717d513f1052f94e77588">&sect;&nbsp;</a></span>DL_I2C_disableACKOverrideOnPECDone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_disableACKOverrideOnPECDone </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable target ACK override when SMBus/PMBus PEC is next byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf46ef6bf50ec1af4e8e92df5f6864bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf46ef6bf50ec1af4e8e92df5f6864bb9">&sect;&nbsp;</a></span>DL_I2C_isACKOverrideOnPECDoneEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isACKOverrideOnPECDoneEnabled </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if target ACK override when SMBus/PMBus PEC is next byte is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If target ACK override when PEC is next byte is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if target ACK override when PEC is next byte is enabled </td></tr>
    <tr><td class="paramname">false</td><td>if target ACK override when PEC is next byte is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa176c415a602e25c2522af69834fb22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa176c415a602e25c2522af69834fb22e">&sect;&nbsp;</a></span>DL_I2C_enableACKOverrideOnPECDone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_enableACKOverrideOnPECDone </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable target ACK override when SMBus/PMBus PEC is done. </p>
<p>When enabled, this bit will automatically turn on the Target ACKOEN field following the ACK/NACK of the received PEC byte.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#gaf5de9af9e0aabca3407b1d09e629bf4d" title="Enable target ACK override. ">DL_I2C_enableTargetACKOverride</a> </dd></dl>

</div>
</div>
<a id="ga92d7de45cbd9952e88b4a501d3f32060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92d7de45cbd9952e88b4a501d3f32060">&sect;&nbsp;</a></span>DL_I2C_getTargetPECCountValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_I2C_getTargetPECCountValue </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the target SMBus/PMBus Packet Error Checking (PEC) count value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value the PEC count is set to</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>between [0x0, 0x01FF] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf819b5cf2cb96615245fd6afc45c7fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf819b5cf2cb96615245fd6afc45c7fc8">&sect;&nbsp;</a></span>DL_I2C_setTargetPECCountValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_setTargetPECCountValue </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the target SMBus/PMBus Packet Error Checking (PEC) count value. </p>
<p>When this field is non zero, the number of I2C data bytes are counted. Refer to the device TRM for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The value to set the PEC count to. Value between [0x0, 0x01FF] </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga68022524b977b63a17465eb61af41e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68022524b977b63a17465eb61af41e8c">&sect;&nbsp;</a></span>DL_I2C_disableTargetPEC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_disableTargetPEC </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable target SMBus/PMBus Packet Error Checking (PEC) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8c12139825d0d12931fdd1587bac33a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c12139825d0d12931fdd1587bac33a8">&sect;&nbsp;</a></span>DL_I2C_isTargetPECEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isTargetPECEnabled </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if target SMBus/PMBus Packet Error Checking (PEC) is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If target PEC is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if target PEC is enabled </td></tr>
    <tr><td class="paramname">false</td><td>if target PEC is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4315266fccc9844113c697f27ec97e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4315266fccc9844113c697f27ec97e8e">&sect;&nbsp;</a></span>DL_I2C_enableTargetPEC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_enableTargetPEC </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable target SMBus/PMBus Packet Error Checking (PEC) </p>
<p>When enabled, the PEC is calculated on all bits accept the Start, Stop, ACK and NACK. The PEC LSFR and the Byte Counter is set to 0 when the State Machine is in the IDLE state, which occurs following a Stop or when a timeout occurs. The Counter is also set to 0 after the PEC byte is sent or received. Note that the NACK is automatically sent following a PEC byte that results in a PEC error. The PEC Polynomial is x^8 + x^2 + x^1 + 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga86d927b9e402e4eb3a7d2baca68eed68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86d927b9e402e4eb3a7d2baca68eed68">&sect;&nbsp;</a></span>DL_I2C_getTargetCurrentPECCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_I2C_getTargetCurrentPECCount </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current SMBus/PMBus PEC byte count of the Target state machine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current PEC byte count of the target state macione</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>between [0x0, 0x01FF] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5c363ffd7432837e627eff1ce2dddb22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c363ffd7432837e627eff1ce2dddb22">&sect;&nbsp;</a></span>DL_I2C_getTargetPECCheckedStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___i2_c.html#gafb5095cf27ba13dbca5226da84dbbf18">DL_I2C_TARGET_PEC_STATUS</a> DL_I2C_getTargetPECCheckedStatus </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get status if SMBus/PMBus target PEC was checked in last transaction. </p>
<p>The status indicates if the target PEC was checked in the transaction that occurred before the last Stop. Latched on Stop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of PEC target checked</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___i2_c.html#gafb5095cf27ba13dbca5226da84dbbf18">DL_I2C_TARGET_PEC_STATUS</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad4bd5e409f70b3580c98ded22075d28b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4bd5e409f70b3580c98ded22075d28b">&sect;&nbsp;</a></span>DL_I2C_getTargetPECCheckError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___i2_c.html#ga96c525c4ee883f347cf21e8676d7c32e">DL_I2C_TARGET_PEC_CHECK_ERROR</a> DL_I2C_getTargetPECCheckError </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get status if SMBus/PMBus target PEC had an error. </p>
<p>The status indicates if a PEC check error occurred in the transaction that occurred before the last Stop. Latched on Stop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of target PEC error check</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___i2_c.html#ga96c525c4ee883f347cf21e8676d7c32e">DL_I2C_TARGET_PEC_CHECK_ERROR</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gada7f75d8e5d94055d89d7de1194ef420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada7f75d8e5d94055d89d7de1194ef420">&sect;&nbsp;</a></span>DL_I2C_getTargetTXFIFOThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___i2_c.html#ga5f984a9185dfb1fde64fd3d8a9b3786c">DL_I2C_TX_FIFO_LEVEL</a> DL_I2C_getTargetTXFIFOThreshold </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get target TX FIFO threshold level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indicates at what fill level in the TX FIFO a threshold will be generated</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___i2_c.html#ga5f984a9185dfb1fde64fd3d8a9b3786c">DL_I2C_TX_FIFO_LEVEL</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaf24be7bed7d0f0b9a23de1da777bdec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf24be7bed7d0f0b9a23de1da777bdec">&sect;&nbsp;</a></span>DL_I2C_setTargetTXFIFOThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_setTargetTXFIFOThreshold </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga5f984a9185dfb1fde64fd3d8a9b3786c">DL_I2C_TX_FIFO_LEVEL</a>&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set target TX FIFO threshold level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Indicates at what fill level in the TX FIFO a threshold will be generated. One of <a class="el" href="group___i2_c.html#ga5f984a9185dfb1fde64fd3d8a9b3786c">DL_I2C_TX_FIFO_LEVEL</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="gae11c2c0e16d80798b2038cef33d75ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae11c2c0e16d80798b2038cef33d75ca7">&sect;&nbsp;</a></span>DL_I2C_stopFlushTargetTXFIFO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_stopFlushTargetTXFIFO </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop target TX FIFO flush. </p>
<p>Before stopping the flush, check if <a class="el" href="group___i2_c.html#ga9d724998617836aaf2aa74587ef6bee8">DL_I2C_isTargetTXFIFOEmpty</a>, indicating flush is complete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga60819784021a8fa3aad6b90195f18aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60819784021a8fa3aad6b90195f18aea">&sect;&nbsp;</a></span>DL_I2C_startFlushTargetTXFIFO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_startFlushTargetTXFIFO </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start target TX FIFO flush. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga117c9355118f61af0ed348d559b2bd04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga117c9355118f61af0ed348d559b2bd04">&sect;&nbsp;</a></span>DL_I2C_stopFlushTargetRXFIFO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_stopFlushTargetRXFIFO </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop target RX FIFO flush. </p>
<p>Before stopping the flush, check if <a class="el" href="group___i2_c.html#ga285819b2a1c642fd3559b40578bab94d">DL_I2C_isTargetRXFIFOEmpty</a>, indicating flush is complete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga303bb2ac9c7ddb984e9ecf8b065adff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga303bb2ac9c7ddb984e9ecf8b065adff7">&sect;&nbsp;</a></span>DL_I2C_startFlushTargetRXFIFO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_startFlushTargetRXFIFO </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start target RX FIFO flush. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga150e0338c2e79c4d42cb3829c732e369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga150e0338c2e79c4d42cb3829c732e369">&sect;&nbsp;</a></span>DL_I2C_getTargetRXFIFOThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___i2_c.html#ga57b2e0df2ed811c2f561b1d6157eded3">DL_I2C_RX_FIFO_LEVEL</a> DL_I2C_getTargetRXFIFOThreshold </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get target RX FIFO threshold level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indicates at what fill level in the RX FIFO a threshold will be generated</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___i2_c.html#ga57b2e0df2ed811c2f561b1d6157eded3">DL_I2C_RX_FIFO_LEVEL</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae0b07311584a20629ed7659a48e9c398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0b07311584a20629ed7659a48e9c398">&sect;&nbsp;</a></span>DL_I2C_setTargetRXFIFOThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_setTargetRXFIFOThreshold </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga57b2e0df2ed811c2f561b1d6157eded3">DL_I2C_RX_FIFO_LEVEL</a>&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set target RX FIFO threshold level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Indicates at what fill level in the RX FIFO a threshold will be generated. One of <a class="el" href="group___i2_c.html#ga57b2e0df2ed811c2f561b1d6157eded3">DL_I2C_RX_FIFO_LEVEL</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga9469148d774eff8154ccd6b6b425cefd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9469148d774eff8154ccd6b6b425cefd">&sect;&nbsp;</a></span>DL_I2C_getTargetRXFIFOCounter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_I2C_getTargetRXFIFOCounter </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get number of bytes which can be read from RX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes which can be read from RX FIFO</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">[0x0,0x8]</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac2586b9de92b58128befa744ea4e34e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2586b9de92b58128befa744ea4e34e0">&sect;&nbsp;</a></span>DL_I2C_getTargetTXFIFOCounter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_I2C_getTargetTXFIFOCounter </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get number of bytes which can be put into TX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes which can be put into TX FIFO</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">[0x0,0x8]</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga27edb7f9f5b76a0bbbea7265fbeb52b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27edb7f9f5b76a0bbbea7265fbeb52b0">&sect;&nbsp;</a></span>DL_I2C_isTargetRXFIFOFlushActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isTargetRXFIFOFlushActive </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if target RX FIFO flush is active. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If target RX FIFO flush is active</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if target RX FIFO flush is active </td></tr>
    <tr><td class="paramname">false</td><td>if target RX FIFO flush is not active </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadc94c89964d04121578b77feae799a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc94c89964d04121578b77feae799a28">&sect;&nbsp;</a></span>DL_I2C_isTargetTXFIFOFlushActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isTargetTXFIFOFlushActive </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if target TX FIFO flush is active. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If target TX FIFO flush is active</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if target TX FIFO flush is active </td></tr>
    <tr><td class="paramname">false</td><td>if target TX FIFO flush is not active </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf840137a80d61bcb583b8cd702207af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf840137a80d61bcb583b8cd702207af4">&sect;&nbsp;</a></span>DL_I2C_enableInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_enableInterrupt </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable I2C interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptMask</td><td>Bit mask of interrupts to enable. Bitwise OR of <a class="el" href="group___d_l___i2_c___i_n_t_e_r_r_u_p_t.html">DL_I2C_INTERRUPT</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1e5c0bb9422da32efc733282061ad2b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e5c0bb9422da32efc733282061ad2b2">&sect;&nbsp;</a></span>DL_I2C_disableInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_disableInterrupt </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable I2C interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptMask</td><td>Bit mask of interrupts to disable. Bitwise OR of <a class="el" href="group___d_l___i2_c___i_n_t_e_r_r_u_p_t.html">DL_I2C_INTERRUPT</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5e5530b9fc68545bebd0a5718ec916ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e5530b9fc68545bebd0a5718ec916ca">&sect;&nbsp;</a></span>DL_I2C_getEnabledInterrupts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_I2C_getEnabledInterrupts </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check which I2C interrupts are enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptMask</td><td>Bit mask of interrupts to check. Bitwise OR of <a class="el" href="group___d_l___i2_c___i_n_t_e_r_r_u_p_t.html">DL_I2C_INTERRUPT</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Which of the requested I2C interrupts are enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Bitwise</td><td>OR of <a class="el" href="group___d_l___i2_c___i_n_t_e_r_r_u_p_t.html">DL_I2C_INTERRUPT</a> values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga93698aae874d9520a3f051e080a78021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93698aae874d9520a3f051e080a78021">&sect;&nbsp;</a></span>DL_I2C_getEnabledInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_I2C_getEnabledInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check interrupt flag of enabled I2C interrupts. </p>
<p>Checks if any of the I2C interrupts that were previously enabled are pending.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptMask</td><td>Bit mask of interrupts to check. Bitwise OR of <a class="el" href="group___d_l___i2_c___i_n_t_e_r_r_u_p_t.html">DL_I2C_INTERRUPT</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Which of the requested I2C interrupts are pending</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Bitwise</td><td>OR of <a class="el" href="group___d_l___i2_c___i_n_t_e_r_r_u_p_t.html">DL_I2C_INTERRUPT</a> values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#gaf840137a80d61bcb583b8cd702207af4" title="Enable I2C interrupts. ">DL_I2C_enableInterrupt</a> </dd></dl>

</div>
</div>
<a id="ga0221bb94f08a499b8e184162c65290fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0221bb94f08a499b8e184162c65290fb">&sect;&nbsp;</a></span>DL_I2C_getRawInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_I2C_getRawInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check interrupt flag of any I2C interrupt. </p>
<p>Checks if any of the I2C interrupts are pending. Interrupts do not have to be previously enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptMask</td><td>Bit mask of interrupts to check. Bitwise OR of <a class="el" href="group___d_l___i2_c___i_n_t_e_r_r_u_p_t.html">DL_I2C_INTERRUPT</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Which of the requested I2C interrupts are pending</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Bitwise</td><td>OR of <a class="el" href="group___d_l___i2_c___i_n_t_e_r_r_u_p_t.html">DL_I2C_INTERRUPT</a> values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5db07afae50024c8e5abd69d3b7d1d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5db07afae50024c8e5abd69d3b7d1d20">&sect;&nbsp;</a></span>DL_I2C_getPendingInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___i2_c.html#ga2aee910b31c80683b76ded8e3c15776a">DL_I2C_IIDX</a> DL_I2C_getPendingInterrupt </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get highest priority pending I2C interrupt. </p>
<p>Checks if any of the I2C interrupts are pending. Interrupts do not have to be previously enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The highest priority pending I2C interrupt</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___i2_c.html#ga2aee910b31c80683b76ded8e3c15776a">DL_I2C_IIDX</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad1a0b850948a25fc7dce6dbb31b60a6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1a0b850948a25fc7dce6dbb31b60a6c">&sect;&nbsp;</a></span>DL_I2C_clearInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_clearInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear pending I2C interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptMask</td><td>Bit mask of interrupts to clear. Bitwise OR of <a class="el" href="group___d_l___i2_c___i_n_t_e_r_r_u_p_t.html">DL_I2C_INTERRUPT</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad066af4645cd9da4d7a1188af1c13a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad066af4645cd9da4d7a1188af1c13a2d">&sect;&nbsp;</a></span>DL_I2C_enableDMAEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_enableDMAEvent </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga5d85e40e4e1b371a6958921cb4d2369f">DL_I2C_EVENT_ROUTE</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interrupt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables I2C interrupt for triggering DMA events. </p>
<p>Enables the I2C interrupt to be used as the condition to generate an event to directly trigger the DMA.</p>
<p>Each event publisher <a class="el" href="group___i2_c.html#ga5d85e40e4e1b371a6958921cb4d2369f">DL_I2C_EVENT_ROUTE</a> can set any one of <a class="el" href="group___d_l___i2_c___d_m_a___i_n_t_e_r_r_u_p_t.html">DL_I2C_DMA_INTERRUPT</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Only one interrupt source should be enabled at a time.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Specifies the register event publisher to configure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interrupt</td><td>Interrupt to enable as the trigger condition for the DMA. One of <a class="el" href="group___d_l___i2_c___d_m_a___i_n_t_e_r_r_u_p_t.html">DL_I2C_DMA_INTERRUPT</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___i2_c.html#gga5d85e40e4e1b371a6958921cb4d2369fa191a6c43cb5070513da653e40459a707">DL_I2C_EVENT_ROUTE_1</a>, and <a class="el" href="group___i2_c.html#gga5d85e40e4e1b371a6958921cb4d2369faa271de21d766a1ada248b4e85db9df80">DL_I2C_EVENT_ROUTE_2</a>.</p>

</div>
</div>
<a id="gabccb980ab71fa7c9020485e561307f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabccb980ab71fa7c9020485e561307f83">&sect;&nbsp;</a></span>DL_I2C_disableDMAEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_disableDMAEvent </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga5d85e40e4e1b371a6958921cb4d2369f">DL_I2C_EVENT_ROUTE</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interrupt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables I2C interrupt from triggering DMA events. </p>
<p>Disables the I2C interrupt from being used as the condition to generate an event to directly trigger the DMA.</p>
<p>Each event publisher <a class="el" href="group___i2_c.html#ga5d85e40e4e1b371a6958921cb4d2369f">DL_I2C_EVENT_ROUTE</a> can set any one of <a class="el" href="group___d_l___i2_c___d_m_a___i_n_t_e_r_r_u_p_t.html">DL_I2C_DMA_INTERRUPT</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Specifies the register event publisher to configure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interrupt</td><td>Interrupt to disable as the trigger condition for the DMA. One of <a class="el" href="group___d_l___i2_c___d_m_a___i_n_t_e_r_r_u_p_t.html">DL_I2C_DMA_INTERRUPT</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___i2_c.html#gga5d85e40e4e1b371a6958921cb4d2369fa191a6c43cb5070513da653e40459a707">DL_I2C_EVENT_ROUTE_1</a>, and <a class="el" href="group___i2_c.html#gga5d85e40e4e1b371a6958921cb4d2369faa271de21d766a1ada248b4e85db9df80">DL_I2C_EVENT_ROUTE_2</a>.</p>

</div>
</div>
<a id="ga41b2ea39e0e5d3e47bd4e9a19a6b3741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41b2ea39e0e5d3e47bd4e9a19a6b3741">&sect;&nbsp;</a></span>DL_I2C_getEnabledDMAEvents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_I2C_getEnabledDMAEvents </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga5d85e40e4e1b371a6958921cb4d2369f">DL_I2C_EVENT_ROUTE</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check which I2C interrupt for DMA receive events is enabled. </p>
<p>This API checks the event publisher register as selected by <a class="el" href="group___i2_c.html#ga5d85e40e4e1b371a6958921cb4d2369f">DL_I2C_EVENT_ROUTE</a>, which are used for triggering the DMA for Controller or Target and receive or transmit events.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Specifies the register event publisher to configure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptMask</td><td>Bit mask of interrupts to check. Bitwise OR of <a class="el" href="group___d_l___i2_c___d_m_a___i_n_t_e_r_r_u_p_t.html">DL_I2C_DMA_INTERRUPT</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only one interrupt source should be enabled at a time.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The requested I2C interrupt status</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___d_l___i2_c___d_m_a___i_n_t_e_r_r_u_p_t.html">DL_I2C_DMA_INTERRUPT</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9d53a14e6aca31dc4ff06be1a048df87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d53a14e6aca31dc4ff06be1a048df87">&sect;&nbsp;</a></span>DL_I2C_getEnabledDMAEventStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_I2C_getEnabledDMAEventStatus </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga5d85e40e4e1b371a6958921cb4d2369f">DL_I2C_EVENT_ROUTE</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check interrupt flag of enabled I2C interrupt for DMA event. </p>
<p>Checks if any of the I2C interrupts for the DMA receive event that were previously enabled are pending. This API checks the event publisher register as selected by <a class="el" href="group___i2_c.html#ga5d85e40e4e1b371a6958921cb4d2369f">DL_I2C_EVENT_ROUTE</a>, which are used for triggering the DMA for Controller or Target and receive or transmit events.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Specifies the register event publisher to configure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptMask</td><td>Bit mask of interrupts to check. Bitwise OR of <a class="el" href="group___d_l___i2_c___d_m_a___i_n_t_e_r_r_u_p_t.html">DL_I2C_DMA_INTERRUPT</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only one interrupt source should be enabled at a time.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The requested I2C interrupt status</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___d_l___i2_c___d_m_a___i_n_t_e_r_r_u_p_t.html">DL_I2C_DMA_INTERRUPT</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#gad066af4645cd9da4d7a1188af1c13a2d" title="Enables I2C interrupt for triggering DMA events. ">DL_I2C_enableDMAEvent</a> </dd></dl>

</div>
</div>
<a id="ga4bbd769481b83644b92c94fe7907f46f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bbd769481b83644b92c94fe7907f46f">&sect;&nbsp;</a></span>DL_I2C_getRawDMAEventStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_I2C_getRawDMAEventStatus </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga5d85e40e4e1b371a6958921cb4d2369f">DL_I2C_EVENT_ROUTE</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check interrupt flag of any I2C interrupt for DMA event. </p>
<p>Checks if any of the I2C interrupts for DMA receive event are pending. Interrupts do not have to be previously enabled. This API checks the event publisher register as selected by <a class="el" href="group___i2_c.html#ga5d85e40e4e1b371a6958921cb4d2369f">DL_I2C_EVENT_ROUTE</a>, which are used for triggering the DMA for Controller or Target and receive or transmit events.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Specifies the register event publisher to configure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptMask</td><td>Bit mask of interrupts to check. Bitwise OR of <a class="el" href="group___d_l___i2_c___d_m_a___i_n_t_e_r_r_u_p_t.html">DL_I2C_DMA_INTERRUPT</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Which of the requested I2C interrupts are pending</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Bitwise</td><td>OR of <a class="el" href="group___d_l___i2_c___d_m_a___i_n_t_e_r_r_u_p_t.html">DL_I2C_DMA_INTERRUPT</a> values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa045fdc0b265088f55098cd6bac045ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa045fdc0b265088f55098cd6bac045ee">&sect;&nbsp;</a></span>DL_I2C_getPendingDMAEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___i2_c.html#gaed43e22303286e1d4d9490c2b6ddf9bd">DL_I2C_DMA_IIDX</a> DL_I2C_getPendingDMAEvent </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga5d85e40e4e1b371a6958921cb4d2369f">DL_I2C_EVENT_ROUTE</a>&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get highest priority pending I2C interrupt for DMA event. </p>
<p>Checks if any of the I2C interrupts for DMA receive event are pending. Interrupts do not have to be previously enabled. This API checks the event publisher register as selected by <a class="el" href="group___i2_c.html#ga5d85e40e4e1b371a6958921cb4d2369f">DL_I2C_EVENT_ROUTE</a>, which are used for triggering the DMA for Controller or Target and receive or transmit events.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Specifies the register event publisher to configure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The highest priority pending I2C interrupt</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___i2_c.html#gaed43e22303286e1d4d9490c2b6ddf9bd">DL_I2C_DMA_IIDX</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaefed7d1c29cd85d5b14a307214dfd29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefed7d1c29cd85d5b14a307214dfd29e">&sect;&nbsp;</a></span>DL_I2C_clearDMAEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_clearDMAEvent </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga5d85e40e4e1b371a6958921cb4d2369f">DL_I2C_EVENT_ROUTE</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interrupt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear pending SPI interrupts for DMA events. </p>
<p>This API checks the event publisher register as selected by <a class="el" href="group___i2_c.html#ga5d85e40e4e1b371a6958921cb4d2369f">DL_I2C_EVENT_ROUTE</a>, which are used for triggering the DMA for Controller or Target and receive or transmit events.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Specifies the register event publisher to configure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interrupt</td><td>Interrupt to clear. One of <a class="el" href="group___d_l___i2_c___d_m_a___i_n_t_e_r_r_u_p_t.html">DL_I2C_DMA_INTERRUPT</a> </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___i2_c.html#gga5d85e40e4e1b371a6958921cb4d2369fa191a6c43cb5070513da653e40459a707">DL_I2C_EVENT_ROUTE_1</a>, and <a class="el" href="group___i2_c.html#gga5d85e40e4e1b371a6958921cb4d2369faa271de21d766a1ada248b4e85db9df80">DL_I2C_EVENT_ROUTE_2</a>.</p>

</div>
</div>
<a id="ga590305a92aef5550d6888806524ff21f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga590305a92aef5550d6888806524ff21f">&sect;&nbsp;</a></span>DL_I2C_disableGlitchFilterChaining()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_disableGlitchFilterChaining </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable analog and digital glitch filter chaining. </p>
<p>Chaining is disabled and only digital filter output is available to IP sampling logic.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5cb2fa42e4d52ac0b5510bdeac1fbc50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cb2fa42e4d52ac0b5510bdeac1fbc50">&sect;&nbsp;</a></span>DL_I2C_isGlitchFilterChainingEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isGlitchFilterChainingEnabled </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if analog and digital glitch filter chaining is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If glitch filter chaining is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if glitch filter chaining is enabled </td></tr>
    <tr><td class="paramname">false</td><td>if glitch filter chaining is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4368b5e37313864f4aac0649ad6c27aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4368b5e37313864f4aac0649ad6c27aa">&sect;&nbsp;</a></span>DL_I2C_enableGlitchFilterChaining()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_enableGlitchFilterChaining </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable analog and digitial glitch filter chaining. </p>
<p>When enabled, analog and digital glitch filters are chained and the output of the combination is made available to IP sampling logic.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga130d812bf54576203bd73a6e2ea4c994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga130d812bf54576203bd73a6e2ea4c994">&sect;&nbsp;</a></span>DL_I2C_getTimeoutACount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_I2C_getTimeoutACount </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Timeout Counter A value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Timeout A counter value</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>between [0x0, 0xFF] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab933bbcbe7466b33a194d239068ce2a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab933bbcbe7466b33a194d239068ce2a6">&sect;&nbsp;</a></span>DL_I2C_setTimeoutACount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_setTimeoutACount </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the Timeout Counter A value. </p>
<p>Timeout A is used for SCL low detection. This field contains the upper 8 bits of a 12-bit pre-load value for the Timeout A count. NOTE: The value of the counter must be greater than 1 to enable the timeout. Each count is equal to 520 times the timeout period of the functional clock. For example, with 8MHz functional clock and a 100KHz operating I2C clock, one timeout period will be equal to (1 / 8MHz) * 520 = 65us.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The value to set the Timeout A counter to. Value between [0x0, 0xFF] </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga5d1ab6b0cfc24086c8eb3d0e6d63b93c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d1ab6b0cfc24086c8eb3d0e6d63b93c">&sect;&nbsp;</a></span>DL_I2C_disableTimeoutA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_disableTimeoutA </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable Timeout Counter A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga04fb9d2a7ff06a3783e784088b2a85f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04fb9d2a7ff06a3783e784088b2a85f3">&sect;&nbsp;</a></span>DL_I2C_isTimeoutAEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isTimeoutAEnabled </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if Timeout Counter A is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If Timeout Counter A is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if Timeout Counter A is enabled </td></tr>
    <tr><td class="paramname">false</td><td>if Timeout Counter A is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae8a0c4ba2d330856108bb8e49cd3398a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8a0c4ba2d330856108bb8e49cd3398a">&sect;&nbsp;</a></span>DL_I2C_enableTimeoutA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_enableTimeoutA </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable Timeout Counter A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3b0d8a559a6dbf2d13c16eefd88bf2e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b0d8a559a6dbf2d13c16eefd88bf2e8">&sect;&nbsp;</a></span>DL_I2C_getCurrentTimeoutACounter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_I2C_getCurrentTimeoutACounter </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current Timer Counter A value. </p>
<p>This field contains the upper 8 bits of a 12-bit current counter for Timeout Counter A.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Timeout A counter value</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>between [0x0, 0xFF] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga65bee72f5f6ded73bea7a7dd3b279281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65bee72f5f6ded73bea7a7dd3b279281">&sect;&nbsp;</a></span>DL_I2C_getTimeoutBCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_I2C_getTimeoutBCount </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Timeout Counter B value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Timeout B counter value</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>between [0x0, 0xFF] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga11b21acce041e3f67cde3e6350a5beb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11b21acce041e3f67cde3e6350a5beb7">&sect;&nbsp;</a></span>DL_I2C_setTimeoutBCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_setTimeoutBCount </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the Timeout Counter B value. </p>
<p>Timeout B is used for SCL high detection. This field contains the upper 8 bits of a 12-bit pre-load value for the Timeout A count. NOTE: The value of the counter must be greater than 1 to enable the timeout. Each count is equal to 1* clock period. For example, with 10MHz functional clock one timeout period will be equal to 1 * 10ns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The value to set the Timeout A counter to. Value between [0x0, 0xFF] </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga1bf4e8e54f57892ff43afab634c4c302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bf4e8e54f57892ff43afab634c4c302">&sect;&nbsp;</a></span>DL_I2C_disableTimeoutB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_disableTimeoutB </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable Timeout Counter B. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0651282f1aaa9514b9faa0f4ff0c8ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0651282f1aaa9514b9faa0f4ff0c8ced">&sect;&nbsp;</a></span>DL_I2C_isTimeoutBEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_I2C_isTimeoutBEnabled </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if Timeout Counter B is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If Timeout Counter B is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if Timeout Counter B is enabled </td></tr>
    <tr><td class="paramname">false</td><td>if Timeout Counter B is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga53dba946d2a45ecee74b2a440fc7f087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53dba946d2a45ecee74b2a440fc7f087">&sect;&nbsp;</a></span>DL_I2C_enableTimeoutB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_I2C_enableTimeoutB </td>
          <td>(</td>
          <td class="paramtype">I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable Timeout Counter B. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9fffbc0549c789af9f3c6c19ec1de436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fffbc0549c789af9f3c6c19ec1de436">&sect;&nbsp;</a></span>DL_I2C_getCurrentTimeoutBCounter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_I2C_getCurrentTimeoutBCounter </td>
          <td>(</td>
          <td class="paramtype">const I2C_Regs *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current Timer Counter B value. </p>
<p>This field contains the upper 8 bits of a 12-bit current counter for Timeout Counter B.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Timeout B counter value</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>between [0x0, 0xFF] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">© Copyright 1995-2025</a>, Texas Instruments Incorporated. All rights reserved. <br/>
  <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
