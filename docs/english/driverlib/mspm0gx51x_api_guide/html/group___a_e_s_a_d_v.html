<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>MSPM0GX51X Driver Library: Advanced Encryption Standard Advanced (AESADV)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MSPM0GX51X Driver Library
   &#160;<span id="projectnumber">2.05.01.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Advanced Encryption Standard Advanced (AESADV)</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Advanced Encryption Standard Advanced (AESADV):</div>
<div class="dyncontent">
<center><table><tr><td><img src="group___a_e_s_a_d_v.png" border="0" alt="" usemap="#group______a__e__s__a__d__v"/>
<map name="group______a__e__s__a__d__v" id="group______a__e__s__a__d__v">
<area shape="rect" id="node1" href="group___d_l___a_e_s_a_d_v___i_n_t_e_r_r_u_p_t.html" title="DL_AESADV_INTERRUPT" alt="" coords="212,5,393,32"/>
<area shape="rect" id="node2" href="group___d_l___a_e_s_a_d_v___e_v_e_n_t.html" title="DL_AESADV_EVENT" alt="" coords="227,56,378,83"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group___d_l___a_e_s_a_d_v___i_n_t_e_r_r_u_p_t"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_l___a_e_s_a_d_v___i_n_t_e_r_r_u_p_t.html">DL_AESADV_INTERRUPT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___d_l___a_e_s_a_d_v___e_v_e_n_t"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_l___a_e_s_a_d_v___e_v_e_n_t.html">DL_AESADV_EVENT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l___a_e_s_a_d_v___config.html">DL_AESADV_Config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration structure for the AESADV module. It contains the superset of configurable information for the control module.  <a href="struct_d_l___a_e_s_a_d_v___config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga029b393df6a4dea6cd9fd94c4ec80ff6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga029b393df6a4dea6cd9fd94c4ec80ff6">DL_AESADV_MODE_MASK</a></td></tr>
<tr class="memdesc:ga029b393df6a4dea6cd9fd94c4ec80ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">AESADV Mode mask for all modes.  <a href="#ga029b393df6a4dea6cd9fd94c4ec80ff6">More...</a><br /></td></tr>
<tr class="separator:ga029b393df6a4dea6cd9fd94c4ec80ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga3f7504f482098af84c7e1f6ee2ee5170"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga3f7504f482098af84c7e1f6ee2ee5170">DL_AESADV_IIDX</a> { <br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#gga3f7504f482098af84c7e1f6ee2ee5170aae03d48295ca3b4dd12a665907e5a88a">DL_AESADV_IIDX_INPUT_CONTEXT_READY</a> = AESADV_CPU_INT_IIDX_STAT_CNTXTRDY, 
<br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#gga3f7504f482098af84c7e1f6ee2ee5170a7e7c6306114c886f9803d4fbba6a53e8">DL_AESADV_IIDX_SAVED_OUTPUT_CONTEXT_READY</a>, 
<br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#gga3f7504f482098af84c7e1f6ee2ee5170a4f0cd2c8ee9cd9f9975b5d0d9e4c197b">DL_AESADV_IIDX_INPUT_READY</a> = AESADV_CPU_INT_IIDX_STAT_INPUTRDY, 
<br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#gga3f7504f482098af84c7e1f6ee2ee5170a500793ed5043fd71d11927d14124e44a">DL_AESADV_IIDX_OUTPUT_READY</a> = AESADV_CPU_INT_IIDX_STAT_OUTPUTRDY, 
<br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#gga3f7504f482098af84c7e1f6ee2ee5170ab5ff5a8820a00fb99e159c65196e5eb6">DL_AESADV_IIDX_DMA_INPUT_TRIGGER</a> = AESADV_DMA_TRIG_DATAIN_IIDX_STAT_TRIG0, 
<br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#gga3f7504f482098af84c7e1f6ee2ee5170a47ac891f2f41b45bd5da61cd84c871c0">DL_AESADV_IIDX_DMA_OUTPUT_TRIGGER</a>
<br />
 }</td></tr>
<tr class="separator:ga3f7504f482098af84c7e1f6ee2ee5170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga554c682ff764f2162c9abe010f1c2f41"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga554c682ff764f2162c9abe010f1c2f41">DL_AESADV_MODE</a> { <br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#gga554c682ff764f2162c9abe010f1c2f41a8368bd9fd3ee972286fbd476554890c2">DL_AESADV_MODE_ECB</a> = 0x00, 
<br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#gga554c682ff764f2162c9abe010f1c2f41a1c53f534357e64ed95e2f23f9e9d997b">DL_AESADV_MODE_CBC</a> = (AESADV_CTRL_CBC_ENABLE), 
<br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#gga554c682ff764f2162c9abe010f1c2f41afb3fe7ec94e5f80a44c8b9afd9520176">DL_AESADV_MODE_CTR</a> = (AESADV_CTRL_CTR_ENABLE), 
<br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#gga554c682ff764f2162c9abe010f1c2f41a186f7f626dd1e667bc12fcb95643bba2">DL_AESADV_MODE_ICM</a> = (AESADV_CTRL_ICM_ENABLE), 
<br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#gga554c682ff764f2162c9abe010f1c2f41ada27fe9c3fdb098a96a846c3d84c2bb4">DL_AESADV_MODE_CFB</a> = (AESADV_CTRL_CFB_ENABLE), 
<br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#gga554c682ff764f2162c9abe010f1c2f41a3891b979740127bed9ea08b316540881">DL_AESADV_MODE_OFB</a> = (AESADV_CTRL_OFB_GCM_CCM_CONT_OFB), 
<br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#gga554c682ff764f2162c9abe010f1c2f41a9b8907917f2198ad604063536053445c">DL_AESADV_MODE_CMAC</a>, 
<br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#gga554c682ff764f2162c9abe010f1c2f41a95279211ddbba2278742d305672536d9">DL_AESADV_MODE_CBCMAC</a> = (AESADV_CTRL_CBCMAC_ENABLE), 
<br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#gga554c682ff764f2162c9abe010f1c2f41a2a9b600bf2e669990c93ad9c5bcb6773">DL_AESADV_MODE_GCM_FORCE_ZERO</a>, 
<br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#gga554c682ff764f2162c9abe010f1c2f41a70b566f2250234f650c5847e28decb9f">DL_AESADV_MODE_GCM_LOAD_HASH_KEY</a>, 
<br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#gga554c682ff764f2162c9abe010f1c2f41a0af9f69c546948653096b3413d7ea1c8">DL_AESADV_MODE_GCM_AUTONOMOUS</a>, 
<br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#gga554c682ff764f2162c9abe010f1c2f41acf72d401f056baa3b4602fe4d81ca929">DL_AESADV_MODE_GCM_GHASH_ONLY</a> = (AESADV_CTRL_GCM_FORCE_ZERO), 
<br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#gga554c682ff764f2162c9abe010f1c2f41acfd482c2ea990d6b972b70a787c558a3">DL_AESADV_MODE_CCM</a> = (AESADV_CTRL_CCM_ENABLE) | (AESADV_CTRL_CTR_ENABLE)
<br />
 }</td></tr>
<tr class="separator:ga554c682ff764f2162c9abe010f1c2f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b4def1e5cd8a87acc22c34575f4d855"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga8b4def1e5cd8a87acc22c34575f4d855">DL_AESADV_KEY_SIZE</a> { <br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#gga8b4def1e5cd8a87acc22c34575f4d855a3eb042f8b9e27f93aeba4d4d6216442b">DL_AESADV_KEY_SIZE_128_BIT</a> = AESADV_CTRL_KEYSIZE_K128, 
<br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#gga8b4def1e5cd8a87acc22c34575f4d855aedd219ebf1a4171b923088d1aa98e759">DL_AESADV_KEY_SIZE_256_BIT</a> = AESADV_CTRL_KEYSIZE_K256
<br />
 }</td></tr>
<tr class="separator:ga8b4def1e5cd8a87acc22c34575f4d855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44eb3717710d41193938f41e4961db04"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga44eb3717710d41193938f41e4961db04">DL_AESADV_DIR</a> { <br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#gga44eb3717710d41193938f41e4961db04addab5de3ec225d83295e04d87422547e">DL_AESADV_DIR_ENCRYPT</a> = AESADV_CTRL_DIR_ENCRYPT, 
<br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#gga44eb3717710d41193938f41e4961db04aea2bc95f98202e1a25e28495a68fc865">DL_AESADV_DIR_DECRYPT</a> = AESADV_CTRL_DIR_DECRYPT
<br />
 }</td></tr>
<tr class="separator:ga44eb3717710d41193938f41e4961db04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab097955be26dd9f1ab86c2abcbf17caa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gab097955be26dd9f1ab86c2abcbf17caa">DL_AESADV_CTR_WIDTH</a> { <br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#ggab097955be26dd9f1ab86c2abcbf17caaaebc6e305c92c43a4aa5a227e7ee3471d">DL_AESADV_CTR_WIDTH_32_BIT</a> = AESADV_CTRL_CTR_WIDTH_CTR32, 
<br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#ggab097955be26dd9f1ab86c2abcbf17caaa6bc9e327775289184023517cee1dfebf">DL_AESADV_CTR_WIDTH_64_BIT</a> = AESADV_CTRL_CTR_WIDTH_CTR64, 
<br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#ggab097955be26dd9f1ab86c2abcbf17caaa6f1d551cd4a6bf6eb868714a3de72fb5">DL_AESADV_CTR_WIDTH_96_BIT</a> = AESADV_CTRL_CTR_WIDTH_CTR96, 
<br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#ggab097955be26dd9f1ab86c2abcbf17caaa96ede50c9129432ba32cccbe3252fa41">DL_AESADV_CTR_WIDTH_128_BIT</a> = AESADV_CTRL_CTR_WIDTH_CTR128
<br />
 }</td></tr>
<tr class="separator:gab097955be26dd9f1ab86c2abcbf17caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aaeae07de1db467360828b0321d2308"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga0aaeae07de1db467360828b0321d2308">DL_AESADV_FB_WIDTH</a> { <b>DL_AESADV_FB_WIDTH_128</b> = AESADV_CTRL_CTR_WIDTH_CFB128
 }</td></tr>
<tr class="separator:ga0aaeae07de1db467360828b0321d2308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9b86859a9a4b0bc1a58f35e65b7fc06"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gab9b86859a9a4b0bc1a58f35e65b7fc06">DL_AESADV_CCM_CTR_WIDTH</a> { <br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#ggab9b86859a9a4b0bc1a58f35e65b7fc06ac3a1081c02f24332c3d167f2d509936c">DL_AESADV_CCM_CTR_WIDTH_2_BYTES</a> = ((uint32_t) 1U &lt;&lt; AESADV_CTRL_CCML_OFS), 
<br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#ggab9b86859a9a4b0bc1a58f35e65b7fc06a30abeba3eab6d600bc28d20ebea315f6">DL_AESADV_CCM_CTR_WIDTH_3_BYTES</a> = ((uint32_t) 2 &lt;&lt; AESADV_CTRL_CCML_OFS), 
<br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#ggab9b86859a9a4b0bc1a58f35e65b7fc06a8b32ffca542563b243fd428a7f89b6a3">DL_AESADV_CCM_CTR_WIDTH_4_BYTES</a> = ((uint32_t) 3 &lt;&lt; AESADV_CTRL_CCML_OFS), 
<br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#ggab9b86859a9a4b0bc1a58f35e65b7fc06a927366b2bace5c90256c0abd2d42c472">DL_AESADV_CCM_CTR_WIDTH_5_BYTES</a> = ((uint32_t) 4 &lt;&lt; AESADV_CTRL_CCML_OFS), 
<br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#ggab9b86859a9a4b0bc1a58f35e65b7fc06a20579185f9b2c5505c0291861a9403ed">DL_AESADV_CCM_CTR_WIDTH_6_BYTES</a> = ((uint32_t) 5 &lt;&lt; AESADV_CTRL_CCML_OFS), 
<br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#ggab9b86859a9a4b0bc1a58f35e65b7fc06a4022e8fb44247c3854a8d7f19ae3f804">DL_AESADV_CCM_CTR_WIDTH_7_BYTES</a> = ((uint32_t) 6 &lt;&lt; AESADV_CTRL_CCML_OFS), 
<br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#ggab9b86859a9a4b0bc1a58f35e65b7fc06aba95065a6cb3bef0d61b4a9e80636e52">DL_AESADV_CCM_CTR_WIDTH_8_BYTES</a> = ((uint32_t) 7 &lt;&lt; AESADV_CTRL_CCML_OFS)
<br />
 }</td></tr>
<tr class="separator:gab9b86859a9a4b0bc1a58f35e65b7fc06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbb14a5048e4b37f6f1f412a610c2e95"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gacbb14a5048e4b37f6f1f412a610c2e95">DL_AESADV_CCM_TAG_WIDTH</a> { <br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#ggacbb14a5048e4b37f6f1f412a610c2e95adc37ceebb4af7ca1ecf75efdf4491255">DL_AESADV_CCM_TAG_WIDTH_1_BYTE</a> = ((uint32_t) 0 &lt;&lt; AESADV_CTRL_CCMM_OFS), 
<br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#ggacbb14a5048e4b37f6f1f412a610c2e95ae9ceba6a60bdeb0551e47ba7d6ad08b1">DL_AESADV_CCM_TAG_WIDTH_2_BYTES</a> = ((uint32_t) 1 &lt;&lt; AESADV_CTRL_CCMM_OFS), 
<br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#ggacbb14a5048e4b37f6f1f412a610c2e95ab9ec3ea2fe106f025c33bd0d24dc3b25">DL_AESADV_CCM_TAG_WIDTH_3_BYTES</a> = ((uint32_t) 2 &lt;&lt; AESADV_CTRL_CCMM_OFS), 
<br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#ggacbb14a5048e4b37f6f1f412a610c2e95a8d860a90beaef2b9258f2eb9adf4394b">DL_AESADV_CCM_TAG_WIDTH_4_BYTES</a> = ((uint32_t) 3 &lt;&lt; AESADV_CTRL_CCMM_OFS), 
<br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#ggacbb14a5048e4b37f6f1f412a610c2e95a155c95adc309162e182eae167e40814e">DL_AESADV_CCM_TAG_WIDTH_5_BYTES</a> = ((uint32_t) 4 &lt;&lt; AESADV_CTRL_CCMM_OFS), 
<br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#ggacbb14a5048e4b37f6f1f412a610c2e95af0749e2c686681d368ebe5d0fe179f45">DL_AESADV_CCM_TAG_WIDTH_6_BYTES</a> = ((uint32_t) 5 &lt;&lt; AESADV_CTRL_CCMM_OFS), 
<br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#ggacbb14a5048e4b37f6f1f412a610c2e95ab4c0830f066bb0d2c3cc197934519b78">DL_AESADV_CCM_TAG_WIDTH_7_BYTES</a> = ((uint32_t) 6 &lt;&lt; AESADV_CTRL_CCMM_OFS), 
<br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#ggacbb14a5048e4b37f6f1f412a610c2e95a46d4c6095e48978432a3a6a68b17e592">DL_AESADV_CCM_TAG_WIDTH_8_BYTES</a> = ((uint32_t) 7 &lt;&lt; AESADV_CTRL_CCMM_OFS)
<br />
 }</td></tr>
<tr class="separator:gacbb14a5048e4b37f6f1f412a610c2e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1afb4e0ea2478e30ffc11bd6b35d4f9d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga1afb4e0ea2478e30ffc11bd6b35d4f9d">DL_AESADV_STATUS</a> { <br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#gga1afb4e0ea2478e30ffc11bd6b35d4f9da9bab81bf201f8ed2c2cec461bd23930c">DL_AESADV_STATUS_SUCCESS</a>, 
<br />
&#160;&#160;<a class="el" href="group___a_e_s_a_d_v.html#gga1afb4e0ea2478e30ffc11bd6b35d4f9da8a177e5c6621d150ad0ab38504c460a9">DL_AESADV_STATUS_UNALIGNED_ACCESS</a>
<br />
 }</td></tr>
<tr class="separator:ga1afb4e0ea2478e30ffc11bd6b35d4f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gafe1dc62b1a7bd85b54ecbd8bc6351ad8"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gafe1dc62b1a7bd85b54ecbd8bc6351ad8">DL_AESADV_enablePower</a> (AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:gafe1dc62b1a7bd85b54ecbd8bc6351ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the Peripheral Write Enable (PWREN) register for the AESADV.  <a href="#gafe1dc62b1a7bd85b54ecbd8bc6351ad8">More...</a><br /></td></tr>
<tr class="separator:gafe1dc62b1a7bd85b54ecbd8bc6351ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1cbde23c65a5652fb5c7fd7fab591ab"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gac1cbde23c65a5652fb5c7fd7fab591ab">DL_AESADV_disablePower</a> (AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:gac1cbde23c65a5652fb5c7fd7fab591ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the Peripheral Write Enable (PWREN) register for the AESADV.  <a href="#gac1cbde23c65a5652fb5c7fd7fab591ab">More...</a><br /></td></tr>
<tr class="separator:gac1cbde23c65a5652fb5c7fd7fab591ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef4310d60b64363afa8c5d9cf64c18b2"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gaef4310d60b64363afa8c5d9cf64c18b2">DL_AESADV_isPowerEnabled</a> (const AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:gaef4310d60b64363afa8c5d9cf64c18b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the Peripheral Write Enable (PWREN) register for the AESADV is enabled.  <a href="#gaef4310d60b64363afa8c5d9cf64c18b2">More...</a><br /></td></tr>
<tr class="separator:gaef4310d60b64363afa8c5d9cf64c18b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf73902aca6c5d54becaa4d2ab4a901c"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gabf73902aca6c5d54becaa4d2ab4a901c">DL_AESADV_reset</a> (AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:gabf73902aca6c5d54becaa4d2ab4a901c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets AESADV module.  <a href="#gabf73902aca6c5d54becaa4d2ab4a901c">More...</a><br /></td></tr>
<tr class="separator:gabf73902aca6c5d54becaa4d2ab4a901c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae7c08c58996f82ec2d425ac29a666b5"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gaae7c08c58996f82ec2d425ac29a666b5">DL_AESADV_isReset</a> (const AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:gaae7c08c58996f82ec2d425ac29a666b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if AESADV module was reset.  <a href="#gaae7c08c58996f82ec2d425ac29a666b5">More...</a><br /></td></tr>
<tr class="separator:gaae7c08c58996f82ec2d425ac29a666b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50d62c7ea3b757dab4cf069210140166"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga50d62c7ea3b757dab4cf069210140166">DL_AESADV_isOutputReady</a> (const AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:ga50d62c7ea3b757dab4cf069210140166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if an AES output block is available to be read.  <a href="#ga50d62c7ea3b757dab4cf069210140166">More...</a><br /></td></tr>
<tr class="separator:ga50d62c7ea3b757dab4cf069210140166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d3b186a710a89f5c9cf2985ed1f0f4c"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga4d3b186a710a89f5c9cf2985ed1f0f4c">DL_AESADV_isInputReady</a> (const AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:ga4d3b186a710a89f5c9cf2985ed1f0f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the input buffer is empty, and more data can be written.  <a href="#ga4d3b186a710a89f5c9cf2985ed1f0f4c">More...</a><br /></td></tr>
<tr class="separator:ga4d3b186a710a89f5c9cf2985ed1f0f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bf3917b12c2477a3253921b775ead8a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga8bf3917b12c2477a3253921b775ead8a">DL_AESADV_setDirection</a> (AESADV_Regs *aesadv, <a class="el" href="group___a_e_s_a_d_v.html#ga44eb3717710d41193938f41e4961db04">DL_AESADV_DIR</a> direction)</td></tr>
<tr class="memdesc:ga8bf3917b12c2477a3253921b775ead8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the direction of the engine (encrypt/decrypt)  <a href="#ga8bf3917b12c2477a3253921b775ead8a">More...</a><br /></td></tr>
<tr class="separator:ga8bf3917b12c2477a3253921b775ead8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4a67d506ea218b2d8c8654e3c4b8fb0"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___a_e_s_a_d_v.html#ga44eb3717710d41193938f41e4961db04">DL_AESADV_DIR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gaf4a67d506ea218b2d8c8654e3c4b8fb0">DL_AESADV_getDirection</a> (const AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:gaf4a67d506ea218b2d8c8654e3c4b8fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the direction of the AESADV peripheral (encrypt/decrypt)  <a href="#gaf4a67d506ea218b2d8c8654e3c4b8fb0">More...</a><br /></td></tr>
<tr class="separator:gaf4a67d506ea218b2d8c8654e3c4b8fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae68377b3cf16f636529dd083b76f674c"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gae68377b3cf16f636529dd083b76f674c">DL_AESADV_setKeySize</a> (AESADV_Regs *aesadv, <a class="el" href="group___a_e_s_a_d_v.html#ga8b4def1e5cd8a87acc22c34575f4d855">DL_AESADV_KEY_SIZE</a> size)</td></tr>
<tr class="memdesc:gae68377b3cf16f636529dd083b76f674c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the key size of the AESADV peripheral.  <a href="#gae68377b3cf16f636529dd083b76f674c">More...</a><br /></td></tr>
<tr class="separator:gae68377b3cf16f636529dd083b76f674c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7beff77f204c79d46ce9850d56b6ba2c"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___a_e_s_a_d_v.html#ga8b4def1e5cd8a87acc22c34575f4d855">DL_AESADV_KEY_SIZE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga7beff77f204c79d46ce9850d56b6ba2c">DL_AESADV_getKeySize</a> (const AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:ga7beff77f204c79d46ce9850d56b6ba2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current key size of the AESADV peripheral.  <a href="#ga7beff77f204c79d46ce9850d56b6ba2c">More...</a><br /></td></tr>
<tr class="separator:ga7beff77f204c79d46ce9850d56b6ba2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0402a5a48ccdde46d4e8d0276a7ef85b"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga0402a5a48ccdde46d4e8d0276a7ef85b">DL_AESADV_setMode</a> (AESADV_Regs *aesadv, <a class="el" href="group___a_e_s_a_d_v.html#ga554c682ff764f2162c9abe010f1c2f41">DL_AESADV_MODE</a> mode)</td></tr>
<tr class="memdesc:ga0402a5a48ccdde46d4e8d0276a7ef85b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the AES algorithm mode.  <a href="#ga0402a5a48ccdde46d4e8d0276a7ef85b">More...</a><br /></td></tr>
<tr class="separator:ga0402a5a48ccdde46d4e8d0276a7ef85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45ad0650442465ea963538c60338c1b3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___a_e_s_a_d_v.html#ga554c682ff764f2162c9abe010f1c2f41">DL_AESADV_MODE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga45ad0650442465ea963538c60338c1b3">DL_AESADV_getMode</a> (const AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:ga45ad0650442465ea963538c60338c1b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current selected mode.  <a href="#ga45ad0650442465ea963538c60338c1b3">More...</a><br /></td></tr>
<tr class="separator:ga45ad0650442465ea963538c60338c1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9579c342b7e0fb73ed299b0ee5ddd8b8"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga9579c342b7e0fb73ed299b0ee5ddd8b8">DL_AESADV_setFeedbackWidth</a> (AESADV_Regs *aesadv, <a class="el" href="group___a_e_s_a_d_v.html#ga0aaeae07de1db467360828b0321d2308">DL_AESADV_FB_WIDTH</a> fbWidth)</td></tr>
<tr class="memdesc:ga9579c342b7e0fb73ed299b0ee5ddd8b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the feedback width of the AESADV peripheral.  <a href="#ga9579c342b7e0fb73ed299b0ee5ddd8b8">More...</a><br /></td></tr>
<tr class="separator:ga9579c342b7e0fb73ed299b0ee5ddd8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06f6c19f69565081d1e95ada4cb70df9"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___a_e_s_a_d_v.html#ga0aaeae07de1db467360828b0321d2308">DL_AESADV_FB_WIDTH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga06f6c19f69565081d1e95ada4cb70df9">DL_AESADV_getFeedbackWidth</a> (const AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:ga06f6c19f69565081d1e95ada4cb70df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current feedback width.  <a href="#ga06f6c19f69565081d1e95ada4cb70df9">More...</a><br /></td></tr>
<tr class="separator:ga06f6c19f69565081d1e95ada4cb70df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2786383ab4632aee2efbd0a4d73247e0"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga2786383ab4632aee2efbd0a4d73247e0">DL_AESADV_setCounterWidth</a> (AESADV_Regs *aesadv, <a class="el" href="group___a_e_s_a_d_v.html#gab097955be26dd9f1ab86c2abcbf17caa">DL_AESADV_CTR_WIDTH</a> ctrWidth)</td></tr>
<tr class="memdesc:ga2786383ab4632aee2efbd0a4d73247e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the counter width of the AESADV peripheral.  <a href="#ga2786383ab4632aee2efbd0a4d73247e0">More...</a><br /></td></tr>
<tr class="separator:ga2786383ab4632aee2efbd0a4d73247e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21a801e78f153a2d1d014554c0d8453b"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___a_e_s_a_d_v.html#gab097955be26dd9f1ab86c2abcbf17caa">DL_AESADV_CTR_WIDTH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga21a801e78f153a2d1d014554c0d8453b">DL_AESADV_getCounterWidth</a> (const AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:ga21a801e78f153a2d1d014554c0d8453b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current counter width.  <a href="#ga21a801e78f153a2d1d014554c0d8453b">More...</a><br /></td></tr>
<tr class="separator:ga21a801e78f153a2d1d014554c0d8453b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga675dcafb57bfb1f227d2fd322841f157"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga675dcafb57bfb1f227d2fd322841f157">DL_AESADV_setCCMCounterWidth</a> (AESADV_Regs *aesadv, <a class="el" href="group___a_e_s_a_d_v.html#gab9b86859a9a4b0bc1a58f35e65b7fc06">DL_AESADV_CCM_CTR_WIDTH</a> ccm_ctrWidth)</td></tr>
<tr class="memdesc:ga675dcafb57bfb1f227d2fd322841f157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the CCM counter width of the AESADV peripheral.  <a href="#ga675dcafb57bfb1f227d2fd322841f157">More...</a><br /></td></tr>
<tr class="separator:ga675dcafb57bfb1f227d2fd322841f157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41e12b3ab143df8f015d7e9bf2b56b08"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___a_e_s_a_d_v.html#gab9b86859a9a4b0bc1a58f35e65b7fc06">DL_AESADV_CCM_CTR_WIDTH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga41e12b3ab143df8f015d7e9bf2b56b08">DL_AESADV_getCCMCounterWidth</a> (const AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:ga41e12b3ab143df8f015d7e9bf2b56b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current CCM-specific counter width.  <a href="#ga41e12b3ab143df8f015d7e9bf2b56b08">More...</a><br /></td></tr>
<tr class="separator:ga41e12b3ab143df8f015d7e9bf2b56b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe52e1e19026511529593869a5d155ca"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gafe52e1e19026511529593869a5d155ca">DL_AESADV_setCCMTagWidth</a> (AESADV_Regs *aesadv, <a class="el" href="group___a_e_s_a_d_v.html#gacbb14a5048e4b37f6f1f412a610c2e95">DL_AESADV_CCM_TAG_WIDTH</a> ccm_tagWidth)</td></tr>
<tr class="memdesc:gafe52e1e19026511529593869a5d155ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the CCM authentication tag width of the AESADV peripheral.  <a href="#gafe52e1e19026511529593869a5d155ca">More...</a><br /></td></tr>
<tr class="separator:gafe52e1e19026511529593869a5d155ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4de7d10b309aaed7b4e861d2dd8c8ef2"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___a_e_s_a_d_v.html#gacbb14a5048e4b37f6f1f412a610c2e95">DL_AESADV_CCM_TAG_WIDTH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga4de7d10b309aaed7b4e861d2dd8c8ef2">DL_AESADV_getCCMTagWidth</a> (const AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:ga4de7d10b309aaed7b4e861d2dd8c8ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current CCM-specific authentication tag width.  <a href="#ga4de7d10b309aaed7b4e861d2dd8c8ef2">More...</a><br /></td></tr>
<tr class="separator:ga4de7d10b309aaed7b4e861d2dd8c8ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga741c350c430fd94c0d035b132e6f7704"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga741c350c430fd94c0d035b132e6f7704">DL_AESADV_haltOperationAndGenerateDigest</a> (AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:ga741c350c430fd94c0d035b132e6f7704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Halt operation and generate intermediate Digest for CCM/GCM.  <a href="#ga741c350c430fd94c0d035b132e6f7704">More...</a><br /></td></tr>
<tr class="separator:ga741c350c430fd94c0d035b132e6f7704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga634fb648c5bc89cf6ca987ffcd99ae09"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga634fb648c5bc89cf6ca987ffcd99ae09">DL_AESADV_resumeAADPhase</a> (AESADV_Regs *aesadv, <a class="el" href="group___a_e_s_a_d_v.html#ga554c682ff764f2162c9abe010f1c2f41">DL_AESADV_MODE</a> mode)</td></tr>
<tr class="memdesc:ga634fb648c5bc89cf6ca987ffcd99ae09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume GCM or CCM operation in the AAD phase.  <a href="#ga634fb648c5bc89cf6ca987ffcd99ae09">More...</a><br /></td></tr>
<tr class="separator:ga634fb648c5bc89cf6ca987ffcd99ae09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1128df7b533eb3f0fc4484df027f8321"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga1128df7b533eb3f0fc4484df027f8321">DL_AESADV_resumeDataPhase</a> (AESADV_Regs *aesadv, <a class="el" href="group___a_e_s_a_d_v.html#ga554c682ff764f2162c9abe010f1c2f41">DL_AESADV_MODE</a> mode)</td></tr>
<tr class="memdesc:ga1128df7b533eb3f0fc4484df027f8321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume GCM or CCM operation in the Data phase.  <a href="#ga1128df7b533eb3f0fc4484df027f8321">More...</a><br /></td></tr>
<tr class="separator:ga1128df7b533eb3f0fc4484df027f8321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb0789492acbbedcda4f07101d743669"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gafb0789492acbbedcda4f07101d743669">DL_AESADV_enableSavedOutputContext</a> (AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:gafb0789492acbbedcda4f07101d743669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the storage and return of a tag or result IV.  <a href="#gafb0789492acbbedcda4f07101d743669">More...</a><br /></td></tr>
<tr class="separator:gafb0789492acbbedcda4f07101d743669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb562db39a3d3416ced4a9b558b21cd1"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gaeb562db39a3d3416ced4a9b558b21cd1">DL_AESADV_disableSavedOutputContext</a> (AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:gaeb562db39a3d3416ced4a9b558b21cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the storage and return of a tag or result IV.  <a href="#gaeb562db39a3d3416ced4a9b558b21cd1">More...</a><br /></td></tr>
<tr class="separator:gaeb562db39a3d3416ced4a9b558b21cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacddcdbe3e806e71ef604ac008c38c16c"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gacddcdbe3e806e71ef604ac008c38c16c">DL_AESADV_isSavedOutputContextEnabled</a> (const AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:gacddcdbe3e806e71ef604ac008c38c16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the storage of additional context is enabled.  <a href="#gacddcdbe3e806e71ef604ac008c38c16c">More...</a><br /></td></tr>
<tr class="separator:gacddcdbe3e806e71ef604ac008c38c16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga783833070331fabb70a867857c8f9c8a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga783833070331fabb70a867857c8f9c8a">DL_AESADV_isSavedOutputContextReady</a> (const AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:ga783833070331fabb70a867857c8f9c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether additional output context is available to be read.  <a href="#ga783833070331fabb70a867857c8f9c8a">More...</a><br /></td></tr>
<tr class="separator:ga783833070331fabb70a867857c8f9c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bc3aa400307a24f59805e03f7217bc0"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga4bc3aa400307a24f59805e03f7217bc0">DL_AESADV_isInputContextWriteable</a> (const AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:ga4bc3aa400307a24f59805e03f7217bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the input context can be written by the application.  <a href="#ga4bc3aa400307a24f59805e03f7217bc0">More...</a><br /></td></tr>
<tr class="separator:ga4bc3aa400307a24f59805e03f7217bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaade07293524fc2235e0dff5965bbf100"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gaade07293524fc2235e0dff5965bbf100">DL_AESADV_setLowerCryptoLength</a> (AESADV_Regs *aesadv, uint32_t lowerLength)</td></tr>
<tr class="memdesc:gaade07293524fc2235e0dff5965bbf100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the lower 32 bits of the crypto input data length in bytes.  <a href="#gaade07293524fc2235e0dff5965bbf100">More...</a><br /></td></tr>
<tr class="separator:gaade07293524fc2235e0dff5965bbf100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fffb47d19570b163cec0e773f47c2fc"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga8fffb47d19570b163cec0e773f47c2fc">DL_AESADV_setUpperCryptoLength</a> (AESADV_Regs *aesadv, uint32_t upperLength)</td></tr>
<tr class="memdesc:ga8fffb47d19570b163cec0e773f47c2fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the upper 29 bits of the crypto input data length in bytes.  <a href="#ga8fffb47d19570b163cec0e773f47c2fc">More...</a><br /></td></tr>
<tr class="separator:ga8fffb47d19570b163cec0e773f47c2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade5f751db1b66488f578fb6689e43d45"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gade5f751db1b66488f578fb6689e43d45">DL_AESADV_setAADLength</a> (AESADV_Regs *aesadv, uint32_t aadLength)</td></tr>
<tr class="memdesc:gade5f751db1b66488f578fb6689e43d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the length of additional authentication data (AAD)  <a href="#gade5f751db1b66488f578fb6689e43d45">More...</a><br /></td></tr>
<tr class="separator:gade5f751db1b66488f578fb6689e43d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga908ceb58d56dd2b3e840ea585f7c263a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga908ceb58d56dd2b3e840ea585f7c263a">DL_AESADV_enableDMAOperation</a> (AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:ga908ceb58d56dd2b3e840ea585f7c263a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables DMA Operation for the AESADV module.  <a href="#ga908ceb58d56dd2b3e840ea585f7c263a">More...</a><br /></td></tr>
<tr class="separator:ga908ceb58d56dd2b3e840ea585f7c263a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab89dc856fb0fe426c0b7313ec57dc5a6"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gab89dc856fb0fe426c0b7313ec57dc5a6">DL_AESADV_disableDMAOperation</a> (AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:gab89dc856fb0fe426c0b7313ec57dc5a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables DMA Operation for the AESADV module.  <a href="#gab89dc856fb0fe426c0b7313ec57dc5a6">More...</a><br /></td></tr>
<tr class="separator:gab89dc856fb0fe426c0b7313ec57dc5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68a793ea15f898faaa2ba6fa40b85047"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga68a793ea15f898faaa2ba6fa40b85047">DL_AESADV_isDMAOperationEnabled</a> (const AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:ga68a793ea15f898faaa2ba6fa40b85047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if DMA Operation is enabled.  <a href="#ga68a793ea15f898faaa2ba6fa40b85047">More...</a><br /></td></tr>
<tr class="separator:ga68a793ea15f898faaa2ba6fa40b85047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb867819958eaeeac5760ca202072ec5"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gafb867819958eaeeac5760ca202072ec5">DL_AESADV_isUserKeyWriteEnabled</a> (const AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:gafb867819958eaeeac5760ca202072ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if User Writes to the Key Registers on the AESADV are allowed.  <a href="#gafb867819958eaeeac5760ca202072ec5">More...</a><br /></td></tr>
<tr class="separator:gafb867819958eaeeac5760ca202072ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89f2de712fd99550d60ee31265b1f54e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___a_e_s_a_d_v.html#ga1afb4e0ea2478e30ffc11bd6b35d4f9d">DL_AESADV_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga89f2de712fd99550d60ee31265b1f54e">DL_AESADV_setKey</a> (AESADV_Regs *aesadv, const uint8_t *key, <a class="el" href="group___a_e_s_a_d_v.html#ga8b4def1e5cd8a87acc22c34575f4d855">DL_AESADV_KEY_SIZE</a> keySize)</td></tr>
<tr class="memdesc:ga89f2de712fd99550d60ee31265b1f54e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a 128 or 256 bit regular key to the AESADV module.  <a href="#ga89f2de712fd99550d60ee31265b1f54e">More...</a><br /></td></tr>
<tr class="separator:ga89f2de712fd99550d60ee31265b1f54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0ff127e7be121c2b91f48258645b507"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gab0ff127e7be121c2b91f48258645b507">DL_AESADV_setKeyAligned</a> (AESADV_Regs *aesadv, const uint32_t *keyAligned, <a class="el" href="group___a_e_s_a_d_v.html#ga8b4def1e5cd8a87acc22c34575f4d855">DL_AESADV_KEY_SIZE</a> keySize)</td></tr>
<tr class="memdesc:gab0ff127e7be121c2b91f48258645b507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a 128 or 256 bit regular key to the AESADV module.  <a href="#gab0ff127e7be121c2b91f48258645b507">More...</a><br /></td></tr>
<tr class="separator:gab0ff127e7be121c2b91f48258645b507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2cb3af978007f1b262249d13017a2a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___a_e_s_a_d_v.html#ga1afb4e0ea2478e30ffc11bd6b35d4f9d">DL_AESADV_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gad2cb3af978007f1b262249d13017a2a7">DL_AESADV_setGCMHashKey</a> (AESADV_Regs *aesadv, const uint8_t *hashKey)</td></tr>
<tr class="memdesc:gad2cb3af978007f1b262249d13017a2a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the hash key  <a href="#gad2cb3af978007f1b262249d13017a2a7">More...</a><br /></td></tr>
<tr class="separator:gad2cb3af978007f1b262249d13017a2a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff639fc3d8cba3e593785ac00788028d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gaff639fc3d8cba3e593785ac00788028d">DL_AESADV_setGCMHashKeyAligned</a> (AESADV_Regs *aesadv, const uint32_t *hashKeyAligned)</td></tr>
<tr class="memdesc:gaff639fc3d8cba3e593785ac00788028d"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the hash key  <a href="#gaff639fc3d8cba3e593785ac00788028d">More...</a><br /></td></tr>
<tr class="separator:gaff639fc3d8cba3e593785ac00788028d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabb73edea2a94b4cb4c243515dd60f58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___a_e_s_a_d_v.html#ga1afb4e0ea2478e30ffc11bd6b35d4f9d">DL_AESADV_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gaabb73edea2a94b4cb4c243515dd60f58">DL_AESADV_setSecondKey</a> (AESADV_Regs *aesadv, const uint8_t *secondKey)</td></tr>
<tr class="memdesc:gaabb73edea2a94b4cb4c243515dd60f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the CBC-MAC second key.  <a href="#gaabb73edea2a94b4cb4c243515dd60f58">More...</a><br /></td></tr>
<tr class="separator:gaabb73edea2a94b4cb4c243515dd60f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga308393d0b482b34cc5e5d9e4c233e484"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga308393d0b482b34cc5e5d9e4c233e484">DL_AESADV_setSecondKeyAligned</a> (AESADV_Regs *aesadv, const uint32_t *secondKeyAligned)</td></tr>
<tr class="memdesc:ga308393d0b482b34cc5e5d9e4c233e484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the CBC-MAC second key.  <a href="#ga308393d0b482b34cc5e5d9e4c233e484">More...</a><br /></td></tr>
<tr class="separator:ga308393d0b482b34cc5e5d9e4c233e484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94c4fa30691ed5cb78ab6d8c39f1c5ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___a_e_s_a_d_v.html#ga1afb4e0ea2478e30ffc11bd6b35d4f9d">DL_AESADV_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga94c4fa30691ed5cb78ab6d8c39f1c5ed">DL_AESADV_setThirdKey</a> (AESADV_Regs *aesadv, const uint8_t *thirdKey)</td></tr>
<tr class="memdesc:ga94c4fa30691ed5cb78ab6d8c39f1c5ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the CBC-MAC third key.  <a href="#ga94c4fa30691ed5cb78ab6d8c39f1c5ed">More...</a><br /></td></tr>
<tr class="separator:ga94c4fa30691ed5cb78ab6d8c39f1c5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85195b695e19629d95405a45c68b908c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga85195b695e19629d95405a45c68b908c">DL_AESADV_setThirdKeyAligned</a> (AESADV_Regs *aesadv, const uint32_t *thirdKeyAligned)</td></tr>
<tr class="memdesc:ga85195b695e19629d95405a45c68b908c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the CBC-MAC third key.  <a href="#ga85195b695e19629d95405a45c68b908c">More...</a><br /></td></tr>
<tr class="separator:ga85195b695e19629d95405a45c68b908c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8481998bca0b6424bb58bf934959c0ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___a_e_s_a_d_v.html#ga1afb4e0ea2478e30ffc11bd6b35d4f9d">DL_AESADV_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga8481998bca0b6424bb58bf934959c0ff">DL_AESADV_loadIntermediateTAG</a> (AESADV_Regs *aesadv, const uint8_t *tag)</td></tr>
<tr class="memdesc:ga8481998bca0b6424bb58bf934959c0ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads either zero or an intermediate 128-bit TAG to resume GCM/CCM.  <a href="#ga8481998bca0b6424bb58bf934959c0ff">More...</a><br /></td></tr>
<tr class="separator:ga8481998bca0b6424bb58bf934959c0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga478a85fb154516cb486a48042f3abff3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga478a85fb154516cb486a48042f3abff3">DL_AESADV_loadIntermediateTAGAligned</a> (AESADV_Regs *aesadv, const uint32_t *tagAligned)</td></tr>
<tr class="memdesc:ga478a85fb154516cb486a48042f3abff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads either zero or an intermediate 128-bit TAG to resume GCM/CCM.  <a href="#ga478a85fb154516cb486a48042f3abff3">More...</a><br /></td></tr>
<tr class="separator:ga478a85fb154516cb486a48042f3abff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92c1172c55a19759f99a2cc6972acfe6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___a_e_s_a_d_v.html#ga1afb4e0ea2478e30ffc11bd6b35d4f9d">DL_AESADV_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga92c1172c55a19759f99a2cc6972acfe6">DL_AESADV_loadInitializationVector</a> (AESADV_Regs *aesadv, const uint8_t *iv)</td></tr>
<tr class="memdesc:ga92c1172c55a19759f99a2cc6972acfe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the 128-bit initialization vector to the AESADV module.  <a href="#ga92c1172c55a19759f99a2cc6972acfe6">More...</a><br /></td></tr>
<tr class="separator:ga92c1172c55a19759f99a2cc6972acfe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70e0fc21651b2cca542b8c3c9232fe8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga70e0fc21651b2cca542b8c3c9232fe8e">DL_AESADV_loadInitializationVectorAligned</a> (AESADV_Regs *aesadv, const uint32_t *ivAligned)</td></tr>
<tr class="memdesc:ga70e0fc21651b2cca542b8c3c9232fe8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the 128-bit initialization vector to the AESADV module.  <a href="#ga70e0fc21651b2cca542b8c3c9232fe8e">More...</a><br /></td></tr>
<tr class="separator:ga70e0fc21651b2cca542b8c3c9232fe8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaab04637c0a0463b6b91c01361aea52d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___a_e_s_a_d_v.html#ga1afb4e0ea2478e30ffc11bd6b35d4f9d">DL_AESADV_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gaaab04637c0a0463b6b91c01361aea52d">DL_AESADV_readInitializationVector</a> (AESADV_Regs *aesadv, const uint8_t *iv)</td></tr>
<tr class="memdesc:gaaab04637c0a0463b6b91c01361aea52d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the 128-bit initialization vector from the AES Module.  <a href="#gaaab04637c0a0463b6b91c01361aea52d">More...</a><br /></td></tr>
<tr class="separator:gaaab04637c0a0463b6b91c01361aea52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1aadf159a751b94643c6ea7c1e58889"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gac1aadf159a751b94643c6ea7c1e58889">DL_AESADV_readInitializationVectorAligned</a> (AESADV_Regs *aesadv, uint32_t *ivAligned)</td></tr>
<tr class="memdesc:gac1aadf159a751b94643c6ea7c1e58889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the 128-bit initialization vector from the AES Module.  <a href="#gac1aadf159a751b94643c6ea7c1e58889">More...</a><br /></td></tr>
<tr class="separator:gac1aadf159a751b94643c6ea7c1e58889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga960f99bd9c3df04b0ae95082cc548830"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga960f99bd9c3df04b0ae95082cc548830">DL_AESADV_loadCCMNonceAndCounter</a> (AESADV_Regs *aesadv, uint8_t *nonce, <a class="el" href="group___a_e_s_a_d_v.html#gab9b86859a9a4b0bc1a58f35e65b7fc06">DL_AESADV_CCM_CTR_WIDTH</a> ctrWidth)</td></tr>
<tr class="memdesc:ga960f99bd9c3df04b0ae95082cc548830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the CCM Nonce And Counter IV, also called A0.  <a href="#ga960f99bd9c3df04b0ae95082cc548830">More...</a><br /></td></tr>
<tr class="separator:ga960f99bd9c3df04b0ae95082cc548830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6210287a9b0a620659f949f4284fb0ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___a_e_s_a_d_v.html#ga1afb4e0ea2478e30ffc11bd6b35d4f9d">DL_AESADV_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga6210287a9b0a620659f949f4284fb0ba">DL_AESADV_loadInputData</a> (AESADV_Regs *aesadv, const uint8_t *data)</td></tr>
<tr class="memdesc:ga6210287a9b0a620659f949f4284fb0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">loads 128 bits (4 words) of input data  <a href="#ga6210287a9b0a620659f949f4284fb0ba">More...</a><br /></td></tr>
<tr class="separator:ga6210287a9b0a620659f949f4284fb0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd3b4defbf270b53a4f8638bb28b0502"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gafd3b4defbf270b53a4f8638bb28b0502">DL_AESADV_loadInputDataAligned</a> (AESADV_Regs *aesadv, const uint32_t *dataAligned)</td></tr>
<tr class="memdesc:gafd3b4defbf270b53a4f8638bb28b0502"><td class="mdescLeft">&#160;</td><td class="mdescRight">loads 128 bits (4 words) of input data  <a href="#gafd3b4defbf270b53a4f8638bb28b0502">More...</a><br /></td></tr>
<tr class="separator:gafd3b4defbf270b53a4f8638bb28b0502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6401f0e6210ee5f15150c50699acba0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___a_e_s_a_d_v.html#ga1afb4e0ea2478e30ffc11bd6b35d4f9d">DL_AESADV_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gab6401f0e6210ee5f15150c50699acba0">DL_AESADV_readOutputData</a> (const AESADV_Regs *aesadv, const uint8_t *data)</td></tr>
<tr class="memdesc:gab6401f0e6210ee5f15150c50699acba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads 128-bits of output data that has been encrypted/decrypted.  <a href="#gab6401f0e6210ee5f15150c50699acba0">More...</a><br /></td></tr>
<tr class="separator:gab6401f0e6210ee5f15150c50699acba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga904f17e8fbfd13cbf37d0ca1c5d9ab44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga904f17e8fbfd13cbf37d0ca1c5d9ab44">DL_AESADV_readOutputDataAligned</a> (const AESADV_Regs *aesadv, uint32_t *dataAligned)</td></tr>
<tr class="memdesc:ga904f17e8fbfd13cbf37d0ca1c5d9ab44"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads 128-bits of output data that has been encrypted/decrypted.  <a href="#ga904f17e8fbfd13cbf37d0ca1c5d9ab44">More...</a><br /></td></tr>
<tr class="separator:ga904f17e8fbfd13cbf37d0ca1c5d9ab44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81ba1b2bba9164e7119bed3e291bfc61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___a_e_s_a_d_v.html#ga1afb4e0ea2478e30ffc11bd6b35d4f9d">DL_AESADV_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga81ba1b2bba9164e7119bed3e291bfc61">DL_AESADV_readTAG</a> (const AESADV_Regs *aesadv, const uint8_t *tag)</td></tr>
<tr class="memdesc:ga81ba1b2bba9164e7119bed3e291bfc61"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads 128-bit output tag at the conclusion of operation/halt  <a href="#ga81ba1b2bba9164e7119bed3e291bfc61">More...</a><br /></td></tr>
<tr class="separator:ga81ba1b2bba9164e7119bed3e291bfc61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1450390c9e4f969ee793e900d9ceaf50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga1450390c9e4f969ee793e900d9ceaf50">DL_AESADV_readTAGAligned</a> (const AESADV_Regs *aesadv, uint32_t *tagAligned)</td></tr>
<tr class="memdesc:ga1450390c9e4f969ee793e900d9ceaf50"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads 128-bit output tag at the conclusion of operation/halt  <a href="#ga1450390c9e4f969ee793e900d9ceaf50">More...</a><br /></td></tr>
<tr class="separator:ga1450390c9e4f969ee793e900d9ceaf50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4c3ef83b58e47e5257c5b2062b81f20"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gac4c3ef83b58e47e5257c5b2062b81f20">DL_AESADV_forceInputDataAvailable</a> (AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:gac4c3ef83b58e47e5257c5b2062b81f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces AESADV to begin processing input data.  <a href="#gac4c3ef83b58e47e5257c5b2062b81f20">More...</a><br /></td></tr>
<tr class="separator:gac4c3ef83b58e47e5257c5b2062b81f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67c05bb974304ca516e46c72ae7a02ff"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga67c05bb974304ca516e46c72ae7a02ff">DL_AESADV_setCCMAlignWord</a> (AESADV_Regs *aesadv, uint32_t alignWord)</td></tr>
<tr class="memdesc:ga67c05bb974304ca516e46c72ae7a02ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the CCM AAD align data word.  <a href="#ga67c05bb974304ca516e46c72ae7a02ff">More...</a><br /></td></tr>
<tr class="separator:ga67c05bb974304ca516e46c72ae7a02ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac7c69f552939143cab3d86db2a4d44b"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gaac7c69f552939143cab3d86db2a4d44b">DL_AESADV_getCCMAlignWord</a> (const AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:gaac7c69f552939143cab3d86db2a4d44b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the CCM AAD align data word.  <a href="#gaac7c69f552939143cab3d86db2a4d44b">More...</a><br /></td></tr>
<tr class="separator:gaac7c69f552939143cab3d86db2a4d44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0f27b2740b67c402c7bdb271f399f21"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gae0f27b2740b67c402c7bdb271f399f21">DL_AESADV_setLowerBlockCount</a> (AESADV_Regs *aesadv, uint32_t lowerBlockCount)</td></tr>
<tr class="memdesc:gae0f27b2740b67c402c7bdb271f399f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the lower 32-bits of the data blocks remaining in an operation.  <a href="#gae0f27b2740b67c402c7bdb271f399f21">More...</a><br /></td></tr>
<tr class="separator:gae0f27b2740b67c402c7bdb271f399f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae75c75b301ea2bb12faa0893975ae1ec"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gae75c75b301ea2bb12faa0893975ae1ec">DL_AESADV_getLowerBlockCount</a> (const AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:gae75c75b301ea2bb12faa0893975ae1ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the lower 32-bits of the data blocks remaining in an operation.  <a href="#gae75c75b301ea2bb12faa0893975ae1ec">More...</a><br /></td></tr>
<tr class="separator:gae75c75b301ea2bb12faa0893975ae1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c1bd8ad42f507be84bdeb2f77467e11"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga4c1bd8ad42f507be84bdeb2f77467e11">DL_AESADV_setUpperBlockCount</a> (AESADV_Regs *aesadv, uint32_t upperBlockCount)</td></tr>
<tr class="memdesc:ga4c1bd8ad42f507be84bdeb2f77467e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the upper 25-bits of the data blocks remaining in an operation.  <a href="#ga4c1bd8ad42f507be84bdeb2f77467e11">More...</a><br /></td></tr>
<tr class="separator:ga4c1bd8ad42f507be84bdeb2f77467e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49c8bfdbe2910b9371fc077c903fd6f8"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga49c8bfdbe2910b9371fc077c903fd6f8">DL_AESADV_getUpperBlockCount</a> (const AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:ga49c8bfdbe2910b9371fc077c903fd6f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the upper 25-bits of the data blocks remaining in an operation.  <a href="#ga49c8bfdbe2910b9371fc077c903fd6f8">More...</a><br /></td></tr>
<tr class="separator:ga49c8bfdbe2910b9371fc077c903fd6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54e6c8aa4200a171548d3b4b9cb00eaa"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga54e6c8aa4200a171548d3b4b9cb00eaa">DL_AESADV_enableInterrupt</a> (AESADV_Regs *aesadv, uint32_t interruptMask)</td></tr>
<tr class="memdesc:ga54e6c8aa4200a171548d3b4b9cb00eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable AESADV interrupts.  <a href="#ga54e6c8aa4200a171548d3b4b9cb00eaa">More...</a><br /></td></tr>
<tr class="separator:ga54e6c8aa4200a171548d3b4b9cb00eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7922537cf28b5963a7ceffaf2d6e87fb"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga7922537cf28b5963a7ceffaf2d6e87fb">DL_AESADV_disableInterrupt</a> (AESADV_Regs *aesadv, uint32_t interruptMask)</td></tr>
<tr class="memdesc:ga7922537cf28b5963a7ceffaf2d6e87fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable AESADV interrupts.  <a href="#ga7922537cf28b5963a7ceffaf2d6e87fb">More...</a><br /></td></tr>
<tr class="separator:ga7922537cf28b5963a7ceffaf2d6e87fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2ca2472856ad8765345546c396ef2e1"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gab2ca2472856ad8765345546c396ef2e1">DL_AESADV_getEnabledInterrupts</a> (const AESADV_Regs *aesadv, uint32_t interruptMask)</td></tr>
<tr class="memdesc:gab2ca2472856ad8765345546c396ef2e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if AES Ready interrupt is enabled.  <a href="#gab2ca2472856ad8765345546c396ef2e1">More...</a><br /></td></tr>
<tr class="separator:gab2ca2472856ad8765345546c396ef2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae581b8646fe45657926297fffb4d1108"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gae581b8646fe45657926297fffb4d1108">DL_AESADV_getEnabledInterruptStatus</a> (const AESADV_Regs *aesadv, uint32_t interruptMask)</td></tr>
<tr class="memdesc:gae581b8646fe45657926297fffb4d1108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check interrupt flag of enabled AESADV interrupts.  <a href="#gae581b8646fe45657926297fffb4d1108">More...</a><br /></td></tr>
<tr class="separator:gae581b8646fe45657926297fffb4d1108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga421329334046bc2bd4f44ed4906bec60"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga421329334046bc2bd4f44ed4906bec60">DL_AESADV_getRawInterruptStatus</a> (const AESADV_Regs *aesadv, uint32_t interruptMask)</td></tr>
<tr class="memdesc:ga421329334046bc2bd4f44ed4906bec60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check interrupt flag of any AESADV interrupts.  <a href="#ga421329334046bc2bd4f44ed4906bec60">More...</a><br /></td></tr>
<tr class="separator:ga421329334046bc2bd4f44ed4906bec60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46bbd7ddc67ebf98ef62a223a9aa7d10"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___a_e_s_a_d_v.html#ga3f7504f482098af84c7e1f6ee2ee5170">DL_AESADV_IIDX</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga46bbd7ddc67ebf98ef62a223a9aa7d10">DL_AESADV_getPendingInterrupt</a> (const AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:ga46bbd7ddc67ebf98ef62a223a9aa7d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get highest priority pending AESADV interrupt.  <a href="#ga46bbd7ddc67ebf98ef62a223a9aa7d10">More...</a><br /></td></tr>
<tr class="separator:ga46bbd7ddc67ebf98ef62a223a9aa7d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7eb3a7cc695446381c4d6c8f2b64fb0"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gaf7eb3a7cc695446381c4d6c8f2b64fb0">DL_AESADV_clearInterruptStatus</a> (AESADV_Regs *aesadv, uint32_t interruptMask)</td></tr>
<tr class="memdesc:gaf7eb3a7cc695446381c4d6c8f2b64fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear pending AESADV Interrupts.  <a href="#gaf7eb3a7cc695446381c4d6c8f2b64fb0">More...</a><br /></td></tr>
<tr class="separator:gaf7eb3a7cc695446381c4d6c8f2b64fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe0964efd679714bba0ae610539735ae"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gabe0964efd679714bba0ae610539735ae">DL_AESADV_enableDMAInputTriggerEvent</a> (AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:gabe0964efd679714bba0ae610539735ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables DMA input trigger to publish AESADV write requests to the DMA.  <a href="#gabe0964efd679714bba0ae610539735ae">More...</a><br /></td></tr>
<tr class="separator:gabe0964efd679714bba0ae610539735ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga355109409c8bf8e2dfd29a18732539e7"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga355109409c8bf8e2dfd29a18732539e7">DL_AESADV_enableDMAOutputTriggerEvent</a> (AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:ga355109409c8bf8e2dfd29a18732539e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables DMA output trigger to publish AESADV read requests to the DMA.  <a href="#ga355109409c8bf8e2dfd29a18732539e7">More...</a><br /></td></tr>
<tr class="separator:ga355109409c8bf8e2dfd29a18732539e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76929642b261317b0a55e7ddd24599ac"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga76929642b261317b0a55e7ddd24599ac">DL_AESADV_disableDMAInputTriggerEvent</a> (AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:ga76929642b261317b0a55e7ddd24599ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable DMA input trigger event.  <a href="#ga76929642b261317b0a55e7ddd24599ac">More...</a><br /></td></tr>
<tr class="separator:ga76929642b261317b0a55e7ddd24599ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10672e657d89dc89e973027e763d1912"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga10672e657d89dc89e973027e763d1912">DL_AESADV_disableDMAOutputTriggerEvent</a> (AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:ga10672e657d89dc89e973027e763d1912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable DMA output trigger event.  <a href="#ga10672e657d89dc89e973027e763d1912">More...</a><br /></td></tr>
<tr class="separator:ga10672e657d89dc89e973027e763d1912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcb98ed153ca4c5b7eb90949bdc4ad45"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gadcb98ed153ca4c5b7eb90949bdc4ad45">DL_AESADV_getEnabledDMAInputTriggerEvent</a> (const AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:gadcb98ed153ca4c5b7eb90949bdc4ad45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the DMA input trigger event is enabled.  <a href="#gadcb98ed153ca4c5b7eb90949bdc4ad45">More...</a><br /></td></tr>
<tr class="separator:gadcb98ed153ca4c5b7eb90949bdc4ad45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eb639ba3b807b860540c2bd3706a262"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga0eb639ba3b807b860540c2bd3706a262">DL_AESADV_getEnabledDMAOutputTriggerEvent</a> (const AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:ga0eb639ba3b807b860540c2bd3706a262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the DMA output trigger event is enabled.  <a href="#ga0eb639ba3b807b860540c2bd3706a262">More...</a><br /></td></tr>
<tr class="separator:ga0eb639ba3b807b860540c2bd3706a262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5bb216de14afb4029f850fd7dd9056b"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gac5bb216de14afb4029f850fd7dd9056b">DL_AESADV_getEnabledDMAInputTriggerEventStatus</a> (const AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:gac5bb216de14afb4029f850fd7dd9056b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check interrupt flag of DMA input trigger event.  <a href="#gac5bb216de14afb4029f850fd7dd9056b">More...</a><br /></td></tr>
<tr class="separator:gac5bb216de14afb4029f850fd7dd9056b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d9d1aeb4264e73d6a9e598c01d676ae"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga4d9d1aeb4264e73d6a9e598c01d676ae">DL_AESADV_getEnabledDMAOutputTriggerEventStatus</a> (const AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:ga4d9d1aeb4264e73d6a9e598c01d676ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check interrupt flag of DMA output trigger event.  <a href="#ga4d9d1aeb4264e73d6a9e598c01d676ae">More...</a><br /></td></tr>
<tr class="separator:ga4d9d1aeb4264e73d6a9e598c01d676ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e4a53eace7cbbfaef2d86511a6e68a1"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga1e4a53eace7cbbfaef2d86511a6e68a1">DL_AESADV_getRawDMAInputTriggerEventStatus</a> (const AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:ga1e4a53eace7cbbfaef2d86511a6e68a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check interrupt flag of DMA input trigger event.  <a href="#ga1e4a53eace7cbbfaef2d86511a6e68a1">More...</a><br /></td></tr>
<tr class="separator:ga1e4a53eace7cbbfaef2d86511a6e68a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecc5b1b7d48d8c30666a3b7e2f239583"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gaecc5b1b7d48d8c30666a3b7e2f239583">DL_AESADV_getRawDMAOutputTriggerEventStatus</a> (const AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:gaecc5b1b7d48d8c30666a3b7e2f239583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check interrupt flag of DMA output trigger event.  <a href="#gaecc5b1b7d48d8c30666a3b7e2f239583">More...</a><br /></td></tr>
<tr class="separator:gaecc5b1b7d48d8c30666a3b7e2f239583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga813824d62e7ae3d0816f6a380cc08de3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___a_e_s_a_d_v.html#ga3f7504f482098af84c7e1f6ee2ee5170">DL_AESADV_IIDX</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga813824d62e7ae3d0816f6a380cc08de3">DL_AESADV_getPendingDMAInputTriggerEvent</a> (const AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:ga813824d62e7ae3d0816f6a380cc08de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get highest priority pending DMA input trigger event.  <a href="#ga813824d62e7ae3d0816f6a380cc08de3">More...</a><br /></td></tr>
<tr class="separator:ga813824d62e7ae3d0816f6a380cc08de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16999323e259031b491f57f42854c155"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___a_e_s_a_d_v.html#ga3f7504f482098af84c7e1f6ee2ee5170">DL_AESADV_IIDX</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga16999323e259031b491f57f42854c155">DL_AESADV_getPendingDMAOutputTriggerEvent</a> (const AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:ga16999323e259031b491f57f42854c155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get highest priority pending DMA output trigger event.  <a href="#ga16999323e259031b491f57f42854c155">More...</a><br /></td></tr>
<tr class="separator:ga16999323e259031b491f57f42854c155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d43af51870a418b9803f8dc420765de"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga3d43af51870a418b9803f8dc420765de">DL_AESADV_clearDMAInputTriggerEventStatus</a> (AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:ga3d43af51870a418b9803f8dc420765de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear pending DMA input trigger event.  <a href="#ga3d43af51870a418b9803f8dc420765de">More...</a><br /></td></tr>
<tr class="separator:ga3d43af51870a418b9803f8dc420765de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dc6f4ca16d58a6ba9a3ebd4b44d6d75"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga4dc6f4ca16d58a6ba9a3ebd4b44d6d75">DL_AESADV_clearDMAOutputTriggerEventStatus</a> (AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:ga4dc6f4ca16d58a6ba9a3ebd4b44d6d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear pending DMA output trigger event.  <a href="#ga4dc6f4ca16d58a6ba9a3ebd4b44d6d75">More...</a><br /></td></tr>
<tr class="separator:ga4dc6f4ca16d58a6ba9a3ebd4b44d6d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2f28566603a5f60c1e14a9560a5058c"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gab2f28566603a5f60c1e14a9560a5058c">DL_AESADV_getDATAINAddr</a> (const AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:gab2f28566603a5f60c1e14a9560a5058c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the address of the AESADV input data register.  <a href="#gab2f28566603a5f60c1e14a9560a5058c">More...</a><br /></td></tr>
<tr class="separator:gab2f28566603a5f60c1e14a9560a5058c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68bea28934ad0996503a7d3b6050b9ea"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga68bea28934ad0996503a7d3b6050b9ea">DL_AESADV_getDATAOUTAddr</a> (const AESADV_Regs *aesadv)</td></tr>
<tr class="memdesc:ga68bea28934ad0996503a7d3b6050b9ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the address of the AESADV output data register.  <a href="#ga68bea28934ad0996503a7d3b6050b9ea">More...</a><br /></td></tr>
<tr class="separator:ga68bea28934ad0996503a7d3b6050b9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33fbb43b746e65758b308363e2914bb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga33fbb43b746e65758b308363e2914bb8">DL_AESADV_initECB</a> (AESADV_Regs *aesadv, const <a class="el" href="struct_d_l___a_e_s_a_d_v___config.html">DL_AESADV_Config</a> *config)</td></tr>
<tr class="memdesc:ga33fbb43b746e65758b308363e2914bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the engine in the Electronic Codebook (ECB) mode.  <a href="#ga33fbb43b746e65758b308363e2914bb8">More...</a><br /></td></tr>
<tr class="separator:ga33fbb43b746e65758b308363e2914bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48add39ee72534807d574adabc4f61ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga48add39ee72534807d574adabc4f61ca">DL_AESADV_initCBC</a> (AESADV_Regs *aesadv, const <a class="el" href="struct_d_l___a_e_s_a_d_v___config.html">DL_AESADV_Config</a> *config)</td></tr>
<tr class="memdesc:ga48add39ee72534807d574adabc4f61ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the engine in the Cipher-Block Chaining (CBC) mode.  <a href="#ga48add39ee72534807d574adabc4f61ca">More...</a><br /></td></tr>
<tr class="separator:ga48add39ee72534807d574adabc4f61ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8001c8319f91c4f3bc89f96fc6d9343"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gaf8001c8319f91c4f3bc89f96fc6d9343">DL_AESADV_initCFB</a> (AESADV_Regs *aesadv, const <a class="el" href="struct_d_l___a_e_s_a_d_v___config.html">DL_AESADV_Config</a> *config)</td></tr>
<tr class="memdesc:gaf8001c8319f91c4f3bc89f96fc6d9343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the engine in the Cipher Feedback (CFB) mode.  <a href="#gaf8001c8319f91c4f3bc89f96fc6d9343">More...</a><br /></td></tr>
<tr class="separator:gaf8001c8319f91c4f3bc89f96fc6d9343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b9352dfacc7354aea98a0dbd9b75c55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga6b9352dfacc7354aea98a0dbd9b75c55">DL_AESADV_initOFB</a> (AESADV_Regs *aesadv, const <a class="el" href="struct_d_l___a_e_s_a_d_v___config.html">DL_AESADV_Config</a> *config)</td></tr>
<tr class="memdesc:ga6b9352dfacc7354aea98a0dbd9b75c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the engine in the Output Feedback (OFB) mode.  <a href="#ga6b9352dfacc7354aea98a0dbd9b75c55">More...</a><br /></td></tr>
<tr class="separator:ga6b9352dfacc7354aea98a0dbd9b75c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf649234917ffda8fb56c8849b8ed3f59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#gaf649234917ffda8fb56c8849b8ed3f59">DL_AESADV_initCTR</a> (AESADV_Regs *aesadv, const <a class="el" href="struct_d_l___a_e_s_a_d_v___config.html">DL_AESADV_Config</a> *config)</td></tr>
<tr class="memdesc:gaf649234917ffda8fb56c8849b8ed3f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the engine in the Counter (CTR) mode.  <a href="#gaf649234917ffda8fb56c8849b8ed3f59">More...</a><br /></td></tr>
<tr class="separator:gaf649234917ffda8fb56c8849b8ed3f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bd842884eeeb6394d39dca3cec080ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga2bd842884eeeb6394d39dca3cec080ac">DL_AESADV_initICM</a> (AESADV_Regs *aesadv, const <a class="el" href="struct_d_l___a_e_s_a_d_v___config.html">DL_AESADV_Config</a> *config)</td></tr>
<tr class="memdesc:ga2bd842884eeeb6394d39dca3cec080ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the engine in the Integer Counter Mode (ICM)  <a href="#ga2bd842884eeeb6394d39dca3cec080ac">More...</a><br /></td></tr>
<tr class="separator:ga2bd842884eeeb6394d39dca3cec080ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90e3e6ef1bfbe884bf0355dea9f5eee9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga90e3e6ef1bfbe884bf0355dea9f5eee9">DL_AESADV_initCMAC</a> (AESADV_Regs *aesadv, const <a class="el" href="struct_d_l___a_e_s_a_d_v___config.html">DL_AESADV_Config</a> *config)</td></tr>
<tr class="memdesc:ga90e3e6ef1bfbe884bf0355dea9f5eee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the engine in the block cipher-based Message Authentication Code (CMAC)  <a href="#ga90e3e6ef1bfbe884bf0355dea9f5eee9">More...</a><br /></td></tr>
<tr class="separator:ga90e3e6ef1bfbe884bf0355dea9f5eee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b5661b4d5d52bd1c7ad0227d54e8f77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga7b5661b4d5d52bd1c7ad0227d54e8f77">DL_AESADV_initCBCMAC</a> (AESADV_Regs *aesadv, const <a class="el" href="struct_d_l___a_e_s_a_d_v___config.html">DL_AESADV_Config</a> *config)</td></tr>
<tr class="memdesc:ga7b5661b4d5d52bd1c7ad0227d54e8f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the engine in the Cipher Block Chaining Message Authenication Code (CBC-MAC)  <a href="#ga7b5661b4d5d52bd1c7ad0227d54e8f77">More...</a><br /></td></tr>
<tr class="separator:ga7b5661b4d5d52bd1c7ad0227d54e8f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89bbf635c29581b3ac9be21ac5454568"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga89bbf635c29581b3ac9be21ac5454568">DL_AESADV_initGCM</a> (AESADV_Regs *aesadv, const <a class="el" href="struct_d_l___a_e_s_a_d_v___config.html">DL_AESADV_Config</a> *config)</td></tr>
<tr class="memdesc:ga89bbf635c29581b3ac9be21ac5454568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the engine in the Galois/Counter Mode (GCM)  <a href="#ga89bbf635c29581b3ac9be21ac5454568">More...</a><br /></td></tr>
<tr class="separator:ga89bbf635c29581b3ac9be21ac5454568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c966e126355e7911d6b087ec23dc928"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_a_d_v.html#ga6c966e126355e7911d6b087ec23dc928">DL_AESADV_initCCM</a> (AESADV_Regs *aesadv, <a class="el" href="struct_d_l___a_e_s_a_d_v___config.html">DL_AESADV_Config</a> *config)</td></tr>
<tr class="memdesc:ga6c966e126355e7911d6b087ec23dc928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the engine in the Counter &amp; CBC-MAC (CCM)mode.  <a href="#ga6c966e126355e7911d6b087ec23dc928">More...</a><br /></td></tr>
<tr class="separator:ga6c966e126355e7911d6b087ec23dc928"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><a class="anchor" id="ti_dl_dl_aesadv_Overview"></a></p><h1>Overview</h1>
<p>The AESADV DriverLib allows full configuration of the MSPM0 AESADV module. The AESADV accelerator module accelerates encryption and decryption operations in hardware based on the FIPS PUB 197 advanced encryption standard (AES).</p>
<hr/>
 <h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga029b393df6a4dea6cd9fd94c4ec80ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga029b393df6a4dea6cd9fd94c4ec80ff6">&sect;&nbsp;</a></span>DL_AESADV_MODE_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DL_AESADV_MODE_MASK</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((AESADV_CTRL_CBC_MASK) | \</div><div class="line">                (AESADV_CTRL_CTR_MASK)     |      (AESADV_CTRL_ICM_MASK) | \</div><div class="line">                (AESADV_CTRL_CFB_MASK)     |   (AESADV_CTRL_CBCMAC_MASK) | \</div><div class="line">                (AESADV_CTRL_GCM_MASK)     |      (AESADV_CTRL_CCM_MASK) | \</div><div class="line">                (AESADV_CTRL_OFB_GCM_CCM_CONT_MASK) | 0x02000000)</div></div><!-- fragment -->
<p>AESADV Mode mask for all modes. </p>

<p>Referenced by <a class="el" href="group___a_e_s_a_d_v.html#ga45ad0650442465ea963538c60338c1b3">DL_AESADV_getMode()</a>, <a class="el" href="group___a_e_s_a_d_v.html#ga634fb648c5bc89cf6ca987ffcd99ae09">DL_AESADV_resumeAADPhase()</a>, <a class="el" href="group___a_e_s_a_d_v.html#ga1128df7b533eb3f0fc4484df027f8321">DL_AESADV_resumeDataPhase()</a>, and <a class="el" href="group___a_e_s_a_d_v.html#ga0402a5a48ccdde46d4e8d0276a7ef85b">DL_AESADV_setMode()</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga3f7504f482098af84c7e1f6ee2ee5170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f7504f482098af84c7e1f6ee2ee5170">&sect;&nbsp;</a></span>DL_AESADV_IIDX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_e_s_a_d_v.html#ga3f7504f482098af84c7e1f6ee2ee5170">DL_AESADV_IIDX</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga3f7504f482098af84c7e1f6ee2ee5170aae03d48295ca3b4dd12a665907e5a88a"></a>DL_AESADV_IIDX_INPUT_CONTEXT_READY&#160;</td><td class="fielddoc"><p>AESADV interrupt index for input context ready to be written </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3f7504f482098af84c7e1f6ee2ee5170a7e7c6306114c886f9803d4fbba6a53e8"></a>DL_AESADV_IIDX_SAVED_OUTPUT_CONTEXT_READY&#160;</td><td class="fielddoc"><p>AESADV interrupt index for saved output context (tag/IV) available </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3f7504f482098af84c7e1f6ee2ee5170a4f0cd2c8ee9cd9f9975b5d0d9e4c197b"></a>DL_AESADV_IIDX_INPUT_READY&#160;</td><td class="fielddoc"><p>AESADV interrupt index indicating the engine can take more input. Not compatible with <a class="el" href="group___a_e_s_a_d_v.html#ga908ceb58d56dd2b3e840ea585f7c263a">DL_AESADV_enableDMAOperation</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3f7504f482098af84c7e1f6ee2ee5170a500793ed5043fd71d11927d14124e44a"></a>DL_AESADV_IIDX_OUTPUT_READY&#160;</td><td class="fielddoc"><p>AESADV interrupt index indicating the engine has available output data. Not compatible with <a class="el" href="group___a_e_s_a_d_v.html#ga908ceb58d56dd2b3e840ea585f7c263a">DL_AESADV_enableDMAOperation</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3f7504f482098af84c7e1f6ee2ee5170ab5ff5a8820a00fb99e159c65196e5eb6"></a>DL_AESADV_IIDX_DMA_INPUT_TRIGGER&#160;</td><td class="fielddoc"><p>AES interrupt index for enabling DMA input request trigger event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3f7504f482098af84c7e1f6ee2ee5170a47ac891f2f41b45bd5da61cd84c871c0"></a>DL_AESADV_IIDX_DMA_OUTPUT_TRIGGER&#160;</td><td class="fielddoc"><p>AES interrupt index for enabling DMA output request trigger event </p>
</td></tr>
</table>

</div>
</div>
<a id="ga554c682ff764f2162c9abe010f1c2f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga554c682ff764f2162c9abe010f1c2f41">&sect;&nbsp;</a></span>DL_AESADV_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_e_s_a_d_v.html#ga554c682ff764f2162c9abe010f1c2f41">DL_AESADV_MODE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga554c682ff764f2162c9abe010f1c2f41a8368bd9fd3ee972286fbd476554890c2"></a>DL_AESADV_MODE_ECB&#160;</td><td class="fielddoc"><p>Electronic Codebook (ECB) mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga554c682ff764f2162c9abe010f1c2f41a1c53f534357e64ed95e2f23f9e9d997b"></a>DL_AESADV_MODE_CBC&#160;</td><td class="fielddoc"><p>Cipher Block Chaining (CBC) mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga554c682ff764f2162c9abe010f1c2f41afb3fe7ec94e5f80a44c8b9afd9520176"></a>DL_AESADV_MODE_CTR&#160;</td><td class="fielddoc"><p>Counter (CTR) mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga554c682ff764f2162c9abe010f1c2f41a186f7f626dd1e667bc12fcb95643bba2"></a>DL_AESADV_MODE_ICM&#160;</td><td class="fielddoc"><p>Integer Counter Mode (ICM). ICM is a variant of CTR with a 16-bit wide counter </p>
</td></tr>
<tr><td class="fieldname"><a id="gga554c682ff764f2162c9abe010f1c2f41ada27fe9c3fdb098a96a846c3d84c2bb4"></a>DL_AESADV_MODE_CFB&#160;</td><td class="fielddoc"><p>Cipher Feedback (CFB) mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga554c682ff764f2162c9abe010f1c2f41a3891b979740127bed9ea08b316540881"></a>DL_AESADV_MODE_OFB&#160;</td><td class="fielddoc"><p>Output Feedback (OFB) mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga554c682ff764f2162c9abe010f1c2f41a9b8907917f2198ad604063536053445c"></a>DL_AESADV_MODE_CMAC&#160;</td><td class="fielddoc"><p>Cipher-based message authentication code (CMAC). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga554c682ff764f2162c9abe010f1c2f41a95279211ddbba2278742d305672536d9"></a>DL_AESADV_MODE_CBCMAC&#160;</td><td class="fielddoc"><p>Cipher block chaining message authentication code (CBC-MAC) mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga554c682ff764f2162c9abe010f1c2f41a2a9b600bf2e669990c93ad9c5bcb6773"></a>DL_AESADV_MODE_GCM_FORCE_ZERO&#160;</td><td class="fielddoc"><p>Galois/Counter Mode (GCM) with GHASH (GHASH_H loaded and Y0-encrypted forced to 0) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga554c682ff764f2162c9abe010f1c2f41a70b566f2250234f650c5847e28decb9f"></a>DL_AESADV_MODE_GCM_LOAD_HASH_KEY&#160;</td><td class="fielddoc"><p>Galois/Counter Mode (GCM) with GHASH (H loaded Y0-encrypted calculated internally) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga554c682ff764f2162c9abe010f1c2f41a0af9f69c546948653096b3413d7ea1c8"></a>DL_AESADV_MODE_GCM_AUTONOMOUS&#160;</td><td class="fielddoc"><p>Galois/Counter Mode (GCM) with Autonomous GHASH (Both H and Y0-encrypted calculated internally) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga554c682ff764f2162c9abe010f1c2f41acf72d401f056baa3b4602fe4d81ca929"></a>DL_AESADV_MODE_GCM_GHASH_ONLY&#160;</td><td class="fielddoc"><p>Galois/Counter Mode GHASH only. Direction must be Decrypt </p>
</td></tr>
<tr><td class="fieldname"><a id="gga554c682ff764f2162c9abe010f1c2f41acfd482c2ea990d6b972b70a787c558a3"></a>DL_AESADV_MODE_CCM&#160;</td><td class="fielddoc"><p>Cipher block chaining, message authentication code (CCM) mode </p>
</td></tr>
</table>

</div>
</div>
<a id="ga8b4def1e5cd8a87acc22c34575f4d855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b4def1e5cd8a87acc22c34575f4d855">&sect;&nbsp;</a></span>DL_AESADV_KEY_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_e_s_a_d_v.html#ga8b4def1e5cd8a87acc22c34575f4d855">DL_AESADV_KEY_SIZE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga8b4def1e5cd8a87acc22c34575f4d855a3eb042f8b9e27f93aeba4d4d6216442b"></a>DL_AESADV_KEY_SIZE_128_BIT&#160;</td><td class="fielddoc"><p>128-bit Key Size </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8b4def1e5cd8a87acc22c34575f4d855aedd219ebf1a4171b923088d1aa98e759"></a>DL_AESADV_KEY_SIZE_256_BIT&#160;</td><td class="fielddoc"><p>256-bit Key Size </p>
</td></tr>
</table>

</div>
</div>
<a id="ga44eb3717710d41193938f41e4961db04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44eb3717710d41193938f41e4961db04">&sect;&nbsp;</a></span>DL_AESADV_DIR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_e_s_a_d_v.html#ga44eb3717710d41193938f41e4961db04">DL_AESADV_DIR</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga44eb3717710d41193938f41e4961db04addab5de3ec225d83295e04d87422547e"></a>DL_AESADV_DIR_ENCRYPT&#160;</td><td class="fielddoc"><p>Encryption </p>
</td></tr>
<tr><td class="fieldname"><a id="gga44eb3717710d41193938f41e4961db04aea2bc95f98202e1a25e28495a68fc865"></a>DL_AESADV_DIR_DECRYPT&#160;</td><td class="fielddoc"><p>Decryption </p>
</td></tr>
</table>

</div>
</div>
<a id="gab097955be26dd9f1ab86c2abcbf17caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab097955be26dd9f1ab86c2abcbf17caa">&sect;&nbsp;</a></span>DL_AESADV_CTR_WIDTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_e_s_a_d_v.html#gab097955be26dd9f1ab86c2abcbf17caa">DL_AESADV_CTR_WIDTH</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab097955be26dd9f1ab86c2abcbf17caaaebc6e305c92c43a4aa5a227e7ee3471d"></a>DL_AESADV_CTR_WIDTH_32_BIT&#160;</td><td class="fielddoc"><p>Counter (CTR) mode 32-bit counter </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab097955be26dd9f1ab86c2abcbf17caaa6bc9e327775289184023517cee1dfebf"></a>DL_AESADV_CTR_WIDTH_64_BIT&#160;</td><td class="fielddoc"><p>Counter (CTR) mode 64-bit counter </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab097955be26dd9f1ab86c2abcbf17caaa6f1d551cd4a6bf6eb868714a3de72fb5"></a>DL_AESADV_CTR_WIDTH_96_BIT&#160;</td><td class="fielddoc"><p>Counter (CTR) mode 96-bit counter </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab097955be26dd9f1ab86c2abcbf17caaa96ede50c9129432ba32cccbe3252fa41"></a>DL_AESADV_CTR_WIDTH_128_BIT&#160;</td><td class="fielddoc"><p>Counter (CTR) mode 128-bit counter </p>
</td></tr>
</table>

</div>
</div>
<a id="ga0aaeae07de1db467360828b0321d2308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0aaeae07de1db467360828b0321d2308">&sect;&nbsp;</a></span>DL_AESADV_FB_WIDTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_e_s_a_d_v.html#ga0aaeae07de1db467360828b0321d2308">DL_AESADV_FB_WIDTH</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gab9b86859a9a4b0bc1a58f35e65b7fc06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9b86859a9a4b0bc1a58f35e65b7fc06">&sect;&nbsp;</a></span>DL_AESADV_CCM_CTR_WIDTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_e_s_a_d_v.html#gab9b86859a9a4b0bc1a58f35e65b7fc06">DL_AESADV_CCM_CTR_WIDTH</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab9b86859a9a4b0bc1a58f35e65b7fc06ac3a1081c02f24332c3d167f2d509936c"></a>DL_AESADV_CCM_CTR_WIDTH_2_BYTES&#160;</td><td class="fielddoc"><p>Counter field width of 2 bytes (value of 1 stored in CCM-L) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab9b86859a9a4b0bc1a58f35e65b7fc06a30abeba3eab6d600bc28d20ebea315f6"></a>DL_AESADV_CCM_CTR_WIDTH_3_BYTES&#160;</td><td class="fielddoc"><p>Counter field width of 3 bytes (value of 2 stored in CCM-L) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab9b86859a9a4b0bc1a58f35e65b7fc06a8b32ffca542563b243fd428a7f89b6a3"></a>DL_AESADV_CCM_CTR_WIDTH_4_BYTES&#160;</td><td class="fielddoc"><p>Counter field width of 4 bytes (value of 3 stored in CCM-L) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab9b86859a9a4b0bc1a58f35e65b7fc06a927366b2bace5c90256c0abd2d42c472"></a>DL_AESADV_CCM_CTR_WIDTH_5_BYTES&#160;</td><td class="fielddoc"><p>Counter field width of 5 bytes (value of 4 stored in CCM-L) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab9b86859a9a4b0bc1a58f35e65b7fc06a20579185f9b2c5505c0291861a9403ed"></a>DL_AESADV_CCM_CTR_WIDTH_6_BYTES&#160;</td><td class="fielddoc"><p>Counter field width of 6 bytes (value of 5 stored in CCM-L) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab9b86859a9a4b0bc1a58f35e65b7fc06a4022e8fb44247c3854a8d7f19ae3f804"></a>DL_AESADV_CCM_CTR_WIDTH_7_BYTES&#160;</td><td class="fielddoc"><p>Counter field width of 7 bytes (value of 6 stored in CCM-L) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab9b86859a9a4b0bc1a58f35e65b7fc06aba95065a6cb3bef0d61b4a9e80636e52"></a>DL_AESADV_CCM_CTR_WIDTH_8_BYTES&#160;</td><td class="fielddoc"><p>Counter field width of 8 bytes (value of 7 stored in CCM-L) </p>
</td></tr>
</table>

</div>
</div>
<a id="gacbb14a5048e4b37f6f1f412a610c2e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbb14a5048e4b37f6f1f412a610c2e95">&sect;&nbsp;</a></span>DL_AESADV_CCM_TAG_WIDTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_e_s_a_d_v.html#gacbb14a5048e4b37f6f1f412a610c2e95">DL_AESADV_CCM_TAG_WIDTH</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggacbb14a5048e4b37f6f1f412a610c2e95adc37ceebb4af7ca1ecf75efdf4491255"></a>DL_AESADV_CCM_TAG_WIDTH_1_BYTE&#160;</td><td class="fielddoc"><p>Authentication field width of 1 byte (value of 0 stored in CCM-M) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacbb14a5048e4b37f6f1f412a610c2e95ae9ceba6a60bdeb0551e47ba7d6ad08b1"></a>DL_AESADV_CCM_TAG_WIDTH_2_BYTES&#160;</td><td class="fielddoc"><p>Authentication field width of 2 bytes (value of 1 stored in CCM-M) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacbb14a5048e4b37f6f1f412a610c2e95ab9ec3ea2fe106f025c33bd0d24dc3b25"></a>DL_AESADV_CCM_TAG_WIDTH_3_BYTES&#160;</td><td class="fielddoc"><p>Authentication field width of 3 bytes (value of 2 stored in CCM-M) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacbb14a5048e4b37f6f1f412a610c2e95a8d860a90beaef2b9258f2eb9adf4394b"></a>DL_AESADV_CCM_TAG_WIDTH_4_BYTES&#160;</td><td class="fielddoc"><p>Authentication field width of 4 bytes (value of 3 stored in CCM-M) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacbb14a5048e4b37f6f1f412a610c2e95a155c95adc309162e182eae167e40814e"></a>DL_AESADV_CCM_TAG_WIDTH_5_BYTES&#160;</td><td class="fielddoc"><p>Authentication field width of 5 bytes (value of 4 stored in CCM-M) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacbb14a5048e4b37f6f1f412a610c2e95af0749e2c686681d368ebe5d0fe179f45"></a>DL_AESADV_CCM_TAG_WIDTH_6_BYTES&#160;</td><td class="fielddoc"><p>Authentication field width of 6 bytes (value of 5 stored in CCM-M) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacbb14a5048e4b37f6f1f412a610c2e95ab4c0830f066bb0d2c3cc197934519b78"></a>DL_AESADV_CCM_TAG_WIDTH_7_BYTES&#160;</td><td class="fielddoc"><p>Authentication field width of 7 bytes (value of 6 stored in CCM-M) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacbb14a5048e4b37f6f1f412a610c2e95a46d4c6095e48978432a3a6a68b17e592"></a>DL_AESADV_CCM_TAG_WIDTH_8_BYTES&#160;</td><td class="fielddoc"><p>Authentication field width of 8 bytes (value of 7 stored in CCM-M) </p>
</td></tr>
</table>

</div>
</div>
<a id="ga1afb4e0ea2478e30ffc11bd6b35d4f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1afb4e0ea2478e30ffc11bd6b35d4f9d">&sect;&nbsp;</a></span>DL_AESADV_STATUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_e_s_a_d_v.html#ga1afb4e0ea2478e30ffc11bd6b35d4f9d">DL_AESADV_STATUS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga1afb4e0ea2478e30ffc11bd6b35d4f9da9bab81bf201f8ed2c2cec461bd23930c"></a>DL_AESADV_STATUS_SUCCESS&#160;</td><td class="fielddoc"><p>Operation was successful </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1afb4e0ea2478e30ffc11bd6b35d4f9da8a177e5c6621d150ad0ab38504c460a9"></a>DL_AESADV_STATUS_UNALIGNED_ACCESS&#160;</td><td class="fielddoc"><p>Operation was not performed because address was unaligned </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gafe1dc62b1a7bd85b54ecbd8bc6351ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe1dc62b1a7bd85b54ecbd8bc6351ad8">&sect;&nbsp;</a></span>DL_AESADV_enablePower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_AESADV_enablePower </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the Peripheral Write Enable (PWREN) register for the AESADV. </p>
<p>Before any peripheral registers can be configured by software, the peripheral itself must be enabled by writing the ENABLE bit together with the appropriate KEY value to the peripheral's PWREN register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac1cbde23c65a5652fb5c7fd7fab591ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1cbde23c65a5652fb5c7fd7fab591ab">&sect;&nbsp;</a></span>DL_AESADV_disablePower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_AESADV_disablePower </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the Peripheral Write Enable (PWREN) register for the AESADV. </p>
<p>When the PWREN.ENABLE bit is cleared, the peripheral's registers are not accessible for read/write operations.</p>
<dl class="section note"><dt>Note</dt><dd>This API does not provide large power savings</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaef4310d60b64363afa8c5d9cf64c18b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef4310d60b64363afa8c5d9cf64c18b2">&sect;&nbsp;</a></span>DL_AESADV_isPowerEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_AESADV_isPowerEnabled </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if the Peripheral Write Enable (PWREN) register for the AESADV is enabled. </p>
<p>Before any peripheral registers can be configured by software, the peripheral itself must be enabled by writing the ENABLE bit together with the appropriate KEY value to the peripheral's PWREN register.</p>
<p>When the PWREN.ENABLE bit is cleared, the peripheral's registers are not accessible for read/write operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if peripheral register access is enabled </dd>
<dd>
false if peripheral register access is disabled </dd></dl>

</div>
</div>
<a id="gabf73902aca6c5d54becaa4d2ab4a901c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf73902aca6c5d54becaa4d2ab4a901c">&sect;&nbsp;</a></span>DL_AESADV_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_AESADV_reset </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets AESADV module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaae7c08c58996f82ec2d425ac29a666b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae7c08c58996f82ec2d425ac29a666b5">&sect;&nbsp;</a></span>DL_AESADV_isReset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_AESADV_isReset </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if AESADV module was reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Peripheral was reset </td></tr>
    <tr><td class="paramname">false</td><td>Peripheral wasn't reset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga50d62c7ea3b757dab4cf069210140166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50d62c7ea3b757dab4cf069210140166">&sect;&nbsp;</a></span>DL_AESADV_isOutputReady()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_AESADV_isOutputReady </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if an AES output block is available to be read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>AES output block is available </td></tr>
    <tr><td class="paramname">false</td><td>No AES output block is available </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4d3b186a710a89f5c9cf2985ed1f0f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d3b186a710a89f5c9cf2985ed1f0f4c">&sect;&nbsp;</a></span>DL_AESADV_isInputReady()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_AESADV_isInputReady </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if the input buffer is empty, and more data can be written. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Input buffer is empty </td></tr>
    <tr><td class="paramname">false</td><td>Input buffer is not empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8bf3917b12c2477a3253921b775ead8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bf3917b12c2477a3253921b775ead8a">&sect;&nbsp;</a></span>DL_AESADV_setDirection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_AESADV_setDirection </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_s_a_d_v.html#ga44eb3717710d41193938f41e4961db04">DL_AESADV_DIR</a>&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the direction of the engine (encrypt/decrypt) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">direction</td><td>Direction. One of <a class="el" href="group___a_e_s_a_d_v.html#ga44eb3717710d41193938f41e4961db04">DL_AESADV_DIR</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>CBC-MAC must be configured as encrypt (<a class="el" href="group___a_e_s_a_d_v.html#gga44eb3717710d41193938f41e4961db04addab5de3ec225d83295e04d87422547e">DL_AESADV_DIR_ENCRYPT</a>). </dd></dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="gaf4a67d506ea218b2d8c8654e3c4b8fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4a67d506ea218b2d8c8654e3c4b8fb0">&sect;&nbsp;</a></span>DL_AESADV_getDirection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___a_e_s_a_d_v.html#ga44eb3717710d41193938f41e4961db04">DL_AESADV_DIR</a> DL_AESADV_getDirection </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the direction of the AESADV peripheral (encrypt/decrypt) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>one of <a class="el" href="group___a_e_s_a_d_v.html#ga44eb3717710d41193938f41e4961db04">DL_AESADV_DIR</a> </dd></dl>

</div>
</div>
<a id="gae68377b3cf16f636529dd083b76f674c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae68377b3cf16f636529dd083b76f674c">&sect;&nbsp;</a></span>DL_AESADV_setKeySize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_AESADV_setKeySize </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_s_a_d_v.html#ga8b4def1e5cd8a87acc22c34575f4d855">DL_AESADV_KEY_SIZE</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the key size of the AESADV peripheral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Key Size. One of <a class="el" href="group___a_e_s_a_d_v.html#ga8b4def1e5cd8a87acc22c34575f4d855">DL_AESADV_KEY_SIZE</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga7beff77f204c79d46ce9850d56b6ba2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7beff77f204c79d46ce9850d56b6ba2c">&sect;&nbsp;</a></span>DL_AESADV_getKeySize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___a_e_s_a_d_v.html#ga8b4def1e5cd8a87acc22c34575f4d855">DL_AESADV_KEY_SIZE</a> DL_AESADV_getKeySize </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current key size of the AESADV peripheral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>one of <a class="el" href="group___a_e_s_a_d_v.html#ga8b4def1e5cd8a87acc22c34575f4d855">DL_AESADV_KEY_SIZE</a>. </dd></dl>

</div>
</div>
<a id="ga0402a5a48ccdde46d4e8d0276a7ef85b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0402a5a48ccdde46d4e8d0276a7ef85b">&sect;&nbsp;</a></span>DL_AESADV_setMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_AESADV_setMode </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_s_a_d_v.html#ga554c682ff764f2162c9abe010f1c2f41">DL_AESADV_MODE</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the AES algorithm mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Algorithm Mode. One of <a class="el" href="group___a_e_s_a_d_v.html#ga554c682ff764f2162c9abe010f1c2f41">DL_AESADV_MODE</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Selecting GCM as a mode requires an additional selection of the GHASH parameters expected. Please refer to the TRM for more information. </dd>
<dd>
Due to the dual use of the OFB/gcm_ccm_continue_aad bit field, if the resumption of the AAD phase of a GCM/CCM operation is desired, it must be set with the mode using <a class="el" href="group___a_e_s_a_d_v.html#ga634fb648c5bc89cf6ca987ffcd99ae09">DL_AESADV_resumeAADPhase</a>, for the bit will be cleared in this function</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#ga634fb648c5bc89cf6ca987ffcd99ae09" title="Resume GCM or CCM operation in the AAD phase. ">DL_AESADV_resumeAADPhase</a> </dd></dl>

<p>References <a class="el" href="group___a_e_s_a_d_v.html#ga029b393df6a4dea6cd9fd94c4ec80ff6">DL_AESADV_MODE_MASK</a>, and <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga45ad0650442465ea963538c60338c1b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45ad0650442465ea963538c60338c1b3">&sect;&nbsp;</a></span>DL_AESADV_getMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___a_e_s_a_d_v.html#ga554c682ff764f2162c9abe010f1c2f41">DL_AESADV_MODE</a> DL_AESADV_getMode </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current selected mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>one of <a class="el" href="group___a_e_s_a_d_v.html#ga554c682ff764f2162c9abe010f1c2f41">DL_AESADV_MODE</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>upon resumption of a AAD phase of operation, the dual-purpose bit of continue AAD/OFB will be read as one. In this case, the mode must be set again for a valid value to be read.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#ga0402a5a48ccdde46d4e8d0276a7ef85b" title="Sets the AES algorithm mode. ">DL_AESADV_setMode</a> </dd></dl>

<p>References <a class="el" href="group___a_e_s_a_d_v.html#ga029b393df6a4dea6cd9fd94c4ec80ff6">DL_AESADV_MODE_MASK</a>.</p>

</div>
</div>
<a id="ga9579c342b7e0fb73ed299b0ee5ddd8b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9579c342b7e0fb73ed299b0ee5ddd8b8">&sect;&nbsp;</a></span>DL_AESADV_setFeedbackWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_AESADV_setFeedbackWidth </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_s_a_d_v.html#ga0aaeae07de1db467360828b0321d2308">DL_AESADV_FB_WIDTH</a>&#160;</td>
          <td class="paramname"><em>fbWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the feedback width of the AESADV peripheral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fbWidth</td><td>Feedback Width. One of <a class="el" href="group___a_e_s_a_d_v.html#ga0aaeae07de1db467360828b0321d2308">DL_AESADV_FB_WIDTH</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this is only applicable in cipher feeback mode (CFB). OFB always has width 128. </dd></dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga06f6c19f69565081d1e95ada4cb70df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06f6c19f69565081d1e95ada4cb70df9">&sect;&nbsp;</a></span>DL_AESADV_getFeedbackWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___a_e_s_a_d_v.html#ga0aaeae07de1db467360828b0321d2308">DL_AESADV_FB_WIDTH</a> DL_AESADV_getFeedbackWidth </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current feedback width. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>one of <a class="el" href="group___a_e_s_a_d_v.html#ga0aaeae07de1db467360828b0321d2308">DL_AESADV_FB_WIDTH</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#ga9579c342b7e0fb73ed299b0ee5ddd8b8" title="Sets the feedback width of the AESADV peripheral. ">DL_AESADV_setFeedbackWidth</a> </dd></dl>

</div>
</div>
<a id="ga2786383ab4632aee2efbd0a4d73247e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2786383ab4632aee2efbd0a4d73247e0">&sect;&nbsp;</a></span>DL_AESADV_setCounterWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_AESADV_setCounterWidth </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_s_a_d_v.html#gab097955be26dd9f1ab86c2abcbf17caa">DL_AESADV_CTR_WIDTH</a>&#160;</td>
          <td class="paramname"><em>ctrWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the counter width of the AESADV peripheral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctrWidth</td><td>Counter Width. One of <a class="el" href="group___a_e_s_a_d_v.html#gab097955be26dd9f1ab86c2abcbf17caa">DL_AESADV_CTR_WIDTH</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this is only applicable in modes CTR, CCM </dd>
<dd>
GCM restricts counter width to 32-bits, which is not required to be set. </dd>
<dd>
if using CCM, the counter width must be wide enough to accommodate the chosen CCM length, one of <a class="el" href="group___a_e_s_a_d_v.html#gab9b86859a9a4b0bc1a58f35e65b7fc06">DL_AESADV_CCM_CTR_WIDTH</a> (in bytes)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#ga675dcafb57bfb1f227d2fd322841f157" title="Sets the CCM counter width of the AESADV peripheral. ">DL_AESADV_setCCMCounterWidth</a> </dd></dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga21a801e78f153a2d1d014554c0d8453b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21a801e78f153a2d1d014554c0d8453b">&sect;&nbsp;</a></span>DL_AESADV_getCounterWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___a_e_s_a_d_v.html#gab097955be26dd9f1ab86c2abcbf17caa">DL_AESADV_CTR_WIDTH</a> DL_AESADV_getCounterWidth </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current counter width. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>one of <a class="el" href="group___a_e_s_a_d_v.html#gab097955be26dd9f1ab86c2abcbf17caa">DL_AESADV_CTR_WIDTH</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#ga2786383ab4632aee2efbd0a4d73247e0" title="Sets the counter width of the AESADV peripheral. ">DL_AESADV_setCounterWidth</a> </dd></dl>

</div>
</div>
<a id="ga675dcafb57bfb1f227d2fd322841f157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga675dcafb57bfb1f227d2fd322841f157">&sect;&nbsp;</a></span>DL_AESADV_setCCMCounterWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_AESADV_setCCMCounterWidth </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_s_a_d_v.html#gab9b86859a9a4b0bc1a58f35e65b7fc06">DL_AESADV_CCM_CTR_WIDTH</a>&#160;</td>
          <td class="paramname"><em>ccm_ctrWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the CCM counter width of the AESADV peripheral. </p>
<p>Counter with CBC-MAC (CCM) Specific. Sets the width of the counter field that is loaded into the initialization vector along with the nonce. This signal is sometimes referred to as CCM-L. The nonce can be calculated via the following table:</p>
<table class="doxtable">
<tr>
<th>DL_AESADV_CCM_CTR_WIDTH (bytes) </th><th>Nonce Array Length Required (bytes)  </th></tr>
<tr>
<td>2 </td><td>13 </td></tr>
<tr>
<td>3 </td><td>12 </td></tr>
<tr>
<td>4 </td><td>11 </td></tr>
<tr>
<td>5 </td><td>10 </td></tr>
<tr>
<td>6 </td><td>9 </td></tr>
<tr>
<td>7 </td><td>8 </td></tr>
<tr>
<td>8 </td><td>7 </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ccm_ctrWidth</td><td>Counter Width. One of <a class="el" href="group___a_e_s_a_d_v.html#gab9b86859a9a4b0bc1a58f35e65b7fc06">DL_AESADV_CCM_CTR_WIDTH</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this is only applicable in modes CCM </dd>
<dd>
The general counter width must be wide enough to accommodate the chosen CCM counter width, one of <a class="el" href="group___a_e_s_a_d_v.html#gab097955be26dd9f1ab86c2abcbf17caa">DL_AESADV_CTR_WIDTH</a> (in bits). A counter width of 64-bits is sufficient to cover all cases.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#ga2786383ab4632aee2efbd0a4d73247e0" title="Sets the counter width of the AESADV peripheral. ">DL_AESADV_setCounterWidth</a> </dd>
<dd>
<a class="el" href="group___a_e_s_a_d_v.html#ga960f99bd9c3df04b0ae95082cc548830" title="Loads the CCM Nonce And Counter IV, also called A0. ">DL_AESADV_loadCCMNonceAndCounter</a> </dd></dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga41e12b3ab143df8f015d7e9bf2b56b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41e12b3ab143df8f015d7e9bf2b56b08">&sect;&nbsp;</a></span>DL_AESADV_getCCMCounterWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___a_e_s_a_d_v.html#gab9b86859a9a4b0bc1a58f35e65b7fc06">DL_AESADV_CCM_CTR_WIDTH</a> DL_AESADV_getCCMCounterWidth </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current CCM-specific counter width. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>one of <a class="el" href="group___a_e_s_a_d_v.html#gab9b86859a9a4b0bc1a58f35e65b7fc06">DL_AESADV_CCM_CTR_WIDTH</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#ga675dcafb57bfb1f227d2fd322841f157" title="Sets the CCM counter width of the AESADV peripheral. ">DL_AESADV_setCCMCounterWidth</a> </dd></dl>

</div>
</div>
<a id="gafe52e1e19026511529593869a5d155ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe52e1e19026511529593869a5d155ca">&sect;&nbsp;</a></span>DL_AESADV_setCCMTagWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_AESADV_setCCMTagWidth </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_s_a_d_v.html#gacbb14a5048e4b37f6f1f412a610c2e95">DL_AESADV_CCM_TAG_WIDTH</a>&#160;</td>
          <td class="paramname"><em>ccm_tagWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the CCM authentication tag width of the AESADV peripheral. </p>
<p>Counter with CBC-MAC (CCM) Specific. Sets the width of the authentication field that is retrieved upon completion of the operation. The first bytes of the calculated tag will be returned, and the rest of the tag ignored. This signal is sometimes referred to as CCM-M. The full-width tag will still be calculated, just the least-significant bits will be used as according to this setting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ccm_tagWidth</td><td>Tag Width. One of <a class="el" href="group___a_e_s_a_d_v.html#gacbb14a5048e4b37f6f1f412a610c2e95">DL_AESADV_CCM_TAG_WIDTH</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga4de7d10b309aaed7b4e861d2dd8c8ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4de7d10b309aaed7b4e861d2dd8c8ef2">&sect;&nbsp;</a></span>DL_AESADV_getCCMTagWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___a_e_s_a_d_v.html#gacbb14a5048e4b37f6f1f412a610c2e95">DL_AESADV_CCM_TAG_WIDTH</a> DL_AESADV_getCCMTagWidth </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current CCM-specific authentication tag width. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>one of <a class="el" href="group___a_e_s_a_d_v.html#gacbb14a5048e4b37f6f1f412a610c2e95">DL_AESADV_CCM_TAG_WIDTH</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#gafe52e1e19026511529593869a5d155ca" title="Sets the CCM authentication tag width of the AESADV peripheral. ">DL_AESADV_setCCMTagWidth</a> </dd></dl>

</div>
</div>
<a id="ga741c350c430fd94c0d035b132e6f7704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga741c350c430fd94c0d035b132e6f7704">&sect;&nbsp;</a></span>DL_AESADV_haltOperationAndGenerateDigest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_AESADV_haltOperationAndGenerateDigest </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Halt operation and generate intermediate Digest for CCM/GCM. </p>
<p>Specific to a multi-block CCM/GCM mode. This will interrupt processing at the boundary of a full AES block (128-bits or 16 bytes) and prepare an intermediate digest that can be used to resume operations. If the user is still inputting additional authentication data (AAD), the operation shall be resumed in the AAD phase. If the user is inputting payload data (ciphertext/plaintext), the operation shall be resumed in the data phase. The user is responsible for reading and saving the intermediate digest to preserve the state for a future resumption of the Operation. The user must have at least 1 or more bytes of additional information that needs to be inputted in order for a halt to occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga634fb648c5bc89cf6ca987ffcd99ae09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga634fb648c5bc89cf6ca987ffcd99ae09">&sect;&nbsp;</a></span>DL_AESADV_resumeAADPhase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_AESADV_resumeAADPhase </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_s_a_d_v.html#ga554c682ff764f2162c9abe010f1c2f41">DL_AESADV_MODE</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume GCM or CCM operation in the AAD phase. </p>
<p>Specific to a multi-block CCM/GCM mode that contains Additional Authentication Data to be written after an operation has been halted. This operation should be performed last, after the entire digest for the example has been added. The mode is written in conjunction with the resumption signal, so it must be provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>A supported GCM or CCM mode from <a class="el" href="group___a_e_s_a_d_v.html#ga554c682ff764f2162c9abe010f1c2f41">DL_AESADV_MODE</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>DL_AESADV_haltOperationAndReturnDigest </dd>
<dd>
<a class="el" href="group___a_e_s_a_d_v.html#ga1128df7b533eb3f0fc4484df027f8321" title="Resume GCM or CCM operation in the Data phase. ">DL_AESADV_resumeDataPhase</a> </dd></dl>

<p>References <a class="el" href="group___a_e_s_a_d_v.html#ga029b393df6a4dea6cd9fd94c4ec80ff6">DL_AESADV_MODE_MASK</a>, and <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga1128df7b533eb3f0fc4484df027f8321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1128df7b533eb3f0fc4484df027f8321">&sect;&nbsp;</a></span>DL_AESADV_resumeDataPhase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_AESADV_resumeDataPhase </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_s_a_d_v.html#ga554c682ff764f2162c9abe010f1c2f41">DL_AESADV_MODE</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume GCM or CCM operation in the Data phase. </p>
<p>Specific to a multi-block CCM/GCM mode that contains additional Payload Data (ciphertext/plaintext) to be written after an operation has been halted, and any and all AAD has already been written before the time of halting. This operation should be performed last, after the entire digest for the example has been added. The mode is written in conjunction with the resumption signal, so it must be provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>A supported GCM or CCM mode from <a class="el" href="group___a_e_s_a_d_v.html#ga554c682ff764f2162c9abe010f1c2f41">DL_AESADV_MODE</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>DL_AESADV_haltOperationAndReturnDigest </dd>
<dd>
<a class="el" href="group___a_e_s_a_d_v.html#ga634fb648c5bc89cf6ca987ffcd99ae09" title="Resume GCM or CCM operation in the AAD phase. ">DL_AESADV_resumeAADPhase</a> </dd></dl>

<p>References <a class="el" href="group___a_e_s_a_d_v.html#ga029b393df6a4dea6cd9fd94c4ec80ff6">DL_AESADV_MODE_MASK</a>, and <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="gafb0789492acbbedcda4f07101d743669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb0789492acbbedcda4f07101d743669">&sect;&nbsp;</a></span>DL_AESADV_enableSavedOutputContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_AESADV_enableSavedOutputContext </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the storage and return of a tag or result IV. </p>
<p>Set if a given configuration must require an authentication TAG or result IV to be stored as part of the result context. This will trigger the context output DMA or interrupt assertion after operation completion. Additionally, the saved context ready will now be set high. Th engine will retain the registers until they have been read. Only after an associated TAG/IV has been read will a new DMA request for an input context be sent. Typically, this is set when methods return a TAG (GCM, CCM, CBCMAC) or in case an IV is to be returned for a future continued operation (CBC, CTR, etc.). If not set, the engine will assert a DMA request with the current context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeb562db39a3d3416ced4a9b558b21cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb562db39a3d3416ced4a9b558b21cd1">&sect;&nbsp;</a></span>DL_AESADV_disableSavedOutputContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_AESADV_disableSavedOutputContext </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the storage and return of a tag or result IV. </p>
<p>Set if a given configuration must require an authentication TAG or result IV to be stored as part of the result context. This will trigger the context output DMA or interrupt assertion after operation completion. Additionally, the saved context ready will now be set high. Th engine will retain the registers until they have been read. Typically, this is set when methods return a TAG (GCM, CCM, CBCMAC) or in case an IV is to be returned for a future continued operation (CBC, CTR, etc.). If not set, the engine will assert a DMA request with the current context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacddcdbe3e806e71ef604ac008c38c16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacddcdbe3e806e71ef604ac008c38c16c">&sect;&nbsp;</a></span>DL_AESADV_isSavedOutputContextEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_AESADV_isSavedOutputContextEnabled </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the storage of additional context is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Saved Output Context is enabled. </td></tr>
    <tr><td class="paramname">false</td><td>Saved Output Context is disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#gafb0789492acbbedcda4f07101d743669" title="Enables the storage and return of a tag or result IV. ">DL_AESADV_enableSavedOutputContext</a> </dd></dl>

</div>
</div>
<a id="ga783833070331fabb70a867857c8f9c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga783833070331fabb70a867857c8f9c8a">&sect;&nbsp;</a></span>DL_AESADV_isSavedOutputContextReady()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_AESADV_isSavedOutputContextReady </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether additional output context is available to be read. </p>
<p>At the end of an operation, if additional result information to the ciphertext/plaintext is available such as TAG/IV(s), this will return true. If this value is high, then the context cannot be written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Saved Output Context is ready to be retrieved. </td></tr>
    <tr><td class="paramname">false</td><td>Saved Output Context is unavailable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#gafb0789492acbbedcda4f07101d743669" title="Enables the storage and return of a tag or result IV. ">DL_AESADV_enableSavedOutputContext</a> </dd></dl>

</div>
</div>
<a id="ga4bc3aa400307a24f59805e03f7217bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bc3aa400307a24f59805e03f7217bc0">&sect;&nbsp;</a></span>DL_AESADV_isInputContextWriteable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_AESADV_isInputContextWriteable </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the input context can be written by the application. </p>
<p>Determines if the context (mode, IV, key, etc.) can be modified from its current state in the application by reading the CNTXT_RDY bit. This does not mean that a previous operation has necessarily finished, just that a new context may be written. Writing a new context before completion of the current context will cancel the current operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Context can be safely written to by the application </td></tr>
    <tr><td class="paramname">false</td><td>Context cannot be written, AES Authentication TAGs or IV's are available and must be read before context can be interrupted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaade07293524fc2235e0dff5965bbf100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaade07293524fc2235e0dff5965bbf100">&sect;&nbsp;</a></span>DL_AESADV_setLowerCryptoLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_AESADV_setLowerCryptoLength </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lowerLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the lower 32 bits of the crypto input data length in bytes. </p>
<p>The entire length of crypto input data that can be provided is 61-bits long, and is thus set in two separate functions. The lower 32-bits will be set and decremented as the operation continues. Setting the crypto length to 0 for basic modes (CBC, CTR, ICM, CFB, OFB) will configure the AESADV module to expect an infinite input stream for the device. For GCM and CCM, this mode does not include Additional Authentication Data, this is set separately. If there is a positive AAD length, it is not required for this register to have a nonzero value. Reads from this register return all zeros, so reads are not necessary. For modes that do not allow partial blocks such as CBC, this number must be a multiple of 16.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lowerLength</td><td>Lower 32-bits of crypto data length that will be inputted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This sets the context for the register, and thus should be called last in the configuration for non-combined modes</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#ga8fffb47d19570b163cec0e773f47c2fc" title="Sets the upper 29 bits of the crypto input data length in bytes. ">DL_AESADV_setUpperCryptoLength</a> </dd>
<dd>
<a class="el" href="group___a_e_s_a_d_v.html#gade5f751db1b66488f578fb6689e43d45" title="Sets the length of additional authentication data (AAD) ">DL_AESADV_setAADLength</a> </dd></dl>

</div>
</div>
<a id="ga8fffb47d19570b163cec0e773f47c2fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fffb47d19570b163cec0e773f47c2fc">&sect;&nbsp;</a></span>DL_AESADV_setUpperCryptoLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_AESADV_setUpperCryptoLength </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>upperLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the upper 29 bits of the crypto input data length in bytes. </p>
<p>The entire length of crypto input data that can be provided is 61-bits long, and is thus set in two separate functions. The upper 29-bits will be set in this function should a length larger than or equal to 2^32 be necessary. Bits 29-31 are to be zeroed out upon a write.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">upperLength</td><td>Upper 29 bits of the crypto data length in bytes that will be inputted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This sets the context for the register in combined modes (GCM/CCM), and thus should be called last in the configuration</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#gaade07293524fc2235e0dff5965bbf100" title="Sets the lower 32 bits of the crypto input data length in bytes. ">DL_AESADV_setLowerCryptoLength</a> </dd></dl>

</div>
</div>
<a id="gade5f751db1b66488f578fb6689e43d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade5f751db1b66488f578fb6689e43d45">&sect;&nbsp;</a></span>DL_AESADV_setAADLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_AESADV_setAADLength </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aadLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the length of additional authentication data (AAD) </p>
<p>Specific to CCM/GCM modes. Sets length of AAD for these modes and 0 otherwise. Can be zero if no AAD, or can be nonzero with a zero crypto length for authentication-only operation. A write to this register triggers the engine to start the context, and should be written after Crypto Length. For GCM this can be any value &lt; 2^32, for CCM this value must be less than 2^16 - 2^8.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aadLength</td><td>length of AAD in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>DL_AESADV_setLowerLength </dd></dl>

</div>
</div>
<a id="ga908ceb58d56dd2b3e840ea585f7c263a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga908ceb58d56dd2b3e840ea585f7c263a">&sect;&nbsp;</a></span>DL_AESADV_enableDMAOperation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_AESADV_enableDMAOperation </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables DMA Operation for the AESADV module. </p>
<p>Sets the AESADV module to run with Data Inputs using the DMA to read/write data rather than using register input/output</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#gab89dc856fb0fe426c0b7313ec57dc5a6" title="Disables DMA Operation for the AESADV module. ">DL_AESADV_disableDMAOperation</a> </dd></dl>

</div>
</div>
<a id="gab89dc856fb0fe426c0b7313ec57dc5a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab89dc856fb0fe426c0b7313ec57dc5a6">&sect;&nbsp;</a></span>DL_AESADV_disableDMAOperation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_AESADV_disableDMAOperation </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables DMA Operation for the AESADV module. </p>
<p>Default behavior. Sets the AESADV module to run using register input output with data provided by the CPU rather than using the DMA</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga68a793ea15f898faaa2ba6fa40b85047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68a793ea15f898faaa2ba6fa40b85047">&sect;&nbsp;</a></span>DL_AESADV_isDMAOperationEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_AESADV_isDMAOperationEnabled </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if DMA Operation is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Configured to read/write data using the DMA </td></tr>
    <tr><td class="paramname">false</td><td>Configured to read/write data using the CPU (Default) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafb867819958eaeeac5760ca202072ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb867819958eaeeac5760ca202072ec5">&sect;&nbsp;</a></span>DL_AESADV_isUserKeyWriteEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_AESADV_isUserKeyWriteEnabled </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if User Writes to the Key Registers on the AESADV are allowed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>User Writes to the Key Registers are allowed </td></tr>
    <tr><td class="paramname">false</td><td>The user cannot write to the Key Registers</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If user key writes are disabled but desired, a module reset is required </dd></dl>

<p>References <a class="el" href="group___a_e_s_a_d_v.html#ga960f99bd9c3df04b0ae95082cc548830">DL_AESADV_loadCCMNonceAndCounter()</a>, <a class="el" href="group___a_e_s_a_d_v.html#ga92c1172c55a19759f99a2cc6972acfe6">DL_AESADV_loadInitializationVector()</a>, <a class="el" href="group___a_e_s_a_d_v.html#ga70e0fc21651b2cca542b8c3c9232fe8e">DL_AESADV_loadInitializationVectorAligned()</a>, <a class="el" href="group___a_e_s_a_d_v.html#ga6210287a9b0a620659f949f4284fb0ba">DL_AESADV_loadInputData()</a>, <a class="el" href="group___a_e_s_a_d_v.html#gafd3b4defbf270b53a4f8638bb28b0502">DL_AESADV_loadInputDataAligned()</a>, <a class="el" href="group___a_e_s_a_d_v.html#ga8481998bca0b6424bb58bf934959c0ff">DL_AESADV_loadIntermediateTAG()</a>, <a class="el" href="group___a_e_s_a_d_v.html#ga478a85fb154516cb486a48042f3abff3">DL_AESADV_loadIntermediateTAGAligned()</a>, <a class="el" href="group___a_e_s_a_d_v.html#gaaab04637c0a0463b6b91c01361aea52d">DL_AESADV_readInitializationVector()</a>, <a class="el" href="group___a_e_s_a_d_v.html#gac1aadf159a751b94643c6ea7c1e58889">DL_AESADV_readInitializationVectorAligned()</a>, <a class="el" href="group___a_e_s_a_d_v.html#gab6401f0e6210ee5f15150c50699acba0">DL_AESADV_readOutputData()</a>, <a class="el" href="group___a_e_s_a_d_v.html#ga904f17e8fbfd13cbf37d0ca1c5d9ab44">DL_AESADV_readOutputDataAligned()</a>, <a class="el" href="group___a_e_s_a_d_v.html#ga81ba1b2bba9164e7119bed3e291bfc61">DL_AESADV_readTAG()</a>, <a class="el" href="group___a_e_s_a_d_v.html#ga1450390c9e4f969ee793e900d9ceaf50">DL_AESADV_readTAGAligned()</a>, <a class="el" href="group___a_e_s_a_d_v.html#gad2cb3af978007f1b262249d13017a2a7">DL_AESADV_setGCMHashKey()</a>, <a class="el" href="group___a_e_s_a_d_v.html#gaff639fc3d8cba3e593785ac00788028d">DL_AESADV_setGCMHashKeyAligned()</a>, <a class="el" href="group___a_e_s_a_d_v.html#ga89f2de712fd99550d60ee31265b1f54e">DL_AESADV_setKey()</a>, <a class="el" href="group___a_e_s_a_d_v.html#gab0ff127e7be121c2b91f48258645b507">DL_AESADV_setKeyAligned()</a>, <a class="el" href="group___a_e_s_a_d_v.html#gaabb73edea2a94b4cb4c243515dd60f58">DL_AESADV_setSecondKey()</a>, <a class="el" href="group___a_e_s_a_d_v.html#ga308393d0b482b34cc5e5d9e4c233e484">DL_AESADV_setSecondKeyAligned()</a>, <a class="el" href="group___a_e_s_a_d_v.html#ga94c4fa30691ed5cb78ab6d8c39f1c5ed">DL_AESADV_setThirdKey()</a>, and <a class="el" href="group___a_e_s_a_d_v.html#ga85195b695e19629d95405a45c68b908c">DL_AESADV_setThirdKeyAligned()</a>.</p>

</div>
</div>
<a id="ga89f2de712fd99550d60ee31265b1f54e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89f2de712fd99550d60ee31265b1f54e">&sect;&nbsp;</a></span>DL_AESADV_setKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___a_e_s_a_d_v.html#ga1afb4e0ea2478e30ffc11bd6b35d4f9d">DL_AESADV_STATUS</a> DL_AESADV_setKey </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_s_a_d_v.html#ga8b4def1e5cd8a87acc22c34575f4d855">DL_AESADV_KEY_SIZE</a>&#160;</td>
          <td class="paramname"><em>keySize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a 128 or 256 bit regular key to the AESADV module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Pointer to an uint8_t array with a length that contains the cipher key </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keySize</td><td>Key Size. One of <a class="el" href="group___a_e_s_a_d_v.html#ga8b4def1e5cd8a87acc22c34575f4d855">DL_AESADV_KEY_SIZE</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of operation. Operation will fail if not 32-bit aligned. One of <a class="el" href="group___a_e_s_a_d_v.html#ga1afb4e0ea2478e30ffc11bd6b35d4f9d">DL_AESADV_STATUS</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function adds additional cycles in order to verify no unaligned access, if this is not necessary, consider using uint32_t pointers and <a class="el" href="group___a_e_s_a_d_v.html#gab0ff127e7be121c2b91f48258645b507">DL_AESADV_setKeyAligned</a> </dd></dl>

<p>Referenced by <a class="el" href="group___a_e_s_a_d_v.html#gafb867819958eaeeac5760ca202072ec5">DL_AESADV_isUserKeyWriteEnabled()</a>.</p>

</div>
</div>
<a id="gab0ff127e7be121c2b91f48258645b507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0ff127e7be121c2b91f48258645b507">&sect;&nbsp;</a></span>DL_AESADV_setKeyAligned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_AESADV_setKeyAligned </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>keyAligned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_s_a_d_v.html#ga8b4def1e5cd8a87acc22c34575f4d855">DL_AESADV_KEY_SIZE</a>&#160;</td>
          <td class="paramname"><em>keySize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a 128 or 256 bit regular key to the AESADV module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyAligned</td><td>Pointer to an uint32_t array with a length that contains the cipher key </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keySize</td><td>Key Size. One of <a class="el" href="group___a_e_s_a_d_v.html#ga8b4def1e5cd8a87acc22c34575f4d855">DL_AESADV_KEY_SIZE</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#ga89f2de712fd99550d60ee31265b1f54e" title="Loads a 128 or 256 bit regular key to the AESADV module. ">DL_AESADV_setKey</a> </dd></dl>

<p>Referenced by <a class="el" href="group___a_e_s_a_d_v.html#gafb867819958eaeeac5760ca202072ec5">DL_AESADV_isUserKeyWriteEnabled()</a>.</p>

</div>
</div>
<a id="gad2cb3af978007f1b262249d13017a2a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2cb3af978007f1b262249d13017a2a7">&sect;&nbsp;</a></span>DL_AESADV_setGCMHashKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___a_e_s_a_d_v.html#ga1afb4e0ea2478e30ffc11bd6b35d4f9d">DL_AESADV_STATUS</a> DL_AESADV_setGCMHashKey </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>hashKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the hash key </p>
<p>GCM-Specific. Sets the GHASH Hash key (sometimes referred to as H) if in a GCM mode other than DL_AESADV_MODE_GCM_AUTONOMOUS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hashKey</td><td>Pointer to an uint8_t array of length 16 that contains the hash key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of operation. Operation will fail if not 32-bit aligned. One of <a class="el" href="group___a_e_s_a_d_v.html#ga1afb4e0ea2478e30ffc11bd6b35d4f9d">DL_AESADV_STATUS</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function adds additional cycles in order to verify no unaligned access, if this is not necessary, consider using uint32_t pointers and <a class="el" href="group___a_e_s_a_d_v.html#gaff639fc3d8cba3e593785ac00788028d">DL_AESADV_setGCMHashKeyAligned</a> </dd></dl>

<p>Referenced by <a class="el" href="group___a_e_s_a_d_v.html#gafb867819958eaeeac5760ca202072ec5">DL_AESADV_isUserKeyWriteEnabled()</a>.</p>

</div>
</div>
<a id="gaff639fc3d8cba3e593785ac00788028d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff639fc3d8cba3e593785ac00788028d">&sect;&nbsp;</a></span>DL_AESADV_setGCMHashKeyAligned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_AESADV_setGCMHashKeyAligned </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>hashKeyAligned</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the hash key </p>
<p>GCM-Specific. Sets the GHASH Hash key (sometimes referred to as H) if in a GCM mode other than DL_AESADV_MODE_GCM_AUTONOMOUS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hashKeyAligned</td><td>Pointer to an uint32_t array of length 4 that contains the hash key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#gad2cb3af978007f1b262249d13017a2a7" title="set the hash key ">DL_AESADV_setGCMHashKey</a> </dd></dl>

<p>Referenced by <a class="el" href="group___a_e_s_a_d_v.html#gafb867819958eaeeac5760ca202072ec5">DL_AESADV_isUserKeyWriteEnabled()</a>.</p>

</div>
</div>
<a id="gaabb73edea2a94b4cb4c243515dd60f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabb73edea2a94b4cb4c243515dd60f58">&sect;&nbsp;</a></span>DL_AESADV_setSecondKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___a_e_s_a_d_v.html#ga1afb4e0ea2478e30ffc11bd6b35d4f9d">DL_AESADV_STATUS</a> DL_AESADV_setSecondKey </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>secondKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads the CBC-MAC second key. </p>
<p>Specific to CBC-MAC operation. Pre-calculated second key to perform a final XOR operation on the last input data block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondKey</td><td>Pointer to an uint8_t array of length 16 containing the second key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of operation. Operation will fail if not 32-bit aligned. One of <a class="el" href="group___a_e_s_a_d_v.html#ga1afb4e0ea2478e30ffc11bd6b35d4f9d">DL_AESADV_STATUS</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function adds additional cycles in order to verify no unaligned access, if this is not necessary, consider using uint32_t pointers and <a class="el" href="group___a_e_s_a_d_v.html#ga308393d0b482b34cc5e5d9e4c233e484">DL_AESADV_setSecondKeyAligned</a> </dd></dl>

<p>Referenced by <a class="el" href="group___a_e_s_a_d_v.html#gafb867819958eaeeac5760ca202072ec5">DL_AESADV_isUserKeyWriteEnabled()</a>.</p>

</div>
</div>
<a id="ga308393d0b482b34cc5e5d9e4c233e484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga308393d0b482b34cc5e5d9e4c233e484">&sect;&nbsp;</a></span>DL_AESADV_setSecondKeyAligned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_AESADV_setSecondKeyAligned </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>secondKeyAligned</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads the CBC-MAC second key. </p>
<p>Specific to CBC-MAC operation. Pre-calculated second key to perform a final XOR operation on the last input data block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondKeyAligned</td><td>Pointer to an uint32_t array of length 4 containing the second key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#gaabb73edea2a94b4cb4c243515dd60f58" title="Loads the CBC-MAC second key. ">DL_AESADV_setSecondKey</a> </dd></dl>

<p>Referenced by <a class="el" href="group___a_e_s_a_d_v.html#gafb867819958eaeeac5760ca202072ec5">DL_AESADV_isUserKeyWriteEnabled()</a>.</p>

</div>
</div>
<a id="ga94c4fa30691ed5cb78ab6d8c39f1c5ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94c4fa30691ed5cb78ab6d8c39f1c5ed">&sect;&nbsp;</a></span>DL_AESADV_setThirdKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___a_e_s_a_d_v.html#ga1afb4e0ea2478e30ffc11bd6b35d4f9d">DL_AESADV_STATUS</a> DL_AESADV_setThirdKey </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>thirdKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads the CBC-MAC third key. </p>
<p>Specific to CBC-MAC operation. Pre-calculated third key to perform a final XOR operation on the last input data block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thirdKey</td><td>Pointer to an uint8_t array of length 16 containing the third key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of operation. Operation will fail if not 32-bit aligned. One of <a class="el" href="group___a_e_s_a_d_v.html#ga1afb4e0ea2478e30ffc11bd6b35d4f9d">DL_AESADV_STATUS</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function adds additional cycles in order to verify no unaligned access, if this is not necessary, consider using uint32_t pointers and <a class="el" href="group___a_e_s_a_d_v.html#ga85195b695e19629d95405a45c68b908c">DL_AESADV_setThirdKeyAligned</a> </dd></dl>

<p>Referenced by <a class="el" href="group___a_e_s_a_d_v.html#gafb867819958eaeeac5760ca202072ec5">DL_AESADV_isUserKeyWriteEnabled()</a>.</p>

</div>
</div>
<a id="ga85195b695e19629d95405a45c68b908c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85195b695e19629d95405a45c68b908c">&sect;&nbsp;</a></span>DL_AESADV_setThirdKeyAligned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_AESADV_setThirdKeyAligned </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>thirdKeyAligned</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads the CBC-MAC third key. </p>
<p>Specific to CBC-MAC operation. Pre-calculated third key to perform a final XOR operation on the last input data block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thirdKeyAligned</td><td>Pointer to an uint32_t array of length 4 containing the third key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#ga94c4fa30691ed5cb78ab6d8c39f1c5ed" title="Loads the CBC-MAC third key. ">DL_AESADV_setThirdKey</a> </dd></dl>

<p>Referenced by <a class="el" href="group___a_e_s_a_d_v.html#gafb867819958eaeeac5760ca202072ec5">DL_AESADV_isUserKeyWriteEnabled()</a>.</p>

</div>
</div>
<a id="ga8481998bca0b6424bb58bf934959c0ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8481998bca0b6424bb58bf934959c0ff">&sect;&nbsp;</a></span>DL_AESADV_loadIntermediateTAG()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___a_e_s_a_d_v.html#ga1afb4e0ea2478e30ffc11bd6b35d4f9d">DL_AESADV_STATUS</a> DL_AESADV_loadIntermediateTAG </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads either zero or an intermediate 128-bit TAG to resume GCM/CCM. </p>
<p>Specific to the GCM/CCM modes. During initialization and beginning of a new combined operation mode (GCM or CCM only), this must be set to 0. However, during continuation this tag is part of the saved intermediate digest that must be restored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Pointer to an uint8_t array of length 16 containing zeroes or the intermediate digest</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of operation. Operation will fail if not 32-bit aligned. One of <a class="el" href="group___a_e_s_a_d_v.html#ga1afb4e0ea2478e30ffc11bd6b35d4f9d">DL_AESADV_STATUS</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function adds additional cycles in order to verify no unaligned access, if this is not necessary, consider using uint32_t pointers and <a class="el" href="group___a_e_s_a_d_v.html#ga478a85fb154516cb486a48042f3abff3">DL_AESADV_loadIntermediateTAGAligned</a> </dd></dl>

<p>Referenced by <a class="el" href="group___a_e_s_a_d_v.html#gafb867819958eaeeac5760ca202072ec5">DL_AESADV_isUserKeyWriteEnabled()</a>.</p>

</div>
</div>
<a id="ga478a85fb154516cb486a48042f3abff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga478a85fb154516cb486a48042f3abff3">&sect;&nbsp;</a></span>DL_AESADV_loadIntermediateTAGAligned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_AESADV_loadIntermediateTAGAligned </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>tagAligned</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads either zero or an intermediate 128-bit TAG to resume GCM/CCM. </p>
<p>Specific to the GCM/CCM modes. During initialization and beginning of a new combined operation mode (GCM or CCM only), this must be set to 0. However, during continuation this tag is part of the saved intermediate digest that must be restored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tagAligned</td><td>Pointer to an uint32_t array of length 4 containing zeroes or the intermediate digest</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#ga8481998bca0b6424bb58bf934959c0ff" title="Loads either zero or an intermediate 128-bit TAG to resume GCM/CCM. ">DL_AESADV_loadIntermediateTAG</a> </dd></dl>

<p>Referenced by <a class="el" href="group___a_e_s_a_d_v.html#gafb867819958eaeeac5760ca202072ec5">DL_AESADV_isUserKeyWriteEnabled()</a>.</p>

</div>
</div>
<a id="ga92c1172c55a19759f99a2cc6972acfe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92c1172c55a19759f99a2cc6972acfe6">&sect;&nbsp;</a></span>DL_AESADV_loadInitializationVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___a_e_s_a_d_v.html#ga1afb4e0ea2478e30ffc11bd6b35d4f9d">DL_AESADV_STATUS</a> DL_AESADV_loadInitializationVector </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>iv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads the 128-bit initialization vector to the AESADV module. </p>
<p>When used with GCM, the upper word iv[127:96] needs to be written with 0x01000000 in order to appropriately mark the initial counter value of 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iv</td><td>Pointer to an uint8_t array of length 16 containing the initialization vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of operation. Operation will fail if not 32-bit aligned. One of <a class="el" href="group___a_e_s_a_d_v.html#ga1afb4e0ea2478e30ffc11bd6b35d4f9d">DL_AESADV_STATUS</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For CCM, this iv must be written with the CCM-specific value A0. This value consists of the concatenation of A0 flags, the nonce, and the counter. There is a specialized function that can load this type of IV found at <a class="el" href="group___a_e_s_a_d_v.html#ga960f99bd9c3df04b0ae95082cc548830">DL_AESADV_loadCCMNonceAndCounter</a>.</dd>
<dd>
This function adds additional cycles in order to verify no unaligned access, if this is not necessary, consider using uint32_t pointers and <a class="el" href="group___a_e_s_a_d_v.html#ga70e0fc21651b2cca542b8c3c9232fe8e">DL_AESADV_loadInitializationVectorAligned</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#ga960f99bd9c3df04b0ae95082cc548830" title="Loads the CCM Nonce And Counter IV, also called A0. ">DL_AESADV_loadCCMNonceAndCounter</a> </dd></dl>

<p>Referenced by <a class="el" href="group___a_e_s_a_d_v.html#gafb867819958eaeeac5760ca202072ec5">DL_AESADV_isUserKeyWriteEnabled()</a>.</p>

</div>
</div>
<a id="ga70e0fc21651b2cca542b8c3c9232fe8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70e0fc21651b2cca542b8c3c9232fe8e">&sect;&nbsp;</a></span>DL_AESADV_loadInitializationVectorAligned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_AESADV_loadInitializationVectorAligned </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>ivAligned</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads the 128-bit initialization vector to the AESADV module. </p>
<p>When used with GCM, the upper word iv[127:96] needs to be written with 0x01000000 in order to appropriately mark the initial counter value of 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ivAligned</td><td>Pointer to an uint32_t array of length 4 containing the initialization vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For CCM, this iv must be written with the CCM-specific value A0. This value consists of the concatenation of A0 flags, the nonce, and the counter. There is a specialized function that can load this type of IV found at <a class="el" href="group___a_e_s_a_d_v.html#ga960f99bd9c3df04b0ae95082cc548830">DL_AESADV_loadCCMNonceAndCounter</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#ga960f99bd9c3df04b0ae95082cc548830" title="Loads the CCM Nonce And Counter IV, also called A0. ">DL_AESADV_loadCCMNonceAndCounter</a> </dd>
<dd>
<a class="el" href="group___a_e_s_a_d_v.html#ga92c1172c55a19759f99a2cc6972acfe6" title="Loads the 128-bit initialization vector to the AESADV module. ">DL_AESADV_loadInitializationVector</a> </dd></dl>

<p>Referenced by <a class="el" href="group___a_e_s_a_d_v.html#gafb867819958eaeeac5760ca202072ec5">DL_AESADV_isUserKeyWriteEnabled()</a>.</p>

</div>
</div>
<a id="gaaab04637c0a0463b6b91c01361aea52d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaab04637c0a0463b6b91c01361aea52d">&sect;&nbsp;</a></span>DL_AESADV_readInitializationVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___a_e_s_a_d_v.html#ga1afb4e0ea2478e30ffc11bd6b35d4f9d">DL_AESADV_STATUS</a> DL_AESADV_readInitializationVector </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>iv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the 128-bit initialization vector from the AES Module. </p>
<p>Contains the latest 128-bit initialization vector output from the engine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">iv</td><td>Pointer to an uint8_t array of length 16 where the iv will be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of operation. Operation will fail if not 32-bit aligned. One of <a class="el" href="group___a_e_s_a_d_v.html#ga1afb4e0ea2478e30ffc11bd6b35d4f9d">DL_AESADV_STATUS</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function adds additional cycles in order to verify no unaligned access, if this is not necessary, consider using uint32_t pointers and <a class="el" href="group___a_e_s_a_d_v.html#gac1aadf159a751b94643c6ea7c1e58889">DL_AESADV_readInitializationVectorAligned</a> </dd></dl>

<p>Referenced by <a class="el" href="group___a_e_s_a_d_v.html#gafb867819958eaeeac5760ca202072ec5">DL_AESADV_isUserKeyWriteEnabled()</a>.</p>

</div>
</div>
<a id="gac1aadf159a751b94643c6ea7c1e58889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1aadf159a751b94643c6ea7c1e58889">&sect;&nbsp;</a></span>DL_AESADV_readInitializationVectorAligned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_AESADV_readInitializationVectorAligned </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>ivAligned</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the 128-bit initialization vector from the AES Module. </p>
<p>Contains the latest 128-bit initialization vector output from the engine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ivAligned</td><td>Pointer to an uint32_t array of length 4 where the iv will be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#gaaab04637c0a0463b6b91c01361aea52d" title="Reads the 128-bit initialization vector from the AES Module. ">DL_AESADV_readInitializationVector</a> </dd></dl>

<p>Referenced by <a class="el" href="group___a_e_s_a_d_v.html#gafb867819958eaeeac5760ca202072ec5">DL_AESADV_isUserKeyWriteEnabled()</a>.</p>

</div>
</div>
<a id="ga960f99bd9c3df04b0ae95082cc548830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga960f99bd9c3df04b0ae95082cc548830">&sect;&nbsp;</a></span>DL_AESADV_loadCCMNonceAndCounter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_AESADV_loadCCMNonceAndCounter </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>nonce</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_s_a_d_v.html#gab9b86859a9a4b0bc1a58f35e65b7fc06">DL_AESADV_CCM_CTR_WIDTH</a>&#160;</td>
          <td class="paramname"><em>ctrWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads the CCM Nonce And Counter IV, also called A0. </p>
<p>CCM-Specific use of the IV field called A0. The A0 field is formatted as follows:</p>
<p>LSB MSB (5'b00000 concat 3'b counterWidth - 1) | Nonce | Counter IV (always 0's)</p>
<p>the counter width is set as one of DL_AESADV_CCM_CTR_WIDTH (equal to counterWidth -1). For example, a 5-byte width for the counter (and thus the data payload width) will correspond to a Counter IV of 40-bits. The counter width taking 8 bits, and the Nonce taking the remaining 80-bits (10 bytes). An 8-byte counter width would yield a counter IV width of 64-bits with a Nonce taking the remaining 54-bits (7 bytes). The LSB of the IV will then be 8'b00000111 or 0x07 (one less than the byte width) Thus, the Nonce should be sufficiently wide to fit the bits that are remaining for the nonce, and this will vary with the counter field width provided. The LSB of the IV will be 0x04 (one less than the byte width)</p>
<p>The following table describes the Nonce array lengths that should be used:</p>
<table class="doxtable">
<tr>
<th>DL_AESADV_CCM_CTR_WIDTH (bytes) </th><th>Nonce Array Length Required (bytes)  </th></tr>
<tr>
<td>2 </td><td>13 </td></tr>
<tr>
<td>3 </td><td>12 </td></tr>
<tr>
<td>4 </td><td>11 </td></tr>
<tr>
<td>5 </td><td>10 </td></tr>
<tr>
<td>6 </td><td>9 </td></tr>
<tr>
<td>7 </td><td>8 </td></tr>
<tr>
<td>8 </td><td>7 </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nonce</td><td>Pointer to the uint8_t nonce Value for CCM, should be unique and length calculated as above. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctrWidth</td><td>Counter Width. One of <a class="el" href="group___a_e_s_a_d_v.html#gab9b86859a9a4b0bc1a58f35e65b7fc06">DL_AESADV_CCM_CTR_WIDTH</a>. Should match width provided in control register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>During halting and resumption of CCM operations, it is required to use the <a class="el" href="group___a_e_s_a_d_v.html#ga92c1172c55a19759f99a2cc6972acfe6">DL_AESADV_loadInitializationVector</a> and <a class="el" href="group___a_e_s_a_d_v.html#gaaab04637c0a0463b6b91c01361aea52d">DL_AESADV_readInitializationVector</a> functions as this preserves the current counter state. This function is designed for initialization of the operation only.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#ga92c1172c55a19759f99a2cc6972acfe6" title="Loads the 128-bit initialization vector to the AESADV module. ">DL_AESADV_loadInitializationVector</a> </dd>
<dd>
<a class="el" href="group___a_e_s_a_d_v.html#gaaab04637c0a0463b6b91c01361aea52d" title="Reads the 128-bit initialization vector from the AES Module. ">DL_AESADV_readInitializationVector</a> </dd></dl>

<p>Referenced by <a class="el" href="group___a_e_s_a_d_v.html#gafb867819958eaeeac5760ca202072ec5">DL_AESADV_isUserKeyWriteEnabled()</a>.</p>

</div>
</div>
<a id="ga6210287a9b0a620659f949f4284fb0ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6210287a9b0a620659f949f4284fb0ba">&sect;&nbsp;</a></span>DL_AESADV_loadInputData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___a_e_s_a_d_v.html#ga1afb4e0ea2478e30ffc11bd6b35d4f9d">DL_AESADV_STATUS</a> DL_AESADV_loadInputData </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>loads 128 bits (4 words) of input data </p>
<p>Loads the next 128 bits of input data. Either AAD (GCM/CCM) or Crypto Data. If less than 128 bits are left (or if the width of data is less than 128 bits ex. CCM), it is still necessary to pad 0's to the remaining bits in order for the engine to start the operation. For GCM/CCM, the last AAD block can have less than 128 bits, and should be padded with 0's rather than appended to the crypto data. For authentication modes (GCM, CCM, CBC-MAC), refer to the TRM for additional information about necessary padding.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to uint8_t bit data array of length 16 to be inputted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of operation. Operation will fail if not 32-bit aligned. One of <a class="el" href="group___a_e_s_a_d_v.html#ga1afb4e0ea2478e30ffc11bd6b35d4f9d">DL_AESADV_STATUS</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function adds additional cycles in order to verify no unaligned access, if this is not necessary, consider using uint32_t pointers and <a class="el" href="group___a_e_s_a_d_v.html#gafd3b4defbf270b53a4f8638bb28b0502">DL_AESADV_loadInputDataAligned</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#gab6401f0e6210ee5f15150c50699acba0" title="reads 128-bits of output data that has been encrypted/decrypted. ">DL_AESADV_readOutputData</a> </dd></dl>

<p>Referenced by <a class="el" href="group___a_e_s_a_d_v.html#gafb867819958eaeeac5760ca202072ec5">DL_AESADV_isUserKeyWriteEnabled()</a>.</p>

</div>
</div>
<a id="gafd3b4defbf270b53a4f8638bb28b0502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd3b4defbf270b53a4f8638bb28b0502">&sect;&nbsp;</a></span>DL_AESADV_loadInputDataAligned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_AESADV_loadInputDataAligned </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>dataAligned</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>loads 128 bits (4 words) of input data </p>
<p>Loads the next 128 bits of input data. Either AAD (GCM/CCM) or Crypto Data. If less than 128 bits are left (or if the width of data is less than 128 bits ex. CCM), it is still necessary to pad 0's to the remaining bits in order for the engine to start the operation. For GCM/CCM, the last AAD block can have less than 128 bits, and should be padded with 0's rather than appended to the crypto data. For authentication modes (GCM, CCM, CBC-MAC), refer to the TRM for additional information about necessary padding.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataAligned</td><td>Pointer to uint32_t bit data array of length 4 to be inputted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#ga6210287a9b0a620659f949f4284fb0ba" title="loads 128 bits (4 words) of input data ">DL_AESADV_loadInputData</a> </dd>
<dd>
<a class="el" href="group___a_e_s_a_d_v.html#ga904f17e8fbfd13cbf37d0ca1c5d9ab44" title="reads 128-bits of output data that has been encrypted/decrypted. ">DL_AESADV_readOutputDataAligned</a> </dd></dl>

<p>Referenced by <a class="el" href="group___a_e_s_a_d_v.html#gafb867819958eaeeac5760ca202072ec5">DL_AESADV_isUserKeyWriteEnabled()</a>.</p>

</div>
</div>
<a id="gab6401f0e6210ee5f15150c50699acba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6401f0e6210ee5f15150c50699acba0">&sect;&nbsp;</a></span>DL_AESADV_readOutputData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___a_e_s_a_d_v.html#ga1afb4e0ea2478e30ffc11bd6b35d4f9d">DL_AESADV_STATUS</a> DL_AESADV_readOutputData </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reads 128-bits of output data that has been encrypted/decrypted. </p>
<p>Reads the ciphertext/plaintext outputted by the AESADV module. If less than 128 bits is expected, there still must be 128-bits read, which must mean the data pointer has at least 128 bits to spare.</p>
<p>Inputting Additional Authentication Data (AAD) will not place any information into the output buffer, thus a read is not required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Pointer to the data that will be read, uint8_t requiring length of at least 16 to not overwrite other variables.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of operation. Operation will fail if not 32-bit aligned. One of <a class="el" href="group___a_e_s_a_d_v.html#ga1afb4e0ea2478e30ffc11bd6b35d4f9d">DL_AESADV_STATUS</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function adds additional cycles in order to verify no unaligned access, if this is not necessary, consider using uint32_t pointers and <a class="el" href="group___a_e_s_a_d_v.html#ga904f17e8fbfd13cbf37d0ca1c5d9ab44">DL_AESADV_readOutputDataAligned</a> </dd></dl>

<p>Referenced by <a class="el" href="group___a_e_s_a_d_v.html#gafb867819958eaeeac5760ca202072ec5">DL_AESADV_isUserKeyWriteEnabled()</a>.</p>

</div>
</div>
<a id="ga904f17e8fbfd13cbf37d0ca1c5d9ab44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga904f17e8fbfd13cbf37d0ca1c5d9ab44">&sect;&nbsp;</a></span>DL_AESADV_readOutputDataAligned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_AESADV_readOutputDataAligned </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>dataAligned</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reads 128-bits of output data that has been encrypted/decrypted. </p>
<p>Reads the ciphertext/plaintext outputted by the AESADV module. If less than 128 bits is expected, there still must be 128-bits read, which must mean the data pointer has at least 128 bits to spare.</p>
<p>Inputting Additional Authentication Data (AAD) will not place any information into the output buffer, thus a read is not required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dataAligned</td><td>Pointer to the data that will be read, uint32_t requiring length of at least 4 to not overwrite other variables.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#gab6401f0e6210ee5f15150c50699acba0" title="reads 128-bits of output data that has been encrypted/decrypted. ">DL_AESADV_readOutputData</a> </dd></dl>

<p>Referenced by <a class="el" href="group___a_e_s_a_d_v.html#gafb867819958eaeeac5760ca202072ec5">DL_AESADV_isUserKeyWriteEnabled()</a>.</p>

</div>
</div>
<a id="ga81ba1b2bba9164e7119bed3e291bfc61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81ba1b2bba9164e7119bed3e291bfc61">&sect;&nbsp;</a></span>DL_AESADV_readTAG()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___a_e_s_a_d_v.html#ga1afb4e0ea2478e30ffc11bd6b35d4f9d">DL_AESADV_STATUS</a> DL_AESADV_readTAG </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reads 128-bit output tag at the conclusion of operation/halt </p>
<p>Specific to authentication-enabled modes. Reads the tag. Only valid at the conclusion of an operation, or because an operation has been halted and requires a digest. In the case of a halted operation, the output will be an intermediate tag for CCM or GCM.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tag</td><td>Pointer to the tag to be read, a uint8_t array of length 16</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of operation. Operation will fail if not 32-bit aligned. One of <a class="el" href="group___a_e_s_a_d_v.html#ga1afb4e0ea2478e30ffc11bd6b35d4f9d">DL_AESADV_STATUS</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function adds additional cycles in order to verify no unaligned access, if this is not necessary, consider using uint32_t pointers and <a class="el" href="group___a_e_s_a_d_v.html#ga1450390c9e4f969ee793e900d9ceaf50">DL_AESADV_readTAGAligned</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#ga783833070331fabb70a867857c8f9c8a" title="Returns whether additional output context is available to be read. ">DL_AESADV_isSavedOutputContextReady</a> </dd></dl>

<p>Referenced by <a class="el" href="group___a_e_s_a_d_v.html#gafb867819958eaeeac5760ca202072ec5">DL_AESADV_isUserKeyWriteEnabled()</a>.</p>

</div>
</div>
<a id="ga1450390c9e4f969ee793e900d9ceaf50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1450390c9e4f969ee793e900d9ceaf50">&sect;&nbsp;</a></span>DL_AESADV_readTAGAligned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_AESADV_readTAGAligned </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>tagAligned</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reads 128-bit output tag at the conclusion of operation/halt </p>
<p>Specific to authentication-enabled modes. Reads the tag. Only valid at the conclusion of an operation, or because an operation has been halted and requires a digest. In the case of a halted operation, the output will be an intermediate tag for CCM or GCM.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tagAligned</td><td>Pointer to the tag to be read, a uint32_t array of length 4</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#ga783833070331fabb70a867857c8f9c8a" title="Returns whether additional output context is available to be read. ">DL_AESADV_isSavedOutputContextReady</a> </dd></dl>

<p>Referenced by <a class="el" href="group___a_e_s_a_d_v.html#gafb867819958eaeeac5760ca202072ec5">DL_AESADV_isUserKeyWriteEnabled()</a>.</p>

</div>
</div>
<a id="gac4c3ef83b58e47e5257c5b2062b81f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4c3ef83b58e47e5257c5b2062b81f20">&sect;&nbsp;</a></span>DL_AESADV_forceInputDataAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_AESADV_forceInputDataAvailable </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forces AESADV to begin processing input data. </p>
<p>This function will validate the input data buffer and force AESADV to begin processing data. Any value can be used in order to force processing data.</p>
<dl class="section note"><dt>Note</dt><dd>To use, <a class="el" href="group___a_e_s_a_d_v.html#ga908ceb58d56dd2b3e840ea585f7c263a">DL_AESADV_enableDMAOperation</a> must not be in use</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga67c05bb974304ca516e46c72ae7a02ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67c05bb974304ca516e46c72ae7a02ff">&sect;&nbsp;</a></span>DL_AESADV_setCCMAlignWord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_AESADV_setCCMAlignWord </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>alignWord</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the CCM AAD align data word. </p>
<p>Specific to CCM mode. Writes the alignment data word used to concatenate to the next block of additional authentication data (AAD). Will need to be set during initialization or during the resumption of a halted CCM operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alignWord</td><td>AAD alignment word of type uint32_t </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaac7c69f552939143cab3d86db2a4d44b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac7c69f552939143cab3d86db2a4d44b">&sect;&nbsp;</a></span>DL_AESADV_getCCMAlignWord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_AESADV_getCCMAlignWord </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the CCM AAD align data word. </p>
<p>Specific to CCM mode. Reads the alignment data word used to concatenate to the next block of additional authentication data (AAD).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current AAD alignment word of type uint32_t </dd></dl>

</div>
</div>
<a id="gae0f27b2740b67c402c7bdb271f399f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0f27b2740b67c402c7bdb271f399f21">&sect;&nbsp;</a></span>DL_AESADV_setLowerBlockCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_AESADV_setLowerBlockCount </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lowerBlockCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the lower 32-bits of the data blocks remaining in an operation. </p>
<p>Specific to GCM/CCM mode. The block count is 57-bits and represents the number of remaining AES cryptographic payload blocks (non-AAD) in an operation. During an interruption of a GCM/CCM operation, this number needs to be saved and restored before resumption.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lowerBlockCount</td><td>Lower 32-bits of the overall data blocks remaining</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#gae75c75b301ea2bb12faa0893975ae1ec" title="Gets the lower 32-bits of the data blocks remaining in an operation. ">DL_AESADV_getLowerBlockCount</a> </dd>
<dd>
<a class="el" href="group___a_e_s_a_d_v.html#ga4c1bd8ad42f507be84bdeb2f77467e11" title="Sets the upper 25-bits of the data blocks remaining in an operation. ">DL_AESADV_setUpperBlockCount</a> </dd></dl>

</div>
</div>
<a id="gae75c75b301ea2bb12faa0893975ae1ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae75c75b301ea2bb12faa0893975ae1ec">&sect;&nbsp;</a></span>DL_AESADV_getLowerBlockCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_AESADV_getLowerBlockCount </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the lower 32-bits of the data blocks remaining in an operation. </p>
<p>Specific to GCM/CCM mode. The block count is 57-bits and represents the number of remaining AES cryptographic payload blocks (non-AAD) in an operation. During an interruption of a GCM/CCM operation, this number needs to be saved and restored before resumption.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Lower 32-bits of overall data blocks remaining</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#gae0f27b2740b67c402c7bdb271f399f21" title="Sets the lower 32-bits of the data blocks remaining in an operation. ">DL_AESADV_setLowerBlockCount</a> </dd></dl>

</div>
</div>
<a id="ga4c1bd8ad42f507be84bdeb2f77467e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c1bd8ad42f507be84bdeb2f77467e11">&sect;&nbsp;</a></span>DL_AESADV_setUpperBlockCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_AESADV_setUpperBlockCount </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>upperBlockCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the upper 25-bits of the data blocks remaining in an operation. </p>
<p>Specific to GCM/CCM mode. The block count is 57-bits and represents the number of remaining AES cryptographic payload blocks (non-AAD) in an operation. During an interruption of a GCM/CCM operation, this number needs to be saved and restored before resumption.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">upperBlockCount</td><td>Upper 25-bits of the overall data blocks remaining (bits [25:31] are ignored)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#ga49c8bfdbe2910b9371fc077c903fd6f8" title="Gets the upper 25-bits of the data blocks remaining in an operation. ">DL_AESADV_getUpperBlockCount</a> </dd>
<dd>
<a class="el" href="group___a_e_s_a_d_v.html#gae0f27b2740b67c402c7bdb271f399f21" title="Sets the lower 32-bits of the data blocks remaining in an operation. ">DL_AESADV_setLowerBlockCount</a> </dd></dl>

</div>
</div>
<a id="ga49c8bfdbe2910b9371fc077c903fd6f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49c8bfdbe2910b9371fc077c903fd6f8">&sect;&nbsp;</a></span>DL_AESADV_getUpperBlockCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_AESADV_getUpperBlockCount </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the upper 25-bits of the data blocks remaining in an operation. </p>
<p>Specific to GCM/CCM mode. The block count is 57-bits and represents the number of remaining AES cryptographic payload blocks (non-AAD) in an operation. During an interruption of a GCM/CCM operation, this number needs to be saved and restored before resumption.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Upper 25-bits of overall data blocks remaining (bits [25:31] are 0)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#ga4c1bd8ad42f507be84bdeb2f77467e11" title="Sets the upper 25-bits of the data blocks remaining in an operation. ">DL_AESADV_setUpperBlockCount</a> </dd></dl>

</div>
</div>
<a id="ga54e6c8aa4200a171548d3b4b9cb00eaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54e6c8aa4200a171548d3b4b9cb00eaa">&sect;&nbsp;</a></span>DL_AESADV_enableInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_AESADV_enableInterrupt </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable AESADV interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptMask</td><td>Bit mask of interrupts to enable. Bitwise OR of <a class="el" href="group___d_l___a_e_s_a_d_v___i_n_t_e_r_r_u_p_t.html">DL_AESADV_INTERRUPT</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7922537cf28b5963a7ceffaf2d6e87fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7922537cf28b5963a7ceffaf2d6e87fb">&sect;&nbsp;</a></span>DL_AESADV_disableInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_AESADV_disableInterrupt </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable AESADV interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptMask</td><td>Bit mask of interrupts to enable. Bitwise OR of <a class="el" href="group___d_l___a_e_s_a_d_v___i_n_t_e_r_r_u_p_t.html">DL_AESADV_INTERRUPT</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab2ca2472856ad8765345546c396ef2e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2ca2472856ad8765345546c396ef2e1">&sect;&nbsp;</a></span>DL_AESADV_getEnabledInterrupts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_AESADV_getEnabledInterrupts </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if AES Ready interrupt is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptMask</td><td>Bit mask of interrupts to check. Bitwise OR of <a class="el" href="group___d_l___a_e_s_a_d_v___i_n_t_e_r_r_u_p_t.html">DL_AESADV_INTERRUPT</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Which of the requested AESADV interrupts are enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Bitwise</td><td>OR of <a class="el" href="group___d_l___a_e_s_a_d_v___i_n_t_e_r_r_u_p_t.html">DL_AESADV_INTERRUPT</a> values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae581b8646fe45657926297fffb4d1108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae581b8646fe45657926297fffb4d1108">&sect;&nbsp;</a></span>DL_AESADV_getEnabledInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_AESADV_getEnabledInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check interrupt flag of enabled AESADV interrupts. </p>
<p>Checks if any of the AESADV interrupts that was previously enabled are pending.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptMask</td><td>Bit mask of interrupts to check. Bitwise OR of <a class="el" href="group___d_l___a_e_s_a_d_v___i_n_t_e_r_r_u_p_t.html">DL_AESADV_INTERRUPT</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Which of the requested and enabled AESADV interrupts are pending</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Bitwise</td><td>OR of <a class="el" href="group___d_l___a_e_s_a_d_v___i_n_t_e_r_r_u_p_t.html">DL_AESADV_INTERRUPT</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#ga54e6c8aa4200a171548d3b4b9cb00eaa" title="Enable AESADV interrupts. ">DL_AESADV_enableInterrupt</a> </dd></dl>

</div>
</div>
<a id="ga421329334046bc2bd4f44ed4906bec60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga421329334046bc2bd4f44ed4906bec60">&sect;&nbsp;</a></span>DL_AESADV_getRawInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_AESADV_getRawInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check interrupt flag of any AESADV interrupts. </p>
<p>Checks if any of the AESADV interrupts are pending. Interrupts do not have to be previously enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptMask</td><td>Bit mask of interrupts to check. Bitwise OR of <a class="el" href="group___d_l___a_e_s_a_d_v___i_n_t_e_r_r_u_p_t.html">DL_AESADV_INTERRUPT</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Which of the requested AESADV interrupts are pending</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Bitwise</td><td>OR of <a class="el" href="group___d_l___a_e_s_a_d_v___i_n_t_e_r_r_u_p_t.html">DL_AESADV_INTERRUPT</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga46bbd7ddc67ebf98ef62a223a9aa7d10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46bbd7ddc67ebf98ef62a223a9aa7d10">&sect;&nbsp;</a></span>DL_AESADV_getPendingInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___a_e_s_a_d_v.html#ga3f7504f482098af84c7e1f6ee2ee5170">DL_AESADV_IIDX</a> DL_AESADV_getPendingInterrupt </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get highest priority pending AESADV interrupt. </p>
<p>Checks if any AESADV interrupts are pending. Interrupt does not have to be previously enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The highest priority pending AESADV interrupt</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___a_e_s_a_d_v.html#ga3f7504f482098af84c7e1f6ee2ee5170">DL_AESADV_IIDX</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf7eb3a7cc695446381c4d6c8f2b64fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7eb3a7cc695446381c4d6c8f2b64fb0">&sect;&nbsp;</a></span>DL_AESADV_clearInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_AESADV_clearInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear pending AESADV Interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptMask</td><td>Bit mask of interrupts to clear. Bitwise OR of <a class="el" href="group___d_l___a_e_s_a_d_v___i_n_t_e_r_r_u_p_t.html">DL_AESADV_INTERRUPT</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabe0964efd679714bba0ae610539735ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe0964efd679714bba0ae610539735ae">&sect;&nbsp;</a></span>DL_AESADV_enableDMAInputTriggerEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_AESADV_enableDMAInputTriggerEvent </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables DMA input trigger to publish AESADV write requests to the DMA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l___a_e_s_a_d_v___e_v_e_n_t.html#ga662e26fd875c2da456c1eb727fe3a2c8">DL_AESADV_EVENT_DMA_DATA_INPUT_TRIGGER</a>.</p>

</div>
</div>
<a id="ga355109409c8bf8e2dfd29a18732539e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga355109409c8bf8e2dfd29a18732539e7">&sect;&nbsp;</a></span>DL_AESADV_enableDMAOutputTriggerEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_AESADV_enableDMAOutputTriggerEvent </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables DMA output trigger to publish AESADV read requests to the DMA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l___a_e_s_a_d_v___e_v_e_n_t.html#ga3502cafdf58f2ad39a3dbaaf9649eeee">DL_AESADV_EVENT_DMA_DATA_OUTPUT_TRIGGER</a>.</p>

</div>
</div>
<a id="ga76929642b261317b0a55e7ddd24599ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76929642b261317b0a55e7ddd24599ac">&sect;&nbsp;</a></span>DL_AESADV_disableDMAInputTriggerEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_AESADV_disableDMAInputTriggerEvent </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable DMA input trigger event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l___a_e_s_a_d_v___e_v_e_n_t.html#ga662e26fd875c2da456c1eb727fe3a2c8">DL_AESADV_EVENT_DMA_DATA_INPUT_TRIGGER</a>.</p>

</div>
</div>
<a id="ga10672e657d89dc89e973027e763d1912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10672e657d89dc89e973027e763d1912">&sect;&nbsp;</a></span>DL_AESADV_disableDMAOutputTriggerEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_AESADV_disableDMAOutputTriggerEvent </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable DMA output trigger event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l___a_e_s_a_d_v___e_v_e_n_t.html#ga3502cafdf58f2ad39a3dbaaf9649eeee">DL_AESADV_EVENT_DMA_DATA_OUTPUT_TRIGGER</a>.</p>

</div>
</div>
<a id="gadcb98ed153ca4c5b7eb90949bdc4ad45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcb98ed153ca4c5b7eb90949bdc4ad45">&sect;&nbsp;</a></span>DL_AESADV_getEnabledDMAInputTriggerEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_AESADV_getEnabledDMAInputTriggerEvent </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the DMA input trigger event is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If DMA input trigger event is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_AESADV_EVENT_DMA_DATA_INPUT_TRIGGER</td><td>if DMA input trigger event is enabled </td></tr>
    <tr><td class="paramname">0</td><td>if DMA input trigger event is not enabled </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l___a_e_s_a_d_v___e_v_e_n_t.html#ga662e26fd875c2da456c1eb727fe3a2c8">DL_AESADV_EVENT_DMA_DATA_INPUT_TRIGGER</a>.</p>

</div>
</div>
<a id="ga0eb639ba3b807b860540c2bd3706a262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0eb639ba3b807b860540c2bd3706a262">&sect;&nbsp;</a></span>DL_AESADV_getEnabledDMAOutputTriggerEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_AESADV_getEnabledDMAOutputTriggerEvent </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the DMA output trigger event is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If DMA output trigger event is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_AESADV_EVENT_DMA_DATA_OUTPUT_TRIGGER</td><td>if DMA output trigger event is enabled </td></tr>
    <tr><td class="paramname">0</td><td>if DMA output trigger event is not enabled </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l___a_e_s_a_d_v___e_v_e_n_t.html#ga3502cafdf58f2ad39a3dbaaf9649eeee">DL_AESADV_EVENT_DMA_DATA_OUTPUT_TRIGGER</a>.</p>

</div>
</div>
<a id="gac5bb216de14afb4029f850fd7dd9056b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5bb216de14afb4029f850fd7dd9056b">&sect;&nbsp;</a></span>DL_AESADV_getEnabledDMAInputTriggerEventStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_AESADV_getEnabledDMAInputTriggerEventStatus </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check interrupt flag of DMA input trigger event. </p>
<p>Checks if DMA input trigger event that was previously enabled is pending.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If DMA input trigger event is pending</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_AESADV_EVENT_DMA_DATA_INPUT_TRIGGER</td><td>if DMA input trigger event is pending </td></tr>
    <tr><td class="paramname">0</td><td>if DMA input trigger event is not pending</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#gabe0964efd679714bba0ae610539735ae" title="Enables DMA input trigger to publish AESADV write requests to the DMA. ">DL_AESADV_enableDMAInputTriggerEvent</a> </dd></dl>

<p>References <a class="el" href="group___d_l___a_e_s_a_d_v___e_v_e_n_t.html#ga662e26fd875c2da456c1eb727fe3a2c8">DL_AESADV_EVENT_DMA_DATA_INPUT_TRIGGER</a>.</p>

</div>
</div>
<a id="ga4d9d1aeb4264e73d6a9e598c01d676ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d9d1aeb4264e73d6a9e598c01d676ae">&sect;&nbsp;</a></span>DL_AESADV_getEnabledDMAOutputTriggerEventStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_AESADV_getEnabledDMAOutputTriggerEventStatus </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check interrupt flag of DMA output trigger event. </p>
<p>Checks if DMA output trigger event that was previously enabled is pending.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If DMA output trigger event is pending</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_AESADV_EVENT_DMA_DATA_OUTPUT_TRIGGER</td><td>if DMA output trigger event is pending </td></tr>
    <tr><td class="paramname">0</td><td>if DMA output trigger event is not pending</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#ga355109409c8bf8e2dfd29a18732539e7" title="Enables DMA output trigger to publish AESADV read requests to the DMA. ">DL_AESADV_enableDMAOutputTriggerEvent</a> </dd></dl>

<p>References <a class="el" href="group___d_l___a_e_s_a_d_v___e_v_e_n_t.html#ga3502cafdf58f2ad39a3dbaaf9649eeee">DL_AESADV_EVENT_DMA_DATA_OUTPUT_TRIGGER</a>.</p>

</div>
</div>
<a id="ga1e4a53eace7cbbfaef2d86511a6e68a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e4a53eace7cbbfaef2d86511a6e68a1">&sect;&nbsp;</a></span>DL_AESADV_getRawDMAInputTriggerEventStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_AESADV_getRawDMAInputTriggerEventStatus </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check interrupt flag of DMA input trigger event. </p>
<p>Checks if DMA input trigger event is pending. Event does not have to be previously enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If DMA input trigger event is pending</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_AESADV_EVENT_DMA_DATA_INPUT_TRIGGER</td><td>if DMA input trigger event is pending </td></tr>
    <tr><td class="paramname">0</td><td>if DMA input trigger event is not pending </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l___a_e_s_a_d_v___e_v_e_n_t.html#ga662e26fd875c2da456c1eb727fe3a2c8">DL_AESADV_EVENT_DMA_DATA_INPUT_TRIGGER</a>.</p>

</div>
</div>
<a id="gaecc5b1b7d48d8c30666a3b7e2f239583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecc5b1b7d48d8c30666a3b7e2f239583">&sect;&nbsp;</a></span>DL_AESADV_getRawDMAOutputTriggerEventStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_AESADV_getRawDMAOutputTriggerEventStatus </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check interrupt flag of DMA output trigger event. </p>
<p>Checks if DMA output trigger event is pending. Event does not have to be previously enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If DMA output trigger event is pending</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_AESADV_EVENT_DMA_DATA_INPUT_TRIGGER</td><td>if DMA output trigger event is pending </td></tr>
    <tr><td class="paramname">0</td><td>if DMA output trigger event is not pending </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l___a_e_s_a_d_v___e_v_e_n_t.html#ga3502cafdf58f2ad39a3dbaaf9649eeee">DL_AESADV_EVENT_DMA_DATA_OUTPUT_TRIGGER</a>.</p>

</div>
</div>
<a id="ga813824d62e7ae3d0816f6a380cc08de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga813824d62e7ae3d0816f6a380cc08de3">&sect;&nbsp;</a></span>DL_AESADV_getPendingDMAInputTriggerEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___a_e_s_a_d_v.html#ga3f7504f482098af84c7e1f6ee2ee5170">DL_AESADV_IIDX</a> DL_AESADV_getPendingDMAInputTriggerEvent </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get highest priority pending DMA input trigger event. </p>
<p>Checks if DMA input trigger event is pending. Event does not have to be previously enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The highest priority pending DMA input trigger event </dd></dl>

</div>
</div>
<a id="ga16999323e259031b491f57f42854c155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16999323e259031b491f57f42854c155">&sect;&nbsp;</a></span>DL_AESADV_getPendingDMAOutputTriggerEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___a_e_s_a_d_v.html#ga3f7504f482098af84c7e1f6ee2ee5170">DL_AESADV_IIDX</a> DL_AESADV_getPendingDMAOutputTriggerEvent </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get highest priority pending DMA output trigger event. </p>
<p>Checks if DMA output trigger event is pending. Event does not have to be previously enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The highest priority pending DMA output trigger event </dd></dl>

</div>
</div>
<a id="ga3d43af51870a418b9803f8dc420765de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d43af51870a418b9803f8dc420765de">&sect;&nbsp;</a></span>DL_AESADV_clearDMAInputTriggerEventStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_AESADV_clearDMAInputTriggerEventStatus </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear pending DMA input trigger event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l___a_e_s_a_d_v___e_v_e_n_t.html#ga662e26fd875c2da456c1eb727fe3a2c8">DL_AESADV_EVENT_DMA_DATA_INPUT_TRIGGER</a>.</p>

</div>
</div>
<a id="ga4dc6f4ca16d58a6ba9a3ebd4b44d6d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4dc6f4ca16d58a6ba9a3ebd4b44d6d75">&sect;&nbsp;</a></span>DL_AESADV_clearDMAOutputTriggerEventStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_AESADV_clearDMAOutputTriggerEventStatus </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear pending DMA output trigger event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l___a_e_s_a_d_v___e_v_e_n_t.html#ga3502cafdf58f2ad39a3dbaaf9649eeee">DL_AESADV_EVENT_DMA_DATA_OUTPUT_TRIGGER</a>.</p>

</div>
</div>
<a id="gab2f28566603a5f60c1e14a9560a5058c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2f28566603a5f60c1e14a9560a5058c">&sect;&nbsp;</a></span>DL_AESADV_getDATAINAddr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uintptr_t DL_AESADV_getDATAINAddr </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the address of the AESADV input data register. </p>
<p>This API can be used with <a class="el" href="group___d_m_a.html#ga7d8be896ace7a9196d11e351e2d2e7f7">DL_DMA_setDestAddr</a> to set the destination address when using DMA transfers. The Data should be written as 128-bit block writes (4 32-bit words) to a region of memory starting at the provided address. Use with the <a class="el" href="group___a_e_s_a_d_v.html#ga908ceb58d56dd2b3e840ea585f7c263a">DL_AESADV_enableDMAOperation</a> The DMA output request use <a class="el" href="group___d_l___a_e_s_a_d_v___e_v_e_n_t.html#ga3502cafdf58f2ad39a3dbaaf9649eeee">DL_AESADV_EVENT_DMA_DATA_OUTPUT_TRIGGER</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address of the AESADV input data register</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#ga908ceb58d56dd2b3e840ea585f7c263a" title="Enables DMA Operation for the AESADV module. ">DL_AESADV_enableDMAOperation</a> </dd></dl>

</div>
</div>
<a id="ga68bea28934ad0996503a7d3b6050b9ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68bea28934ad0996503a7d3b6050b9ea">&sect;&nbsp;</a></span>DL_AESADV_getDATAOUTAddr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uintptr_t DL_AESADV_getDATAOUTAddr </td>
          <td>(</td>
          <td class="paramtype">const AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the address of the AESADV output data register. </p>
<p>This API can be used with <a class="el" href="group___d_m_a.html#ga7d8be896ace7a9196d11e351e2d2e7f7">DL_DMA_setDestAddr</a> to set the destination address when using DMA transfers. The Data should be read as 128-bit block read (4 32-bit words) to a region of memory starting at the provided address. Use with the <a class="el" href="group___a_e_s_a_d_v.html#ga908ceb58d56dd2b3e840ea585f7c263a">DL_AESADV_enableDMAOperation</a> The DMA output request use <a class="el" href="group___d_l___a_e_s_a_d_v___e_v_e_n_t.html#ga3502cafdf58f2ad39a3dbaaf9649eeee">DL_AESADV_EVENT_DMA_DATA_OUTPUT_TRIGGER</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address of the AESADV output data register</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#ga908ceb58d56dd2b3e840ea585f7c263a" title="Enables DMA Operation for the AESADV module. ">DL_AESADV_enableDMAOperation</a> </dd></dl>

<p>References <a class="el" href="group___a_e_s_a_d_v.html#ga48add39ee72534807d574adabc4f61ca">DL_AESADV_initCBC()</a>, <a class="el" href="group___a_e_s_a_d_v.html#ga7b5661b4d5d52bd1c7ad0227d54e8f77">DL_AESADV_initCBCMAC()</a>, <a class="el" href="group___a_e_s_a_d_v.html#ga6c966e126355e7911d6b087ec23dc928">DL_AESADV_initCCM()</a>, <a class="el" href="group___a_e_s_a_d_v.html#gaf8001c8319f91c4f3bc89f96fc6d9343">DL_AESADV_initCFB()</a>, <a class="el" href="group___a_e_s_a_d_v.html#ga90e3e6ef1bfbe884bf0355dea9f5eee9">DL_AESADV_initCMAC()</a>, <a class="el" href="group___a_e_s_a_d_v.html#gaf649234917ffda8fb56c8849b8ed3f59">DL_AESADV_initCTR()</a>, <a class="el" href="group___a_e_s_a_d_v.html#ga33fbb43b746e65758b308363e2914bb8">DL_AESADV_initECB()</a>, <a class="el" href="group___a_e_s_a_d_v.html#ga89bbf635c29581b3ac9be21ac5454568">DL_AESADV_initGCM()</a>, <a class="el" href="group___a_e_s_a_d_v.html#ga2bd842884eeeb6394d39dca3cec080ac">DL_AESADV_initICM()</a>, and <a class="el" href="group___a_e_s_a_d_v.html#ga6b9352dfacc7354aea98a0dbd9b75c55">DL_AESADV_initOFB()</a>.</p>

</div>
</div>
<a id="ga33fbb43b746e65758b308363e2914bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33fbb43b746e65758b308363e2914bb8">&sect;&nbsp;</a></span>DL_AESADV_initECB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_AESADV_initECB </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_d_l___a_e_s_a_d_v___config.html">DL_AESADV_Config</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the engine in the Electronic Codebook (ECB) mode. </p>
<p>This function is designed to place the engine in Electronic Codebook (ECB) mode with all necessary control context. The primary key, however, must be set into the AES engine before this function is called. This is because the key could come from either the KEYSTORECTL or from plaintext depending on system setting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Pointer to configuration struct with valid values for: direction, lowerCryptoLength, upperCryptoLength</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#ga89f2de712fd99550d60ee31265b1f54e" title="Loads a 128 or 256 bit regular key to the AESADV module. ">DL_AESADV_setKey</a> </dd></dl>

<p>Referenced by <a class="el" href="group___a_e_s_a_d_v.html#ga68bea28934ad0996503a7d3b6050b9ea">DL_AESADV_getDATAOUTAddr()</a>.</p>

</div>
</div>
<a id="ga48add39ee72534807d574adabc4f61ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48add39ee72534807d574adabc4f61ca">&sect;&nbsp;</a></span>DL_AESADV_initCBC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_AESADV_initCBC </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_d_l___a_e_s_a_d_v___config.html">DL_AESADV_Config</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the engine in the Cipher-Block Chaining (CBC) mode. </p>
<p>This function is designed to place the engine in Cipher Block Chaining (CBC) mode with all necessary control context. The primary key, however, must be set into the AES engine before this function is called. This is because the key could come from either the KEYSTORECTL or from plaintext depending on system setting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Pointer to configuration struct with valid values for: direction, iv, lowerCryptoLength, upperCryptoLength</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#ga89f2de712fd99550d60ee31265b1f54e" title="Loads a 128 or 256 bit regular key to the AESADV module. ">DL_AESADV_setKey</a> </dd></dl>

<p>Referenced by <a class="el" href="group___a_e_s_a_d_v.html#ga68bea28934ad0996503a7d3b6050b9ea">DL_AESADV_getDATAOUTAddr()</a>.</p>

</div>
</div>
<a id="gaf8001c8319f91c4f3bc89f96fc6d9343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8001c8319f91c4f3bc89f96fc6d9343">&sect;&nbsp;</a></span>DL_AESADV_initCFB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_AESADV_initCFB </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_d_l___a_e_s_a_d_v___config.html">DL_AESADV_Config</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the engine in the Cipher Feedback (CFB) mode. </p>
<p>This function is designed to place the engine in Cipher Feedback (CFB) mode with all necessary control context. The primary key, however, must be set into the AES engine before this function is called. This is because the key could come from either the KEYSTORECTL or from plaintext depending on system setting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Pointer to configuration struct with valid values for: direction, iv, lowerCryptoLength, upperCryptoLength, cfb_fbWidth</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#ga89f2de712fd99550d60ee31265b1f54e" title="Loads a 128 or 256 bit regular key to the AESADV module. ">DL_AESADV_setKey</a> </dd></dl>

<p>Referenced by <a class="el" href="group___a_e_s_a_d_v.html#ga68bea28934ad0996503a7d3b6050b9ea">DL_AESADV_getDATAOUTAddr()</a>.</p>

</div>
</div>
<a id="ga6b9352dfacc7354aea98a0dbd9b75c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b9352dfacc7354aea98a0dbd9b75c55">&sect;&nbsp;</a></span>DL_AESADV_initOFB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_AESADV_initOFB </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_d_l___a_e_s_a_d_v___config.html">DL_AESADV_Config</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the engine in the Output Feedback (OFB) mode. </p>
<p>This function is designed to place the engine in Output Feedback (OFB) mode with all necessary control context. The primary key, however, must be set into the AES engine before this function is called. This is because the key could come from either the KEYSTORECTL or from plaintext depending on system setting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Pointer to configuration struct with valid values for: direction, iv, lowerCryptoLength, upperCryptoLength</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#ga89f2de712fd99550d60ee31265b1f54e" title="Loads a 128 or 256 bit regular key to the AESADV module. ">DL_AESADV_setKey</a> </dd></dl>

<p>Referenced by <a class="el" href="group___a_e_s_a_d_v.html#ga68bea28934ad0996503a7d3b6050b9ea">DL_AESADV_getDATAOUTAddr()</a>.</p>

</div>
</div>
<a id="gaf649234917ffda8fb56c8849b8ed3f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf649234917ffda8fb56c8849b8ed3f59">&sect;&nbsp;</a></span>DL_AESADV_initCTR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_AESADV_initCTR </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_d_l___a_e_s_a_d_v___config.html">DL_AESADV_Config</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the engine in the Counter (CTR) mode. </p>
<p>This function is designed to place the engine in Counter (CTR) mode with all necessary control context. The primary key, however, must be set into the AES engine before this function is called. This is because the key could come from either the KEYSTORECTL or from plaintext depending on system setting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Pointer to configuration struct with valid values for: direction iv, lowerCryptoLength, upperCryptoLength, ctr_ctrWidth. IV is typically 0x00000001</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#ga89f2de712fd99550d60ee31265b1f54e" title="Loads a 128 or 256 bit regular key to the AESADV module. ">DL_AESADV_setKey</a> </dd></dl>

<p>Referenced by <a class="el" href="group___a_e_s_a_d_v.html#ga68bea28934ad0996503a7d3b6050b9ea">DL_AESADV_getDATAOUTAddr()</a>.</p>

</div>
</div>
<a id="ga2bd842884eeeb6394d39dca3cec080ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bd842884eeeb6394d39dca3cec080ac">&sect;&nbsp;</a></span>DL_AESADV_initICM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_AESADV_initICM </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_d_l___a_e_s_a_d_v___config.html">DL_AESADV_Config</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the engine in the Integer Counter Mode (ICM) </p>
<p>This function is designed to place the engine in Integer Counter Mode (ICM) with all necessary control context. ICM is a variant of CTR mode with a 16- bit wide counter value. The primary key, however, must be set into the AES engine before this function is called. This is because the key could come from either the KEYSTORECTL or from plaintext depending on system setting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Pointer to configuration struct with valid values for: direction iv, lowerCryptoLength, upperCryptoLength. IV is typically 0x00000001</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#ga89f2de712fd99550d60ee31265b1f54e" title="Loads a 128 or 256 bit regular key to the AESADV module. ">DL_AESADV_setKey</a> </dd></dl>

<p>Referenced by <a class="el" href="group___a_e_s_a_d_v.html#ga68bea28934ad0996503a7d3b6050b9ea">DL_AESADV_getDATAOUTAddr()</a>.</p>

</div>
</div>
<a id="ga90e3e6ef1bfbe884bf0355dea9f5eee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90e3e6ef1bfbe884bf0355dea9f5eee9">&sect;&nbsp;</a></span>DL_AESADV_initCMAC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_AESADV_initCMAC </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_d_l___a_e_s_a_d_v___config.html">DL_AESADV_Config</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the engine in the block cipher-based Message Authentication Code (CMAC) </p>
<p>This function is designed to place the engine in block cipher-based Message Authentication Code: CMAC. CMAC is strictly authentication and does not generate any ciphertext or plaintext, but only a tag. CMAC is also recommended by NIST in SP 800-38B for authentication. It consists of a primary key as well as derived keys K1 and K2 which must be provided in the configuration. The engine will not derive K1 and K2, and these must be calculated beforehand and included in the config struct. The primary key from which K1 and K2 are derived, however, must be set in the AES engine before this function is called. This is because the key could come from either the KEYSTORECTL or from plaintext depending on system setting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Pointer to configuration struct with valid values for: K1, K2, lowerCryptoLength, upperCryptoLength.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#ga89f2de712fd99550d60ee31265b1f54e" title="Loads a 128 or 256 bit regular key to the AESADV module. ">DL_AESADV_setKey</a> </dd></dl>

<p>Referenced by <a class="el" href="group___a_e_s_a_d_v.html#ga68bea28934ad0996503a7d3b6050b9ea">DL_AESADV_getDATAOUTAddr()</a>.</p>

</div>
</div>
<a id="ga7b5661b4d5d52bd1c7ad0227d54e8f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b5661b4d5d52bd1c7ad0227d54e8f77">&sect;&nbsp;</a></span>DL_AESADV_initCBCMAC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_AESADV_initCBCMAC </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_d_l___a_e_s_a_d_v___config.html">DL_AESADV_Config</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the engine in the Cipher Block Chaining Message Authenication Code (CBC-MAC) </p>
<p>This function is designed to place the engine in Cipher Block Chaining Message Authenication Code (CBC-MAC). CBC-MAC is strictly authentication and does not generate any ciphertext or plaintext, but only a tag. The primary key, however, must be set into the AES engine before this function is called. This is because the key could come from either the KEYSTORECTL or from plaintext depending on system setting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Pointer to configuration struct with valid values for: lowerCryptoLength, upperCryptoLength.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#ga89f2de712fd99550d60ee31265b1f54e" title="Loads a 128 or 256 bit regular key to the AESADV module. ">DL_AESADV_setKey</a> </dd></dl>

<p>Referenced by <a class="el" href="group___a_e_s_a_d_v.html#ga68bea28934ad0996503a7d3b6050b9ea">DL_AESADV_getDATAOUTAddr()</a>.</p>

</div>
</div>
<a id="ga89bbf635c29581b3ac9be21ac5454568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89bbf635c29581b3ac9be21ac5454568">&sect;&nbsp;</a></span>DL_AESADV_initGCM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_AESADV_initGCM </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_d_l___a_e_s_a_d_v___config.html">DL_AESADV_Config</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the engine in the Galois/Counter Mode (GCM) </p>
<p>This function is designed to place the engine in Galois/Counter Mode (GCM). GCM is both authentication and data encryption, and will generate both ciphertext/plaintext and the corresponding tag. The primary key and hash key (if expected from <a class="el" href="group___a_e_s_a_d_v.html#ga554c682ff764f2162c9abe010f1c2f41">DL_AESADV_MODE</a>) must be set into the AES engine before this function is called. This is because the key could come from either the KEYSTORECTL or from plaintext depending on system setting. After this function has completed, the user is to first input all additional authentication data (AAD) before entering the crypto payload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Pointer to configuration struct with valid values for: mode (one of the GCM operations), direction, iv, lowerCryptoLength, upperCryptoLength, aadLength. IV is typically 0x00000001. The maximum length in bytes is 2^36 - 32.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#ga89f2de712fd99550d60ee31265b1f54e" title="Loads a 128 or 256 bit regular key to the AESADV module. ">DL_AESADV_setKey</a> </dd>
<dd>
DL_AESADV_setHashKey </dd></dl>

<p>Referenced by <a class="el" href="group___a_e_s_a_d_v.html#ga68bea28934ad0996503a7d3b6050b9ea">DL_AESADV_getDATAOUTAddr()</a>.</p>

</div>
</div>
<a id="ga6c966e126355e7911d6b087ec23dc928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c966e126355e7911d6b087ec23dc928">&sect;&nbsp;</a></span>DL_AESADV_initCCM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_AESADV_initCCM </td>
          <td>(</td>
          <td class="paramtype">AESADV_Regs *&#160;</td>
          <td class="paramname"><em>aesadv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_d_l___a_e_s_a_d_v___config.html">DL_AESADV_Config</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the engine in the Counter &amp; CBC-MAC (CCM)mode. </p>
<p>This function is designed to place the engine in Counter and Cipher-Block Chaining Message Authentication Code (CCM) mode. CCM is both authentication and data encryption, and will generate both ciphertext/plaintext and the corresponding tag. To calculate the length of the nonce and the counter width, please refer to <a class="el" href="group___a_e_s_a_d_v.html#ga960f99bd9c3df04b0ae95082cc548830">DL_AESADV_loadCCMNonceAndCounter</a>. After this function has completed, the user is to first input all additional authentication data (AAD) before entering the crypto payload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aesadv</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Pointer to configuration struct with valid values for: direction, nonce, ccm_ctrWidth, ccm_tagWidth, lowerCryptoLength, upperCryptoLength, aadLength IV is typically 0x00000001. The maximum AAD Length is 2^16-2^8</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_e_s_a_d_v.html#ga89f2de712fd99550d60ee31265b1f54e" title="Loads a 128 or 256 bit regular key to the AESADV module. ">DL_AESADV_setKey</a> </dd></dl>

<p>Referenced by <a class="el" href="group___a_e_s_a_d_v.html#ga68bea28934ad0996503a7d3b6050b9ea">DL_AESADV_getDATAOUTAddr()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="https://www.ti.com/corp/docs/legal/copyright.shtml"> Copyright 1995-2025</a>, Texas Instruments Incorporated. All rights reserved. <br/>
  <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
