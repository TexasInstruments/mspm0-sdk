<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>MSPM0L122X_L222X Driver Library: MSPM0L122X_L222X System Control (SYSCTL)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MSPM0L122X_L222X Driver Library
   &#160;<span id="projectnumber">2.05.01.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MSPM0L122X_L222X System Control (SYSCTL)</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for MSPM0L122X_L222X System Control (SYSCTL):</div>
<div class="dyncontent">
<center><table><tr><td><img src="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.png" border="0" alt="" usemap="#group______s__y__s__c__t__l______m__s__p__m0__l122__x______l222__x"/>
<map name="group______s__y__s__c__t__l______m__s__p__m0__l122__x______l222__x" id="group______s__y__s__c__t__l______m__s__p__m0__l122__x______l222__x">
<area shape="rect" id="node2" href="group___d_l___s_y_s_c_t_l___i_n_t_e_r_r_u_p_t.html" title="DL_SYSCTL_INTERRUPT" alt="" coords="268,5,443,32"/>
<area shape="rect" id="node3" href="group___d_l___s_y_s_c_t_l___c_l_k___s_t_a_t_u_s.html" title="DL_SYSCTL_CLK_STATUS" alt="" coords="264,56,447,83"/>
<area shape="rect" id="node4" href="group___d_l___s_y_s_c_t_l___s_t_a_t_u_s.html" title="DL_SYSCTL_STATUS" alt="" coords="280,107,431,133"/>
<area shape="rect" id="node5" href="group___d_l___s_y_s_c_t_l___r_e_s_e_t.html" title="DL_SYSCTL_RESET" alt="" coords="284,157,427,184"/>
<area shape="rect" id="node6" href="group___d_l___s_y_s_c_t_l___n_m_i.html" title="DL_SYSCTL_NMI" alt="" coords="292,208,419,235"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group___d_l___s_y_s_c_t_l___r_e_s_e_t"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_l___s_y_s_c_t_l___r_e_s_e_t.html">DL_SYSCTL_RESET</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___d_l___s_y_s_c_t_l___i_n_t_e_r_r_u_p_t"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_l___s_y_s_c_t_l___i_n_t_e_r_r_u_p_t.html">DL_SYSCTL_INTERRUPT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___d_l___s_y_s_c_t_l___n_m_i"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_l___s_y_s_c_t_l___n_m_i.html">DL_SYSCTL_NMI</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___d_l___s_y_s_c_t_l___c_l_k___s_t_a_t_u_s"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_l___s_y_s_c_t_l___c_l_k___s_t_a_t_u_s.html">DL_SYSCTL_CLK_STATUS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___d_l___s_y_s_c_t_l___s_t_a_t_u_s"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_l___s_y_s_c_t_l___s_t_a_t_u_s.html">DL_SYSCTL_STATUS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l___s_y_s_c_t_l___s_y_s_o_s_c_user_trim_config.html">DL_SYSCTL_SYSOSCUserTrimConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration struct for <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga24a8058e617b55c859d4fc7b8dce56ca">DL_SYSCTL_configSYSOSCUserTrim</a>.  <a href="struct_d_l___s_y_s_c_t_l___s_y_s_o_s_c_user_trim_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l___s_y_s_c_t_l___l_f_c_l_k_config.html">DL_SYSCTL_LFCLKConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration struct for <a class="el" href="struct_d_l___s_y_s_c_t_l___l_f_c_l_k_config.html">DL_SYSCTL_LFCLKConfig</a>.  <a href="struct_d_l___s_y_s_c_t_l___l_f_c_l_k_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga4da4b81ab27057df56b8933baa88f495"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga4da4b81ab27057df56b8933baa88f495">DL_SYSCTL_setMCLKSource</a>(current,  next, ...)&#160;&#160;&#160;DL_SYSCTL_switchMCLKfrom##current##to##next(__VA_ARGS__);</td></tr>
<tr class="memdesc:ga4da4b81ab27057df56b8933baa88f495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change MCLK source.  <a href="#ga4da4b81ab27057df56b8933baa88f495">More...</a><br /></td></tr>
<tr class="separator:ga4da4b81ab27057df56b8933baa88f495"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga11f6187e683dcf2a0892c4ca5a818156"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga11f6187e683dcf2a0892c4ca5a818156">DL_SYSCTL_IIDX</a> { <br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga11f6187e683dcf2a0892c4ca5a818156a2f3e40fca586aecb1441f01a6754528b">DL_SYSCTL_IIDX_LFOSC_GOOD</a> = SYSCTL_IIDX_STAT_LFOSCGOOD, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga11f6187e683dcf2a0892c4ca5a818156af66353af425d4fdab66d1b89d4d0080c">DL_SYSCTL_IIDX_ANALOG_CLOCK_ERROR</a> = SYSCTL_IIDX_STAT_ANACLKERR, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga11f6187e683dcf2a0892c4ca5a818156ab9b42fe9e21276a511cfa8762c3b5521">DL_SYSCTL_IIDX_FLASH_SEC</a> = SYSCTL_IIDX_STAT_FLASHSEC, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga11f6187e683dcf2a0892c4ca5a818156a1dbdd9ef94c4e5278f9a4c185eb964e2">DL_SYSCTL_IIDX_SRAM_SEC</a> = SYSCTL_IIDX_STAT_SRAMSEC, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga11f6187e683dcf2a0892c4ca5a818156aaed008cb41818421b22cf98b1eb987cd">DL_SYSCTL_IIDX_LFXT_GOOD</a> = SYSCTL_IIDX_STAT_LFXTGOOD, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga11f6187e683dcf2a0892c4ca5a818156ac0b2b14d77cbbdd7ae23701ca09e7cf4">DL_SYSCTL_IIDX_HFCLK_GOOD</a> = SYSCTL_IIDX_STAT_HFCLKGOOD, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga11f6187e683dcf2a0892c4ca5a818156a78a5d4fb99a0d4398b0ee09f921f5c00">DL_SYSCTL_IIDX_HSCLK_GOOD</a> = SYSCTL_IIDX_STAT_HSCLKGOOD
<br />
 }</td></tr>
<tr class="separator:ga11f6187e683dcf2a0892c4ca5a818156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bcbb65890c723d59c075c19f49419e6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga6bcbb65890c723d59c075c19f49419e6">DL_SYSCTL_NMI_IIDX</a> { <br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga6bcbb65890c723d59c075c19f49419e6ae3180225fdb12c084461ea6c23b0a52d">DL_SYSCTL_NMI_IIDX_VBAT_ON</a> = SYSCTL_NMIIIDX_STAT_VBATUP, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga6bcbb65890c723d59c075c19f49419e6a9bb3e715d4a5a8ffaaf3bf04b6de6348">DL_SYSCTL_NMI_IIDX_VBAT_OFF</a> = SYSCTL_NMIIIDX_STAT_VBATDN, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga6bcbb65890c723d59c075c19f49419e6a8559633525839701876612217870e674">DL_SYSCTL_NMI_IIDX_SRAM_DED</a> = SYSCTL_NMIIIDX_STAT_SRAMDED, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga6bcbb65890c723d59c075c19f49419e6a1d7717f94056d2806267e23a56c49a0f">DL_SYSCTL_NMI_IIDX_FLASH_DED</a> = SYSCTL_NMIIIDX_STAT_FLASHDED, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga6bcbb65890c723d59c075c19f49419e6a958ed4545b4335d9a35d046c2644b4a1">DL_SYSCTL_NMI_IIDX_LFCLK_FAIL</a> = SYSCTL_NMIIIDX_STAT_LFCLKFAIL, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga6bcbb65890c723d59c075c19f49419e6a32ad0925f1581a29af6b155572b0ae41">DL_SYSCTL_NMI_IIDX_WWDT0_FAULT</a> = SYSCTL_NMIIIDX_STAT_WWDT0, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga6bcbb65890c723d59c075c19f49419e6adbbc9c64fa4723a7d96cb43234323cb1">DL_SYSCTL_NMI_IIDX_BORLVL</a> = SYSCTL_NMIIIDX_STAT_BORLVL, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga6bcbb65890c723d59c075c19f49419e6a477a9fed19f8834707ec78f8448d5768">DL_SYSCTL_NMI_IIDX_NO_INT</a> = SYSCTL_NMIIIDX_STAT_NO_INTR
<br />
 }</td></tr>
<tr class="separator:ga6bcbb65890c723d59c075c19f49419e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06e41abcd8e8c7519885e1a6f9f740e7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga06e41abcd8e8c7519885e1a6f9f740e7">DL_SYSCTL_ERROR_BEHAVIOR</a> { <br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga06e41abcd8e8c7519885e1a6f9f740e7abf6f1c4723ee80095714fd57cb4867f2">DL_SYSCTL_ERROR_BEHAVIOR_RESET</a> = 0x0, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga06e41abcd8e8c7519885e1a6f9f740e7ac239a8ae4ef547487c103d3a78f39f57">DL_SYSCTL_ERROR_BEHAVIOR_NMI</a> = 0x1
<br />
 }</td></tr>
<tr class="separator:ga06e41abcd8e8c7519885e1a6f9f740e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d02be2892b083ae42dc5ec338f52e46"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga2d02be2892b083ae42dc5ec338f52e46">DL_SYSCTL_SYSOSC_FREQ</a> { <br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga2d02be2892b083ae42dc5ec338f52e46a5ce32737edb72b88716f735b239eb057">DL_SYSCTL_SYSOSC_FREQ_4M</a> = (SYSCTL_SYSOSCCFG_FREQ_SYSOSC4M), 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga2d02be2892b083ae42dc5ec338f52e46a5c7a90ae7d414ed52626f9a29cdac113">DL_SYSCTL_SYSOSC_FREQ_BASE</a> = (SYSCTL_SYSOSCCFG_FREQ_SYSOSCBASE), 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga2d02be2892b083ae42dc5ec338f52e46aff6715c44cbe87725711d1dbec4dba5f">DL_SYSCTL_SYSOSC_FREQ_USERTRIM</a> = (SYSCTL_SYSOSCCFG_FREQ_SYSOSCUSER)
<br />
 }</td></tr>
<tr class="separator:ga2d02be2892b083ae42dc5ec338f52e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a8e0f66c60740baf11ae908341967b1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga3a8e0f66c60740baf11ae908341967b1">DL_SYSCTL_SYSOSC_USERTRIM_FREQ</a> { <br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga3a8e0f66c60740baf11ae908341967b1a61fcdf47be744018be9280d133a1a392">DL_SYSCTL_SYSOSC_USERTRIM_FREQ_16M</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga3a8e0f66c60740baf11ae908341967b1a95f7ac9d85d51942b44e8ce046649a08">DL_SYSCTL_SYSOSC_USERTRIM_FREQ_24M</a>
<br />
 }</td></tr>
<tr class="separator:ga3a8e0f66c60740baf11ae908341967b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada7eec2f3ea44a593a298c232fa8b98a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gada7eec2f3ea44a593a298c232fa8b98a">DL_SYSCTL_LFXT_DRIVE_STRENGTH</a> { <br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggada7eec2f3ea44a593a298c232fa8b98aa36f8ff9c3c74583f9175b7addc7242a9">DL_SYSCTL_LFXT_DRIVE_STRENGTH_LOWEST</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggada7eec2f3ea44a593a298c232fa8b98aad9bcbac2b22642ae52255975beee3ac8">DL_SYSCTL_LFXT_DRIVE_STRENGTH_LOWER</a> = (SYSCTL_LFCLKCFG_XT1DRIVE_LOWERDRV), 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggada7eec2f3ea44a593a298c232fa8b98aabf6b3e301f9c103463d099e597c8098b">DL_SYSCTL_LFXT_DRIVE_STRENGTH_HIGHER</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggada7eec2f3ea44a593a298c232fa8b98aa997253e7d266796a5c2fe11ee353fafa">DL_SYSCTL_LFXT_DRIVE_STRENGTH_HIGHEST</a>
<br />
 }</td></tr>
<tr class="separator:gada7eec2f3ea44a593a298c232fa8b98a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae709a299b57e30a00d2b05c12eaba591"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gae709a299b57e30a00d2b05c12eaba591">DL_SYSCTL_HFXT_RANGE</a> { <br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggae709a299b57e30a00d2b05c12eaba591a36054538d603ede5d5dc83971ec87e2d">DL_SYSCTL_HFXT_RANGE_4_8_MHZ</a> = SYSCTL_HFCLKCLKCFG_HFXTRSEL_RANGE4TO8, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggae709a299b57e30a00d2b05c12eaba591ace9a335a4287749c133fb992cb25b81b">DL_SYSCTL_HFXT_RANGE_8_16_MHZ</a> = SYSCTL_HFCLKCLKCFG_HFXTRSEL_RANGE8TO16, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggae709a299b57e30a00d2b05c12eaba591a5cca9d95913be9ddd9541c96b3224e01">DL_SYSCTL_HFXT_RANGE_16_32_MHZ</a> = SYSCTL_HFCLKCLKCFG_HFXTRSEL_RANGE16TO32, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggae709a299b57e30a00d2b05c12eaba591afeeff43614fe8e4bfae9346a9851e3ac">DL_SYSCTL_HFXT_RANGE_32_48_MHZ</a> = SYSCTL_HFCLKCLKCFG_HFXTRSEL_RANGE32TO48
<br />
 }</td></tr>
<tr class="separator:gae709a299b57e30a00d2b05c12eaba591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb318a4bb7a5bfb1555f660f63d32fbb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gadb318a4bb7a5bfb1555f660f63d32fbb">DL_SYSCTL_HSCLK_SOURCE</a> { <br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggadb318a4bb7a5bfb1555f660f63d32fbba8b263baa2fc4481f47a1f1a3ed7dd11c">DL_SYSCTL_HSCLK_SOURCE_INVALID</a> = 0x0, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggadb318a4bb7a5bfb1555f660f63d32fbba3dad0117e0b7effe624afd46cc3d9c8b">DL_SYSCTL_HSCLK_SOURCE_HFCLK</a> = SYSCTL_HSCLKCFG_HSCLKSEL_HFCLKCLK
<br />
 }</td></tr>
<tr class="separator:gadb318a4bb7a5bfb1555f660f63d32fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga644e04bc507e88dee66e3018d9dc1810"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga644e04bc507e88dee66e3018d9dc1810">DL_SYSCTL_MCLK_SOURCE</a> { <br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga644e04bc507e88dee66e3018d9dc1810a547a849ffccb2e4138f86a7fb43fa779">DL_SYSCTL_MCLK_SOURCE_SYSOSC</a> = SYSCTL_MCLKCFG_USEHSCLK_DISABLE, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga644e04bc507e88dee66e3018d9dc1810ac0715b7a79355262910d55373c6c752c">DL_SYSCTL_MCLK_SOURCE_HSCLK</a> = SYSCTL_MCLKCFG_USEHSCLK_ENABLE, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga644e04bc507e88dee66e3018d9dc1810af3668692deb5cff6da4b607c734a7179">DL_SYSCTL_MCLK_SOURCE_LFCLK</a> = SYSCTL_MCLKCFG_USELFCLK_ENABLE
<br />
 }</td></tr>
<tr class="separator:ga644e04bc507e88dee66e3018d9dc1810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga840c7f725afee13c0ba40fcad6ba5097"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga840c7f725afee13c0ba40fcad6ba5097">DL_SYSCTL_MCLK_DIVIDER</a> { <br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga840c7f725afee13c0ba40fcad6ba5097a476e7f20cd61f90f32dc8018f33abe3f">DL_SYSCTL_MCLK_DIVIDER_DISABLE</a> = 0x0, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga840c7f725afee13c0ba40fcad6ba5097a38afbe3d6f25b42913aeefaeccdfe5ac">DL_SYSCTL_MCLK_DIVIDER_2</a> = 0x1, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga840c7f725afee13c0ba40fcad6ba5097a74057127e23a03bc65bc15c02ffa3f3f">DL_SYSCTL_MCLK_DIVIDER_3</a> = 0x2, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga840c7f725afee13c0ba40fcad6ba5097a7bcedb58eab18dbdf416ecc07e610632">DL_SYSCTL_MCLK_DIVIDER_4</a> = 0x3, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga840c7f725afee13c0ba40fcad6ba5097af84c79151c829826b168ca02003b5ec8">DL_SYSCTL_MCLK_DIVIDER_5</a> = 0x4, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga840c7f725afee13c0ba40fcad6ba5097a2f5030f6b178e9e598960496520cdd24">DL_SYSCTL_MCLK_DIVIDER_6</a> = 0x5, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga840c7f725afee13c0ba40fcad6ba5097a22dc0f7556cc142526fe25aebe152913">DL_SYSCTL_MCLK_DIVIDER_7</a> = 0x6, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga840c7f725afee13c0ba40fcad6ba5097afc5274c5d7763951badb27da578b4c8a">DL_SYSCTL_MCLK_DIVIDER_8</a> = 0x7, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga840c7f725afee13c0ba40fcad6ba5097a025bb95642eb7c6ae03fcfec87729d94">DL_SYSCTL_MCLK_DIVIDER_9</a> = 0x8, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga840c7f725afee13c0ba40fcad6ba5097a6d9076f6a17fd95b86e0ee5f5cc3fd41">DL_SYSCTL_MCLK_DIVIDER_10</a> = 0x9, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga840c7f725afee13c0ba40fcad6ba5097a99da84ff0c05c1b0fe5e17a1b0731947">DL_SYSCTL_MCLK_DIVIDER_11</a> = 0xA, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga840c7f725afee13c0ba40fcad6ba5097ae9dd2c19d5dd16034effdec11b5ab75d">DL_SYSCTL_MCLK_DIVIDER_12</a> = 0xB, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga840c7f725afee13c0ba40fcad6ba5097a37e1c980bc9f9519d44cdac785be61b7">DL_SYSCTL_MCLK_DIVIDER_13</a> = 0xC, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga840c7f725afee13c0ba40fcad6ba5097af5e0ea1efa364c9a82735b929a6e8c72">DL_SYSCTL_MCLK_DIVIDER_14</a> = 0xD, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga840c7f725afee13c0ba40fcad6ba5097aa5a72527e231f88148048288645d94ef">DL_SYSCTL_MCLK_DIVIDER_15</a> = 0xE, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga840c7f725afee13c0ba40fcad6ba5097a7d38a9cb643c82faa3f335e040165ad7">DL_SYSCTL_MCLK_DIVIDER_16</a> = 0xF
<br />
 }</td></tr>
<tr class="separator:ga840c7f725afee13c0ba40fcad6ba5097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4345c30b25b31b0a0baba36fbcedceed"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga4345c30b25b31b0a0baba36fbcedceed">DL_SYSCTL_CLK_OUT_SOURCE</a> { <br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga4345c30b25b31b0a0baba36fbcedceeda1fffbdabf818fd0041d98f32fe3fc52b">DL_SYSCTL_CLK_OUT_SOURCE_SYSOSC</a> = SYSCTL_GENCLKCFG_EXCLKSRC_SYSOSC, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga4345c30b25b31b0a0baba36fbcedceeda9f8fa6205533e732cbd3f5bfc654eba5">DL_SYSCTL_CLK_OUT_SOURCE_ULPCLK</a> = SYSCTL_GENCLKCFG_EXCLKSRC_ULPCLK, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga4345c30b25b31b0a0baba36fbcedceeda09781e0480e8c64e74396c3023b6de8a">DL_SYSCTL_CLK_OUT_SOURCE_LFCLK</a> = SYSCTL_GENCLKCFG_EXCLKSRC_LFCLK, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga4345c30b25b31b0a0baba36fbcedceeda30c4c3ab4aa5edc4c76fd27af5cb7fdd">DL_SYSCTL_CLK_OUT_SOURCE_MFPCLK</a> = SYSCTL_GENCLKCFG_EXCLKSRC_MFPCLK, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga4345c30b25b31b0a0baba36fbcedceeda26273c65d42b0053a83644b47cf8286d">DL_SYSCTL_CLK_OUT_SOURCE_HFCLK</a> = SYSCTL_GENCLKCFG_EXCLKSRC_HFCLK
<br />
 }</td></tr>
<tr class="separator:ga4345c30b25b31b0a0baba36fbcedceed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga981fe3602bfb00a63911e2e14f82f1bf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga981fe3602bfb00a63911e2e14f82f1bf">DL_SYSCTL_CLK_OUT_DIVIDE</a> { <br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga981fe3602bfb00a63911e2e14f82f1bfa3086dfe271764336af993ebeb14b836c">DL_SYSCTL_CLK_OUT_DIVIDE_DISABLE</a> = SYSCTL_GENCLKCFG_EXCLKDIVEN_PASSTHRU, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga981fe3602bfb00a63911e2e14f82f1bfa2589380f318d6ed62657def569fc0c58">DL_SYSCTL_CLK_OUT_DIVIDE_2</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga981fe3602bfb00a63911e2e14f82f1bfa24ecabcea5db39cdf88f56a30d5af2c7">DL_SYSCTL_CLK_OUT_DIVIDE_4</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga981fe3602bfb00a63911e2e14f82f1bfa625f52ecc24152fef1359c982d7ff1d3">DL_SYSCTL_CLK_OUT_DIVIDE_6</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga981fe3602bfb00a63911e2e14f82f1bfaa267fc8dd6bedc181a2bf8588c0011ac">DL_SYSCTL_CLK_OUT_DIVIDE_8</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga981fe3602bfb00a63911e2e14f82f1bfa67c0c39ea30db5880322ab808faf5099">DL_SYSCTL_CLK_OUT_DIVIDE_10</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga981fe3602bfb00a63911e2e14f82f1bfadc7d4a76fbad91622ff14d2306b3e0f9">DL_SYSCTL_CLK_OUT_DIVIDE_12</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga981fe3602bfb00a63911e2e14f82f1bfaae2c556a83f23e30f70800292217cf35">DL_SYSCTL_CLK_OUT_DIVIDE_14</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga981fe3602bfb00a63911e2e14f82f1bfa66c6542f1561f72b09f36b28b4c76092">DL_SYSCTL_CLK_OUT_DIVIDE_16</a>
<br />
 }</td></tr>
<tr class="separator:ga981fe3602bfb00a63911e2e14f82f1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7015e4698d5924cb3f6b05f26e76f8ef"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga7015e4698d5924cb3f6b05f26e76f8ef">DL_SYSCTL_MFPCLK_SOURCE</a> { <br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga7015e4698d5924cb3f6b05f26e76f8efa75c4e9a2bfb1c6ea5e1fcd8a49be9fcd">DL_SYSCTL_MFPCLK_SOURCE_SYSOSC</a> = SYSCTL_GENCLKCFG_MFPCLKSRC_SYSOSC, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga7015e4698d5924cb3f6b05f26e76f8efaec4f54f78f9b8bbb9f3fbe1842e463ba">DL_SYSCTL_MFPCLK_SOURCE_HFCLK</a> = SYSCTL_GENCLKCFG_MFPCLKSRC_HFCLK
<br />
 }</td></tr>
<tr class="separator:ga7015e4698d5924cb3f6b05f26e76f8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeec66a871ef0d069fc54f791abbfb84e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaeec66a871ef0d069fc54f791abbfb84e">DL_SYSCTL_HFCLK_MFPCLK_DIVIDER</a> { <br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggaeec66a871ef0d069fc54f791abbfb84ea1f1d64d9e79109df1ff3e8c218ee64b5">DL_SYSCTL_HFCLK_MFPCLK_DIVIDER_DISABLE</a> = 0x0, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggaeec66a871ef0d069fc54f791abbfb84ea2453b2b6c2225c99190d9e8e17baca14">DL_SYSCTL_HFCLK_MFPCLK_DIVIDER_2</a> = 0x1, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggaeec66a871ef0d069fc54f791abbfb84ea5ece7cc1305cc1d5fbdcdfff24cad83f">DL_SYSCTL_HFCLK_MFPCLK_DIVIDER_3</a> = 0x2, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggaeec66a871ef0d069fc54f791abbfb84ea6a0575d67fd7d62f7d558bb69b6ee2a4">DL_SYSCTL_HFCLK_MFPCLK_DIVIDER_4</a> = 0x3, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggaeec66a871ef0d069fc54f791abbfb84ea23016eec3ffe39dd0995daa6944a301e">DL_SYSCTL_HFCLK_MFPCLK_DIVIDER_5</a> = 0x4, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggaeec66a871ef0d069fc54f791abbfb84eaaeeb69c46d662ae0bb0d403dc3b9d551">DL_SYSCTL_HFCLK_MFPCLK_DIVIDER_6</a> = 0x5, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggaeec66a871ef0d069fc54f791abbfb84eac3e99a6893c96c06db4a6d1a06dd0c54">DL_SYSCTL_HFCLK_MFPCLK_DIVIDER_7</a> = 0x6, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggaeec66a871ef0d069fc54f791abbfb84ea80004c8f15ea2bff7b6a456103e99943">DL_SYSCTL_HFCLK_MFPCLK_DIVIDER_8</a> = 0x7, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggaeec66a871ef0d069fc54f791abbfb84ea85153914d4a12b6b850f122f063742b1">DL_SYSCTL_HFCLK_MFPCLK_DIVIDER_9</a> = 0x8, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggaeec66a871ef0d069fc54f791abbfb84ea9b1c1d0ea4813fe93bef28c5b9be299c">DL_SYSCTL_HFCLK_MFPCLK_DIVIDER_10</a> = 0x9, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggaeec66a871ef0d069fc54f791abbfb84ea1e6b3a0e4af3eba88723de06f8136d3a">DL_SYSCTL_HFCLK_MFPCLK_DIVIDER_11</a> = 0xA, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggaeec66a871ef0d069fc54f791abbfb84ea14dc4cd67dca322ffc7a1241a8e468f9">DL_SYSCTL_HFCLK_MFPCLK_DIVIDER_12</a> = 0xB, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggaeec66a871ef0d069fc54f791abbfb84ea64a0d83501759e4e20bbf268e6efebc1">DL_SYSCTL_HFCLK_MFPCLK_DIVIDER_13</a> = 0xC, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggaeec66a871ef0d069fc54f791abbfb84ea09d96122efd5130e9003b73c7f5f50dc">DL_SYSCTL_HFCLK_MFPCLK_DIVIDER_14</a> = 0xD, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggaeec66a871ef0d069fc54f791abbfb84eaf1b96e7769a5e065baf560347462000d">DL_SYSCTL_HFCLK_MFPCLK_DIVIDER_15</a> = 0xE, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggaeec66a871ef0d069fc54f791abbfb84eae9e32cd906b34c5359ae03b64eee2cf1">DL_SYSCTL_HFCLK_MFPCLK_DIVIDER_16</a> = 0xF
<br />
 }</td></tr>
<tr class="separator:gaeec66a871ef0d069fc54f791abbfb84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade1fd3f998053938225af73b519f695d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gade1fd3f998053938225af73b519f695d">DL_SYSCTL_FCC_TRIG_TYPE</a> { <br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggade1fd3f998053938225af73b519f695dac0c3ec1156a639be149fd425d7c2f30b">DL_SYSCTL_FCC_TRIG_TYPE_RISE_RISE</a> = SYSCTL_GENCLKCFG_FCCLVLTRIG_RISE2RISE, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggade1fd3f998053938225af73b519f695da8b28715409d6ba8c85324a66c47f6685">DL_SYSCTL_FCC_TRIG_TYPE_LEVEL</a> = SYSCTL_GENCLKCFG_FCCLVLTRIG_LEVEL
<br />
 }</td></tr>
<tr class="separator:gade1fd3f998053938225af73b519f695d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad56cf7d1f7fe634c4575f18669403887"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gad56cf7d1f7fe634c4575f18669403887">DL_SYSCTL_FCC_TRIG_SOURCE</a> { <br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggad56cf7d1f7fe634c4575f18669403887a90120d214d281e5834c91fcc2246c65f">DL_SYSCTL_FCC_TRIG_SOURCE_FCC_IN</a> = SYSCTL_GENCLKCFG_FCCTRIGSRC_EXTPIN, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggad56cf7d1f7fe634c4575f18669403887a77cd1f55d7e84392a22d6bc0d61cfa5a">DL_SYSCTL_FCC_TRIG_SOURCE_LFCLK</a> = SYSCTL_GENCLKCFG_FCCTRIGSRC_LFCLK
<br />
 }</td></tr>
<tr class="separator:gad56cf7d1f7fe634c4575f18669403887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga088842c40b39b18edd2e81f898deea08"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga088842c40b39b18edd2e81f898deea08">DL_SYSCTL_FCC_CLOCK_SOURCE</a> { <br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga088842c40b39b18edd2e81f898deea08a087da1902cb25949e87f2b7a7b4d54a7">DL_SYSCTL_FCC_CLOCK_SOURCE_MCLK</a> = SYSCTL_GENCLKCFG_FCCSELCLK_MCLK, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga088842c40b39b18edd2e81f898deea08a9f4b0f224b1406f7b41575a70bfc100d">DL_SYSCTL_FCC_CLOCK_SOURCE_SYSOSC</a> = SYSCTL_GENCLKCFG_FCCSELCLK_SYSOSC, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga088842c40b39b18edd2e81f898deea08a2e2bc7b7dc2d1eca4ce33b05d6443f17">DL_SYSCTL_FCC_CLOCK_SOURCE_HFCLK</a> = SYSCTL_GENCLKCFG_FCCSELCLK_HFCLK, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga088842c40b39b18edd2e81f898deea08af755622422e205de38e72a739b244954">DL_SYSCTL_FCC_CLOCK_SOURCE_CLK_OUT</a> = SYSCTL_GENCLKCFG_FCCSELCLK_EXTCLK, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga088842c40b39b18edd2e81f898deea08a0eaba1358f46f9bc711bf1a6aedb3e63">DL_SYSCTL_FCC_CLOCK_SOURCE_FCC_IN</a> = SYSCTL_GENCLKCFG_FCCSELCLK_FCCIN
<br />
 }</td></tr>
<tr class="separator:ga088842c40b39b18edd2e81f898deea08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga919e05d2b9725602984a9ae8bee98b09"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga919e05d2b9725602984a9ae8bee98b09">DL_SYSCTL_FCC_TRIG_CNT</a> { <br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga919e05d2b9725602984a9ae8bee98b09afc04c9a99adeaafb43085c483e24a2d9">DL_SYSCTL_FCC_TRIG_CNT_01</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga919e05d2b9725602984a9ae8bee98b09acf11c755cfdb171c0a549ae981ce1bdb">DL_SYSCTL_FCC_TRIG_CNT_02</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga919e05d2b9725602984a9ae8bee98b09a747964ac94db3f2f6b4638fcc8335c19">DL_SYSCTL_FCC_TRIG_CNT_03</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga919e05d2b9725602984a9ae8bee98b09a0449cd8177ddb8e48d4dd60da5b89218">DL_SYSCTL_FCC_TRIG_CNT_04</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga919e05d2b9725602984a9ae8bee98b09a94a32f9aa11c8768b8848e98624c9065">DL_SYSCTL_FCC_TRIG_CNT_05</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga919e05d2b9725602984a9ae8bee98b09a07e7dad1eaf504cc8f2a7265e1b1d1cf">DL_SYSCTL_FCC_TRIG_CNT_06</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga919e05d2b9725602984a9ae8bee98b09a1b0632698c6fe5e44789fd581ec387be">DL_SYSCTL_FCC_TRIG_CNT_07</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga919e05d2b9725602984a9ae8bee98b09a5a0303b71f399093433eb2b134b15038">DL_SYSCTL_FCC_TRIG_CNT_08</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga919e05d2b9725602984a9ae8bee98b09afea4ff6b427b3dd939ca068e27241cbb">DL_SYSCTL_FCC_TRIG_CNT_09</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga919e05d2b9725602984a9ae8bee98b09a3214c76b86f82d23e43bbe71f8835f35">DL_SYSCTL_FCC_TRIG_CNT_10</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga919e05d2b9725602984a9ae8bee98b09a62ca09dc4687e54d16f47e67e8ec540b">DL_SYSCTL_FCC_TRIG_CNT_11</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga919e05d2b9725602984a9ae8bee98b09a5a29bfa5c08b110d2643b389b4a6f3a0">DL_SYSCTL_FCC_TRIG_CNT_12</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga919e05d2b9725602984a9ae8bee98b09a2fb872a52fb5659a0cc35220fe7cf313">DL_SYSCTL_FCC_TRIG_CNT_13</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga919e05d2b9725602984a9ae8bee98b09a6064a9292349077943cb45b4e954770e">DL_SYSCTL_FCC_TRIG_CNT_14</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga919e05d2b9725602984a9ae8bee98b09a6e3d20f31b809c8cb383d259e3623da5">DL_SYSCTL_FCC_TRIG_CNT_15</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga919e05d2b9725602984a9ae8bee98b09a255ced9fca1030b33cca4411a444c22b">DL_SYSCTL_FCC_TRIG_CNT_16</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga919e05d2b9725602984a9ae8bee98b09ad5b98f12f98f7e8d92311de426f75c1e">DL_SYSCTL_FCC_TRIG_CNT_17</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga919e05d2b9725602984a9ae8bee98b09a024d1b04db029d13e2e073a125aaf4df">DL_SYSCTL_FCC_TRIG_CNT_18</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga919e05d2b9725602984a9ae8bee98b09a4710b170551cadb9ce90ea9b09a3d22d">DL_SYSCTL_FCC_TRIG_CNT_19</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga919e05d2b9725602984a9ae8bee98b09a4c8ecde7efad5a46b611806d27e77697">DL_SYSCTL_FCC_TRIG_CNT_20</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga919e05d2b9725602984a9ae8bee98b09a89013024ab99ed3a83d384fe6cf48db9">DL_SYSCTL_FCC_TRIG_CNT_21</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga919e05d2b9725602984a9ae8bee98b09a71d55dcd1e2613b586ff145f8e68071d">DL_SYSCTL_FCC_TRIG_CNT_22</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga919e05d2b9725602984a9ae8bee98b09a07a7278a546826b56389397ffe7039dc">DL_SYSCTL_FCC_TRIG_CNT_23</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga919e05d2b9725602984a9ae8bee98b09a70620e75d5d7984fa508aa9c0bdcc0e8">DL_SYSCTL_FCC_TRIG_CNT_24</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga919e05d2b9725602984a9ae8bee98b09aa8ee0f6224cb116e86e55efd0df39ead">DL_SYSCTL_FCC_TRIG_CNT_25</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga919e05d2b9725602984a9ae8bee98b09acd20c2d85a6014a170ebdfdb96bad800">DL_SYSCTL_FCC_TRIG_CNT_26</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga919e05d2b9725602984a9ae8bee98b09a1d1e5ce3bb9f2d832db7e14431ec789d">DL_SYSCTL_FCC_TRIG_CNT_27</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga919e05d2b9725602984a9ae8bee98b09a50dde3cfab1d68874c2c7cea8fc6ad11">DL_SYSCTL_FCC_TRIG_CNT_28</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga919e05d2b9725602984a9ae8bee98b09aef0ac4baa864fd78d72062a04311b263">DL_SYSCTL_FCC_TRIG_CNT_29</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga919e05d2b9725602984a9ae8bee98b09a4b710d07bcc6a3aeafa44e64ba803014">DL_SYSCTL_FCC_TRIG_CNT_30</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga919e05d2b9725602984a9ae8bee98b09a97089d26eaaf5afb4109e4e3adcb369e">DL_SYSCTL_FCC_TRIG_CNT_31</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga919e05d2b9725602984a9ae8bee98b09ad98278a742e6480a46bb9f71fdcfa652">DL_SYSCTL_FCC_TRIG_CNT_32</a>
<br />
 }</td></tr>
<tr class="separator:ga919e05d2b9725602984a9ae8bee98b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bac12ff08dc5a074df489d69ae0cc80"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga4bac12ff08dc5a074df489d69ae0cc80">DL_SYSCTL_VBOOST</a> { <br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga4bac12ff08dc5a074df489d69ae0cc80a8db68ccb4dea061b752afab3f2528dad">DL_SYSCTL_VBOOST_ONDEMAND</a> = SYSCTL_GENCLKCFG_ANACPUMPCFG_ONDEMAND, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga4bac12ff08dc5a074df489d69ae0cc80a8e47ea05e82c8a4ccc77375247def200">DL_SYSCTL_VBOOST_ONACTIVE</a> = SYSCTL_GENCLKCFG_ANACPUMPCFG_ONACTIVE, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga4bac12ff08dc5a074df489d69ae0cc80a0ba4dab7f64a61b42589e9e8192c7937">DL_SYSCTL_VBOOST_ONALWAYS</a> = SYSCTL_GENCLKCFG_ANACPUMPCFG_ONALWAYS
<br />
 }</td></tr>
<tr class="separator:ga4bac12ff08dc5a074df489d69ae0cc80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b893ce5af5fab09fed655808c393c92"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga7b893ce5af5fab09fed655808c393c92">DL_SYSCTL_FLASH_WAIT_STATE</a> { <br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga7b893ce5af5fab09fed655808c393c92a73abfef9528fab56cc8b883391180e1f">DL_SYSCTL_FLASH_WAIT_STATE_0</a> = ((uint32_t) 0x00000000U), 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga7b893ce5af5fab09fed655808c393c92a926e37211580037e0551db02d876c3d4">DL_SYSCTL_FLASH_WAIT_STATE_1</a> = ((uint32_t) 0x00000100U), 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga7b893ce5af5fab09fed655808c393c92acbabe7fb6483992feb1a70374bd40b37">DL_SYSCTL_FLASH_WAIT_STATE_2</a> = ((uint32_t) 0x00000200U)
<br />
 }</td></tr>
<tr class="separator:ga7b893ce5af5fab09fed655808c393c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18ce5da5d89d2c8b34c490167e3bcbff"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga18ce5da5d89d2c8b34c490167e3bcbff">DL_SYSCTL_POWER_POLICY_RUN_SLEEP</a> { <br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga18ce5da5d89d2c8b34c490167e3bcbffab7397c00fbb8bf006d66c64391691a6d">DL_SYSCTL_POWER_POLICY_RUN_SLEEP_NOT_ENABLED</a> = 0x0, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga18ce5da5d89d2c8b34c490167e3bcbffa5cea3f2f437e48f960bf813c92e7f675">DL_SYSCTL_POWER_POLICY_RUN_SLEEP0</a> = 0x1, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga18ce5da5d89d2c8b34c490167e3bcbffa67eae8887adf0cf5b8bacebb75f6ef53">DL_SYSCTL_POWER_POLICY_RUN_SLEEP1</a> = 0x2, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga18ce5da5d89d2c8b34c490167e3bcbffafd5407e76420f253130219eedc2c9202">DL_SYSCTL_POWER_POLICY_RUN_SLEEP2</a> = 0x3
<br />
 }</td></tr>
<tr class="separator:ga18ce5da5d89d2c8b34c490167e3bcbff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea2b0481ee57f8c16678f03d8b459012"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaea2b0481ee57f8c16678f03d8b459012">DL_SYSCTL_POWER_POLICY_STOP</a> { <br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggaea2b0481ee57f8c16678f03d8b459012a7176ffee58e3f5d64ac4008409c71133">DL_SYSCTL_POWER_POLICY_STOP_NOT_ENABLED</a> = 0x0, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggaea2b0481ee57f8c16678f03d8b459012a4dcdb65add63fb93223e2f43c1cd23c1">DL_SYSCTL_POWER_POLICY_STOP0</a> = 0x1, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggaea2b0481ee57f8c16678f03d8b459012a7d156e0a6a2a5f4a2df8cfe7091306d4">DL_SYSCTL_POWER_POLICY_STOP1</a> = 0x2, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggaea2b0481ee57f8c16678f03d8b459012a1da57d6c2a0bc45d592cf031824a2b18">DL_SYSCTL_POWER_POLICY_STOP2</a> = 0x3
<br />
 }</td></tr>
<tr class="separator:gaea2b0481ee57f8c16678f03d8b459012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf84ef067c088e88595332daf7d0611b4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaf84ef067c088e88595332daf7d0611b4">DL_SYSCTL_POWER_POLICY_STANDBY</a> { <br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggaf84ef067c088e88595332daf7d0611b4a23d10cc44f9dd16749d7b4bc4d7fd238">DL_SYSCTL_POWER_POLICY_STANDBY_NOT_ENABLED</a> = 0x0, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggaf84ef067c088e88595332daf7d0611b4af01e24ef571759ddb35606a11f855c68">DL_SYSCTL_POWER_POLICY_STANDBY0</a> = 0x1, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggaf84ef067c088e88595332daf7d0611b4a88400aa474b64a342c6872b4c2365269">DL_SYSCTL_POWER_POLICY_STANDBY1</a> = 0x2
<br />
 }</td></tr>
<tr class="separator:gaf84ef067c088e88595332daf7d0611b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab31acca537d5af4a0710888c9fcb6be8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gab31acca537d5af4a0710888c9fcb6be8">DL_SYSCTL_BOR_THRESHOLD_LEVEL</a> { <br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggab31acca537d5af4a0710888c9fcb6be8a0e8afb986eaf313b904b37a561f0f936">DL_SYSCTL_BOR_THRESHOLD_LEVEL_0</a> = SYSCTL_BORTHRESHOLD_LEVEL_BORMIN, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggab31acca537d5af4a0710888c9fcb6be8a000529e00d369928e99b2af14a81341d">DL_SYSCTL_BOR_THRESHOLD_LEVEL_1</a> = SYSCTL_BORTHRESHOLD_LEVEL_BORLEVEL1, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggab31acca537d5af4a0710888c9fcb6be8a5f4c15d42beafe6fef957c646211fe75">DL_SYSCTL_BOR_THRESHOLD_LEVEL_2</a> = SYSCTL_BORTHRESHOLD_LEVEL_BORLEVEL2, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggab31acca537d5af4a0710888c9fcb6be8a76000141ff342ac44d376a6c731b7658">DL_SYSCTL_BOR_THRESHOLD_LEVEL_3</a> = SYSCTL_BORTHRESHOLD_LEVEL_BORLEVEL3
<br />
 }</td></tr>
<tr class="separator:gab31acca537d5af4a0710888c9fcb6be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4ba3ae564f39aac9884ee95b1a4bf50"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gac4ba3ae564f39aac9884ee95b1a4bf50">DL_SYSCTL_SHUTDOWN_STORAGE_BYTE</a> { <br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggac4ba3ae564f39aac9884ee95b1a4bf50a9a839986e475201a3bec706242dec6f6">DL_SYSCTL_SHUTDOWN_STORAGE_BYTE_0</a> = 0x0, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggac4ba3ae564f39aac9884ee95b1a4bf50a99f38145140a68566d04475967fe7e37">DL_SYSCTL_SHUTDOWN_STORAGE_BYTE_1</a> = 0x1, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggac4ba3ae564f39aac9884ee95b1a4bf50a37c833ae47434f9ff95123be14adad11">DL_SYSCTL_SHUTDOWN_STORAGE_BYTE_2</a> = 0x2, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ggac4ba3ae564f39aac9884ee95b1a4bf50a2c2bb4e1944f593d12cc74c627dcffc5">DL_SYSCTL_SHUTDOWN_STORAGE_BYTE_3</a> = 0x3
<br />
 }</td></tr>
<tr class="separator:gac4ba3ae564f39aac9884ee95b1a4bf50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72bea3c6a78a3a5c0d389ac78cacce74"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga72bea3c6a78a3a5c0d389ac78cacce74">DL_SYSCTL_RESET_CAUSE</a> { <br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga72bea3c6a78a3a5c0d389ac78cacce74aa31c5345c5fd11432afb02136df91b47">DL_SYSCTL_RESET_CAUSE_NO_RESET</a> = SYSCTL_RSTCAUSE_ID_NORST, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga72bea3c6a78a3a5c0d389ac78cacce74aba0ecbc9a1288478f17ce17cab230e4c">DL_SYSCTL_RESET_CAUSE_POR_HW_FAILURE</a> = SYSCTL_RSTCAUSE_ID_PORHWFAIL, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga72bea3c6a78a3a5c0d389ac78cacce74a8225b982b575931daa13a7cc3534a51b">DL_SYSCTL_RESET_CAUSE_POR_EXTERNAL_NRST</a> = SYSCTL_RSTCAUSE_ID_POREXNRST, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga72bea3c6a78a3a5c0d389ac78cacce74af3b77e3f7038b268bfe8ae8fad0f8af4">DL_SYSCTL_RESET_CAUSE_POR_SW_TRIGGERED</a> = SYSCTL_RSTCAUSE_ID_PORSW, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga72bea3c6a78a3a5c0d389ac78cacce74ad6352674f8bd0b35b683f727574876cd">DL_SYSCTL_RESET_CAUSE_BOR_SUPPLY_FAILURE</a> = SYSCTL_RSTCAUSE_ID_BORSUPPLY, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga72bea3c6a78a3a5c0d389ac78cacce74a51c8d78a172fb933581c44d9480b8162">DL_SYSCTL_RESET_CAUSE_BOR_WAKE_FROM_SHUTDOWN</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga72bea3c6a78a3a5c0d389ac78cacce74a8f41dee0474459a4d83ed6dad79265f6">DL_SYSCTL_RESET_CAUSE_BOOTRST_NON_PMU_PARITY_FAULT</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga72bea3c6a78a3a5c0d389ac78cacce74a9bfeada7e2e2f6f2cdb4b07749d0793a">DL_SYSCTL_RESET_CAUSE_BOOTRST_CLOCK_FAULT</a> = SYSCTL_RSTCAUSE_ID_BOOTCLKFAIL, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga72bea3c6a78a3a5c0d389ac78cacce74ae47babed21c67032bb5914713703a54c">DL_SYSCTL_RESET_CAUSE_BOOTRST_SW_TRIGGERED</a> = SYSCTL_RSTCAUSE_ID_BOOTSW, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga72bea3c6a78a3a5c0d389ac78cacce74a32f13a84287cb475a3ece1325d4a7e6a">DL_SYSCTL_RESET_CAUSE_BOOTRST_EXTERNAL_NRST</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga72bea3c6a78a3a5c0d389ac78cacce74a35a4d8706bc7db707d77a0aa45181348">DL_SYSCTL_RESET_CAUSE_SYSRST_BSL_EXIT</a> = SYSCTL_RSTCAUSE_ID_SYSBSLEXIT, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga72bea3c6a78a3a5c0d389ac78cacce74a9813d61a110213e9d9d9aacf1dddfd07">DL_SYSCTL_RESET_CAUSE_SYSRST_BSL_ENTRY</a> = SYSCTL_RSTCAUSE_ID_SYSBSLENTRY, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga72bea3c6a78a3a5c0d389ac78cacce74a6d68291dbc3d2ef9b008e4167b36ea56">DL_SYSCTL_RESET_CAUSE_SYSRST_WWDT0_VIOLATION</a> = SYSCTL_RSTCAUSE_ID_SYSWWDT0, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga72bea3c6a78a3a5c0d389ac78cacce74a675864d237067e66f6817c30e55992a9">DL_SYSCTL_RESET_CAUSE_SYSRST_WWDT1_VIOLATION</a> = SYSCTL_RSTCAUSE_ID_SYSWWDT1, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga72bea3c6a78a3a5c0d389ac78cacce74ad301368ad5c66087c12b93c990010ad4">DL_SYSCTL_RESET_CAUSE_SYSRST_FLASH_ECC_ERROR</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga72bea3c6a78a3a5c0d389ac78cacce74ae135df8b36832289fbc3fdcaebbcbcf9">DL_SYSCTL_RESET_CAUSE_SYSRST_CPU_LOCKUP_VIOLATION</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga72bea3c6a78a3a5c0d389ac78cacce74a11f7d4e0dc57e771b1f550e2329db5c3">DL_SYSCTL_RESET_CAUSE_SYSRST_DEBUG_TRIGGERED</a> = SYSCTL_RSTCAUSE_ID_SYSDBG, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga72bea3c6a78a3a5c0d389ac78cacce74a6c0bcede4d3dc76c1cd48147f204a6ab">DL_SYSCTL_RESET_CAUSE_SYSRST_SW_TRIGGERED</a> = SYSCTL_RSTCAUSE_ID_SYSSW, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga72bea3c6a78a3a5c0d389ac78cacce74a4a5597716638e00d9f67cd34d178ffcc">DL_SYSCTL_RESET_CAUSE_CPURST_DEBUG_TRIGGERED</a> = SYSCTL_RSTCAUSE_ID_CPUDBG, 
<br />
&#160;&#160;<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga72bea3c6a78a3a5c0d389ac78cacce74a046f56eeb9a823bdb58d22f5006518bd">DL_SYSCTL_RESET_CAUSE_CPURST_SW_TRIGGERED</a> = SYSCTL_RSTCAUSE_ID_CPUSW
<br />
 }</td></tr>
<tr class="separator:ga72bea3c6a78a3a5c0d389ac78cacce74"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf9e752083d5fdc113ea0f41e3986d21e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaf9e752083d5fdc113ea0f41e3986d21e">DL_SYSCTL_enableSleepOnExit</a> (void)</td></tr>
<tr class="memdesc:gaf9e752083d5fdc113ea0f41e3986d21e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable sleep on exit.  <a href="#gaf9e752083d5fdc113ea0f41e3986d21e">More...</a><br /></td></tr>
<tr class="separator:gaf9e752083d5fdc113ea0f41e3986d21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79bcb1f2d3bc41df3c4ad440c24bb184"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga79bcb1f2d3bc41df3c4ad440c24bb184">DL_SYSCTL_disableSleepOnExit</a> (void)</td></tr>
<tr class="memdesc:ga79bcb1f2d3bc41df3c4ad440c24bb184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable sleep on exit.  <a href="#ga79bcb1f2d3bc41df3c4ad440c24bb184">More...</a><br /></td></tr>
<tr class="separator:ga79bcb1f2d3bc41df3c4ad440c24bb184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46e355dbc1046be4a89d029edb8f9af4"><td class="memItemLeft" align="right" valign="top"><a id="ga46e355dbc1046be4a89d029edb8f9af4"></a>
__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga46e355dbc1046be4a89d029edb8f9af4">DL_SYSCTL_isSleepOnExitEnabled</a> (void)</td></tr>
<tr class="memdesc:ga46e355dbc1046be4a89d029edb8f9af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if sleep on exit is enabled. <br /></td></tr>
<tr class="separator:ga46e355dbc1046be4a89d029edb8f9af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga832b40751fd398154265ed5dfb60e2db"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga832b40751fd398154265ed5dfb60e2db">DL_SYSCTL_enableEventOnPend</a> (void)</td></tr>
<tr class="memdesc:ga832b40751fd398154265ed5dfb60e2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable send event on pending bit.  <a href="#ga832b40751fd398154265ed5dfb60e2db">More...</a><br /></td></tr>
<tr class="separator:ga832b40751fd398154265ed5dfb60e2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga659b9a76ea959eb05e5d1a1d50b797ff"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga659b9a76ea959eb05e5d1a1d50b797ff">DL_SYSCTL_disableEventOnPend</a> (void)</td></tr>
<tr class="memdesc:ga659b9a76ea959eb05e5d1a1d50b797ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable send event on pending bit.  <a href="#ga659b9a76ea959eb05e5d1a1d50b797ff">More...</a><br /></td></tr>
<tr class="separator:ga659b9a76ea959eb05e5d1a1d50b797ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa56d230c1cfc401cda33d204bdc9a65"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaaa56d230c1cfc401cda33d204bdc9a65">DL_SYSCTL_isEventOnPendEnabled</a> (void)</td></tr>
<tr class="memdesc:gaaa56d230c1cfc401cda33d204bdc9a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if send event on pending bit is enabled.  <a href="#gaaa56d230c1cfc401cda33d204bdc9a65">More...</a><br /></td></tr>
<tr class="separator:gaaa56d230c1cfc401cda33d204bdc9a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd92a7a341922bbc907eab2d03e0c233"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gadd92a7a341922bbc907eab2d03e0c233">DL_SYSCTL_switchMCLKfromSYSOSCtoLFCLK</a> (bool disableSYSOSC)</td></tr>
<tr class="memdesc:gadd92a7a341922bbc907eab2d03e0c233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change MCLK source from SYSOSC to LFCLK.  <a href="#gadd92a7a341922bbc907eab2d03e0c233">More...</a><br /></td></tr>
<tr class="separator:gadd92a7a341922bbc907eab2d03e0c233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0da6dd4face824795caadc20aad63c3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga0da6dd4face824795caadc20aad63c3b">DL_SYSCTL_switchMCLKfromLFCLKtoSYSOSC</a> (void)</td></tr>
<tr class="memdesc:ga0da6dd4face824795caadc20aad63c3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change MCLK source from LFCLK to SYSOSC.  <a href="#ga0da6dd4face824795caadc20aad63c3b">More...</a><br /></td></tr>
<tr class="separator:ga0da6dd4face824795caadc20aad63c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f3c956c0b9432ffa85e6e6bcfce25fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga5f3c956c0b9432ffa85e6e6bcfce25fa">DL_SYSCTL_switchMCLKfromSYSOSCtoHSCLK</a> (<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gadb318a4bb7a5bfb1555f660f63d32fbb">DL_SYSCTL_HSCLK_SOURCE</a> source)</td></tr>
<tr class="memdesc:ga5f3c956c0b9432ffa85e6e6bcfce25fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change MCLK source from SYSOSC to HSCLK.  <a href="#ga5f3c956c0b9432ffa85e6e6bcfce25fa">More...</a><br /></td></tr>
<tr class="separator:ga5f3c956c0b9432ffa85e6e6bcfce25fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cf7ee635c6302eaf96e1fb9e86acc1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga3cf7ee635c6302eaf96e1fb9e86acc1f">DL_SYSCTL_switchMCLKfromHSCLKtoSYSOSC</a> (void)</td></tr>
<tr class="memdesc:ga3cf7ee635c6302eaf96e1fb9e86acc1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change MCLK source from HSCLK to SYSOSC.  <a href="#ga3cf7ee635c6302eaf96e1fb9e86acc1f">More...</a><br /></td></tr>
<tr class="separator:ga3cf7ee635c6302eaf96e1fb9e86acc1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb3e59122b0186605828738a46ddedb3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gabb3e59122b0186605828738a46ddedb3">DL_SYSCTL_setPowerPolicyRUN0SLEEP0</a> (void)</td></tr>
<tr class="memdesc:gabb3e59122b0186605828738a46ddedb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the RUN/SLEEP mode power policy to RUN0/SLEEP0.  <a href="#gabb3e59122b0186605828738a46ddedb3">More...</a><br /></td></tr>
<tr class="separator:gabb3e59122b0186605828738a46ddedb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed73b665ecd6ea709c7ac5d73d22d6f8"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaed73b665ecd6ea709c7ac5d73d22d6f8">DL_SYSCTL_setPowerPolicyRUN1SLEEP1</a> (void)</td></tr>
<tr class="memdesc:gaed73b665ecd6ea709c7ac5d73d22d6f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the RUN/SLEEP mode power policy to RUN1/SLEEP1.  <a href="#gaed73b665ecd6ea709c7ac5d73d22d6f8">More...</a><br /></td></tr>
<tr class="separator:gaed73b665ecd6ea709c7ac5d73d22d6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaace70635f3ea92cae14c2f1df0c55633"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaace70635f3ea92cae14c2f1df0c55633">DL_SYSCTL_setPowerPolicyRUN2SLEEP2</a> (void)</td></tr>
<tr class="memdesc:gaace70635f3ea92cae14c2f1df0c55633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the RUN/SLEEP mode power policy to RUN2/SLEEP2.  <a href="#gaace70635f3ea92cae14c2f1df0c55633">More...</a><br /></td></tr>
<tr class="separator:gaace70635f3ea92cae14c2f1df0c55633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad01310dac26cd98b8978fc6459b44074"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga18ce5da5d89d2c8b34c490167e3bcbff">DL_SYSCTL_POWER_POLICY_RUN_SLEEP</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gad01310dac26cd98b8978fc6459b44074">DL_SYSCTL_getPowerPolicyRUNSLEEP</a> (void)</td></tr>
<tr class="memdesc:gad01310dac26cd98b8978fc6459b44074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the RUN/SLEEP mode power policy.  <a href="#gad01310dac26cd98b8978fc6459b44074">More...</a><br /></td></tr>
<tr class="separator:gad01310dac26cd98b8978fc6459b44074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d3118b7857c9909a6aa831c961190b0"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga7d3118b7857c9909a6aa831c961190b0">DL_SYSCTL_setPowerPolicySTOP0</a> (void)</td></tr>
<tr class="memdesc:ga7d3118b7857c9909a6aa831c961190b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the STOP mode power policy to STOP0.  <a href="#ga7d3118b7857c9909a6aa831c961190b0">More...</a><br /></td></tr>
<tr class="separator:ga7d3118b7857c9909a6aa831c961190b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68f967ab5833ec9020aa2f3a6929c0dd"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga68f967ab5833ec9020aa2f3a6929c0dd">DL_SYSCTL_setPowerPolicySTOP1</a> (void)</td></tr>
<tr class="memdesc:ga68f967ab5833ec9020aa2f3a6929c0dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the STOP mode power policy to STOP1.  <a href="#ga68f967ab5833ec9020aa2f3a6929c0dd">More...</a><br /></td></tr>
<tr class="separator:ga68f967ab5833ec9020aa2f3a6929c0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga959701e9c1c7f9ec6847994ad02f33da"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga959701e9c1c7f9ec6847994ad02f33da">DL_SYSCTL_setPowerPolicySTOP2</a> (void)</td></tr>
<tr class="memdesc:ga959701e9c1c7f9ec6847994ad02f33da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the STOP mode power policy to STOP2.  <a href="#ga959701e9c1c7f9ec6847994ad02f33da">More...</a><br /></td></tr>
<tr class="separator:ga959701e9c1c7f9ec6847994ad02f33da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf40c9a9621190c006e48f4e2885b6be3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaea2b0481ee57f8c16678f03d8b459012">DL_SYSCTL_POWER_POLICY_STOP</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaf40c9a9621190c006e48f4e2885b6be3">DL_SYSCTL_getPowerPolicySTOP</a> (void)</td></tr>
<tr class="memdesc:gaf40c9a9621190c006e48f4e2885b6be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the STOP mode power policy.  <a href="#gaf40c9a9621190c006e48f4e2885b6be3">More...</a><br /></td></tr>
<tr class="separator:gaf40c9a9621190c006e48f4e2885b6be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a9723385f17fa55edb70dfd007cb098"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga0a9723385f17fa55edb70dfd007cb098">DL_SYSCTL_setPowerPolicySTANDBY0</a> (void)</td></tr>
<tr class="memdesc:ga0a9723385f17fa55edb70dfd007cb098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the STANDBY mode power policy to STANDBY0.  <a href="#ga0a9723385f17fa55edb70dfd007cb098">More...</a><br /></td></tr>
<tr class="separator:ga0a9723385f17fa55edb70dfd007cb098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga597aa8110c977218350edb231bd60255"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga597aa8110c977218350edb231bd60255">DL_SYSCTL_setPowerPolicySTANDBY1</a> (void)</td></tr>
<tr class="memdesc:ga597aa8110c977218350edb231bd60255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the STANDBY mode power policy to STANDBY1.  <a href="#ga597aa8110c977218350edb231bd60255">More...</a><br /></td></tr>
<tr class="separator:ga597aa8110c977218350edb231bd60255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga164be7dcbe5dd57187d8c6d86aebe902"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaf84ef067c088e88595332daf7d0611b4">DL_SYSCTL_POWER_POLICY_STANDBY</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga164be7dcbe5dd57187d8c6d86aebe902">DL_SYSCTL_getPowerPolicySTANDBY</a> (void)</td></tr>
<tr class="memdesc:ga164be7dcbe5dd57187d8c6d86aebe902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the STANDBY mode power policy.  <a href="#ga164be7dcbe5dd57187d8c6d86aebe902">More...</a><br /></td></tr>
<tr class="separator:ga164be7dcbe5dd57187d8c6d86aebe902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06040876cc0d4e00b7ca0d4179aed61d"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga06040876cc0d4e00b7ca0d4179aed61d">DL_SYSCTL_setPowerPolicySHUTDOWN</a> (void)</td></tr>
<tr class="memdesc:ga06040876cc0d4e00b7ca0d4179aed61d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set power policy to SHUTDOWN mode.  <a href="#ga06040876cc0d4e00b7ca0d4179aed61d">More...</a><br /></td></tr>
<tr class="separator:ga06040876cc0d4e00b7ca0d4179aed61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7f269eeb1d06cba787e84b19a55d3a9"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gac7f269eeb1d06cba787e84b19a55d3a9">DL_SYSCTL_setBORThreshold</a> (<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gab31acca537d5af4a0710888c9fcb6be8">DL_SYSCTL_BOR_THRESHOLD_LEVEL</a> thresholdLevel)</td></tr>
<tr class="memdesc:gac7f269eeb1d06cba787e84b19a55d3a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the brown-out reset (BOR) threshold level.  <a href="#gac7f269eeb1d06cba787e84b19a55d3a9">More...</a><br /></td></tr>
<tr class="separator:gac7f269eeb1d06cba787e84b19a55d3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade6cc0ae8994808608697159762f0e1a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gab31acca537d5af4a0710888c9fcb6be8">DL_SYSCTL_BOR_THRESHOLD_LEVEL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gade6cc0ae8994808608697159762f0e1a">DL_SYSCTL_getBORThreshold</a> (void)</td></tr>
<tr class="memdesc:gade6cc0ae8994808608697159762f0e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the brown-out reset (BOR) threshold level.  <a href="#gade6cc0ae8994808608697159762f0e1a">More...</a><br /></td></tr>
<tr class="separator:gade6cc0ae8994808608697159762f0e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58632451ef9a852ee2390880849c5bb9"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga58632451ef9a852ee2390880849c5bb9">DL_SYSCTL_activateBORThreshold</a> (void)</td></tr>
<tr class="memdesc:ga58632451ef9a852ee2390880849c5bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate the BOR threshold level.  <a href="#ga58632451ef9a852ee2390880849c5bb9">More...</a><br /></td></tr>
<tr class="separator:ga58632451ef9a852ee2390880849c5bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba4ac323b5111764c4648811d21a672a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaba4ac323b5111764c4648811d21a672a">DL_SYSCTL_resetDevice</a> (uint32_t resetType)</td></tr>
<tr class="memdesc:gaba4ac323b5111764c4648811d21a672a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the device.  <a href="#gaba4ac323b5111764c4648811d21a672a">More...</a><br /></td></tr>
<tr class="separator:gaba4ac323b5111764c4648811d21a672a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd2bea2fc1b092320d43e1151c5aad54"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gabd2bea2fc1b092320d43e1151c5aad54">DL_SYSCTL_enableInterrupt</a> (uint32_t interruptMask)</td></tr>
<tr class="memdesc:gabd2bea2fc1b092320d43e1151c5aad54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable SYSCTL interrupts.  <a href="#gabd2bea2fc1b092320d43e1151c5aad54">More...</a><br /></td></tr>
<tr class="separator:gabd2bea2fc1b092320d43e1151c5aad54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga647ad30eff4e2c48ed86cbfffa418f40"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga647ad30eff4e2c48ed86cbfffa418f40">DL_SYSCTL_disableInterrupt</a> (uint32_t interruptMask)</td></tr>
<tr class="memdesc:ga647ad30eff4e2c48ed86cbfffa418f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable SYSCTL interrupts.  <a href="#ga647ad30eff4e2c48ed86cbfffa418f40">More...</a><br /></td></tr>
<tr class="separator:ga647ad30eff4e2c48ed86cbfffa418f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2511982eda39b33b67f1950b724b138"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gae2511982eda39b33b67f1950b724b138">DL_SYSCTL_getEnabledInterrupts</a> (uint32_t interruptMask)</td></tr>
<tr class="memdesc:gae2511982eda39b33b67f1950b724b138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check which SYSCTL interrupts are enabled.  <a href="#gae2511982eda39b33b67f1950b724b138">More...</a><br /></td></tr>
<tr class="separator:gae2511982eda39b33b67f1950b724b138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7df488a265f542a75d4864637f5be9f0"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga7df488a265f542a75d4864637f5be9f0">DL_SYSCTL_getEnabledInterruptStatus</a> (uint32_t interruptMask)</td></tr>
<tr class="memdesc:ga7df488a265f542a75d4864637f5be9f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check interrupt flag of enabled SYSCTL interrupts.  <a href="#ga7df488a265f542a75d4864637f5be9f0">More...</a><br /></td></tr>
<tr class="separator:ga7df488a265f542a75d4864637f5be9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga435916056d795f4b8aa8a2e10e5699ba"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga435916056d795f4b8aa8a2e10e5699ba">DL_SYSCTL_getRawInterruptStatus</a> (uint32_t interruptMask)</td></tr>
<tr class="memdesc:ga435916056d795f4b8aa8a2e10e5699ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check interrupt flag of any SYSCTL interrupt.  <a href="#ga435916056d795f4b8aa8a2e10e5699ba">More...</a><br /></td></tr>
<tr class="separator:ga435916056d795f4b8aa8a2e10e5699ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44cc4bb4792e909f761fdd8e460ca38a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga11f6187e683dcf2a0892c4ca5a818156">DL_SYSCTL_IIDX</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga44cc4bb4792e909f761fdd8e460ca38a">DL_SYSCTL_getPendingInterrupt</a> (void)</td></tr>
<tr class="memdesc:ga44cc4bb4792e909f761fdd8e460ca38a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get highest priority pending SYSCTL interrupt.  <a href="#ga44cc4bb4792e909f761fdd8e460ca38a">More...</a><br /></td></tr>
<tr class="separator:ga44cc4bb4792e909f761fdd8e460ca38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d1cdccf9e4494a8eeee66ade782664b"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga9d1cdccf9e4494a8eeee66ade782664b">DL_SYSCTL_clearInterruptStatus</a> (uint32_t interruptMask)</td></tr>
<tr class="memdesc:ga9d1cdccf9e4494a8eeee66ade782664b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear pending SYSCTL interrupts.  <a href="#ga9d1cdccf9e4494a8eeee66ade782664b">More...</a><br /></td></tr>
<tr class="separator:ga9d1cdccf9e4494a8eeee66ade782664b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a00ecf8f2acc672901f6ec6bd0d1267"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga8a00ecf8f2acc672901f6ec6bd0d1267">DL_SYSCTL_getRawNonMaskableInterruptStatus</a> (uint32_t interruptMask)</td></tr>
<tr class="memdesc:ga8a00ecf8f2acc672901f6ec6bd0d1267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check interrupt flag of any SYSCTL non-maskable interrupt.  <a href="#ga8a00ecf8f2acc672901f6ec6bd0d1267">More...</a><br /></td></tr>
<tr class="separator:ga8a00ecf8f2acc672901f6ec6bd0d1267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae19cd3d180fb0da4e2fd138c5308d56d"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga6bcbb65890c723d59c075c19f49419e6">DL_SYSCTL_NMI_IIDX</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gae19cd3d180fb0da4e2fd138c5308d56d">DL_SYSCTL_getPendingNonMaskableInterrupt</a> (void)</td></tr>
<tr class="memdesc:gae19cd3d180fb0da4e2fd138c5308d56d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get highest priority pending SYSCTL non-maskable interrupt.  <a href="#gae19cd3d180fb0da4e2fd138c5308d56d">More...</a><br /></td></tr>
<tr class="separator:gae19cd3d180fb0da4e2fd138c5308d56d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4c55590db0e90d4aa990e72fe18247d"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaf4c55590db0e90d4aa990e72fe18247d">DL_SYSCTL_clearNonMaskableInterruptStatus</a> (uint32_t interruptMask)</td></tr>
<tr class="memdesc:gaf4c55590db0e90d4aa990e72fe18247d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear pending SYSCTL non-maskable interrupts.  <a href="#gaf4c55590db0e90d4aa990e72fe18247d">More...</a><br /></td></tr>
<tr class="separator:gaf4c55590db0e90d4aa990e72fe18247d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga089727156353964f3376b19f408f3c56"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga089727156353964f3376b19f408f3c56">DL_SYSCTL_setWWDT0ErrorBehavior</a> (<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga06e41abcd8e8c7519885e1a6f9f740e7">DL_SYSCTL_ERROR_BEHAVIOR</a> behavior)</td></tr>
<tr class="memdesc:ga089727156353964f3376b19f408f3c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the behavior when a WWDT0 error occurs.  <a href="#ga089727156353964f3376b19f408f3c56">More...</a><br /></td></tr>
<tr class="separator:ga089727156353964f3376b19f408f3c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae88d90b3e0b9a99319ff849709b5fb5c"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga06e41abcd8e8c7519885e1a6f9f740e7">DL_SYSCTL_ERROR_BEHAVIOR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gae88d90b3e0b9a99319ff849709b5fb5c">DL_SYSCTL_getWWDT0ErrorBehavior</a> (void)</td></tr>
<tr class="memdesc:gae88d90b3e0b9a99319ff849709b5fb5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the behavior when a WWDT0 error occurs.  <a href="#gae88d90b3e0b9a99319ff849709b5fb5c">More...</a><br /></td></tr>
<tr class="separator:gae88d90b3e0b9a99319ff849709b5fb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d95f2379d3521583246b962818f35d3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga1d95f2379d3521583246b962818f35d3">DL_SYSCTL_setMCLKDivider</a> (<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga840c7f725afee13c0ba40fcad6ba5097">DL_SYSCTL_MCLK_DIVIDER</a> divider)</td></tr>
<tr class="memdesc:ga1d95f2379d3521583246b962818f35d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Main Clock (MCLK) divider (MDIV)  <a href="#ga1d95f2379d3521583246b962818f35d3">More...</a><br /></td></tr>
<tr class="separator:ga1d95f2379d3521583246b962818f35d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga513371a6042a86c8229a50d07fc923ed"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga840c7f725afee13c0ba40fcad6ba5097">DL_SYSCTL_MCLK_DIVIDER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga513371a6042a86c8229a50d07fc923ed">DL_SYSCTL_getMCLKDivider</a> (void)</td></tr>
<tr class="memdesc:ga513371a6042a86c8229a50d07fc923ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Main Clock (MCLK) divider (MDIV)  <a href="#ga513371a6042a86c8229a50d07fc923ed">More...</a><br /></td></tr>
<tr class="separator:ga513371a6042a86c8229a50d07fc923ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1593a733c8f1982417ae0b30f7c9297c"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga644e04bc507e88dee66e3018d9dc1810">DL_SYSCTL_MCLK_SOURCE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga1593a733c8f1982417ae0b30f7c9297c">DL_SYSCTL_getMCLKSource</a> (void)</td></tr>
<tr class="memdesc:ga1593a733c8f1982417ae0b30f7c9297c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the source for the Main Clock (MCLK)  <a href="#ga1593a733c8f1982417ae0b30f7c9297c">More...</a><br /></td></tr>
<tr class="separator:ga1593a733c8f1982417ae0b30f7c9297c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga561ed1294f48e5d0c04ff6e6f5856a1e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga561ed1294f48e5d0c04ff6e6f5856a1e">DL_SYSCTL_setSYSOSCFreq</a> (<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga2d02be2892b083ae42dc5ec338f52e46">DL_SYSCTL_SYSOSC_FREQ</a> freq)</td></tr>
<tr class="memdesc:ga561ed1294f48e5d0c04ff6e6f5856a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the target frequency of the System Oscillator (SYSOSC)  <a href="#ga561ed1294f48e5d0c04ff6e6f5856a1e">More...</a><br /></td></tr>
<tr class="separator:ga561ed1294f48e5d0c04ff6e6f5856a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24a8058e617b55c859d4fc7b8dce56ca"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga24a8058e617b55c859d4fc7b8dce56ca">DL_SYSCTL_configSYSOSCUserTrim</a> (const <a class="el" href="struct_d_l___s_y_s_c_t_l___s_y_s_o_s_c_user_trim_config.html">DL_SYSCTL_SYSOSCUserTrimConfig</a> *config)</td></tr>
<tr class="memdesc:ga24a8058e617b55c859d4fc7b8dce56ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim the System Oscillator (SYSOSC) to 16MHz or 24MHz.  <a href="#ga24a8058e617b55c859d4fc7b8dce56ca">More...</a><br /></td></tr>
<tr class="separator:ga24a8058e617b55c859d4fc7b8dce56ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc3bac88b735b1939e09de8296381872"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga2d02be2892b083ae42dc5ec338f52e46">DL_SYSCTL_SYSOSC_FREQ</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gacc3bac88b735b1939e09de8296381872">DL_SYSCTL_getTargetSYSOSCFreq</a> (void)</td></tr>
<tr class="memdesc:gacc3bac88b735b1939e09de8296381872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the target frequency of the System Oscillator (SYSOSC) Target/desired SYSOSC frequency may be different than current/actual SYSOSC frequency during gear shift and other operations. This function matches what is input by <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga561ed1294f48e5d0c04ff6e6f5856a1e">DL_SYSCTL_setSYSOSCFreq</a>.  <a href="#gacc3bac88b735b1939e09de8296381872">More...</a><br /></td></tr>
<tr class="separator:gacc3bac88b735b1939e09de8296381872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb7e0a77752c9b876b9289a443341362"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga2d02be2892b083ae42dc5ec338f52e46">DL_SYSCTL_SYSOSC_FREQ</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gacb7e0a77752c9b876b9289a443341362">DL_SYSCTL_getCurrentSYSOSCFreq</a> (void)</td></tr>
<tr class="memdesc:gacb7e0a77752c9b876b9289a443341362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current frequency of the System Oscillator (SYSOSC) Current/actual SYSOSC frequency may be different than target/desired SYSOSC frequency during gear shift and other operations.  <a href="#gacb7e0a77752c9b876b9289a443341362">More...</a><br /></td></tr>
<tr class="separator:gacb7e0a77752c9b876b9289a443341362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc4dead61fdff7cac031224790efb999"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gabc4dead61fdff7cac031224790efb999">DL_SYSCTL_getClockStatus</a> (void)</td></tr>
<tr class="memdesc:gabc4dead61fdff7cac031224790efb999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns status of the different clocks in CKM.  <a href="#gabc4dead61fdff7cac031224790efb999">More...</a><br /></td></tr>
<tr class="separator:gabc4dead61fdff7cac031224790efb999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c56e55435135b41670c72c9311116c1"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga0c56e55435135b41670c72c9311116c1">DL_SYSCTL_getStatus</a> (void)</td></tr>
<tr class="memdesc:ga0c56e55435135b41670c72c9311116c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns general status of SYSCTL.  <a href="#ga0c56e55435135b41670c72c9311116c1">More...</a><br /></td></tr>
<tr class="separator:ga0c56e55435135b41670c72c9311116c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ff18a52a5b1ddb681127f640453ceb0"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga6ff18a52a5b1ddb681127f640453ceb0">DL_SYSCTL_clearECCErrorStatus</a> (void)</td></tr>
<tr class="memdesc:ga6ff18a52a5b1ddb681127f640453ceb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the ECC error bits in SYSSTATUS.  <a href="#ga6ff18a52a5b1ddb681127f640453ceb0">More...</a><br /></td></tr>
<tr class="separator:ga6ff18a52a5b1ddb681127f640453ceb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b11d6f9180b94ee3cd0ae8088f52ecf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga1b11d6f9180b94ee3cd0ae8088f52ecf">DL_SYSCTL_setLFCLKSourceLFXT</a> (const <a class="el" href="struct_d_l___s_y_s_c_t_l___l_f_c_l_k_config.html">DL_SYSCTL_LFCLKConfig</a> *config)</td></tr>
<tr class="memdesc:ga1b11d6f9180b94ee3cd0ae8088f52ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change LFCLK source to external crystal LFXT.  <a href="#ga1b11d6f9180b94ee3cd0ae8088f52ecf">More...</a><br /></td></tr>
<tr class="separator:ga1b11d6f9180b94ee3cd0ae8088f52ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9ae1fe965282a867dfd06090393fce1"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gac9ae1fe965282a867dfd06090393fce1">DL_SYSCTL_setLFCLKSourceEXLF</a> (void)</td></tr>
<tr class="memdesc:gac9ae1fe965282a867dfd06090393fce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change LFCLK source to external digital LFCLK_IN.  <a href="#gac9ae1fe965282a867dfd06090393fce1">More...</a><br /></td></tr>
<tr class="separator:gac9ae1fe965282a867dfd06090393fce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae689ceed07203a48905faf6682c2f63a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gae689ceed07203a48905faf6682c2f63a">DL_SYSCTL_setHFCLKSourceHFXT</a> (<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gae709a299b57e30a00d2b05c12eaba591">DL_SYSCTL_HFXT_RANGE</a> range)</td></tr>
<tr class="memdesc:gae689ceed07203a48905faf6682c2f63a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change HFCLK source to external crystal HFXT with default parameters.  <a href="#gae689ceed07203a48905faf6682c2f63a">More...</a><br /></td></tr>
<tr class="separator:gae689ceed07203a48905faf6682c2f63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e765de836ed9b826189538c67ce3903"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga0e765de836ed9b826189538c67ce3903">DL_SYSCTL_setHFCLKSourceHFXTParams</a> (<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gae709a299b57e30a00d2b05c12eaba591">DL_SYSCTL_HFXT_RANGE</a> range, uint32_t startupTime, bool monitorEnable)</td></tr>
<tr class="memdesc:ga0e765de836ed9b826189538c67ce3903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change HFCLK source to external crystal HFXT with custom parameters.  <a href="#ga0e765de836ed9b826189538c67ce3903">More...</a><br /></td></tr>
<tr class="separator:ga0e765de836ed9b826189538c67ce3903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b677e9635ac00678d6513d23a6369e4"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga3b677e9635ac00678d6513d23a6369e4">DL_SYSCTL_setHFCLKSourceHFCLKIN</a> (void)</td></tr>
<tr class="memdesc:ga3b677e9635ac00678d6513d23a6369e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change HFCLK source to external digital HFCLK_IN.  <a href="#ga3b677e9635ac00678d6513d23a6369e4">More...</a><br /></td></tr>
<tr class="separator:ga3b677e9635ac00678d6513d23a6369e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad038f76d15dfa17e0d04e12c0c9a58e6"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gad038f76d15dfa17e0d04e12c0c9a58e6">DL_SYSCTL_disableHFXT</a> (void)</td></tr>
<tr class="memdesc:gad038f76d15dfa17e0d04e12c0c9a58e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the HFXT.  <a href="#gad038f76d15dfa17e0d04e12c0c9a58e6">More...</a><br /></td></tr>
<tr class="separator:gad038f76d15dfa17e0d04e12c0c9a58e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga878454028c81a441ec3bfd9419d3c51c"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gadb318a4bb7a5bfb1555f660f63d32fbb">DL_SYSCTL_HSCLK_SOURCE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga878454028c81a441ec3bfd9419d3c51c">DL_SYSCTL_getHSCLKSource</a> (void)</td></tr>
<tr class="memdesc:ga878454028c81a441ec3bfd9419d3c51c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the source of High Speed Clock (HSCLK)  <a href="#ga878454028c81a441ec3bfd9419d3c51c">More...</a><br /></td></tr>
<tr class="separator:ga878454028c81a441ec3bfd9419d3c51c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1286904349677daa6ecad36b8d9b83db"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga1286904349677daa6ecad36b8d9b83db">DL_SYSCTL_setHSCLKSource</a> (<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gadb318a4bb7a5bfb1555f660f63d32fbb">DL_SYSCTL_HSCLK_SOURCE</a> source)</td></tr>
<tr class="memdesc:ga1286904349677daa6ecad36b8d9b83db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the source of High Speed Clock (HSCLK)  <a href="#ga1286904349677daa6ecad36b8d9b83db">More...</a><br /></td></tr>
<tr class="separator:ga1286904349677daa6ecad36b8d9b83db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga537bf2725b6ee2069d6262ab2ce500cf"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga7015e4698d5924cb3f6b05f26e76f8ef">DL_SYSCTL_MFPCLK_SOURCE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga537bf2725b6ee2069d6262ab2ce500cf">DL_SYSCTL_getMFPCLKSource</a> (void)</td></tr>
<tr class="memdesc:ga537bf2725b6ee2069d6262ab2ce500cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the source of Middle Frequency Precision Clock (MFPCLK)  <a href="#ga537bf2725b6ee2069d6262ab2ce500cf">More...</a><br /></td></tr>
<tr class="separator:ga537bf2725b6ee2069d6262ab2ce500cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7097c67efa10770a6fa55d0e8ab3a75a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga7097c67efa10770a6fa55d0e8ab3a75a">DL_SYSCTL_setMFPCLKSource</a> (<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga7015e4698d5924cb3f6b05f26e76f8ef">DL_SYSCTL_MFPCLK_SOURCE</a> source)</td></tr>
<tr class="memdesc:ga7097c67efa10770a6fa55d0e8ab3a75a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the source of Middle Frequency Precision Clock (MFPCLK)  <a href="#ga7097c67efa10770a6fa55d0e8ab3a75a">More...</a><br /></td></tr>
<tr class="separator:ga7097c67efa10770a6fa55d0e8ab3a75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9751ef1f940f0b445bb5218929706bd3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga9751ef1f940f0b445bb5218929706bd3">DL_SYSCTL_enableMFCLK</a> (void)</td></tr>
<tr class="memdesc:ga9751ef1f940f0b445bb5218929706bd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the Medium Frequency Clock (MFCLK)  <a href="#ga9751ef1f940f0b445bb5218929706bd3">More...</a><br /></td></tr>
<tr class="separator:ga9751ef1f940f0b445bb5218929706bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6bcd3c73673d174417ea62f2e41d83c"><td class="memItemLeft" align="right" valign="top"><a id="gae6bcd3c73673d174417ea62f2e41d83c"></a>
__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gae6bcd3c73673d174417ea62f2e41d83c">DL_SYSCTL_disableMFCLK</a> (void)</td></tr>
<tr class="memdesc:gae6bcd3c73673d174417ea62f2e41d83c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the Medium Frequency Clock (MFCLK) <br /></td></tr>
<tr class="separator:gae6bcd3c73673d174417ea62f2e41d83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78c88e3044b7101bb2d38762cbc1c3ee"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga78c88e3044b7101bb2d38762cbc1c3ee">DL_SYSCTL_enableMFPCLK</a> (void)</td></tr>
<tr class="memdesc:ga78c88e3044b7101bb2d38762cbc1c3ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the Middle Frequency Precision Clock (MFPCLK)  <a href="#ga78c88e3044b7101bb2d38762cbc1c3ee">More...</a><br /></td></tr>
<tr class="separator:ga78c88e3044b7101bb2d38762cbc1c3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56c2fec5e1322ea838a19f6ff34e1b10"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga56c2fec5e1322ea838a19f6ff34e1b10">DL_SYSCTL_disableMFPCLK</a> (void)</td></tr>
<tr class="memdesc:ga56c2fec5e1322ea838a19f6ff34e1b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the Middle Frequency Precision Clock (MFPCLK)  <a href="#ga56c2fec5e1322ea838a19f6ff34e1b10">More...</a><br /></td></tr>
<tr class="separator:ga56c2fec5e1322ea838a19f6ff34e1b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9561095907a62e45aff6a7d25cf3d106"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga9561095907a62e45aff6a7d25cf3d106">DL_SYSCTL_setHFCLKDividerForMFPCLK</a> (<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaeec66a871ef0d069fc54f791abbfb84e">DL_SYSCTL_HFCLK_MFPCLK_DIVIDER</a> divider)</td></tr>
<tr class="memdesc:ga9561095907a62e45aff6a7d25cf3d106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the divider for HFCLK when HFCLK is used as the MFPCLK source.  <a href="#ga9561095907a62e45aff6a7d25cf3d106">More...</a><br /></td></tr>
<tr class="separator:ga9561095907a62e45aff6a7d25cf3d106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30945b87ed22b61047209e8f6f3986eb"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaeec66a871ef0d069fc54f791abbfb84e">DL_SYSCTL_HFCLK_MFPCLK_DIVIDER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga30945b87ed22b61047209e8f6f3986eb">DL_SYSCTL_getHFCLKDividerForMFPCLK</a> (void)</td></tr>
<tr class="memdesc:ga30945b87ed22b61047209e8f6f3986eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the divider for HFCLK when HFCLK is used as the MFPCLK source.  <a href="#ga30945b87ed22b61047209e8f6f3986eb">More...</a><br /></td></tr>
<tr class="separator:ga30945b87ed22b61047209e8f6f3986eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac17c9e77ba1b2ff630fc5ea449a38695"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gac17c9e77ba1b2ff630fc5ea449a38695">DL_SYSCTL_enableExternalClock</a> (<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga4345c30b25b31b0a0baba36fbcedceed">DL_SYSCTL_CLK_OUT_SOURCE</a> source, <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga981fe3602bfb00a63911e2e14f82f1bf">DL_SYSCTL_CLK_OUT_DIVIDE</a> divider)</td></tr>
<tr class="memdesc:gac17c9e77ba1b2ff630fc5ea449a38695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the External Clock (CLK_OUT)  <a href="#gac17c9e77ba1b2ff630fc5ea449a38695">More...</a><br /></td></tr>
<tr class="separator:gac17c9e77ba1b2ff630fc5ea449a38695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga296ed5001418143d4c334728094a7221"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga296ed5001418143d4c334728094a7221">DL_SYSCTL_disableExternalClock</a> (void)</td></tr>
<tr class="memdesc:ga296ed5001418143d4c334728094a7221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the External Clock (CLK_OUT)  <a href="#ga296ed5001418143d4c334728094a7221">More...</a><br /></td></tr>
<tr class="separator:ga296ed5001418143d4c334728094a7221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca52ca0f8f1ca52a3115cfd3a7ac9645"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaca52ca0f8f1ca52a3115cfd3a7ac9645">DL_SYSCTL_disableExternalClockDivider</a> (void)</td></tr>
<tr class="memdesc:gaca52ca0f8f1ca52a3115cfd3a7ac9645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the External Clock (CLK_OUT) Divider.  <a href="#gaca52ca0f8f1ca52a3115cfd3a7ac9645">More...</a><br /></td></tr>
<tr class="separator:gaca52ca0f8f1ca52a3115cfd3a7ac9645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga449282c13007199d5d46284f369766dc"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga449282c13007199d5d46284f369766dc">DL_SYSCTL_blockAllAsyncFastClockRequests</a> (void)</td></tr>
<tr class="memdesc:ga449282c13007199d5d46284f369766dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks all asynchronous fast clock requests.  <a href="#ga449282c13007199d5d46284f369766dc">More...</a><br /></td></tr>
<tr class="separator:ga449282c13007199d5d46284f369766dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89f44149aa50423b0a37240235a38a71"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga89f44149aa50423b0a37240235a38a71">DL_SYSCTL_allowAllAsyncFastClockRequests</a> (void)</td></tr>
<tr class="memdesc:ga89f44149aa50423b0a37240235a38a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows all asynchronous fast clock requests.  <a href="#ga89f44149aa50423b0a37240235a38a71">More...</a><br /></td></tr>
<tr class="separator:ga89f44149aa50423b0a37240235a38a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b4ec4f609664cf4e4be7818a730d7d2"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga3b4ec4f609664cf4e4be7818a730d7d2">DL_SYSCTL_enableFastCPUEventHandling</a> (void)</td></tr>
<tr class="memdesc:ga3b4ec4f609664cf4e4be7818a730d7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an asynchronous fast clock request upon any IRQ request to CPU.  <a href="#ga3b4ec4f609664cf4e4be7818a730d7d2">More...</a><br /></td></tr>
<tr class="separator:ga3b4ec4f609664cf4e4be7818a730d7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeb976e93dce87431582f90277c8d2ac"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaeeb976e93dce87431582f90277c8d2ac">DL_SYSCTL_disableFastCPUEventHandling</a> (void)</td></tr>
<tr class="memdesc:gaeeb976e93dce87431582f90277c8d2ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maintains current system clock speed for IRQ request to CPU.  <a href="#gaeeb976e93dce87431582f90277c8d2ac">More...</a><br /></td></tr>
<tr class="separator:gaeeb976e93dce87431582f90277c8d2ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7beee417ca0bdccc26483e11e9943e59"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga7beee417ca0bdccc26483e11e9943e59">DL_SYSCTL_setSRAMBoundaryAddress</a> (uint32_t address)</td></tr>
<tr class="memdesc:ga7beee417ca0bdccc26483e11e9943e59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the SRAM boundary address to act as partition for read-execute permission.  <a href="#ga7beee417ca0bdccc26483e11e9943e59">More...</a><br /></td></tr>
<tr class="separator:ga7beee417ca0bdccc26483e11e9943e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dc3f7fb33dacb281fc578b6a5bbdca6"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga3dc3f7fb33dacb281fc578b6a5bbdca6">DL_SYSCTL_getSRAMBoundaryAddress</a> (void)</td></tr>
<tr class="memdesc:ga3dc3f7fb33dacb281fc578b6a5bbdca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the SRAM boundary address.  <a href="#ga3dc3f7fb33dacb281fc578b6a5bbdca6">More...</a><br /></td></tr>
<tr class="separator:ga3dc3f7fb33dacb281fc578b6a5bbdca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga192193cab933ec53c22d47cd69c5adc6"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga192193cab933ec53c22d47cd69c5adc6">DL_SYSCTL_setFlashWaitState</a> (<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga7b893ce5af5fab09fed655808c393c92">DL_SYSCTL_FLASH_WAIT_STATE</a> waitState)</td></tr>
<tr class="memdesc:ga192193cab933ec53c22d47cd69c5adc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set flash wait state.  <a href="#ga192193cab933ec53c22d47cd69c5adc6">More...</a><br /></td></tr>
<tr class="separator:ga192193cab933ec53c22d47cd69c5adc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga528655371e502e1afae771af169e4a69"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga7b893ce5af5fab09fed655808c393c92">DL_SYSCTL_FLASH_WAIT_STATE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga528655371e502e1afae771af169e4a69">DL_SYSCTL_getFlashWaitState</a> (void)</td></tr>
<tr class="memdesc:ga528655371e502e1afae771af169e4a69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get flash wait state.  <a href="#ga528655371e502e1afae771af169e4a69">More...</a><br /></td></tr>
<tr class="separator:ga528655371e502e1afae771af169e4a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d9e793740c9501a14647715e2f9313a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga3d9e793740c9501a14647715e2f9313a">DL_SYSCTL_readFCC</a> (void)</td></tr>
<tr class="memdesc:ga3d9e793740c9501a14647715e2f9313a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Frequency Clock Counter (FCC)  <a href="#ga3d9e793740c9501a14647715e2f9313a">More...</a><br /></td></tr>
<tr class="separator:ga3d9e793740c9501a14647715e2f9313a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7df43169548c7515fc5352790ec226e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gac7df43169548c7515fc5352790ec226e">DL_SYSCTL_startFCC</a> (void)</td></tr>
<tr class="memdesc:gac7df43169548c7515fc5352790ec226e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start Frequency Clock Counter (FCC)  <a href="#gac7df43169548c7515fc5352790ec226e">More...</a><br /></td></tr>
<tr class="separator:gac7df43169548c7515fc5352790ec226e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c359b196e7bee473007998b4342a541"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga1c359b196e7bee473007998b4342a541">DL_SYSCTL_isFCCDone</a> (void)</td></tr>
<tr class="memdesc:ga1c359b196e7bee473007998b4342a541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether FCC is done capturing.  <a href="#ga1c359b196e7bee473007998b4342a541">More...</a><br /></td></tr>
<tr class="separator:ga1c359b196e7bee473007998b4342a541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc3a566bffa1f7cb61c94dddc2ad7870"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gabc3a566bffa1f7cb61c94dddc2ad7870">DL_SYSCTL_configFCC</a> (<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gade1fd3f998053938225af73b519f695d">DL_SYSCTL_FCC_TRIG_TYPE</a> trigLvl, <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gad56cf7d1f7fe634c4575f18669403887">DL_SYSCTL_FCC_TRIG_SOURCE</a> trigSrc, <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga088842c40b39b18edd2e81f898deea08">DL_SYSCTL_FCC_CLOCK_SOURCE</a> clkSrc)</td></tr>
<tr class="memdesc:gabc3a566bffa1f7cb61c94dddc2ad7870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the Frequency Clock Counter (FCC)  <a href="#gabc3a566bffa1f7cb61c94dddc2ad7870">More...</a><br /></td></tr>
<tr class="separator:gabc3a566bffa1f7cb61c94dddc2ad7870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04566c3fe45eed79d9d05248c3173b16"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga04566c3fe45eed79d9d05248c3173b16">DL_SYSCTL_setFCCPeriods</a> (<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga919e05d2b9725602984a9ae8bee98b09">DL_SYSCTL_FCC_TRIG_CNT</a> periods)</td></tr>
<tr class="memdesc:ga04566c3fe45eed79d9d05248c3173b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets number of rising-edge to rising-edge period for Frequency Clock Counter (FCC)  <a href="#ga04566c3fe45eed79d9d05248c3173b16">More...</a><br /></td></tr>
<tr class="separator:ga04566c3fe45eed79d9d05248c3173b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c3f461bd82d8f9dc1f3eb380502ab25"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga919e05d2b9725602984a9ae8bee98b09">DL_SYSCTL_FCC_TRIG_CNT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga5c3f461bd82d8f9dc1f3eb380502ab25">DL_SYSCTL_getFCCPeriods</a> (void)</td></tr>
<tr class="memdesc:ga5c3f461bd82d8f9dc1f3eb380502ab25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets number of rising-edge to rising-edge period for Frequency Clock Counter (FCC)  <a href="#ga5c3f461bd82d8f9dc1f3eb380502ab25">More...</a><br /></td></tr>
<tr class="separator:ga5c3f461bd82d8f9dc1f3eb380502ab25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8209173a763a90618c126b4f3a0a533a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga8209173a763a90618c126b4f3a0a533a">DL_SYSCTL_enableSYSOSCFCL</a> (void)</td></tr>
<tr class="memdesc:ga8209173a763a90618c126b4f3a0a533a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable Frequency Correction Loop (FCL) in Internal Resistor Mode.  <a href="#ga8209173a763a90618c126b4f3a0a533a">More...</a><br /></td></tr>
<tr class="separator:ga8209173a763a90618c126b4f3a0a533a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3974b94a8e546a7d399b77a90657f680"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga3974b94a8e546a7d399b77a90657f680">DL_SYSCTL_enableSYSOSCFCLExternalResistor</a> (void)</td></tr>
<tr class="memdesc:ga3974b94a8e546a7d399b77a90657f680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable Frequency Correction Loop (FCL) in External Resistor Mode.  <a href="#ga3974b94a8e546a7d399b77a90657f680">More...</a><br /></td></tr>
<tr class="separator:ga3974b94a8e546a7d399b77a90657f680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0b1c86e5a0be32ac2238c2a0e2540b2"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gae0b1c86e5a0be32ac2238c2a0e2540b2">DL_SYSCTL_enableWriteLock</a> (void)</td></tr>
<tr class="memdesc:gae0b1c86e5a0be32ac2238c2a0e2540b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable write protection of selected SYSCTL registers.  <a href="#gae0b1c86e5a0be32ac2238c2a0e2540b2">More...</a><br /></td></tr>
<tr class="separator:gae0b1c86e5a0be32ac2238c2a0e2540b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga277a6e9bb37507630bc258f3d0cbcaed"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga277a6e9bb37507630bc258f3d0cbcaed">DL_SYSCTL_disableWriteLock</a> (void)</td></tr>
<tr class="memdesc:ga277a6e9bb37507630bc258f3d0cbcaed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable write protection of selected SYSCTL registers.  <a href="#ga277a6e9bb37507630bc258f3d0cbcaed">More...</a><br /></td></tr>
<tr class="separator:ga277a6e9bb37507630bc258f3d0cbcaed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c2c4728010a6f06487971a43b594896"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga5c2c4728010a6f06487971a43b594896">DL_SYSCTL_setVBOOSTConfig</a> (<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga4bac12ff08dc5a074df489d69ae0cc80">DL_SYSCTL_VBOOST</a> setting)</td></tr>
<tr class="memdesc:ga5c2c4728010a6f06487971a43b594896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets operating mode of VBOOST (analog charge pump)  <a href="#ga5c2c4728010a6f06487971a43b594896">More...</a><br /></td></tr>
<tr class="separator:ga5c2c4728010a6f06487971a43b594896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9027ace807fff308872a42ea19283b78"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga4bac12ff08dc5a074df489d69ae0cc80">DL_SYSCTL_VBOOST</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga9027ace807fff308872a42ea19283b78">DL_SYSCTL_getVBOOSTConfig</a> (void)</td></tr>
<tr class="memdesc:ga9027ace807fff308872a42ea19283b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets operating mode of VBOOST (analog charge pump)  <a href="#ga9027ace807fff308872a42ea19283b78">More...</a><br /></td></tr>
<tr class="separator:ga9027ace807fff308872a42ea19283b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41542df65ab8053c8db5695febe0865b"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga41542df65ab8053c8db5695febe0865b">DL_SYSCTL_getShutdownStorageByte</a> (<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gac4ba3ae564f39aac9884ee95b1a4bf50">DL_SYSCTL_SHUTDOWN_STORAGE_BYTE</a> index)</td></tr>
<tr class="memdesc:ga41542df65ab8053c8db5695febe0865b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return byte that was saved through SHUTDOWN.  <a href="#ga41542df65ab8053c8db5695febe0865b">More...</a><br /></td></tr>
<tr class="separator:ga41542df65ab8053c8db5695febe0865b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3862a4ee9f928a49e09ab17f77448242"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga3862a4ee9f928a49e09ab17f77448242">DL_SYSCTL_setShutdownStorageByte</a> (<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gac4ba3ae564f39aac9884ee95b1a4bf50">DL_SYSCTL_SHUTDOWN_STORAGE_BYTE</a> index, uint8_t data)</td></tr>
<tr class="memdesc:ga3862a4ee9f928a49e09ab17f77448242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a byte to SHUTDOWN memory.  <a href="#ga3862a4ee9f928a49e09ab17f77448242">More...</a><br /></td></tr>
<tr class="separator:ga3862a4ee9f928a49e09ab17f77448242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeca20e76a7f28e0623d43a00ae583d80"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaeca20e76a7f28e0623d43a00ae583d80">DL_SYSCTL_releaseShutdownIO</a> (void)</td></tr>
<tr class="memdesc:gaeca20e76a7f28e0623d43a00ae583d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable SHUTDOWN IO Release.  <a href="#gaeca20e76a7f28e0623d43a00ae583d80">More...</a><br /></td></tr>
<tr class="separator:gaeca20e76a7f28e0623d43a00ae583d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga484efea497454075cc913a878804d020"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga484efea497454075cc913a878804d020">DL_SYSCTL_disableNRSTPin</a> (void)</td></tr>
<tr class="memdesc:ga484efea497454075cc913a878804d020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the reset functionality of the NRST pin.  <a href="#ga484efea497454075cc913a878804d020">More...</a><br /></td></tr>
<tr class="separator:ga484efea497454075cc913a878804d020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c76ab08305e09c585144dc3f3d08eab"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga3c76ab08305e09c585144dc3f3d08eab">DL_SYSCTL_disableSWD</a> (void)</td></tr>
<tr class="memdesc:ga3c76ab08305e09c585144dc3f3d08eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable Serial Wire Debug (SWD) functionality.  <a href="#ga3c76ab08305e09c585144dc3f3d08eab">More...</a><br /></td></tr>
<tr class="separator:ga3c76ab08305e09c585144dc3f3d08eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga894bf68f6e9bc1f15fc1a8c26e01c0d3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga72bea3c6a78a3a5c0d389ac78cacce74">DL_SYSCTL_RESET_CAUSE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga894bf68f6e9bc1f15fc1a8c26e01c0d3">DL_SYSCTL_getResetCause</a> (void)</td></tr>
<tr class="memdesc:ga894bf68f6e9bc1f15fc1a8c26e01c0d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return byte that is stored in RSTCAUSE.  <a href="#ga894bf68f6e9bc1f15fc1a8c26e01c0d3">More...</a><br /></td></tr>
<tr class="separator:ga894bf68f6e9bc1f15fc1a8c26e01c0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ea033c2a0d0f2e64c3ad4ce7e9b8b66"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga0ea033c2a0d0f2e64c3ad4ce7e9b8b66">DL_SYSCTL_setHFXTStartupTime</a> (uint32_t startupTime)</td></tr>
<tr class="memdesc:ga0ea033c2a0d0f2e64c3ad4ce7e9b8b66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the HFXT startup time.  <a href="#ga0ea033c2a0d0f2e64c3ad4ce7e9b8b66">More...</a><br /></td></tr>
<tr class="separator:ga0ea033c2a0d0f2e64c3ad4ce7e9b8b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29dbe951600e38179bb36db2090c8bcc"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga29dbe951600e38179bb36db2090c8bcc">DL_SYSCTL_getHFXTStartupTime</a> (void)</td></tr>
<tr class="memdesc:ga29dbe951600e38179bb36db2090c8bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the HFXT startup time.  <a href="#ga29dbe951600e38179bb36db2090c8bcc">More...</a><br /></td></tr>
<tr class="separator:ga29dbe951600e38179bb36db2090c8bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadea6cf63b237f315f0d02d85d6ec7aca"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gadea6cf63b237f315f0d02d85d6ec7aca">DL_SYSCTL_setHFXTFrequencyRange</a> (<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gae709a299b57e30a00d2b05c12eaba591">DL_SYSCTL_HFXT_RANGE</a> range)</td></tr>
<tr class="memdesc:gadea6cf63b237f315f0d02d85d6ec7aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the HFXT frequency range.  <a href="#gadea6cf63b237f315f0d02d85d6ec7aca">More...</a><br /></td></tr>
<tr class="separator:gadea6cf63b237f315f0d02d85d6ec7aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad290b4bb6f05012ce8984e879fe9c5e8"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gae709a299b57e30a00d2b05c12eaba591">DL_SYSCTL_HFXT_RANGE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gad290b4bb6f05012ce8984e879fe9c5e8">DL_SYSCTL_getHFXTFrequencyRange</a> (void)</td></tr>
<tr class="memdesc:gad290b4bb6f05012ce8984e879fe9c5e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the HFXT frequency range.  <a href="#gad290b4bb6f05012ce8984e879fe9c5e8">More...</a><br /></td></tr>
<tr class="separator:gad290b4bb6f05012ce8984e879fe9c5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90f01dd71b9d1f8a74bdd08859701269"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga90f01dd71b9d1f8a74bdd08859701269">DL_SYSCTL_enableHFCLKStartupMonitor</a> (void)</td></tr>
<tr class="memdesc:ga90f01dd71b9d1f8a74bdd08859701269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the HFCLK startup monitor.  <a href="#ga90f01dd71b9d1f8a74bdd08859701269">More...</a><br /></td></tr>
<tr class="separator:ga90f01dd71b9d1f8a74bdd08859701269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf0d5f1b30a5ee48602236c0415240e1"><td class="memItemLeft" align="right" valign="top"><a id="gacf0d5f1b30a5ee48602236c0415240e1"></a>
__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gacf0d5f1b30a5ee48602236c0415240e1">DL_SYSCTL_disableHFCLKStartupMonitor</a> (void)</td></tr>
<tr class="memdesc:gacf0d5f1b30a5ee48602236c0415240e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the HFCLK startup monitor. <br /></td></tr>
<tr class="separator:gacf0d5f1b30a5ee48602236c0415240e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b827d98ddbc2ba384560e36e12218f7"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga4b827d98ddbc2ba384560e36e12218f7">DL_SYSCTL_getTempCalibrationConstant</a> (void)</td></tr>
<tr class="memdesc:ga4b827d98ddbc2ba384560e36e12218f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the calibration constant of the temperature sensor to be used in temperature calculation.  <a href="#ga4b827d98ddbc2ba384560e36e12218f7">More...</a><br /></td></tr>
<tr class="separator:ga4b827d98ddbc2ba384560e36e12218f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19d019a22533e245c58eb7df62817565"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga19d019a22533e245c58eb7df62817565">DL_SYSCTL_initReadExecuteProtectFirewall</a> (uint32_t startAddr, uint32_t endAddr)</td></tr>
<tr class="memdesc:ga19d019a22533e245c58eb7df62817565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the Read Execute (RX) Protect Firewall.  <a href="#ga19d019a22533e245c58eb7df62817565">More...</a><br /></td></tr>
<tr class="separator:ga19d019a22533e245c58eb7df62817565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga948875f053637b9177d221a3f9fe564b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga948875f053637b9177d221a3f9fe564b">DL_SYSCTL_initIPProtectFirewall</a> (uint32_t startAddr, uint32_t endAddr)</td></tr>
<tr class="memdesc:ga948875f053637b9177d221a3f9fe564b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the IP Protect Firewall.  <a href="#ga948875f053637b9177d221a3f9fe564b">More...</a><br /></td></tr>
<tr class="separator:ga948875f053637b9177d221a3f9fe564b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9db06453c59cb1810344af02182dc3e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gad9db06453c59cb1810344af02182dc3e">DL_SYSCTL_setWriteProtectFirewallAddrRange</a> (uint32_t addrMask)</td></tr>
<tr class="memdesc:gad9db06453c59cb1810344af02182dc3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the address range of the Write Protect Firewall.  <a href="#gad9db06453c59cb1810344af02182dc3e">More...</a><br /></td></tr>
<tr class="separator:gad9db06453c59cb1810344af02182dc3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98aa82f207eb441076f6d77f75c100a0"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga98aa82f207eb441076f6d77f75c100a0">DL_SYSCTL_getWriteProtectFirewallAddrRange</a> (void)</td></tr>
<tr class="memdesc:ga98aa82f207eb441076f6d77f75c100a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the address range of the Write Protect Firewall.  <a href="#ga98aa82f207eb441076f6d77f75c100a0">More...</a><br /></td></tr>
<tr class="separator:ga98aa82f207eb441076f6d77f75c100a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d878647af29356ab0e2d83ff1cbb2c2"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga1d878647af29356ab0e2d83ff1cbb2c2">DL_SYSCTL_setReadExecuteProtectFirewallAddrStart</a> (uint32_t startAddr)</td></tr>
<tr class="memdesc:ga1d878647af29356ab0e2d83ff1cbb2c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the start address of the Read Execute (RX) Protect Firewall.  <a href="#ga1d878647af29356ab0e2d83ff1cbb2c2">More...</a><br /></td></tr>
<tr class="separator:ga1d878647af29356ab0e2d83ff1cbb2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ea8fa7a283057d47127c18a4ff433d7"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga6ea8fa7a283057d47127c18a4ff433d7">DL_SYSCTL_getReadExecuteProtectFirewallAddrStart</a> (void)</td></tr>
<tr class="memdesc:ga6ea8fa7a283057d47127c18a4ff433d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the start address of the Read Execute (RX) Protect Firewall.  <a href="#ga6ea8fa7a283057d47127c18a4ff433d7">More...</a><br /></td></tr>
<tr class="separator:ga6ea8fa7a283057d47127c18a4ff433d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3295c299836bb72c482de842aaf584b3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga3295c299836bb72c482de842aaf584b3">DL_SYSCTL_setReadExecuteProtectFirewallAddrEnd</a> (uint32_t endAddr)</td></tr>
<tr class="memdesc:ga3295c299836bb72c482de842aaf584b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the end address of the Read Execute (RX) Protect Firewall.  <a href="#ga3295c299836bb72c482de842aaf584b3">More...</a><br /></td></tr>
<tr class="separator:ga3295c299836bb72c482de842aaf584b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c60d5560c2003f12004862834f16470"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga7c60d5560c2003f12004862834f16470">DL_SYSCTL_getReadExecuteProtectFirewallAddrEnd</a> (void)</td></tr>
<tr class="memdesc:ga7c60d5560c2003f12004862834f16470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the end address of the Read Execute (RX) Protect Firewall.  <a href="#ga7c60d5560c2003f12004862834f16470">More...</a><br /></td></tr>
<tr class="separator:ga7c60d5560c2003f12004862834f16470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga137cc4c74b4e7705b1f61d8bbac0b7fa"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga137cc4c74b4e7705b1f61d8bbac0b7fa">DL_SYSCTL_setIPProtectFirewallAddrStart</a> (uint32_t startAddr)</td></tr>
<tr class="memdesc:ga137cc4c74b4e7705b1f61d8bbac0b7fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the start address of the IP Protect Firewall.  <a href="#ga137cc4c74b4e7705b1f61d8bbac0b7fa">More...</a><br /></td></tr>
<tr class="separator:ga137cc4c74b4e7705b1f61d8bbac0b7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9307cba882dafded10d4b5e2c40fea34"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga9307cba882dafded10d4b5e2c40fea34">DL_SYSCTL_getIPProtectFirewallAddrStart</a> (void)</td></tr>
<tr class="memdesc:ga9307cba882dafded10d4b5e2c40fea34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the start address of the IP Protect Firewall.  <a href="#ga9307cba882dafded10d4b5e2c40fea34">More...</a><br /></td></tr>
<tr class="separator:ga9307cba882dafded10d4b5e2c40fea34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9d96c3d1ccaec65df43f9a4f32b079d"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gad9d96c3d1ccaec65df43f9a4f32b079d">DL_SYSCTL_setIPProtectFirewallAddrEnd</a> (uint32_t endAddr)</td></tr>
<tr class="memdesc:gad9d96c3d1ccaec65df43f9a4f32b079d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the end address of the IP Protect firewall.  <a href="#gad9d96c3d1ccaec65df43f9a4f32b079d">More...</a><br /></td></tr>
<tr class="separator:gad9d96c3d1ccaec65df43f9a4f32b079d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48caf7ed99261c82a96effdf4cd1b891"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga48caf7ed99261c82a96effdf4cd1b891">DL_SYSCTL_getIPProtectFirewallAddrEnd</a> (void)</td></tr>
<tr class="memdesc:ga48caf7ed99261c82a96effdf4cd1b891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the end address of the IP Protect Firewall.  <a href="#ga48caf7ed99261c82a96effdf4cd1b891">More...</a><br /></td></tr>
<tr class="separator:ga48caf7ed99261c82a96effdf4cd1b891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae11d79a48531e1add5af74bc4e144570"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gae11d79a48531e1add5af74bc4e144570">DL_SYSCTL_enableFlashBankSwap</a> (void)</td></tr>
<tr class="memdesc:gae11d79a48531e1add5af74bc4e144570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the policy to allow flash bank swapping.  <a href="#gae11d79a48531e1add5af74bc4e144570">More...</a><br /></td></tr>
<tr class="separator:gae11d79a48531e1add5af74bc4e144570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga571b235e2377a6cbf4272afb5c7b1d86"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga571b235e2377a6cbf4272afb5c7b1d86">DL_SYSCTL_disableFlashBankSwap</a> (void)</td></tr>
<tr class="memdesc:ga571b235e2377a6cbf4272afb5c7b1d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the policy to allow flash bank swapping.  <a href="#ga571b235e2377a6cbf4272afb5c7b1d86">More...</a><br /></td></tr>
<tr class="separator:ga571b235e2377a6cbf4272afb5c7b1d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41a8a9766d3a093f2fe159e2e303a869"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga41a8a9766d3a093f2fe159e2e303a869">DL_SYSCTL_executeFromUpperFlashBank</a> (void)</td></tr>
<tr class="memdesc:ga41a8a9766d3a093f2fe159e2e303a869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform bank swap and execute from the Upper Flash Bank.  <a href="#ga41a8a9766d3a093f2fe159e2e303a869">More...</a><br /></td></tr>
<tr class="separator:ga41a8a9766d3a093f2fe159e2e303a869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c85a96966b32d1958d5d2826343e395"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga5c85a96966b32d1958d5d2826343e395">DL_SYSCTL_executeFromLowerFlashBank</a> (void)</td></tr>
<tr class="memdesc:ga5c85a96966b32d1958d5d2826343e395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform bank swap and execute from the Lower Flash Bank.  <a href="#ga5c85a96966b32d1958d5d2826343e395">More...</a><br /></td></tr>
<tr class="separator:ga5c85a96966b32d1958d5d2826343e395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4011eeeeb356cbba8baaa538446519c"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gad4011eeeeb356cbba8baaa538446519c">DL_SYSCTL_enableReadExecuteProtectFirewall</a> (void)</td></tr>
<tr class="memdesc:gad4011eeeeb356cbba8baaa538446519c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable Read Execute (RX) Protect Firewall.  <a href="#gad4011eeeeb356cbba8baaa538446519c">More...</a><br /></td></tr>
<tr class="separator:gad4011eeeeb356cbba8baaa538446519c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65d27a7b90a1a15683f82c1cfa1776c7"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga65d27a7b90a1a15683f82c1cfa1776c7">DL_SYSCTL_enableIPProtectFirewall</a> (void)</td></tr>
<tr class="memdesc:ga65d27a7b90a1a15683f82c1cfa1776c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable IP Protect Firewall.  <a href="#ga65d27a7b90a1a15683f82c1cfa1776c7">More...</a><br /></td></tr>
<tr class="separator:ga65d27a7b90a1a15683f82c1cfa1776c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39c018eec70c3968558ac32300a69b0b"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga39c018eec70c3968558ac32300a69b0b">DL_SYSCTL_enableSRAMBoundaryLock</a> (void)</td></tr>
<tr class="memdesc:ga39c018eec70c3968558ac32300a69b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable SRAM Boundary Lock.  <a href="#ga39c018eec70c3968558ac32300a69b0b">More...</a><br /></td></tr>
<tr class="separator:ga39c018eec70c3968558ac32300a69b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae13f129230a2aa0792c4bb6b0b7bca5f"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gae13f129230a2aa0792c4bb6b0b7bca5f">DL_SYSCTL_isINITDONEIssued</a> (void)</td></tr>
<tr class="memdesc:gae13f129230a2aa0792c4bb6b0b7bca5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if INITDONE has been issued by the CSC.  <a href="#gae13f129230a2aa0792c4bb6b0b7bca5f">More...</a><br /></td></tr>
<tr class="separator:gae13f129230a2aa0792c4bb6b0b7bca5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b3fdfac4c06261311a6aa9cf842215a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga7b3fdfac4c06261311a6aa9cf842215a">DL_SYSCTL_ifCSCExists</a> (void)</td></tr>
<tr class="memdesc:ga7b3fdfac4c06261311a6aa9cf842215a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if Customer Startup Code (CSC) exists in system.  <a href="#ga7b3fdfac4c06261311a6aa9cf842215a">More...</a><br /></td></tr>
<tr class="separator:ga7b3fdfac4c06261311a6aa9cf842215a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga671e7e6af56965ed0b7235852e8c2f84"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga671e7e6af56965ed0b7235852e8c2f84">DL_SYSCTL_isReadExecuteProtectFirewallEnabled</a> (void)</td></tr>
<tr class="memdesc:ga671e7e6af56965ed0b7235852e8c2f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if Read Execute (RX) Protect Firewall is enabled.  <a href="#ga671e7e6af56965ed0b7235852e8c2f84">More...</a><br /></td></tr>
<tr class="separator:ga671e7e6af56965ed0b7235852e8c2f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a69123e3a00e6fabfab28115dc05d0e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga0a69123e3a00e6fabfab28115dc05d0e">DL_SYSCTL_isIPProtectFirewallEnabled</a> (void)</td></tr>
<tr class="memdesc:ga0a69123e3a00e6fabfab28115dc05d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if IP Protect Firewall is enabled.  <a href="#ga0a69123e3a00e6fabfab28115dc05d0e">More...</a><br /></td></tr>
<tr class="separator:ga0a69123e3a00e6fabfab28115dc05d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa8b0ce6cc91389e1a7d25ef48ab4db9"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaaa8b0ce6cc91389e1a7d25ef48ab4db9">DL_SYSCTL_isSRAMBoundaryLocked</a> (void)</td></tr>
<tr class="memdesc:gaaa8b0ce6cc91389e1a7d25ef48ab4db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if SRAM Boundary Lock is enabled.  <a href="#gaaa8b0ce6cc91389e1a7d25ef48ab4db9">More...</a><br /></td></tr>
<tr class="separator:gaaa8b0ce6cc91389e1a7d25ef48ab4db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b61e3a92f4be62b70cdb43e03866b19"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga3b61e3a92f4be62b70cdb43e03866b19">DL_SYSCTL_isFlashBankSwapEnabled</a> (void)</td></tr>
<tr class="memdesc:ga3b61e3a92f4be62b70cdb43e03866b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if Flash Bank swapping is enabled.  <a href="#ga3b61e3a92f4be62b70cdb43e03866b19">More...</a><br /></td></tr>
<tr class="separator:ga3b61e3a92f4be62b70cdb43e03866b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaf14ccfbcd9f94da7e6fd6c2602e290"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gafaf14ccfbcd9f94da7e6fd6c2602e290">DL_SYSCTL_isExecuteFromUpperFlashBank</a> (void)</td></tr>
<tr class="memdesc:gafaf14ccfbcd9f94da7e6fd6c2602e290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if executing from upper flash bank.  <a href="#gafaf14ccfbcd9f94da7e6fd6c2602e290">More...</a><br /></td></tr>
<tr class="separator:gafaf14ccfbcd9f94da7e6fd6c2602e290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9277fcfa0fe871174a7fbac755aa5d5"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gac9277fcfa0fe871174a7fbac755aa5d5">DL_SYSCTL_isExecuteFromLowerFlashBank</a> (void)</td></tr>
<tr class="memdesc:gac9277fcfa0fe871174a7fbac755aa5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if executing from lower flash bank.  <a href="#gac9277fcfa0fe871174a7fbac755aa5d5">More...</a><br /></td></tr>
<tr class="separator:gac9277fcfa0fe871174a7fbac755aa5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4146b44f3a171973a9e4e601756dc4f"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gac4146b44f3a171973a9e4e601756dc4f">DL_SYSCTL_issueINITDONE</a> (void)</td></tr>
<tr class="memdesc:gac4146b44f3a171973a9e4e601756dc4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate that INIT is done.  <a href="#gac4146b44f3a171973a9e4e601756dc4f">More...</a><br /></td></tr>
<tr class="separator:gac4146b44f3a171973a9e4e601756dc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4b18c2097c46a7239bff4729b5f926e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaf4b18c2097c46a7239bff4729b5f926e">DL_SYSCTL_enableSuperCapacitor</a> (void)</td></tr>
<tr class="memdesc:gaf4b18c2097c46a7239bff4729b5f926e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables super capacitor function.  <a href="#gaf4b18c2097c46a7239bff4729b5f926e">More...</a><br /></td></tr>
<tr class="separator:gaf4b18c2097c46a7239bff4729b5f926e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52ad1c1dc4bb33d1ad49e20f09ca7341"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga52ad1c1dc4bb33d1ad49e20f09ca7341">DL_SYSCTL_disableSuperCapacitor</a> (void)</td></tr>
<tr class="memdesc:ga52ad1c1dc4bb33d1ad49e20f09ca7341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables super capacitor function.  <a href="#ga52ad1c1dc4bb33d1ad49e20f09ca7341">More...</a><br /></td></tr>
<tr class="separator:ga52ad1c1dc4bb33d1ad49e20f09ca7341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9d509fefc4781f67086d9dac367fbb4"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaa9d509fefc4781f67086d9dac367fbb4">DL_SYSCTL_isSuperCapacitorEnabled</a> (void)</td></tr>
<tr class="memdesc:gaa9d509fefc4781f67086d9dac367fbb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if super capacitor function is enabled.  <a href="#gaa9d509fefc4781f67086d9dac367fbb4">More...</a><br /></td></tr>
<tr class="separator:gaa9d509fefc4781f67086d9dac367fbb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><a class="anchor" id="ti_dl_m0p_mspm0l122x_l222x_dl_sysctl_Overview"></a></p><h1>Overview</h1>
<p>The System Control (SysCtl) module enables control over system wide settings like clocks and power management.</p>
<hr/>
 <h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga4da4b81ab27057df56b8933baa88f495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4da4b81ab27057df56b8933baa88f495">&sect;&nbsp;</a></span>DL_SYSCTL_setMCLKSource</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DL_SYSCTL_setMCLKSource</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">current, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">next, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;DL_SYSCTL_switchMCLKfrom##current##to##next(__VA_ARGS__);</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change MCLK source. </p>
<p>To ensure good clocking behavior, these are the recommended steps for transition. Valid sources and destinations: LFCLK, SYSOSC, HSCLK</p>
<p>Depending on current MCLK source, steps to switch to next MCLK source can vary. This is a macro that redirects to the different possible transitions.</p>
<p>Only valid for RUN modes. In low power modes, MCLK transitions are handled by hardware.</p>
<dl class="section note"><dt>Note</dt><dd>Different transition APIs may require different input parameters Transitions between LFCLK and HSCLK requires going through SYSOSC.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gadd92a7a341922bbc907eab2d03e0c233" title="Change MCLK source from SYSOSC to LFCLK. ">DL_SYSCTL_switchMCLKfromSYSOSCtoLFCLK</a> </dd>
<dd>
<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga0da6dd4face824795caadc20aad63c3b" title="Change MCLK source from LFCLK to SYSOSC. ">DL_SYSCTL_switchMCLKfromLFCLKtoSYSOSC</a> </dd>
<dd>
<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga5f3c956c0b9432ffa85e6e6bcfce25fa" title="Change MCLK source from SYSOSC to HSCLK. ">DL_SYSCTL_switchMCLKfromSYSOSCtoHSCLK</a> </dd>
<dd>
<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga3cf7ee635c6302eaf96e1fb9e86acc1f" title="Change MCLK source from HSCLK to SYSOSC. ">DL_SYSCTL_switchMCLKfromHSCLKtoSYSOSC</a> </dd></dl>

<p>Referenced by <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gabb3e59122b0186605828738a46ddedb3">DL_SYSCTL_setPowerPolicyRUN0SLEEP0()</a>, <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaed73b665ecd6ea709c7ac5d73d22d6f8">DL_SYSCTL_setPowerPolicyRUN1SLEEP1()</a>, and <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaace70635f3ea92cae14c2f1df0c55633">DL_SYSCTL_setPowerPolicyRUN2SLEEP2()</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga11f6187e683dcf2a0892c4ca5a818156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11f6187e683dcf2a0892c4ca5a818156">&sect;&nbsp;</a></span>DL_SYSCTL_IIDX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga11f6187e683dcf2a0892c4ca5a818156">DL_SYSCTL_IIDX</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga11f6187e683dcf2a0892c4ca5a818156a2f3e40fca586aecb1441f01a6754528b"></a>DL_SYSCTL_IIDX_LFOSC_GOOD&#160;</td><td class="fielddoc"><p>Low Frequency Oscillator is stabilized and ready to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga11f6187e683dcf2a0892c4ca5a818156af66353af425d4fdab66d1b89d4d0080c"></a>DL_SYSCTL_IIDX_ANALOG_CLOCK_ERROR&#160;</td><td class="fielddoc"><p>Analog clocking consistency error. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga11f6187e683dcf2a0892c4ca5a818156ab9b42fe9e21276a511cfa8762c3b5521"></a>DL_SYSCTL_IIDX_FLASH_SEC&#160;</td><td class="fielddoc"><p>Flash Single Error Correct. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga11f6187e683dcf2a0892c4ca5a818156a1dbdd9ef94c4e5278f9a4c185eb964e2"></a>DL_SYSCTL_IIDX_SRAM_SEC&#160;</td><td class="fielddoc"><p>SRAM Single Error Correct. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga11f6187e683dcf2a0892c4ca5a818156aaed008cb41818421b22cf98b1eb987cd"></a>DL_SYSCTL_IIDX_LFXT_GOOD&#160;</td><td class="fielddoc"><p>Low Frequency Crystal is stabilized and ready to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga11f6187e683dcf2a0892c4ca5a818156ac0b2b14d77cbbdd7ae23701ca09e7cf4"></a>DL_SYSCTL_IIDX_HFCLK_GOOD&#160;</td><td class="fielddoc"><p>High Frequency Clock is stabilized and ready to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga11f6187e683dcf2a0892c4ca5a818156a78a5d4fb99a0d4398b0ee09f921f5c00"></a>DL_SYSCTL_IIDX_HSCLK_GOOD&#160;</td><td class="fielddoc"><p>High Speed Clock is stabilized and ready to use. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga6bcbb65890c723d59c075c19f49419e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bcbb65890c723d59c075c19f49419e6">&sect;&nbsp;</a></span>DL_SYSCTL_NMI_IIDX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga6bcbb65890c723d59c075c19f49419e6">DL_SYSCTL_NMI_IIDX</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga6bcbb65890c723d59c075c19f49419e6ae3180225fdb12c084461ea6c23b0a52d"></a>DL_SYSCTL_NMI_IIDX_VBAT_ON&#160;</td><td class="fielddoc"><p>NMI interrupt index for VBAT power on. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6bcbb65890c723d59c075c19f49419e6a9bb3e715d4a5a8ffaaf3bf04b6de6348"></a>DL_SYSCTL_NMI_IIDX_VBAT_OFF&#160;</td><td class="fielddoc"><p>NMI interrupt index for VBAT power off. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6bcbb65890c723d59c075c19f49419e6a8559633525839701876612217870e674"></a>DL_SYSCTL_NMI_IIDX_SRAM_DED&#160;</td><td class="fielddoc"><p>NMI interrupt index for SRAM Double Error Detect. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6bcbb65890c723d59c075c19f49419e6a1d7717f94056d2806267e23a56c49a0f"></a>DL_SYSCTL_NMI_IIDX_FLASH_DED&#160;</td><td class="fielddoc"><p>NMI interrupt index for Flash Double Error Detect. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6bcbb65890c723d59c075c19f49419e6a958ed4545b4335d9a35d046c2644b4a1"></a>DL_SYSCTL_NMI_IIDX_LFCLK_FAIL&#160;</td><td class="fielddoc"><p>NMI interrupt index for LFCLK Monitor Fail. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6bcbb65890c723d59c075c19f49419e6a32ad0925f1581a29af6b155572b0ae41"></a>DL_SYSCTL_NMI_IIDX_WWDT0_FAULT&#160;</td><td class="fielddoc"><p>NMI interrupt index for Watchdog 0 Fault. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6bcbb65890c723d59c075c19f49419e6adbbc9c64fa4723a7d96cb43234323cb1"></a>DL_SYSCTL_NMI_IIDX_BORLVL&#160;</td><td class="fielddoc"><p>NMI interrupt index for early BOR. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6bcbb65890c723d59c075c19f49419e6a477a9fed19f8834707ec78f8448d5768"></a>DL_SYSCTL_NMI_IIDX_NO_INT&#160;</td><td class="fielddoc"><p>NMI interrupt index for no interrupt pending. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga06e41abcd8e8c7519885e1a6f9f740e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06e41abcd8e8c7519885e1a6f9f740e7">&sect;&nbsp;</a></span>DL_SYSCTL_ERROR_BEHAVIOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga06e41abcd8e8c7519885e1a6f9f740e7">DL_SYSCTL_ERROR_BEHAVIOR</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga06e41abcd8e8c7519885e1a6f9f740e7abf6f1c4723ee80095714fd57cb4867f2"></a>DL_SYSCTL_ERROR_BEHAVIOR_RESET&#160;</td><td class="fielddoc"><p>The error event will trigger a SYSRST. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga06e41abcd8e8c7519885e1a6f9f740e7ac239a8ae4ef547487c103d3a78f39f57"></a>DL_SYSCTL_ERROR_BEHAVIOR_NMI&#160;</td><td class="fielddoc"><p>The error event will trigger an NMI. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga2d02be2892b083ae42dc5ec338f52e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d02be2892b083ae42dc5ec338f52e46">&sect;&nbsp;</a></span>DL_SYSCTL_SYSOSC_FREQ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga2d02be2892b083ae42dc5ec338f52e46">DL_SYSCTL_SYSOSC_FREQ</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga2d02be2892b083ae42dc5ec338f52e46a5ce32737edb72b88716f735b239eb057"></a>DL_SYSCTL_SYSOSC_FREQ_4M&#160;</td><td class="fielddoc"><p>Use 4MHz for System Oscillator (SYSOSC) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2d02be2892b083ae42dc5ec338f52e46a5c7a90ae7d414ed52626f9a29cdac113"></a>DL_SYSCTL_SYSOSC_FREQ_BASE&#160;</td><td class="fielddoc"><p>Use BASE (32MHz) for System Oscillator (SYSOSC) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2d02be2892b083ae42dc5ec338f52e46aff6715c44cbe87725711d1dbec4dba5f"></a>DL_SYSCTL_SYSOSC_FREQ_USERTRIM&#160;</td><td class="fielddoc"><p>User will trim the System Oscillator (SYSOSC) to 16MHz or 24MHz </p>
</td></tr>
</table>

</div>
</div>
<a id="ga3a8e0f66c60740baf11ae908341967b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a8e0f66c60740baf11ae908341967b1">&sect;&nbsp;</a></span>DL_SYSCTL_SYSOSC_USERTRIM_FREQ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga3a8e0f66c60740baf11ae908341967b1">DL_SYSCTL_SYSOSC_USERTRIM_FREQ</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga3a8e0f66c60740baf11ae908341967b1a61fcdf47be744018be9280d133a1a392"></a>DL_SYSCTL_SYSOSC_USERTRIM_FREQ_16M&#160;</td><td class="fielddoc"><p>Set SYSOSC user trim frequency target to 16MHz </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3a8e0f66c60740baf11ae908341967b1a95f7ac9d85d51942b44e8ce046649a08"></a>DL_SYSCTL_SYSOSC_USERTRIM_FREQ_24M&#160;</td><td class="fielddoc"><p>Set SYSOSC user trim frequency target to 24MHz </p>
</td></tr>
</table>

</div>
</div>
<a id="gada7eec2f3ea44a593a298c232fa8b98a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada7eec2f3ea44a593a298c232fa8b98a">&sect;&nbsp;</a></span>DL_SYSCTL_LFXT_DRIVE_STRENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gada7eec2f3ea44a593a298c232fa8b98a">DL_SYSCTL_LFXT_DRIVE_STRENGTH</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggada7eec2f3ea44a593a298c232fa8b98aa36f8ff9c3c74583f9175b7addc7242a9"></a>DL_SYSCTL_LFXT_DRIVE_STRENGTH_LOWEST&#160;</td><td class="fielddoc"><p>Lowest Drive and Current </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada7eec2f3ea44a593a298c232fa8b98aad9bcbac2b22642ae52255975beee3ac8"></a>DL_SYSCTL_LFXT_DRIVE_STRENGTH_LOWER&#160;</td><td class="fielddoc"><p>Lower Drive and Current </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada7eec2f3ea44a593a298c232fa8b98aabf6b3e301f9c103463d099e597c8098b"></a>DL_SYSCTL_LFXT_DRIVE_STRENGTH_HIGHER&#160;</td><td class="fielddoc"><p>Higher Drive and Current </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada7eec2f3ea44a593a298c232fa8b98aa997253e7d266796a5c2fe11ee353fafa"></a>DL_SYSCTL_LFXT_DRIVE_STRENGTH_HIGHEST&#160;</td><td class="fielddoc"><p>Highest Drive and Current </p>
</td></tr>
</table>

</div>
</div>
<a id="gae709a299b57e30a00d2b05c12eaba591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae709a299b57e30a00d2b05c12eaba591">&sect;&nbsp;</a></span>DL_SYSCTL_HFXT_RANGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gae709a299b57e30a00d2b05c12eaba591">DL_SYSCTL_HFXT_RANGE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae709a299b57e30a00d2b05c12eaba591a36054538d603ede5d5dc83971ec87e2d"></a>DL_SYSCTL_HFXT_RANGE_4_8_MHZ&#160;</td><td class="fielddoc"><p>HFXT frequency range between 4 and 8 MHz </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae709a299b57e30a00d2b05c12eaba591ace9a335a4287749c133fb992cb25b81b"></a>DL_SYSCTL_HFXT_RANGE_8_16_MHZ&#160;</td><td class="fielddoc"><p>HFXT frequency range between 8.01 and 16 MHz </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae709a299b57e30a00d2b05c12eaba591a5cca9d95913be9ddd9541c96b3224e01"></a>DL_SYSCTL_HFXT_RANGE_16_32_MHZ&#160;</td><td class="fielddoc"><p>HFXT frequency range between 16.01 and 32 MHz </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae709a299b57e30a00d2b05c12eaba591afeeff43614fe8e4bfae9346a9851e3ac"></a>DL_SYSCTL_HFXT_RANGE_32_48_MHZ&#160;</td><td class="fielddoc"><p>HFXT frequency range between 32.01 and 48 MHz </p>
</td></tr>
</table>

</div>
</div>
<a id="gadb318a4bb7a5bfb1555f660f63d32fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb318a4bb7a5bfb1555f660f63d32fbb">&sect;&nbsp;</a></span>DL_SYSCTL_HSCLK_SOURCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gadb318a4bb7a5bfb1555f660f63d32fbb">DL_SYSCTL_HSCLK_SOURCE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggadb318a4bb7a5bfb1555f660f63d32fbba8b263baa2fc4481f47a1f1a3ed7dd11c"></a>DL_SYSCTL_HSCLK_SOURCE_INVALID&#160;</td><td class="fielddoc"><p>Invalid source for HSCLK </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadb318a4bb7a5bfb1555f660f63d32fbba3dad0117e0b7effe624afd46cc3d9c8b"></a>DL_SYSCTL_HSCLK_SOURCE_HFCLK&#160;</td><td class="fielddoc"><p>Use HFLK as input source for HSCLK </p>
</td></tr>
</table>

</div>
</div>
<a id="ga644e04bc507e88dee66e3018d9dc1810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga644e04bc507e88dee66e3018d9dc1810">&sect;&nbsp;</a></span>DL_SYSCTL_MCLK_SOURCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga644e04bc507e88dee66e3018d9dc1810">DL_SYSCTL_MCLK_SOURCE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga644e04bc507e88dee66e3018d9dc1810a547a849ffccb2e4138f86a7fb43fa779"></a>DL_SYSCTL_MCLK_SOURCE_SYSOSC&#160;</td><td class="fielddoc"><p>Use System Oscillator (SYSOSC) as MCLK source (default after reset) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga644e04bc507e88dee66e3018d9dc1810ac0715b7a79355262910d55373c6c752c"></a>DL_SYSCTL_MCLK_SOURCE_HSCLK&#160;</td><td class="fielddoc"><p>Use High Speed Clock (HSCLK) as MCLK source (HFCLK, ...) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga644e04bc507e88dee66e3018d9dc1810af3668692deb5cff6da4b607c734a7179"></a>DL_SYSCTL_MCLK_SOURCE_LFCLK&#160;</td><td class="fielddoc"><p>Use the Low Frequency Clock (LFCLK) as the clock source </p>
</td></tr>
</table>

</div>
</div>
<a id="ga840c7f725afee13c0ba40fcad6ba5097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga840c7f725afee13c0ba40fcad6ba5097">&sect;&nbsp;</a></span>DL_SYSCTL_MCLK_DIVIDER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga840c7f725afee13c0ba40fcad6ba5097">DL_SYSCTL_MCLK_DIVIDER</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga840c7f725afee13c0ba40fcad6ba5097a476e7f20cd61f90f32dc8018f33abe3f"></a>DL_SYSCTL_MCLK_DIVIDER_DISABLE&#160;</td><td class="fielddoc"><p>Disable MCLK divider. Change SYSOSC freq only when MDIV is disabled </p>
</td></tr>
<tr><td class="fieldname"><a id="gga840c7f725afee13c0ba40fcad6ba5097a38afbe3d6f25b42913aeefaeccdfe5ac"></a>DL_SYSCTL_MCLK_DIVIDER_2&#160;</td><td class="fielddoc"><p>Divide MCLK frequency by 2 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga840c7f725afee13c0ba40fcad6ba5097a74057127e23a03bc65bc15c02ffa3f3f"></a>DL_SYSCTL_MCLK_DIVIDER_3&#160;</td><td class="fielddoc"><p>Divide MCLK frequency by 3 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga840c7f725afee13c0ba40fcad6ba5097a7bcedb58eab18dbdf416ecc07e610632"></a>DL_SYSCTL_MCLK_DIVIDER_4&#160;</td><td class="fielddoc"><p>Divide MCLK frequency by 4 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga840c7f725afee13c0ba40fcad6ba5097af84c79151c829826b168ca02003b5ec8"></a>DL_SYSCTL_MCLK_DIVIDER_5&#160;</td><td class="fielddoc"><p>Divide MCLK frequency by 5 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga840c7f725afee13c0ba40fcad6ba5097a2f5030f6b178e9e598960496520cdd24"></a>DL_SYSCTL_MCLK_DIVIDER_6&#160;</td><td class="fielddoc"><p>Divide MCLK frequency by 6 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga840c7f725afee13c0ba40fcad6ba5097a22dc0f7556cc142526fe25aebe152913"></a>DL_SYSCTL_MCLK_DIVIDER_7&#160;</td><td class="fielddoc"><p>Divide MCLK frequency by 7 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga840c7f725afee13c0ba40fcad6ba5097afc5274c5d7763951badb27da578b4c8a"></a>DL_SYSCTL_MCLK_DIVIDER_8&#160;</td><td class="fielddoc"><p>Divide MCLK frequency by 8 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga840c7f725afee13c0ba40fcad6ba5097a025bb95642eb7c6ae03fcfec87729d94"></a>DL_SYSCTL_MCLK_DIVIDER_9&#160;</td><td class="fielddoc"><p>Divide MCLK frequency by 9 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga840c7f725afee13c0ba40fcad6ba5097a6d9076f6a17fd95b86e0ee5f5cc3fd41"></a>DL_SYSCTL_MCLK_DIVIDER_10&#160;</td><td class="fielddoc"><p>Divide MCLK frequency by 10 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga840c7f725afee13c0ba40fcad6ba5097a99da84ff0c05c1b0fe5e17a1b0731947"></a>DL_SYSCTL_MCLK_DIVIDER_11&#160;</td><td class="fielddoc"><p>Divide MCLK frequency by 11 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga840c7f725afee13c0ba40fcad6ba5097ae9dd2c19d5dd16034effdec11b5ab75d"></a>DL_SYSCTL_MCLK_DIVIDER_12&#160;</td><td class="fielddoc"><p>Divide MCLK frequency by 12 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga840c7f725afee13c0ba40fcad6ba5097a37e1c980bc9f9519d44cdac785be61b7"></a>DL_SYSCTL_MCLK_DIVIDER_13&#160;</td><td class="fielddoc"><p>Divide MCLK frequency by 13 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga840c7f725afee13c0ba40fcad6ba5097af5e0ea1efa364c9a82735b929a6e8c72"></a>DL_SYSCTL_MCLK_DIVIDER_14&#160;</td><td class="fielddoc"><p>Divide MCLK frequency by 14 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga840c7f725afee13c0ba40fcad6ba5097aa5a72527e231f88148048288645d94ef"></a>DL_SYSCTL_MCLK_DIVIDER_15&#160;</td><td class="fielddoc"><p>Divide MCLK frequency by 15 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga840c7f725afee13c0ba40fcad6ba5097a7d38a9cb643c82faa3f335e040165ad7"></a>DL_SYSCTL_MCLK_DIVIDER_16&#160;</td><td class="fielddoc"><p>Divide MCLK frequency by 16 </p>
</td></tr>
</table>

</div>
</div>
<a id="ga4345c30b25b31b0a0baba36fbcedceed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4345c30b25b31b0a0baba36fbcedceed">&sect;&nbsp;</a></span>DL_SYSCTL_CLK_OUT_SOURCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga4345c30b25b31b0a0baba36fbcedceed">DL_SYSCTL_CLK_OUT_SOURCE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga4345c30b25b31b0a0baba36fbcedceeda1fffbdabf818fd0041d98f32fe3fc52b"></a>DL_SYSCTL_CLK_OUT_SOURCE_SYSOSC&#160;</td><td class="fielddoc"><p>Use System Oscillator (SYSOSC) as CLK_OUT source </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4345c30b25b31b0a0baba36fbcedceeda9f8fa6205533e732cbd3f5bfc654eba5"></a>DL_SYSCTL_CLK_OUT_SOURCE_ULPCLK&#160;</td><td class="fielddoc"><p>Use Ultra Low Power Clock (ULPCLK) as CLK_OUT source. <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga981fe3602bfb00a63911e2e14f82f1bfa3086dfe271764336af993ebeb14b836c">DL_SYSCTL_CLK_OUT_DIVIDE_DISABLE</a> must not be selected for this configuration. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4345c30b25b31b0a0baba36fbcedceeda09781e0480e8c64e74396c3023b6de8a"></a>DL_SYSCTL_CLK_OUT_SOURCE_LFCLK&#160;</td><td class="fielddoc"><p>Use Low Frequency Clock (LFCLK) as CLK_OUT source </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4345c30b25b31b0a0baba36fbcedceeda30c4c3ab4aa5edc4c76fd27af5cb7fdd"></a>DL_SYSCTL_CLK_OUT_SOURCE_MFPCLK&#160;</td><td class="fielddoc"><p>Use Middle Frequency Precision Clock (MFPCLK) as CLK_OUT source. <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga981fe3602bfb00a63911e2e14f82f1bfa3086dfe271764336af993ebeb14b836c">DL_SYSCTL_CLK_OUT_DIVIDE_DISABLE</a> must not be selected for this configuration. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4345c30b25b31b0a0baba36fbcedceeda26273c65d42b0053a83644b47cf8286d"></a>DL_SYSCTL_CLK_OUT_SOURCE_HFCLK&#160;</td><td class="fielddoc"><p>Use High Frequency Clock (HFCLK) as CLK_OUT source </p>
</td></tr>
</table>

</div>
</div>
<a id="ga981fe3602bfb00a63911e2e14f82f1bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga981fe3602bfb00a63911e2e14f82f1bf">&sect;&nbsp;</a></span>DL_SYSCTL_CLK_OUT_DIVIDE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga981fe3602bfb00a63911e2e14f82f1bf">DL_SYSCTL_CLK_OUT_DIVIDE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga981fe3602bfb00a63911e2e14f82f1bfa3086dfe271764336af993ebeb14b836c"></a>DL_SYSCTL_CLK_OUT_DIVIDE_DISABLE&#160;</td><td class="fielddoc"><p>Disable the External Clock (CLK_OUT) output divider </p>
</td></tr>
<tr><td class="fieldname"><a id="gga981fe3602bfb00a63911e2e14f82f1bfa2589380f318d6ed62657def569fc0c58"></a>DL_SYSCTL_CLK_OUT_DIVIDE_2&#160;</td><td class="fielddoc"><p>Divide External Clock (CLK_OUT) output by 2 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga981fe3602bfb00a63911e2e14f82f1bfa24ecabcea5db39cdf88f56a30d5af2c7"></a>DL_SYSCTL_CLK_OUT_DIVIDE_4&#160;</td><td class="fielddoc"><p>Divide External Clock (CLK_OUT) output by 4 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga981fe3602bfb00a63911e2e14f82f1bfa625f52ecc24152fef1359c982d7ff1d3"></a>DL_SYSCTL_CLK_OUT_DIVIDE_6&#160;</td><td class="fielddoc"><p>Divide External Clock (CLK_OUT) output by 6 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga981fe3602bfb00a63911e2e14f82f1bfaa267fc8dd6bedc181a2bf8588c0011ac"></a>DL_SYSCTL_CLK_OUT_DIVIDE_8&#160;</td><td class="fielddoc"><p>Divide External Clock (CLK_OUT) output by 8 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga981fe3602bfb00a63911e2e14f82f1bfa67c0c39ea30db5880322ab808faf5099"></a>DL_SYSCTL_CLK_OUT_DIVIDE_10&#160;</td><td class="fielddoc"><p>Divide External Clock (CLK_OUT) output by 10 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga981fe3602bfb00a63911e2e14f82f1bfadc7d4a76fbad91622ff14d2306b3e0f9"></a>DL_SYSCTL_CLK_OUT_DIVIDE_12&#160;</td><td class="fielddoc"><p>Divide External Clock (CLK_OUT) output by 12 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga981fe3602bfb00a63911e2e14f82f1bfaae2c556a83f23e30f70800292217cf35"></a>DL_SYSCTL_CLK_OUT_DIVIDE_14&#160;</td><td class="fielddoc"><p>Divide External Clock (CLK_OUT) output by 14 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga981fe3602bfb00a63911e2e14f82f1bfa66c6542f1561f72b09f36b28b4c76092"></a>DL_SYSCTL_CLK_OUT_DIVIDE_16&#160;</td><td class="fielddoc"><p>Divide External Clock (CLK_OUT) output by 16 </p>
</td></tr>
</table>

</div>
</div>
<a id="ga7015e4698d5924cb3f6b05f26e76f8ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7015e4698d5924cb3f6b05f26e76f8ef">&sect;&nbsp;</a></span>DL_SYSCTL_MFPCLK_SOURCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga7015e4698d5924cb3f6b05f26e76f8ef">DL_SYSCTL_MFPCLK_SOURCE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga7015e4698d5924cb3f6b05f26e76f8efa75c4e9a2bfb1c6ea5e1fcd8a49be9fcd"></a>DL_SYSCTL_MFPCLK_SOURCE_SYSOSC&#160;</td><td class="fielddoc"><p>Use System Oscillator (SYSOSC) as MFPCLK source </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7015e4698d5924cb3f6b05f26e76f8efaec4f54f78f9b8bbb9f3fbe1842e463ba"></a>DL_SYSCTL_MFPCLK_SOURCE_HFCLK&#160;</td><td class="fielddoc"><p>Use High Frequency Clock (HFCLK) as MFPCLK source </p>
</td></tr>
</table>

</div>
</div>
<a id="gaeec66a871ef0d069fc54f791abbfb84e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeec66a871ef0d069fc54f791abbfb84e">&sect;&nbsp;</a></span>DL_SYSCTL_HFCLK_MFPCLK_DIVIDER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaeec66a871ef0d069fc54f791abbfb84e">DL_SYSCTL_HFCLK_MFPCLK_DIVIDER</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaeec66a871ef0d069fc54f791abbfb84ea1f1d64d9e79109df1ff3e8c218ee64b5"></a>DL_SYSCTL_HFCLK_MFPCLK_DIVIDER_DISABLE&#160;</td><td class="fielddoc"><p>HFCLK is not divided before being used for MFPCLK </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeec66a871ef0d069fc54f791abbfb84ea2453b2b6c2225c99190d9e8e17baca14"></a>DL_SYSCTL_HFCLK_MFPCLK_DIVIDER_2&#160;</td><td class="fielddoc"><p>Divide HFCLK by 2 before being used for MFPCLK </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeec66a871ef0d069fc54f791abbfb84ea5ece7cc1305cc1d5fbdcdfff24cad83f"></a>DL_SYSCTL_HFCLK_MFPCLK_DIVIDER_3&#160;</td><td class="fielddoc"><p>Divide HFCLK by 3 before being used for MFPCLK </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeec66a871ef0d069fc54f791abbfb84ea6a0575d67fd7d62f7d558bb69b6ee2a4"></a>DL_SYSCTL_HFCLK_MFPCLK_DIVIDER_4&#160;</td><td class="fielddoc"><p>Divide HFCLK by 4 before being used for MFPCLK </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeec66a871ef0d069fc54f791abbfb84ea23016eec3ffe39dd0995daa6944a301e"></a>DL_SYSCTL_HFCLK_MFPCLK_DIVIDER_5&#160;</td><td class="fielddoc"><p>Divide HFCLK by 5 before being used for MFPCLK </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeec66a871ef0d069fc54f791abbfb84eaaeeb69c46d662ae0bb0d403dc3b9d551"></a>DL_SYSCTL_HFCLK_MFPCLK_DIVIDER_6&#160;</td><td class="fielddoc"><p>Divide HFCLK by 6 before being used for MFPCLK </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeec66a871ef0d069fc54f791abbfb84eac3e99a6893c96c06db4a6d1a06dd0c54"></a>DL_SYSCTL_HFCLK_MFPCLK_DIVIDER_7&#160;</td><td class="fielddoc"><p>Divide HFCLK by 7 before being used for MFPCLK </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeec66a871ef0d069fc54f791abbfb84ea80004c8f15ea2bff7b6a456103e99943"></a>DL_SYSCTL_HFCLK_MFPCLK_DIVIDER_8&#160;</td><td class="fielddoc"><p>Divide HFCLK by 8 before being used for MFPCLK </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeec66a871ef0d069fc54f791abbfb84ea85153914d4a12b6b850f122f063742b1"></a>DL_SYSCTL_HFCLK_MFPCLK_DIVIDER_9&#160;</td><td class="fielddoc"><p>Divide HFCLK by 9 before being used for MFPCLK </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeec66a871ef0d069fc54f791abbfb84ea9b1c1d0ea4813fe93bef28c5b9be299c"></a>DL_SYSCTL_HFCLK_MFPCLK_DIVIDER_10&#160;</td><td class="fielddoc"><p>Divide HFCLK by 10 before being used for MFPCLK </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeec66a871ef0d069fc54f791abbfb84ea1e6b3a0e4af3eba88723de06f8136d3a"></a>DL_SYSCTL_HFCLK_MFPCLK_DIVIDER_11&#160;</td><td class="fielddoc"><p>Divide HFCLK by 11 before being used for MFPCLK </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeec66a871ef0d069fc54f791abbfb84ea14dc4cd67dca322ffc7a1241a8e468f9"></a>DL_SYSCTL_HFCLK_MFPCLK_DIVIDER_12&#160;</td><td class="fielddoc"><p>Divide HFCLK by 12 before being used for MFPCLK </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeec66a871ef0d069fc54f791abbfb84ea64a0d83501759e4e20bbf268e6efebc1"></a>DL_SYSCTL_HFCLK_MFPCLK_DIVIDER_13&#160;</td><td class="fielddoc"><p>Divide HFCLK by 13 before being used for MFPCLK </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeec66a871ef0d069fc54f791abbfb84ea09d96122efd5130e9003b73c7f5f50dc"></a>DL_SYSCTL_HFCLK_MFPCLK_DIVIDER_14&#160;</td><td class="fielddoc"><p>Divide HFCLK by 14 before being used for MFPCLK </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeec66a871ef0d069fc54f791abbfb84eaf1b96e7769a5e065baf560347462000d"></a>DL_SYSCTL_HFCLK_MFPCLK_DIVIDER_15&#160;</td><td class="fielddoc"><p>Divide HFCLK by 15 before being used for MFPCLK </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeec66a871ef0d069fc54f791abbfb84eae9e32cd906b34c5359ae03b64eee2cf1"></a>DL_SYSCTL_HFCLK_MFPCLK_DIVIDER_16&#160;</td><td class="fielddoc"><p>Divide HFCLK by 16 before being used for MFPCLK </p>
</td></tr>
</table>

</div>
</div>
<a id="gade1fd3f998053938225af73b519f695d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade1fd3f998053938225af73b519f695d">&sect;&nbsp;</a></span>DL_SYSCTL_FCC_TRIG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gade1fd3f998053938225af73b519f695d">DL_SYSCTL_FCC_TRIG_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggade1fd3f998053938225af73b519f695dac0c3ec1156a639be149fd425d7c2f30b"></a>DL_SYSCTL_FCC_TRIG_TYPE_RISE_RISE&#160;</td><td class="fielddoc"><p>FCC trigger is rising-edge to rising-edge pulse </p>
</td></tr>
<tr><td class="fieldname"><a id="ggade1fd3f998053938225af73b519f695da8b28715409d6ba8c85324a66c47f6685"></a>DL_SYSCTL_FCC_TRIG_TYPE_LEVEL&#160;</td><td class="fielddoc"><p>FCC trigger is active-high pulse level </p>
</td></tr>
</table>

</div>
</div>
<a id="gad56cf7d1f7fe634c4575f18669403887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad56cf7d1f7fe634c4575f18669403887">&sect;&nbsp;</a></span>DL_SYSCTL_FCC_TRIG_SOURCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gad56cf7d1f7fe634c4575f18669403887">DL_SYSCTL_FCC_TRIG_SOURCE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad56cf7d1f7fe634c4575f18669403887a90120d214d281e5834c91fcc2246c65f"></a>DL_SYSCTL_FCC_TRIG_SOURCE_FCC_IN&#160;</td><td class="fielddoc"><p>FCC trigger source is FCC_IN external pin </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad56cf7d1f7fe634c4575f18669403887a77cd1f55d7e84392a22d6bc0d61cfa5a"></a>DL_SYSCTL_FCC_TRIG_SOURCE_LFCLK&#160;</td><td class="fielddoc"><p>FCC trigger source is LFCLK </p>
</td></tr>
</table>

</div>
</div>
<a id="ga088842c40b39b18edd2e81f898deea08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga088842c40b39b18edd2e81f898deea08">&sect;&nbsp;</a></span>DL_SYSCTL_FCC_CLOCK_SOURCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga088842c40b39b18edd2e81f898deea08">DL_SYSCTL_FCC_CLOCK_SOURCE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga088842c40b39b18edd2e81f898deea08a087da1902cb25949e87f2b7a7b4d54a7"></a>DL_SYSCTL_FCC_CLOCK_SOURCE_MCLK&#160;</td><td class="fielddoc"><p>FCC clock source to capture is MCLK </p>
</td></tr>
<tr><td class="fieldname"><a id="gga088842c40b39b18edd2e81f898deea08a9f4b0f224b1406f7b41575a70bfc100d"></a>DL_SYSCTL_FCC_CLOCK_SOURCE_SYSOSC&#160;</td><td class="fielddoc"><p>FCC clock source to capture is SYSOSC </p>
</td></tr>
<tr><td class="fieldname"><a id="gga088842c40b39b18edd2e81f898deea08a2e2bc7b7dc2d1eca4ce33b05d6443f17"></a>DL_SYSCTL_FCC_CLOCK_SOURCE_HFCLK&#160;</td><td class="fielddoc"><p>FCC clock source to capture is HFCLK </p>
</td></tr>
<tr><td class="fieldname"><a id="gga088842c40b39b18edd2e81f898deea08af755622422e205de38e72a739b244954"></a>DL_SYSCTL_FCC_CLOCK_SOURCE_CLK_OUT&#160;</td><td class="fielddoc"><p>FCC clock source to capture is CLK_OUT </p>
</td></tr>
<tr><td class="fieldname"><a id="gga088842c40b39b18edd2e81f898deea08a0eaba1358f46f9bc711bf1a6aedb3e63"></a>DL_SYSCTL_FCC_CLOCK_SOURCE_FCC_IN&#160;</td><td class="fielddoc"><p>FCC clock source to capture is FCC_IN </p>
</td></tr>
</table>

</div>
</div>
<a id="ga919e05d2b9725602984a9ae8bee98b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga919e05d2b9725602984a9ae8bee98b09">&sect;&nbsp;</a></span>DL_SYSCTL_FCC_TRIG_CNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga919e05d2b9725602984a9ae8bee98b09">DL_SYSCTL_FCC_TRIG_CNT</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga919e05d2b9725602984a9ae8bee98b09afc04c9a99adeaafb43085c483e24a2d9"></a>DL_SYSCTL_FCC_TRIG_CNT_01&#160;</td><td class="fielddoc"><p>One monitoring period </p>
</td></tr>
<tr><td class="fieldname"><a id="gga919e05d2b9725602984a9ae8bee98b09acf11c755cfdb171c0a549ae981ce1bdb"></a>DL_SYSCTL_FCC_TRIG_CNT_02&#160;</td><td class="fielddoc"><p>Two monitoring period </p>
</td></tr>
<tr><td class="fieldname"><a id="gga919e05d2b9725602984a9ae8bee98b09a747964ac94db3f2f6b4638fcc8335c19"></a>DL_SYSCTL_FCC_TRIG_CNT_03&#160;</td><td class="fielddoc"><p>Three monitoring period </p>
</td></tr>
<tr><td class="fieldname"><a id="gga919e05d2b9725602984a9ae8bee98b09a0449cd8177ddb8e48d4dd60da5b89218"></a>DL_SYSCTL_FCC_TRIG_CNT_04&#160;</td><td class="fielddoc"><p>Four monitoring period </p>
</td></tr>
<tr><td class="fieldname"><a id="gga919e05d2b9725602984a9ae8bee98b09a94a32f9aa11c8768b8848e98624c9065"></a>DL_SYSCTL_FCC_TRIG_CNT_05&#160;</td><td class="fielddoc"><p>Five monitoring period </p>
</td></tr>
<tr><td class="fieldname"><a id="gga919e05d2b9725602984a9ae8bee98b09a07e7dad1eaf504cc8f2a7265e1b1d1cf"></a>DL_SYSCTL_FCC_TRIG_CNT_06&#160;</td><td class="fielddoc"><p>Six monitoring period </p>
</td></tr>
<tr><td class="fieldname"><a id="gga919e05d2b9725602984a9ae8bee98b09a1b0632698c6fe5e44789fd581ec387be"></a>DL_SYSCTL_FCC_TRIG_CNT_07&#160;</td><td class="fielddoc"><p>Seven monitoring period </p>
</td></tr>
<tr><td class="fieldname"><a id="gga919e05d2b9725602984a9ae8bee98b09a5a0303b71f399093433eb2b134b15038"></a>DL_SYSCTL_FCC_TRIG_CNT_08&#160;</td><td class="fielddoc"><p>Eight monitoring period </p>
</td></tr>
<tr><td class="fieldname"><a id="gga919e05d2b9725602984a9ae8bee98b09afea4ff6b427b3dd939ca068e27241cbb"></a>DL_SYSCTL_FCC_TRIG_CNT_09&#160;</td><td class="fielddoc"><p>Nine monitoring period </p>
</td></tr>
<tr><td class="fieldname"><a id="gga919e05d2b9725602984a9ae8bee98b09a3214c76b86f82d23e43bbe71f8835f35"></a>DL_SYSCTL_FCC_TRIG_CNT_10&#160;</td><td class="fielddoc"><p>Ten monitoring period </p>
</td></tr>
<tr><td class="fieldname"><a id="gga919e05d2b9725602984a9ae8bee98b09a62ca09dc4687e54d16f47e67e8ec540b"></a>DL_SYSCTL_FCC_TRIG_CNT_11&#160;</td><td class="fielddoc"><p>Eleven monitoring period </p>
</td></tr>
<tr><td class="fieldname"><a id="gga919e05d2b9725602984a9ae8bee98b09a5a29bfa5c08b110d2643b389b4a6f3a0"></a>DL_SYSCTL_FCC_TRIG_CNT_12&#160;</td><td class="fielddoc"><p>Twelve monitoring period </p>
</td></tr>
<tr><td class="fieldname"><a id="gga919e05d2b9725602984a9ae8bee98b09a2fb872a52fb5659a0cc35220fe7cf313"></a>DL_SYSCTL_FCC_TRIG_CNT_13&#160;</td><td class="fielddoc"><p>Thirteen monitoring period </p>
</td></tr>
<tr><td class="fieldname"><a id="gga919e05d2b9725602984a9ae8bee98b09a6064a9292349077943cb45b4e954770e"></a>DL_SYSCTL_FCC_TRIG_CNT_14&#160;</td><td class="fielddoc"><p>Fourteen monitoring period </p>
</td></tr>
<tr><td class="fieldname"><a id="gga919e05d2b9725602984a9ae8bee98b09a6e3d20f31b809c8cb383d259e3623da5"></a>DL_SYSCTL_FCC_TRIG_CNT_15&#160;</td><td class="fielddoc"><p>Fifteen monitoring period </p>
</td></tr>
<tr><td class="fieldname"><a id="gga919e05d2b9725602984a9ae8bee98b09a255ced9fca1030b33cca4411a444c22b"></a>DL_SYSCTL_FCC_TRIG_CNT_16&#160;</td><td class="fielddoc"><p>Sixteen monitoring period </p>
</td></tr>
<tr><td class="fieldname"><a id="gga919e05d2b9725602984a9ae8bee98b09ad5b98f12f98f7e8d92311de426f75c1e"></a>DL_SYSCTL_FCC_TRIG_CNT_17&#160;</td><td class="fielddoc"><p>Seventeen monitoring period </p>
</td></tr>
<tr><td class="fieldname"><a id="gga919e05d2b9725602984a9ae8bee98b09a024d1b04db029d13e2e073a125aaf4df"></a>DL_SYSCTL_FCC_TRIG_CNT_18&#160;</td><td class="fielddoc"><p>Eighteen monitoring period </p>
</td></tr>
<tr><td class="fieldname"><a id="gga919e05d2b9725602984a9ae8bee98b09a4710b170551cadb9ce90ea9b09a3d22d"></a>DL_SYSCTL_FCC_TRIG_CNT_19&#160;</td><td class="fielddoc"><p>Nineteen monitoring period </p>
</td></tr>
<tr><td class="fieldname"><a id="gga919e05d2b9725602984a9ae8bee98b09a4c8ecde7efad5a46b611806d27e77697"></a>DL_SYSCTL_FCC_TRIG_CNT_20&#160;</td><td class="fielddoc"><p>Twenty monitoring period </p>
</td></tr>
<tr><td class="fieldname"><a id="gga919e05d2b9725602984a9ae8bee98b09a89013024ab99ed3a83d384fe6cf48db9"></a>DL_SYSCTL_FCC_TRIG_CNT_21&#160;</td><td class="fielddoc"><p>Twenty-one monitoring period </p>
</td></tr>
<tr><td class="fieldname"><a id="gga919e05d2b9725602984a9ae8bee98b09a71d55dcd1e2613b586ff145f8e68071d"></a>DL_SYSCTL_FCC_TRIG_CNT_22&#160;</td><td class="fielddoc"><p>Twenty-two monitoring period </p>
</td></tr>
<tr><td class="fieldname"><a id="gga919e05d2b9725602984a9ae8bee98b09a07a7278a546826b56389397ffe7039dc"></a>DL_SYSCTL_FCC_TRIG_CNT_23&#160;</td><td class="fielddoc"><p>Twenty-three monitoring period </p>
</td></tr>
<tr><td class="fieldname"><a id="gga919e05d2b9725602984a9ae8bee98b09a70620e75d5d7984fa508aa9c0bdcc0e8"></a>DL_SYSCTL_FCC_TRIG_CNT_24&#160;</td><td class="fielddoc"><p>Twenty-four monitoring period </p>
</td></tr>
<tr><td class="fieldname"><a id="gga919e05d2b9725602984a9ae8bee98b09aa8ee0f6224cb116e86e55efd0df39ead"></a>DL_SYSCTL_FCC_TRIG_CNT_25&#160;</td><td class="fielddoc"><p>Twenty-five monitoring period </p>
</td></tr>
<tr><td class="fieldname"><a id="gga919e05d2b9725602984a9ae8bee98b09acd20c2d85a6014a170ebdfdb96bad800"></a>DL_SYSCTL_FCC_TRIG_CNT_26&#160;</td><td class="fielddoc"><p>Twenty-six monitoring period </p>
</td></tr>
<tr><td class="fieldname"><a id="gga919e05d2b9725602984a9ae8bee98b09a1d1e5ce3bb9f2d832db7e14431ec789d"></a>DL_SYSCTL_FCC_TRIG_CNT_27&#160;</td><td class="fielddoc"><p>Twenty-seven monitoring period </p>
</td></tr>
<tr><td class="fieldname"><a id="gga919e05d2b9725602984a9ae8bee98b09a50dde3cfab1d68874c2c7cea8fc6ad11"></a>DL_SYSCTL_FCC_TRIG_CNT_28&#160;</td><td class="fielddoc"><p>Twenty-eight monitoring period </p>
</td></tr>
<tr><td class="fieldname"><a id="gga919e05d2b9725602984a9ae8bee98b09aef0ac4baa864fd78d72062a04311b263"></a>DL_SYSCTL_FCC_TRIG_CNT_29&#160;</td><td class="fielddoc"><p>Twenty-nine monitoring period </p>
</td></tr>
<tr><td class="fieldname"><a id="gga919e05d2b9725602984a9ae8bee98b09a4b710d07bcc6a3aeafa44e64ba803014"></a>DL_SYSCTL_FCC_TRIG_CNT_30&#160;</td><td class="fielddoc"><p>Thirty monitoring period </p>
</td></tr>
<tr><td class="fieldname"><a id="gga919e05d2b9725602984a9ae8bee98b09a97089d26eaaf5afb4109e4e3adcb369e"></a>DL_SYSCTL_FCC_TRIG_CNT_31&#160;</td><td class="fielddoc"><p>Thirty-one monitoring period </p>
</td></tr>
<tr><td class="fieldname"><a id="gga919e05d2b9725602984a9ae8bee98b09ad98278a742e6480a46bb9f71fdcfa652"></a>DL_SYSCTL_FCC_TRIG_CNT_32&#160;</td><td class="fielddoc"><p>Thirty-two monitoring period </p>
</td></tr>
</table>

</div>
</div>
<a id="ga4bac12ff08dc5a074df489d69ae0cc80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bac12ff08dc5a074df489d69ae0cc80">&sect;&nbsp;</a></span>DL_SYSCTL_VBOOST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga4bac12ff08dc5a074df489d69ae0cc80">DL_SYSCTL_VBOOST</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga4bac12ff08dc5a074df489d69ae0cc80a8db68ccb4dea061b752afab3f2528dad"></a>DL_SYSCTL_VBOOST_ONDEMAND&#160;</td><td class="fielddoc"><p>VBOOST enabled only when COMP/OPA/GPAMP is enabled </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4bac12ff08dc5a074df489d69ae0cc80a8e47ea05e82c8a4ccc77375247def200"></a>DL_SYSCTL_VBOOST_ONACTIVE&#160;</td><td class="fielddoc"><p>VBOOST enabled in RUN/SLEEP, and in STOP/STANDBY if COMP/OPA/GPAMP is enabled </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4bac12ff08dc5a074df489d69ae0cc80a0ba4dab7f64a61b42589e9e8192c7937"></a>DL_SYSCTL_VBOOST_ONALWAYS&#160;</td><td class="fielddoc"><p>VBOOST enabled in all power modes except SHUTDOWN for fastest startup </p>
</td></tr>
</table>

</div>
</div>
<a id="ga7b893ce5af5fab09fed655808c393c92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b893ce5af5fab09fed655808c393c92">&sect;&nbsp;</a></span>DL_SYSCTL_FLASH_WAIT_STATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga7b893ce5af5fab09fed655808c393c92">DL_SYSCTL_FLASH_WAIT_STATE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga7b893ce5af5fab09fed655808c393c92a73abfef9528fab56cc8b883391180e1f"></a>DL_SYSCTL_FLASH_WAIT_STATE_0&#160;</td><td class="fielddoc"><p>0 flash wait states </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7b893ce5af5fab09fed655808c393c92a926e37211580037e0551db02d876c3d4"></a>DL_SYSCTL_FLASH_WAIT_STATE_1&#160;</td><td class="fielddoc"><p>1 flash wait states </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7b893ce5af5fab09fed655808c393c92acbabe7fb6483992feb1a70374bd40b37"></a>DL_SYSCTL_FLASH_WAIT_STATE_2&#160;</td><td class="fielddoc"><p>2 flash wait states </p>
</td></tr>
</table>

</div>
</div>
<a id="ga18ce5da5d89d2c8b34c490167e3bcbff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18ce5da5d89d2c8b34c490167e3bcbff">&sect;&nbsp;</a></span>DL_SYSCTL_POWER_POLICY_RUN_SLEEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga18ce5da5d89d2c8b34c490167e3bcbff">DL_SYSCTL_POWER_POLICY_RUN_SLEEP</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga18ce5da5d89d2c8b34c490167e3bcbffab7397c00fbb8bf006d66c64391691a6d"></a>DL_SYSCTL_POWER_POLICY_RUN_SLEEP_NOT_ENABLED&#160;</td><td class="fielddoc"><p>RUN/SLEEP power policy is not enabled </p>
</td></tr>
<tr><td class="fieldname"><a id="gga18ce5da5d89d2c8b34c490167e3bcbffa5cea3f2f437e48f960bf813c92e7f675"></a>DL_SYSCTL_POWER_POLICY_RUN_SLEEP0&#160;</td><td class="fielddoc"><p>Enable RUN0/SLEEP0 power mode policy. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga18ce5da5d89d2c8b34c490167e3bcbffa67eae8887adf0cf5b8bacebb75f6ef53"></a>DL_SYSCTL_POWER_POLICY_RUN_SLEEP1&#160;</td><td class="fielddoc"><p>Enable the RUN1/SLEEP1 power mode policy </p>
</td></tr>
<tr><td class="fieldname"><a id="gga18ce5da5d89d2c8b34c490167e3bcbffafd5407e76420f253130219eedc2c9202"></a>DL_SYSCTL_POWER_POLICY_RUN_SLEEP2&#160;</td><td class="fielddoc"><p>Enable the RUN2/SLEEP2 power mode policy </p>
</td></tr>
</table>

</div>
</div>
<a id="gaea2b0481ee57f8c16678f03d8b459012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea2b0481ee57f8c16678f03d8b459012">&sect;&nbsp;</a></span>DL_SYSCTL_POWER_POLICY_STOP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaea2b0481ee57f8c16678f03d8b459012">DL_SYSCTL_POWER_POLICY_STOP</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaea2b0481ee57f8c16678f03d8b459012a7176ffee58e3f5d64ac4008409c71133"></a>DL_SYSCTL_POWER_POLICY_STOP_NOT_ENABLED&#160;</td><td class="fielddoc"><p>STOP power policy is not enabled </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaea2b0481ee57f8c16678f03d8b459012a4dcdb65add63fb93223e2f43c1cd23c1"></a>DL_SYSCTL_POWER_POLICY_STOP0&#160;</td><td class="fielddoc"><p>Enable the STOP0 power mode policy </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaea2b0481ee57f8c16678f03d8b459012a7d156e0a6a2a5f4a2df8cfe7091306d4"></a>DL_SYSCTL_POWER_POLICY_STOP1&#160;</td><td class="fielddoc"><p>Enable the STOP1 power mode policy </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaea2b0481ee57f8c16678f03d8b459012a1da57d6c2a0bc45d592cf031824a2b18"></a>DL_SYSCTL_POWER_POLICY_STOP2&#160;</td><td class="fielddoc"><p>Enable the STOP2 power mode policy </p>
</td></tr>
</table>

</div>
</div>
<a id="gaf84ef067c088e88595332daf7d0611b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf84ef067c088e88595332daf7d0611b4">&sect;&nbsp;</a></span>DL_SYSCTL_POWER_POLICY_STANDBY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaf84ef067c088e88595332daf7d0611b4">DL_SYSCTL_POWER_POLICY_STANDBY</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf84ef067c088e88595332daf7d0611b4a23d10cc44f9dd16749d7b4bc4d7fd238"></a>DL_SYSCTL_POWER_POLICY_STANDBY_NOT_ENABLED&#160;</td><td class="fielddoc"><p>STANDBY power policy is not enabled </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf84ef067c088e88595332daf7d0611b4af01e24ef571759ddb35606a11f855c68"></a>DL_SYSCTL_POWER_POLICY_STANDBY0&#160;</td><td class="fielddoc"><p>Enable the STANDBY0 power mode policy </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf84ef067c088e88595332daf7d0611b4a88400aa474b64a342c6872b4c2365269"></a>DL_SYSCTL_POWER_POLICY_STANDBY1&#160;</td><td class="fielddoc"><p>Enable the STANDBY1 power mode policy </p>
</td></tr>
</table>

</div>
</div>
<a id="gab31acca537d5af4a0710888c9fcb6be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab31acca537d5af4a0710888c9fcb6be8">&sect;&nbsp;</a></span>DL_SYSCTL_BOR_THRESHOLD_LEVEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gab31acca537d5af4a0710888c9fcb6be8">DL_SYSCTL_BOR_THRESHOLD_LEVEL</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab31acca537d5af4a0710888c9fcb6be8a0e8afb986eaf313b904b37a561f0f936"></a>DL_SYSCTL_BOR_THRESHOLD_LEVEL_0&#160;</td><td class="fielddoc"><p>BOR0 threshold level. This is the minimum allowed threshold. A BOR0- violation will force a re-boot. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab31acca537d5af4a0710888c9fcb6be8a000529e00d369928e99b2af14a81341d"></a>DL_SYSCTL_BOR_THRESHOLD_LEVEL_1&#160;</td><td class="fielddoc"><p>BOR1 threshold level. A BOR1- violation generates an interrupt </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab31acca537d5af4a0710888c9fcb6be8a5f4c15d42beafe6fef957c646211fe75"></a>DL_SYSCTL_BOR_THRESHOLD_LEVEL_2&#160;</td><td class="fielddoc"><p>BOR2 threshold level. A BOR2- violation generates an interrupt </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab31acca537d5af4a0710888c9fcb6be8a76000141ff342ac44d376a6c731b7658"></a>DL_SYSCTL_BOR_THRESHOLD_LEVEL_3&#160;</td><td class="fielddoc"><p>BOR3 threshold level. A BOR3- violation generates an interrupt </p>
</td></tr>
</table>

</div>
</div>
<a id="gac4ba3ae564f39aac9884ee95b1a4bf50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4ba3ae564f39aac9884ee95b1a4bf50">&sect;&nbsp;</a></span>DL_SYSCTL_SHUTDOWN_STORAGE_BYTE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gac4ba3ae564f39aac9884ee95b1a4bf50">DL_SYSCTL_SHUTDOWN_STORAGE_BYTE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac4ba3ae564f39aac9884ee95b1a4bf50a9a839986e475201a3bec706242dec6f6"></a>DL_SYSCTL_SHUTDOWN_STORAGE_BYTE_0&#160;</td><td class="fielddoc"><p>Shutdown Storage Byte 0 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac4ba3ae564f39aac9884ee95b1a4bf50a99f38145140a68566d04475967fe7e37"></a>DL_SYSCTL_SHUTDOWN_STORAGE_BYTE_1&#160;</td><td class="fielddoc"><p>Shutdown Storage Byte 1 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac4ba3ae564f39aac9884ee95b1a4bf50a37c833ae47434f9ff95123be14adad11"></a>DL_SYSCTL_SHUTDOWN_STORAGE_BYTE_2&#160;</td><td class="fielddoc"><p>Shutdown Storage Byte 2 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac4ba3ae564f39aac9884ee95b1a4bf50a2c2bb4e1944f593d12cc74c627dcffc5"></a>DL_SYSCTL_SHUTDOWN_STORAGE_BYTE_3&#160;</td><td class="fielddoc"><p>Shutdown Storage Byte 3 </p>
</td></tr>
</table>

</div>
</div>
<a id="ga72bea3c6a78a3a5c0d389ac78cacce74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72bea3c6a78a3a5c0d389ac78cacce74">&sect;&nbsp;</a></span>DL_SYSCTL_RESET_CAUSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga72bea3c6a78a3a5c0d389ac78cacce74">DL_SYSCTL_RESET_CAUSE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga72bea3c6a78a3a5c0d389ac78cacce74aa31c5345c5fd11432afb02136df91b47"></a>DL_SYSCTL_RESET_CAUSE_NO_RESET&#160;</td><td class="fielddoc"><p>No Reset Since Last Read </p>
</td></tr>
<tr><td class="fieldname"><a id="gga72bea3c6a78a3a5c0d389ac78cacce74aba0ecbc9a1288478f17ce17cab230e4c"></a>DL_SYSCTL_RESET_CAUSE_POR_HW_FAILURE&#160;</td><td class="fielddoc"><p>(VDD &lt; POR- violation) or (PMU trim parity fault) or (SHUTDNSTOREx parity fault) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga72bea3c6a78a3a5c0d389ac78cacce74a8225b982b575931daa13a7cc3534a51b"></a>DL_SYSCTL_RESET_CAUSE_POR_EXTERNAL_NRST&#160;</td><td class="fielddoc"><p>NRST pin reset (&gt;1s) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga72bea3c6a78a3a5c0d389ac78cacce74af3b77e3f7038b268bfe8ae8fad0f8af4"></a>DL_SYSCTL_RESET_CAUSE_POR_SW_TRIGGERED&#160;</td><td class="fielddoc"><p>Software-triggered POR </p>
</td></tr>
<tr><td class="fieldname"><a id="gga72bea3c6a78a3a5c0d389ac78cacce74ad6352674f8bd0b35b683f727574876cd"></a>DL_SYSCTL_RESET_CAUSE_BOR_SUPPLY_FAILURE&#160;</td><td class="fielddoc"><p>VDD &lt; BOR- violation </p>
</td></tr>
<tr><td class="fieldname"><a id="gga72bea3c6a78a3a5c0d389ac78cacce74a51c8d78a172fb933581c44d9480b8162"></a>DL_SYSCTL_RESET_CAUSE_BOR_WAKE_FROM_SHUTDOWN&#160;</td><td class="fielddoc"><p>Wake from SHUTDOWN </p>
</td></tr>
<tr><td class="fieldname"><a id="gga72bea3c6a78a3a5c0d389ac78cacce74a8f41dee0474459a4d83ed6dad79265f6"></a>DL_SYSCTL_RESET_CAUSE_BOOTRST_NON_PMU_PARITY_FAULT&#160;</td><td class="fielddoc"><p>Non-PMU trim parity fault </p>
</td></tr>
<tr><td class="fieldname"><a id="gga72bea3c6a78a3a5c0d389ac78cacce74a9bfeada7e2e2f6f2cdb4b07749d0793a"></a>DL_SYSCTL_RESET_CAUSE_BOOTRST_CLOCK_FAULT&#160;</td><td class="fielddoc"><p>Fatal clock fault </p>
</td></tr>
<tr><td class="fieldname"><a id="gga72bea3c6a78a3a5c0d389ac78cacce74ae47babed21c67032bb5914713703a54c"></a>DL_SYSCTL_RESET_CAUSE_BOOTRST_SW_TRIGGERED&#160;</td><td class="fielddoc"><p>Software-triggered BOOTRST </p>
</td></tr>
<tr><td class="fieldname"><a id="gga72bea3c6a78a3a5c0d389ac78cacce74a32f13a84287cb475a3ece1325d4a7e6a"></a>DL_SYSCTL_RESET_CAUSE_BOOTRST_EXTERNAL_NRST&#160;</td><td class="fielddoc"><p>NRST pin reset (&lt;1s) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga72bea3c6a78a3a5c0d389ac78cacce74a35a4d8706bc7db707d77a0aa45181348"></a>DL_SYSCTL_RESET_CAUSE_SYSRST_BSL_EXIT&#160;</td><td class="fielddoc"><p>BSL exit </p>
</td></tr>
<tr><td class="fieldname"><a id="gga72bea3c6a78a3a5c0d389ac78cacce74a9813d61a110213e9d9d9aacf1dddfd07"></a>DL_SYSCTL_RESET_CAUSE_SYSRST_BSL_ENTRY&#160;</td><td class="fielddoc"><p>BSL entry </p>
</td></tr>
<tr><td class="fieldname"><a id="gga72bea3c6a78a3a5c0d389ac78cacce74a6d68291dbc3d2ef9b008e4167b36ea56"></a>DL_SYSCTL_RESET_CAUSE_SYSRST_WWDT0_VIOLATION&#160;</td><td class="fielddoc"><p>WWDT0 violation </p>
</td></tr>
<tr><td class="fieldname"><a id="gga72bea3c6a78a3a5c0d389ac78cacce74a675864d237067e66f6817c30e55992a9"></a>DL_SYSCTL_RESET_CAUSE_SYSRST_WWDT1_VIOLATION&#160;</td><td class="fielddoc"><p>WWDT1 violation </p>
</td></tr>
<tr><td class="fieldname"><a id="gga72bea3c6a78a3a5c0d389ac78cacce74ad301368ad5c66087c12b93c990010ad4"></a>DL_SYSCTL_RESET_CAUSE_SYSRST_FLASH_ECC_ERROR&#160;</td><td class="fielddoc"><p>Uncorrectable flash ECC error </p>
</td></tr>
<tr><td class="fieldname"><a id="gga72bea3c6a78a3a5c0d389ac78cacce74ae135df8b36832289fbc3fdcaebbcbcf9"></a>DL_SYSCTL_RESET_CAUSE_SYSRST_CPU_LOCKUP_VIOLATION&#160;</td><td class="fielddoc"><p>CPULOCK violation </p>
</td></tr>
<tr><td class="fieldname"><a id="gga72bea3c6a78a3a5c0d389ac78cacce74a11f7d4e0dc57e771b1f550e2329db5c3"></a>DL_SYSCTL_RESET_CAUSE_SYSRST_DEBUG_TRIGGERED&#160;</td><td class="fielddoc"><p>Debug-triggered SYSRST </p>
</td></tr>
<tr><td class="fieldname"><a id="gga72bea3c6a78a3a5c0d389ac78cacce74a6c0bcede4d3dc76c1cd48147f204a6ab"></a>DL_SYSCTL_RESET_CAUSE_SYSRST_SW_TRIGGERED&#160;</td><td class="fielddoc"><p>Software-triggered SYSRST </p>
</td></tr>
<tr><td class="fieldname"><a id="gga72bea3c6a78a3a5c0d389ac78cacce74a4a5597716638e00d9f67cd34d178ffcc"></a>DL_SYSCTL_RESET_CAUSE_CPURST_DEBUG_TRIGGERED&#160;</td><td class="fielddoc"><p>Debug-triggered CPURST </p>
</td></tr>
<tr><td class="fieldname"><a id="gga72bea3c6a78a3a5c0d389ac78cacce74a046f56eeb9a823bdb58d22f5006518bd"></a>DL_SYSCTL_RESET_CAUSE_CPURST_SW_TRIGGERED&#160;</td><td class="fielddoc"><p>Software-triggered CPURST </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf9e752083d5fdc113ea0f41e3986d21e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9e752083d5fdc113ea0f41e3986d21e">&sect;&nbsp;</a></span>DL_SYSCTL_enableSleepOnExit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_enableSleepOnExit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable sleep on exit. </p>
<p>Enables sleep on exit when the CPU moves from handler mode to thread mode. By enabling, allows an interrupt driven application to avoid returning to an empty main application. </p>

</div>
</div>
<a id="ga79bcb1f2d3bc41df3c4ad440c24bb184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79bcb1f2d3bc41df3c4ad440c24bb184">&sect;&nbsp;</a></span>DL_SYSCTL_disableSleepOnExit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_disableSleepOnExit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable sleep on exit. </p>
<p>Disables sleep on exit when the CPU moves from handler mode to thread mode. </p>

</div>
</div>
<a id="ga832b40751fd398154265ed5dfb60e2db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga832b40751fd398154265ed5dfb60e2db">&sect;&nbsp;</a></span>DL_SYSCTL_enableEventOnPend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_enableEventOnPend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable send event on pending bit. </p>
<p>When enabled, any enabled event and all interrupts (including disabled interrupts) can wakeup the processor. </p>

</div>
</div>
<a id="ga659b9a76ea959eb05e5d1a1d50b797ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga659b9a76ea959eb05e5d1a1d50b797ff">&sect;&nbsp;</a></span>DL_SYSCTL_disableEventOnPend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_disableEventOnPend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable send event on pending bit. </p>
<p>When disabled, only enabled interrupts or events can wake up the processor. Disabled interrupts are excluded. </p>

</div>
</div>
<a id="gaaa56d230c1cfc401cda33d204bdc9a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa56d230c1cfc401cda33d204bdc9a65">&sect;&nbsp;</a></span>DL_SYSCTL_isEventOnPendEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_SYSCTL_isEventOnPendEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if send event on pending bit is enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the enabled status of the send event on pending bit</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Send event on pending bit is enabled </td></tr>
    <tr><td class="paramname">false</td><td>Send event on pending bit is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadd92a7a341922bbc907eab2d03e0c233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd92a7a341922bbc907eab2d03e0c233">&sect;&nbsp;</a></span>DL_SYSCTL_switchMCLKfromSYSOSCtoLFCLK()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_SYSCTL_switchMCLKfromSYSOSCtoLFCLK </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>disableSYSOSC</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change MCLK source from SYSOSC to LFCLK. </p>
<dl class="section pre"><dt>Precondition</dt><dd>If disabling SYSOSC, high speed oscillators (HFXT,...) must be disabled beforehand. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>MCLK source is switched to LFCLK, function will busy-wait until confirmed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">disableSYSOSC</td><td>Whether to leave SYSOSC running or not </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0da6dd4face824795caadc20aad63c3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0da6dd4face824795caadc20aad63c3b">&sect;&nbsp;</a></span>DL_SYSCTL_switchMCLKfromLFCLKtoSYSOSC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_SYSCTL_switchMCLKfromLFCLKtoSYSOSC </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change MCLK source from LFCLK to SYSOSC. </p>
<dl class="section post"><dt>Postcondition</dt><dd>MCLK source is switched to SYSOSC, function will busy-wait until confirmed. </dd></dl>

</div>
</div>
<a id="ga5f3c956c0b9432ffa85e6e6bcfce25fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f3c956c0b9432ffa85e6e6bcfce25fa">&sect;&nbsp;</a></span>DL_SYSCTL_switchMCLKfromSYSOSCtoHSCLK()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_SYSCTL_switchMCLKfromSYSOSCtoHSCLK </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gadb318a4bb7a5bfb1555f660f63d32fbb">DL_SYSCTL_HSCLK_SOURCE</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change MCLK source from SYSOSC to HSCLK. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The desired HSCLK source is enabled beforehand (HFXT, HFCLK_IN). </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>MCLK source is switched to HSCLK, function will busy-wait until confirmed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>Desired high-speed clock source </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3cf7ee635c6302eaf96e1fb9e86acc1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cf7ee635c6302eaf96e1fb9e86acc1f">&sect;&nbsp;</a></span>DL_SYSCTL_switchMCLKfromHSCLKtoSYSOSC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_SYSCTL_switchMCLKfromHSCLKtoSYSOSC </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change MCLK source from HSCLK to SYSOSC. </p>
<dl class="section pre"><dt>Precondition</dt><dd>MCLK is sourced from a valid, running HSCLK source (HFXT, HFCLK_IN) </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>MCLK source is switched to SYSOSC, function will busy-wait until confirmed.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>No HSCLK sources are disabled by this function </dd></dl>

</div>
</div>
<a id="gabb3e59122b0186605828738a46ddedb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb3e59122b0186605828738a46ddedb3">&sect;&nbsp;</a></span>DL_SYSCTL_setPowerPolicyRUN0SLEEP0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_setPowerPolicyRUN0SLEEP0 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the RUN/SLEEP mode power policy to RUN0/SLEEP0. </p>
<p>In RUN0, the MCLK and the CPUCLK run from a fast clock source (SYSOSC, or HFCLK).</p>
<p>Setting the RUN power policy will also set the SLEEP power policy. The SLEEP mode behavior is always identical to RUN mode, just with the CPUCLK disabled. As such, the SLEEP behavior is determined by the configuration of the RUN mode. To actually enter SLEEP mode, you must call <code>__WFI()</code> to wait for interrupts or <code>__WFE()</code> to wait for ARM events. <code>__WFI()</code> is used in interrupt-driven applications, and <code>__WFE()</code> is used for interactions between the interrupt handler and main application.</p>
<p>There are three RUN/SLEEP mode policy options: RUN0/SLEEP0, RUN1/SLEEP1, and RUN2/SLEEP2. Refer to the device TRM for more information on each policy</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga4da4b81ab27057df56b8933baa88f495" title="Change MCLK source. ">DL_SYSCTL_setMCLKSource</a> </dd></dl>

<p>References <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga4da4b81ab27057df56b8933baa88f495">DL_SYSCTL_setMCLKSource</a>.</p>

</div>
</div>
<a id="gaed73b665ecd6ea709c7ac5d73d22d6f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed73b665ecd6ea709c7ac5d73d22d6f8">&sect;&nbsp;</a></span>DL_SYSCTL_setPowerPolicyRUN1SLEEP1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_setPowerPolicyRUN1SLEEP1 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the RUN/SLEEP mode power policy to RUN1/SLEEP1. </p>
<p>In RUN1, the MCLK and the CPUCLK run from LFCLK (at 32kHz) to reduce active power, but SYSOSC is left enabled to service analog modules such as an ADC, DAC, OPA, or COMP (in HS mode).</p>
<p>Setting the RUN power policy will also set the SLEEP power policy. The SLEEP mode behavior is always identical to RUN mode, just with the CPUCLK disabled. As such, the SLEEP behavior is determined by the configuration of the RUN mode. To actually enter SLEEP mode, you must call <code>__WFI()</code> to wait for interrupts or <code>__WFE()</code> to wait for ARM events. <code>__WFI()</code> is used in interrupt-driven applications, and <code>__WFE()</code> is used for interactions between the interrupt handler and main application.</p>
<p>There are three RUN/SLEEP mode policy options: RUN0/SLEEP0, RUN1/SLEEP1, and RUN2/SLEEP2. Refer to the device TRM for more information on each policy</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga4da4b81ab27057df56b8933baa88f495" title="Change MCLK source. ">DL_SYSCTL_setMCLKSource</a> </dd></dl>

<p>References <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga4da4b81ab27057df56b8933baa88f495">DL_SYSCTL_setMCLKSource</a>.</p>

</div>
</div>
<a id="gaace70635f3ea92cae14c2f1df0c55633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaace70635f3ea92cae14c2f1df0c55633">&sect;&nbsp;</a></span>DL_SYSCTL_setPowerPolicyRUN2SLEEP2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_setPowerPolicyRUN2SLEEP2 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the RUN/SLEEP mode power policy to RUN2/SLEEP2. </p>
<p>In RUN2, the MCLK and the CPUCLK run from LFCLK (at 32kHz), and SYSOSC is completely disabled to save power. This is the lowest power state with the CPU running</p>
<p>Setting the RUN power policy will also set the SLEEP power policy. The SLEEP mode behavior is always identical to RUN mode, just with the CPUCLK disabled. As such, the SLEEP behavior is determined by the configuration of the RUN mode. To actually enter SLEEP mode, you must call <code>__WFI()</code> to wait for interrupts or <code>__WFE()</code> to wait for ARM events. <code>__WFI()</code> is used in interrupt-driven applications, and <code>__WFE()</code> is used for interactions between the interrupt handler and main application.</p>
<p>There are three RUN/SLEEP mode policy options: RUN0/SLEEP0, RUN1/SLEEP1, and RUN2/SLEEP2. Refer to the device TRM for more information on each policy</p>
<dl class="section note"><dt>Note</dt><dd>Since this turns off SYSOSC, HSCLK sources MUST be disabled before calling</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga4da4b81ab27057df56b8933baa88f495" title="Change MCLK source. ">DL_SYSCTL_setMCLKSource</a> </dd></dl>

<p>References <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gad01310dac26cd98b8978fc6459b44074">DL_SYSCTL_getPowerPolicyRUNSLEEP()</a>, and <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga4da4b81ab27057df56b8933baa88f495">DL_SYSCTL_setMCLKSource</a>.</p>

</div>
</div>
<a id="gad01310dac26cd98b8978fc6459b44074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad01310dac26cd98b8978fc6459b44074">&sect;&nbsp;</a></span>DL_SYSCTL_getPowerPolicyRUNSLEEP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga18ce5da5d89d2c8b34c490167e3bcbff">DL_SYSCTL_POWER_POLICY_RUN_SLEEP</a> DL_SYSCTL_getPowerPolicyRUNSLEEP </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the RUN/SLEEP mode power policy. </p>
<p>Get which RUN/SLEEP power policy has been set.</p>
<p>The SLEEP mode behavior is always identical to RUN mode, just with the CPUCLK disabled. As such, the SLEEP behavior is determined by the configuration of the RUN mode.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the current RUN/SLEEP mode power policy</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga18ce5da5d89d2c8b34c490167e3bcbff">DL_SYSCTL_POWER_POLICY_RUN_SLEEP</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaace70635f3ea92cae14c2f1df0c55633">DL_SYSCTL_setPowerPolicyRUN2SLEEP2()</a>.</p>

</div>
</div>
<a id="ga7d3118b7857c9909a6aa831c961190b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d3118b7857c9909a6aa831c961190b0">&sect;&nbsp;</a></span>DL_SYSCTL_setPowerPolicySTOP0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_setPowerPolicySTOP0 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the STOP mode power policy to STOP0. </p>
<p>In STOP0, the SYSOSC is left running at the current frequency when entering STOP mode (either 32MHz, 24MHz, 16MHz, or 4MHz). ULPCLK is always limited to 4MHz automatically by hardware, but SYSOSC is not disturbed to support consistent operation of analog peripherals such as the ADC, OPA, or COMP.</p>
<p>There are three STOP mode policy options: STOP0, STOP1, and STOP2. Refer to the device TRM for more information on each policy.</p>
<dl class="section post"><dt>Postcondition</dt><dd>This API does not actually enter STOP mode. After using this API to set the power policy, to enter STOP mode you must call <code>__WFI()</code> to wait for interrupts or <code>__WFE()</code> to wait for ARM events. <code>__WFI()</code> is used in interrupt-driven applications, and <code>__WFE()</code> is used for interactions between the interrupt handler and main application. </dd></dl>

</div>
</div>
<a id="ga68f967ab5833ec9020aa2f3a6929c0dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68f967ab5833ec9020aa2f3a6929c0dd">&sect;&nbsp;</a></span>DL_SYSCTL_setPowerPolicySTOP1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_setPowerPolicySTOP1 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the STOP mode power policy to STOP1. </p>
<p>In STOP1, the SYSOSC is gear shifted from its current frequency to 4MHz for the lowest power consumption in STOP mode with SYSOSC running. SYSOSC and ULPCLK both run at 4MHz.</p>
<p>There are three STOP mode policy options: STOP0, STOP1, and STOP2. Refer to the device TRM for more information on each policy.</p>
<dl class="section post"><dt>Postcondition</dt><dd>This API does not actually enter STOP mode. After using this API to set the power policy, to enter STOP mode you must call <code>__WFI()</code> to wait for interrupts or <code>__WFE()</code> to wait for ARM events. <code>__WFI()</code> is used in interrupt-driven applications, and <code>__WFE()</code> is used for interactions between the interrupt handler and main application. </dd></dl>

</div>
</div>
<a id="ga959701e9c1c7f9ec6847994ad02f33da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga959701e9c1c7f9ec6847994ad02f33da">&sect;&nbsp;</a></span>DL_SYSCTL_setPowerPolicySTOP2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_setPowerPolicySTOP2 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the STOP mode power policy to STOP2. </p>
<p>In STOP2, the SYSOSC is disabled and the ULPCLK is sourced from LFCLK at 32kHz. This is the lowest power state in STOP mode.</p>
<p>There are three STOP mode policy options: STOP0, STOP1, and STOP2. Refer to the device TRM for more information on each policy.</p>
<dl class="section post"><dt>Postcondition</dt><dd>This API does not actually enter STOP mode. After using this API to set the power policy, to enter STOP mode you must call <code>__WFI()</code> to wait for interrupts or <code>__WFE()</code> to wait for ARM events. <code>__WFI()</code> is used in interrupt-driven applications, and <code>__WFE()</code> is used for interactions between the interrupt handler and main application. </dd></dl>

<p>References <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaf40c9a9621190c006e48f4e2885b6be3">DL_SYSCTL_getPowerPolicySTOP()</a>.</p>

</div>
</div>
<a id="gaf40c9a9621190c006e48f4e2885b6be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf40c9a9621190c006e48f4e2885b6be3">&sect;&nbsp;</a></span>DL_SYSCTL_getPowerPolicySTOP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaea2b0481ee57f8c16678f03d8b459012">DL_SYSCTL_POWER_POLICY_STOP</a> DL_SYSCTL_getPowerPolicySTOP </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the STOP mode power policy. </p>
<p>Get which STOP power policy has been set.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the current STOP mode power policy</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaea2b0481ee57f8c16678f03d8b459012">DL_SYSCTL_POWER_POLICY_STOP</a> if a STOP power policy </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga959701e9c1c7f9ec6847994ad02f33da">DL_SYSCTL_setPowerPolicySTOP2()</a>.</p>

</div>
</div>
<a id="ga0a9723385f17fa55edb70dfd007cb098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a9723385f17fa55edb70dfd007cb098">&sect;&nbsp;</a></span>DL_SYSCTL_setPowerPolicySTANDBY0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_setPowerPolicySTANDBY0 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the STANDBY mode power policy to STANDBY0. </p>
<p>In STANDBY0, all PD0 peripherals receive the ULPCLK and LFCLK, and the RTC receives RTCCLK.</p>
<p>There are two STANDBY mode policy options: STANDBY0 and STANDBY1.</p>
<dl class="section post"><dt>Postcondition</dt><dd>This API does not actually enter STANDBY mode. After using this API to set the power policy, to enter STANDBY mode you must call <code>__WFI()</code> to wait for interrupts or <code>__WFE()</code> to wait for ARM events. <code>__WFI()</code> is used in interrupt-driven applications, and <code>__WFE()</code> is used for interactions between the interrupt handler and main application. </dd></dl>

</div>
</div>
<a id="ga597aa8110c977218350edb231bd60255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga597aa8110c977218350edb231bd60255">&sect;&nbsp;</a></span>DL_SYSCTL_setPowerPolicySTANDBY1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_setPowerPolicySTANDBY1 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the STANDBY mode power policy to STANDBY1. </p>
<p>In STANDBY1, only TIMG0 and TIMG1 receive ULPCLK/LFCLK. The RTC continues to receive RTCCLK. A TIMG0/1 interrupt, RTC interrupt, or ADC trigger in STANDBY1 always triggers an asynchronous fast clock request to wake the system. Other PD0 peripherals (such as UART, I2C, GPIO, and COMP) can also wake the system upon an external event through an asynchronous fast clock request, but they are not actively clocked in STANDBY1.</p>
<p>There are two STANDBY mode policy options: STANDBY0 and STANDBY1.</p>
<dl class="section post"><dt>Postcondition</dt><dd>This API does not actually enter STANDBY mode. After using this API to set the power policy, to enter STANDBY mode you must call <code>__WFI()</code> to wait for interrupts or <code>__WFE()</code> to wait for ARM events. <code>__WFI()</code> is used in interrupt-driven applications, and <code>__WFE()</code> is used for interactions between the interrupt handler and main application. </dd></dl>

<p>References <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga164be7dcbe5dd57187d8c6d86aebe902">DL_SYSCTL_getPowerPolicySTANDBY()</a>.</p>

</div>
</div>
<a id="ga164be7dcbe5dd57187d8c6d86aebe902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga164be7dcbe5dd57187d8c6d86aebe902">&sect;&nbsp;</a></span>DL_SYSCTL_getPowerPolicySTANDBY()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaf84ef067c088e88595332daf7d0611b4">DL_SYSCTL_POWER_POLICY_STANDBY</a> DL_SYSCTL_getPowerPolicySTANDBY </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the STANDBY mode power policy. </p>
<p>Get which STANDBY power policy has been set.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the current STANDBY mode power policy</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaf84ef067c088e88595332daf7d0611b4">DL_SYSCTL_POWER_POLICY_STANDBY</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga597aa8110c977218350edb231bd60255">DL_SYSCTL_setPowerPolicySTANDBY1()</a>.</p>

</div>
</div>
<a id="ga06040876cc0d4e00b7ca0d4179aed61d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06040876cc0d4e00b7ca0d4179aed61d">&sect;&nbsp;</a></span>DL_SYSCTL_setPowerPolicySHUTDOWN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_setPowerPolicySHUTDOWN </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set power policy to SHUTDOWN mode. </p>
<p>In SHUTDOWN mode, no clocks are available. The core regulator is completely disabled and all SRAM and register contents are lost, with the exception of the 4 bytes of general purpose memory in SYSCTL which may be used to store state information. The BOR and bandgap circuit are disabled. The device may wake up via a wake-up capable IO, a debug connection, or NRST. SHUTDOWN mode has the lowest current consumption of any operating mode. Exiting SHUTDOWN mode triggers a BOR.</p>
<p>There is only one SHUTDOWN mode policy option: SHUTDOWN.</p>
<dl class="section post"><dt>Postcondition</dt><dd>This API does not actually enter SHUTDOWN mode. After using this API to enable SHUTDOWN mode, to enter SHUTDOWN mode you must call <code>__WFI()</code> to wait for interrupts or <code>__WFE()</code> to wait for ARM events. <code>__WFI()</code> is used in interrupt-driven applications, and <code>__WFE()</code> is used for interactions between the interrupt handler and main application. </dd></dl>

</div>
</div>
<a id="gac7f269eeb1d06cba787e84b19a55d3a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7f269eeb1d06cba787e84b19a55d3a9">&sect;&nbsp;</a></span>DL_SYSCTL_setBORThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_setBORThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gab31acca537d5af4a0710888c9fcb6be8">DL_SYSCTL_BOR_THRESHOLD_LEVEL</a>&#160;</td>
          <td class="paramname"><em>thresholdLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the brown-out reset (BOR) threshold level. </p>
<p>Note that this API does NOT activate the BOR threshold. After setting the threshold level with this API, call <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga58632451ef9a852ee2390880849c5bb9">DL_SYSCTL_activateBORThreshold</a> to actually activate the new threshold.</p>
<p>During startup, the BOR threshold defaults to BOR0 (the lowet value) to ensure the device always starts at the specified VDD minimum. After boot, the BOR threshold level can be configured to a different level. When the BOR threshold is BOR0, a BOR0- violation always generates a BOR- violation signal to SYSCTL, generating a BOR level reset. When the BOR threshold is re-configured to BOR1, BOR2, or BOR3 the BOR circuit will generate a SYSCTL interrupt rather than asserting a BOR- violation. This may be used to give the application an indication that the supply has dropped below a certain level without causing a reset. If the BOR is in interrupt mode (threshold level of BOR1-3), and VDD drops below the respective BORx- level, an interrupt will be generated and the BOR circuit will automatically switch the BOR threshold level to BOR0 to ensure that a BOR- violation is asserted if VDD drops below BOR0-.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thresholdLevel</td><td>The BOR threshold level to set. One of <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gab31acca537d5af4a0710888c9fcb6be8">DL_SYSCTL_BOR_THRESHOLD_LEVEL</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>DL_SYSCTL_activateBORThreshold </dd></dl>

</div>
</div>
<a id="gade6cc0ae8994808608697159762f0e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade6cc0ae8994808608697159762f0e1a">&sect;&nbsp;</a></span>DL_SYSCTL_getBORThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gab31acca537d5af4a0710888c9fcb6be8">DL_SYSCTL_BOR_THRESHOLD_LEVEL</a> DL_SYSCTL_getBORThreshold </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the brown-out reset (BOR) threshold level. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the current BOR threshold level.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gab31acca537d5af4a0710888c9fcb6be8">DL_SYSCTL_BOR_THRESHOLD_LEVEL</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga58632451ef9a852ee2390880849c5bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58632451ef9a852ee2390880849c5bb9">&sect;&nbsp;</a></span>DL_SYSCTL_activateBORThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_activateBORThreshold </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Activate the BOR threshold level. </p>
<p>Attempts to change the active BOR mode to the BOR threshold that was set via <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gac7f269eeb1d06cba787e84b19a55d3a9">DL_SYSCTL_setBORThreshold</a>.</p>
<p>Setting this bit also clears any prior BOR violation status indications.</p>
<p>After calling this API, the change can be validated by calling <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga0c56e55435135b41670c72c9311116c1">DL_SYSCTL_getStatus</a> and checking the return value.</p>
<dl class="section pre"><dt>Precondition</dt><dd>DL_SYSCTL_setBORThreshold </dd></dl>

</div>
</div>
<a id="gaba4ac323b5111764c4648811d21a672a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba4ac323b5111764c4648811d21a672a">&sect;&nbsp;</a></span>DL_SYSCTL_resetDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_resetDevice </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>resetType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the device. </p>
<p>Resets the device using the type of reset selected. This function does not return, the reset will happen immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">resetType</td><td>Type of reset to perform. One of <a class="el" href="group___d_l___s_y_s_c_t_l___r_e_s_e_t.html">DL_SYSCTL_RESET</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabd2bea2fc1b092320d43e1151c5aad54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd2bea2fc1b092320d43e1151c5aad54">&sect;&nbsp;</a></span>DL_SYSCTL_enableInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_enableInterrupt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable SYSCTL interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptMask</td><td>Bit mask of interrupts to enable. Bitwise OR of <a class="el" href="group___d_l___s_y_s_c_t_l___i_n_t_e_r_r_u_p_t.html">DL_SYSCTL_INTERRUPT</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga647ad30eff4e2c48ed86cbfffa418f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga647ad30eff4e2c48ed86cbfffa418f40">&sect;&nbsp;</a></span>DL_SYSCTL_disableInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_disableInterrupt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable SYSCTL interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptMask</td><td>Bit mask of interrupts to enable. Bitwise OR of <a class="el" href="group___d_l___s_y_s_c_t_l___i_n_t_e_r_r_u_p_t.html">DL_SYSCTL_INTERRUPT</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae2511982eda39b33b67f1950b724b138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2511982eda39b33b67f1950b724b138">&sect;&nbsp;</a></span>DL_SYSCTL_getEnabledInterrupts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_SYSCTL_getEnabledInterrupts </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check which SYSCTL interrupts are enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptMask</td><td>Bit mask of interrupts to check. Bitwise OR of <a class="el" href="group___d_l___s_y_s_c_t_l___i_n_t_e_r_r_u_p_t.html">DL_SYSCTL_INTERRUPT</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Which of the requested SYSCTL interrupts are enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Bitwise</td><td>OR of <a class="el" href="group___d_l___s_y_s_c_t_l___i_n_t_e_r_r_u_p_t.html">DL_SYSCTL_INTERRUPT</a> values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7df488a265f542a75d4864637f5be9f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7df488a265f542a75d4864637f5be9f0">&sect;&nbsp;</a></span>DL_SYSCTL_getEnabledInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_SYSCTL_getEnabledInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check interrupt flag of enabled SYSCTL interrupts. </p>
<p>Checks if any of the SYSCTL interrupts that were previously enabled are pending.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptMask</td><td>Bit mask of interrupts to check. Bitwise OR of <a class="el" href="group___d_l___s_y_s_c_t_l___i_n_t_e_r_r_u_p_t.html">DL_SYSCTL_INTERRUPT</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Which of the requested SYSCTL interrupts are pending</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Bitwise</td><td>OR of <a class="el" href="group___d_l___s_y_s_c_t_l___i_n_t_e_r_r_u_p_t.html">DL_SYSCTL_INTERRUPT</a> values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gabd2bea2fc1b092320d43e1151c5aad54" title="Enable SYSCTL interrupts. ">DL_SYSCTL_enableInterrupt</a> </dd></dl>

</div>
</div>
<a id="ga435916056d795f4b8aa8a2e10e5699ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga435916056d795f4b8aa8a2e10e5699ba">&sect;&nbsp;</a></span>DL_SYSCTL_getRawInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_SYSCTL_getRawInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check interrupt flag of any SYSCTL interrupt. </p>
<p>Checks if any of the SYSCTL interrupts are pending. Interrupts do not have to be previously enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptMask</td><td>Bit mask of interrupts to check. Bitwise OR of <a class="el" href="group___d_l___s_y_s_c_t_l___i_n_t_e_r_r_u_p_t.html">DL_SYSCTL_INTERRUPT</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Which of the requested SYSCTL interrupts are pending</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Bitwise</td><td>OR of <a class="el" href="group___d_l___s_y_s_c_t_l___i_n_t_e_r_r_u_p_t.html">DL_SYSCTL_INTERRUPT</a> values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga44cc4bb4792e909f761fdd8e460ca38a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44cc4bb4792e909f761fdd8e460ca38a">&sect;&nbsp;</a></span>DL_SYSCTL_getPendingInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga11f6187e683dcf2a0892c4ca5a818156">DL_SYSCTL_IIDX</a> DL_SYSCTL_getPendingInterrupt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get highest priority pending SYSCTL interrupt. </p>
<p>Checks if any of the SYSCTL interrupts are pending. Interrupts do not have to be previously enabled.</p>
<dl class="section return"><dt>Returns</dt><dd>The highest priority pending SYSCTL interrupt</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga11f6187e683dcf2a0892c4ca5a818156">DL_SYSCTL_IIDX</a> values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9d1cdccf9e4494a8eeee66ade782664b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d1cdccf9e4494a8eeee66ade782664b">&sect;&nbsp;</a></span>DL_SYSCTL_clearInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_clearInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear pending SYSCTL interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptMask</td><td>Bit mask of interrupts to clear. Bitwise OR of <a class="el" href="group___d_l___s_y_s_c_t_l___i_n_t_e_r_r_u_p_t.html">DL_SYSCTL_INTERRUPT</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8a00ecf8f2acc672901f6ec6bd0d1267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a00ecf8f2acc672901f6ec6bd0d1267">&sect;&nbsp;</a></span>DL_SYSCTL_getRawNonMaskableInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_SYSCTL_getRawNonMaskableInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check interrupt flag of any SYSCTL non-maskable interrupt. </p>
<p>Checks if any of the SYSCTL non-maskable interrupts are pending. Interrupts do not have to be previously enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptMask</td><td>Bit mask of interrupts to check. Bitwise OR of <a class="el" href="group___d_l___s_y_s_c_t_l___n_m_i.html">DL_SYSCTL_NMI</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Which of the requested SYSCTL non-maskable interrupts are pending</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Bitwise</td><td>OR of <a class="el" href="group___d_l___s_y_s_c_t_l___n_m_i.html">DL_SYSCTL_NMI</a> values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae19cd3d180fb0da4e2fd138c5308d56d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae19cd3d180fb0da4e2fd138c5308d56d">&sect;&nbsp;</a></span>DL_SYSCTL_getPendingNonMaskableInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga6bcbb65890c723d59c075c19f49419e6">DL_SYSCTL_NMI_IIDX</a> DL_SYSCTL_getPendingNonMaskableInterrupt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get highest priority pending SYSCTL non-maskable interrupt. </p>
<p>Checks if any of the SYSCTL non-maskable interrupts are pending. Interrupts do not have to be previously enabled.</p>
<dl class="section return"><dt>Returns</dt><dd>The highest priority pending SYSCTL non-maskable interrupt</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga6bcbb65890c723d59c075c19f49419e6">DL_SYSCTL_NMI_IIDX</a> values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf4c55590db0e90d4aa990e72fe18247d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4c55590db0e90d4aa990e72fe18247d">&sect;&nbsp;</a></span>DL_SYSCTL_clearNonMaskableInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_clearNonMaskableInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear pending SYSCTL non-maskable interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptMask</td><td>Bit mask of interrupts to clear. Bitwise OR of <a class="el" href="group___d_l___s_y_s_c_t_l___n_m_i.html">DL_SYSCTL_NMI</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga089727156353964f3376b19f408f3c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga089727156353964f3376b19f408f3c56">&sect;&nbsp;</a></span>DL_SYSCTL_setWWDT0ErrorBehavior()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_setWWDT0ErrorBehavior </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga06e41abcd8e8c7519885e1a6f9f740e7">DL_SYSCTL_ERROR_BEHAVIOR</a>&#160;</td>
          <td class="paramname"><em>behavior</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the behavior when a WWDT0 error occurs. </p>
<p>Configures whether a WWDT0 error will trigger a BOOTRST or an NMI (non-maskable interrupt). By default, this error will trigger a BOOTRST.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">behavior</td><td>The behavior when a Flash ECC DED occurrs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>DL_SYSCTL_enableNonMaskableInterrupt </dd></dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="gae88d90b3e0b9a99319ff849709b5fb5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae88d90b3e0b9a99319ff849709b5fb5c">&sect;&nbsp;</a></span>DL_SYSCTL_getWWDT0ErrorBehavior()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga06e41abcd8e8c7519885e1a6f9f740e7">DL_SYSCTL_ERROR_BEHAVIOR</a> DL_SYSCTL_getWWDT0ErrorBehavior </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the behavior when a WWDT0 error occurs. </p>
<p>By default, this error will trigger a BOOTRST.</p>
<dl class="section return"><dt>Returns</dt><dd>The behavior when a WWDT0 error occurs</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga06e41abcd8e8c7519885e1a6f9f740e7">DL_SYSCTL_ERROR_BEHAVIOR</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1d95f2379d3521583246b962818f35d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d95f2379d3521583246b962818f35d3">&sect;&nbsp;</a></span>DL_SYSCTL_setMCLKDivider()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_setMCLKDivider </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga840c7f725afee13c0ba40fcad6ba5097">DL_SYSCTL_MCLK_DIVIDER</a>&#160;</td>
          <td class="paramname"><em>divider</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the Main Clock (MCLK) divider (MDIV) </p>
<p>Additionally, can use this function to disable MDIV. MDIV must be disabled before changing SYSOSC frequency.</p>
<p>MDIV is not valid if MCLK source is HSCLK. MDIV is not used if MCLK source if LFCLK.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">divider</td><td>Should be DL_SYSCTL_MCLK_DIVIDER_DISABLE if source is HSCLK, a don't care if LFCLK, and one of DL_SYSCTL_MCLK_DIVIDER if SYSOSC. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga513371a6042a86c8229a50d07fc923ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga513371a6042a86c8229a50d07fc923ed">&sect;&nbsp;</a></span>DL_SYSCTL_getMCLKDivider()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga840c7f725afee13c0ba40fcad6ba5097">DL_SYSCTL_MCLK_DIVIDER</a> DL_SYSCTL_getMCLKDivider </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Main Clock (MCLK) divider (MDIV) </p>
<dl class="section return"><dt>Returns</dt><dd>The value of the Main Clock (MCLK) divider (MDIV)</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Should</td><td>be DL_SYSCTL_MCLK_DIVIDER_DISABLE if source is HSCLK, a don't care if LFCLK, and one of DL_SYSCTL_MCLK_DIVIDER if SYSOSC. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1593a733c8f1982417ae0b30f7c9297c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1593a733c8f1982417ae0b30f7c9297c">&sect;&nbsp;</a></span>DL_SYSCTL_getMCLKSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga644e04bc507e88dee66e3018d9dc1810">DL_SYSCTL_MCLK_SOURCE</a> DL_SYSCTL_getMCLKSource </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the source for the Main Clock (MCLK) </p>
<dl class="section return"><dt>Returns</dt><dd>The source for the Main Clock (MCLK)</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga644e04bc507e88dee66e3018d9dc1810">DL_SYSCTL_MCLK_SOURCE</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga561ed1294f48e5d0c04ff6e6f5856a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga561ed1294f48e5d0c04ff6e6f5856a1e">&sect;&nbsp;</a></span>DL_SYSCTL_setSYSOSCFreq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_setSYSOSCFreq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga2d02be2892b083ae42dc5ec338f52e46">DL_SYSCTL_SYSOSC_FREQ</a>&#160;</td>
          <td class="paramname"><em>freq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the target frequency of the System Oscillator (SYSOSC) </p>
<p>Target/desired SYSOSC frequency may be different than current/actual SYSOSC frequency during gear shift and other operations.</p>
<p>The System Oscillator (SYSOSC) is an on-chip, accurate, configurable oscillator with factory trimmed support for 32MHz (base frequency) and 4MHz (low frequency) operation. It can also operate at 16MHz or 24MHz by using the <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga24a8058e617b55c859d4fc7b8dce56ca">DL_SYSCTL_configSYSOSCUserTrim</a> function instead.</p>
<p>SYSOSC provides a flexible high-speed clock source for the system in cases where the HFXT is either not present or not used.</p>
<p>MDIV must be disabled before changing SYSOSC freq. See <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga1d95f2379d3521583246b962818f35d3">DL_SYSCTL_setMCLKDivider</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">freq</td><td>Target frequency to use for the System Oscillator (SYSOSC). <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga2d02be2892b083ae42dc5ec338f52e46a5ce32737edb72b88716f735b239eb057">DL_SYSCTL_SYSOSC_FREQ_4M</a> or <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga2d02be2892b083ae42dc5ec338f52e46a5c7a90ae7d414ed52626f9a29cdac113">DL_SYSCTL_SYSOSC_FREQ_BASE</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga24a8058e617b55c859d4fc7b8dce56ca" title="Trim the System Oscillator (SYSOSC) to 16MHz or 24MHz. ">DL_SYSCTL_configSYSOSCUserTrim</a> </dd>
<dd>
<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga1d95f2379d3521583246b962818f35d3" title="Set the Main Clock (MCLK) divider (MDIV) ">DL_SYSCTL_setMCLKDivider</a> </dd></dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga24a8058e617b55c859d4fc7b8dce56ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24a8058e617b55c859d4fc7b8dce56ca">&sect;&nbsp;</a></span>DL_SYSCTL_configSYSOSCUserTrim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_configSYSOSCUserTrim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_d_l___s_y_s_c_t_l___s_y_s_o_s_c_user_trim_config.html">DL_SYSCTL_SYSOSCUserTrimConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trim the System Oscillator (SYSOSC) to 16MHz or 24MHz. </p>
<p>The trim values supplied in the config struct must be determined by experimentation. Please refer to the "SYSOSC User Trim Procedure" section in the CKM Technical Reference Manual. Each device must be trimmed individually for accuracy.</p>
<p>MDIV must be disabled before changing SYSOSC freq. See <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga1d95f2379d3521583246b962818f35d3">DL_SYSCTL_setMCLKDivider</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Pointer to the SYSOSC user trim configuration struct <a class="el" href="struct_d_l___s_y_s_c_t_l___s_y_s_o_s_c_user_trim_config.html">DL_SYSCTL_SYSOSCUserTrimConfig</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga561ed1294f48e5d0c04ff6e6f5856a1e" title="Set the target frequency of the System Oscillator (SYSOSC) ">DL_SYSCTL_setSYSOSCFreq</a> </dd>
<dd>
<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga1d95f2379d3521583246b962818f35d3" title="Set the Main Clock (MCLK) divider (MDIV) ">DL_SYSCTL_setMCLKDivider</a> </dd></dl>

<p>References <a class="el" href="struct_d_l___s_y_s_c_t_l___s_y_s_o_s_c_user_trim_config.html#a7055ba639e1c2dc2cf69f31d2ef21734">DL_SYSCTL_SYSOSCUserTrimConfig::capacitor</a>, <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>, <a class="el" href="struct_d_l___s_y_s_c_t_l___s_y_s_o_s_c_user_trim_config.html#a38dc7573c05eeb52b051f29dea0b5015">DL_SYSCTL_SYSOSCUserTrimConfig::freq</a>, <a class="el" href="struct_d_l___s_y_s_c_t_l___s_y_s_o_s_c_user_trim_config.html#ab3938582512a9285f9b8d74af2512e27">DL_SYSCTL_SYSOSCUserTrimConfig::rDiv</a>, <a class="el" href="struct_d_l___s_y_s_c_t_l___s_y_s_o_s_c_user_trim_config.html#afff83ba02fc792ef01423f2a4ce1675a">DL_SYSCTL_SYSOSCUserTrimConfig::resistorCoarse</a>, and <a class="el" href="struct_d_l___s_y_s_c_t_l___s_y_s_o_s_c_user_trim_config.html#a786544d8366502a336eab6979915ef8c">DL_SYSCTL_SYSOSCUserTrimConfig::resistorFine</a>.</p>

</div>
</div>
<a id="gacc3bac88b735b1939e09de8296381872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc3bac88b735b1939e09de8296381872">&sect;&nbsp;</a></span>DL_SYSCTL_getTargetSYSOSCFreq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga2d02be2892b083ae42dc5ec338f52e46">DL_SYSCTL_SYSOSC_FREQ</a> DL_SYSCTL_getTargetSYSOSCFreq </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the target frequency of the System Oscillator (SYSOSC) Target/desired SYSOSC frequency may be different than current/actual SYSOSC frequency during gear shift and other operations. This function matches what is input by <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga561ed1294f48e5d0c04ff6e6f5856a1e">DL_SYSCTL_setSYSOSCFreq</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The target frequency of System Oscillator (SYSOSC). One of <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga2d02be2892b083ae42dc5ec338f52e46">DL_SYSCTL_SYSOSC_FREQ</a>. </dd></dl>

</div>
</div>
<a id="gacb7e0a77752c9b876b9289a443341362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb7e0a77752c9b876b9289a443341362">&sect;&nbsp;</a></span>DL_SYSCTL_getCurrentSYSOSCFreq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga2d02be2892b083ae42dc5ec338f52e46">DL_SYSCTL_SYSOSC_FREQ</a> DL_SYSCTL_getCurrentSYSOSCFreq </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current frequency of the System Oscillator (SYSOSC) Current/actual SYSOSC frequency may be different than target/desired SYSOSC frequency during gear shift and other operations. </p>
<dl class="section return"><dt>Returns</dt><dd>The current frequency of System Oscillator (SYSOSC). One of <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga2d02be2892b083ae42dc5ec338f52e46">DL_SYSCTL_SYSOSC_FREQ</a>. </dd></dl>

</div>
</div>
<a id="gabc4dead61fdff7cac031224790efb999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc4dead61fdff7cac031224790efb999">&sect;&nbsp;</a></span>DL_SYSCTL_getClockStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_SYSCTL_getClockStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns status of the different clocks in CKM. </p>
<dl class="section return"><dt>Returns</dt><dd>Full status of all clock selections</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Bitwise</td><td>OR of <a class="el" href="group___d_l___s_y_s_c_t_l___c_l_k___s_t_a_t_u_s.html">DL_SYSCTL_CLK_STATUS</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga1c359b196e7bee473007998b4342a541">DL_SYSCTL_isFCCDone()</a>.</p>

</div>
</div>
<a id="ga0c56e55435135b41670c72c9311116c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c56e55435135b41670c72c9311116c1">&sect;&nbsp;</a></span>DL_SYSCTL_getStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_SYSCTL_getStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns general status of SYSCTL. </p>
<dl class="section return"><dt>Returns</dt><dd>Full status of all general conditions in SYSCTL</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Bitwise</td><td>OR of <a class="el" href="group___d_l___s_y_s_c_t_l___s_t_a_t_u_s.html">DL_SYSCTL_STATUS</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6ff18a52a5b1ddb681127f640453ceb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ff18a52a5b1ddb681127f640453ceb0">&sect;&nbsp;</a></span>DL_SYSCTL_clearECCErrorStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_clearECCErrorStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the ECC error bits in SYSSTATUS. </p>
<p>The ECC error bits in SYSSTATUS are sticky (they remain set when an ECC error occurs even if future reads do not have errors), and can be cleared through this API. </p>

<p>References <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga1b11d6f9180b94ee3cd0ae8088f52ecf">DL_SYSCTL_setLFCLKSourceLFXT()</a>.</p>

</div>
</div>
<a id="ga1b11d6f9180b94ee3cd0ae8088f52ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b11d6f9180b94ee3cd0ae8088f52ecf">&sect;&nbsp;</a></span>DL_SYSCTL_setLFCLKSourceLFXT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_SYSCTL_setLFCLKSourceLFXT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_d_l___s_y_s_c_t_l___l_f_c_l_k_config.html">DL_SYSCTL_LFCLKConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change LFCLK source to external crystal LFXT. </p>
<p>LFOSC is the internal 32kHz oscillator and default LFCLK source after a BOR. Once LFCLK source is changed, the change is locked, LFOSC is disabled to save power, and LFCLK source cannot be selected again without BOR.</p>
<p>LFXT is an ultra-low power crystal oscillator which supports driving a standard 32.768kHz watch crystal.</p>
<p>To use the LFXT, a watch crystal must be populated between LFXIN and LFXOUT pins. Find more info in LFXT section of CKM Technical Reference Manual.</p>
<p>GPIO/IOMUX must be configure LFXT functionality for LFXIN and LFXOUT before calling this function.</p>
<p>This basic implementation will busy-wait until LFXT oscillator is stabilized. But a more advanced implementation can do other things while the LFXT is stabilizing. You can enable LFXTGOOD interrupt, or check CLKSTATUS.LFXTGOOD when convenient, as long as you do not switch the source via SETUSELFXT until LFXTGOOD is set.</p>
<p>LFCLK_IN and LFXT are mutually exclusive. This function assumes LFCLK_IN is disabled (default).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Pointer to the LFCLK configuration struct <a class="el" href="struct_d_l___s_y_s_c_t_l___l_f_c_l_k_config.html">DL_SYSCTL_LFCLKConfig</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga6ff18a52a5b1ddb681127f640453ceb0">DL_SYSCTL_clearECCErrorStatus()</a>.</p>

</div>
</div>
<a id="gac9ae1fe965282a867dfd06090393fce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9ae1fe965282a867dfd06090393fce1">&sect;&nbsp;</a></span>DL_SYSCTL_setLFCLKSourceEXLF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_setLFCLKSourceEXLF </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change LFCLK source to external digital LFCLK_IN. </p>
<p>LFOSC is the internal 32kHz oscillator and default LFCLK source after a BOR. Once LFCLK source is changed, the change is locked, LFOSC is disabled to save power, and LFCLK source cannot be selected again without BOR.</p>
<p>LFCLK_IN is a low frequency digital clock input compatible with 32.768kHz typical frequency digital square wave CMOS clock inputs (typical duty cycle of 50%).</p>
<p>Digital clock input must be valid and GPIO/IOMUX must be configured separately on the appropriate pin before calling this function to enable LFCLK_IN.</p>
<p>LFCLK_IN and LFXT are mutually exclusive. This function assumes LFXT is disabled (default). </p>

<p>References <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gae689ceed07203a48905faf6682c2f63a">DL_SYSCTL_setHFCLKSourceHFXT()</a>, and <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga0e765de836ed9b826189538c67ce3903">DL_SYSCTL_setHFCLKSourceHFXTParams()</a>.</p>

</div>
</div>
<a id="gae689ceed07203a48905faf6682c2f63a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae689ceed07203a48905faf6682c2f63a">&sect;&nbsp;</a></span>DL_SYSCTL_setHFCLKSourceHFXT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_SYSCTL_setHFCLKSourceHFXT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gae709a299b57e30a00d2b05c12eaba591">DL_SYSCTL_HFXT_RANGE</a>&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change HFCLK source to external crystal HFXT with default parameters. </p>
<p>HFXT is a high frequency crystal oscillator which supports standard crystals and resonators in the 4-48MHz range to generate a stable high-speed reference clock for the system.</p>
<p>To use the HFXT, a crystal or resonator must be populated between HFXIN and HFXOUT pins. Find more info in HFXT section of CKM Technical Reference Manual.</p>
<p>GPIO/IOMUX must be configure HFXT functionality for HFXIN and HFXOUT before calling this function.</p>
<p>The HFXT startup time is set to ~0.512ms based on the TYP datasheet recommendation. Additionally, the HFCLK startup monitor is enabled.</p>
<p>This basic implementation will busy-wait until HFXT oscillator is stabilized. But a more advanced implementation can do other things while the HFXT is stabilizing. You can enable HFCLKGOOD interrupt, or check CLKSTATUS.HFCLKGOOD when convenient, as long as you do not switch the source before HFCLKGOOD is set.</p>
<p>To modify the default HFXT startup time or disable the startup monitor, use <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga0e765de836ed9b826189538c67ce3903">DL_SYSCTL_setHFCLKSourceHFXTParams</a> instead of this API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">range</td><td>HFXT frequency range </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gac9ae1fe965282a867dfd06090393fce1">DL_SYSCTL_setLFCLKSourceEXLF()</a>.</p>

</div>
</div>
<a id="ga0e765de836ed9b826189538c67ce3903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e765de836ed9b826189538c67ce3903">&sect;&nbsp;</a></span>DL_SYSCTL_setHFCLKSourceHFXTParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_SYSCTL_setHFCLKSourceHFXTParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gae709a299b57e30a00d2b05c12eaba591">DL_SYSCTL_HFXT_RANGE</a>&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>startupTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>monitorEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change HFCLK source to external crystal HFXT with custom parameters. </p>
<p>HFXT is a high frequency crystal oscillator which supports standard crystals and resonators in the 4-48MHz range to generate a stable high-speed reference clock for the system.</p>
<p>To use the HFXT, a crystal or resonator must be populated between HFXIN and HFXOUT pins. Find more info in HFXT section of CKM Technical Reference Manual.</p>
<p>GPIO/IOMUX must be configure HFXT functionality for HFXIN and HFXOUT before calling this function.</p>
<p>If the HFCLK startup monitor is enabled, then the HFXT will be checked after the amount of time specified by the startupTime parameter. This basic implementation will busy-wait until HFXT oscillator is stabilized. But a more advanced implementation can do other things while the HFXT is stabilizing. You can enable HFCLKGOOD interrupt, or check CLKSTATUS.HFCLKGOOD when convenient, as long as you do not switch the source before HFCLKGOOD is set.</p>
<p>If the HFCLK startup monitor is disabled, then this implementation will not check if the HFXT oscillator is stabilized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">range</td><td>HFXT frequency range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startupTime</td><td>HFXT startup time </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">monitorEnable</td><td>Whether to enable the HFCLK startup monitor </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gac9ae1fe965282a867dfd06090393fce1">DL_SYSCTL_setLFCLKSourceEXLF()</a>.</p>

</div>
</div>
<a id="ga3b677e9635ac00678d6513d23a6369e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b677e9635ac00678d6513d23a6369e4">&sect;&nbsp;</a></span>DL_SYSCTL_setHFCLKSourceHFCLKIN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_setHFCLKSourceHFCLKIN </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change HFCLK source to external digital HFCLK_IN. </p>
<p>HFCLK_IN can be used to bypass the HFXT circuit and bring 4-48MHz typical frequency digital clock into the devce as HFCLK source instead of HFXT.</p>
<p>HFCLK_IN is a digital clock input compatible with digital square wave CMOS clock inputs and should have typical duty cycle of 50%.</p>
<p>Digital clock input must be valid and GPIO/IOMUX must be configured separately on the appropriate pin before calling this function to enable HFCLK_IN. </p>

</div>
</div>
<a id="gad038f76d15dfa17e0d04e12c0c9a58e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad038f76d15dfa17e0d04e12c0c9a58e6">&sect;&nbsp;</a></span>DL_SYSCTL_disableHFXT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_disableHFXT </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the HFXT. </p>
<p>If HFXT is already enabled, application software must verify that either an HFCLKGOOD indication or an HFCLKOFF (off/dead) indication in the CLKSTATUS register was asserted by hardware before attempting to disable the HFXT by clearing HFXTEN. When disabling the HFXT by clearing HFXTEN, the HFXT must not be re-enabled again until the HFCLKOFF bit in the CLKSTATUS register is set by hardware.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gabc4dead61fdff7cac031224790efb999" title="Returns status of the different clocks in CKM. ">DL_SYSCTL_getClockStatus</a> </dd></dl>

</div>
</div>
<a id="ga878454028c81a441ec3bfd9419d3c51c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga878454028c81a441ec3bfd9419d3c51c">&sect;&nbsp;</a></span>DL_SYSCTL_getHSCLKSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gadb318a4bb7a5bfb1555f660f63d32fbb">DL_SYSCTL_HSCLK_SOURCE</a> DL_SYSCTL_getHSCLKSource </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the source of High Speed Clock (HSCLK) </p>
<p>HSCLK can be sourced by HFCLK. HSCLK is an optional source for MCLK alongside SYSOSC or LFCLK.</p>
<dl class="section return"><dt>Returns</dt><dd>The source of HSCLK. One of <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gadb318a4bb7a5bfb1555f660f63d32fbb">DL_SYSCTL_HSCLK_SOURCE</a>. </dd></dl>

</div>
</div>
<a id="ga1286904349677daa6ecad36b8d9b83db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1286904349677daa6ecad36b8d9b83db">&sect;&nbsp;</a></span>DL_SYSCTL_setHSCLKSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_setHSCLKSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gadb318a4bb7a5bfb1555f660f63d32fbb">DL_SYSCTL_HSCLK_SOURCE</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the source of High Speed Clock (HSCLK) </p>
<p>HSCLK can be sourced by HFCLK. HSCLK is an optional source for MCLK alongside SYSOSC or LFCLK.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>The source of HSCLK. One of <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gadb318a4bb7a5bfb1555f660f63d32fbb">DL_SYSCTL_HSCLK_SOURCE</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga537bf2725b6ee2069d6262ab2ce500cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga537bf2725b6ee2069d6262ab2ce500cf">&sect;&nbsp;</a></span>DL_SYSCTL_getMFPCLKSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga7015e4698d5924cb3f6b05f26e76f8ef">DL_SYSCTL_MFPCLK_SOURCE</a> DL_SYSCTL_getMFPCLKSource </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the source of Middle Frequency Precision Clock (MFPCLK) </p>
<p>MFPCLK is a continuous 4MHz to DAC module in RUN/SLEEP/STOP mode. Unlike MFCLK, MFPCLK is async to MCLK/ULPCLK, providing higher DAC precision and performance. MFPCLK is the only clock source for DAC.</p>
<dl class="section return"><dt>Returns</dt><dd>The source of MFPCLK. One of <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga7015e4698d5924cb3f6b05f26e76f8ef">DL_SYSCTL_MFPCLK_SOURCE</a>. </dd></dl>

</div>
</div>
<a id="ga7097c67efa10770a6fa55d0e8ab3a75a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7097c67efa10770a6fa55d0e8ab3a75a">&sect;&nbsp;</a></span>DL_SYSCTL_setMFPCLKSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_setMFPCLKSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga7015e4698d5924cb3f6b05f26e76f8ef">DL_SYSCTL_MFPCLK_SOURCE</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the source of Middle Frequency Precision Clock (MFPCLK) </p>
<p>MFPCLK is a continuous 4MHz to DAC module in RUN/SLEEP/STOP mode. Unlike MFCLK, MFPCLK is async to MCLK/ULPCLK, providing higher DAC precision and performance. MFPCLK is the only clock source for DAC.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>The source of MFPCLK. One of <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga7015e4698d5924cb3f6b05f26e76f8ef">DL_SYSCTL_MFPCLK_SOURCE</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga9751ef1f940f0b445bb5218929706bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9751ef1f940f0b445bb5218929706bd3">&sect;&nbsp;</a></span>DL_SYSCTL_enableMFCLK()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_enableMFCLK </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the Medium Frequency Clock (MFCLK) </p>
<p>MFCLK provides a continuous 4MHz clock to drive certain peripherals on the system. The 4MHz rate is always derived from SYSOSC, and the divider is automatically applied to maintain the 4MHz rate regardless of SYSOSC frequency. MCLK is ideal for timers and serial interfaces which require a constant clock source in RUN/SLEEP/STOP power modes.</p>
<p>MFCLK can only run if 3 conditions are met:</p>
<p>1) Power mode must be RUN, SLEEP, or STOP. 2) USEMFTICK register bit is set, which this function does 3) MDIV must be set to <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gga840c7f725afee13c0ba40fcad6ba5097a476e7f20cd61f90f32dc8018f33abe3f">DL_SYSCTL_MCLK_DIVIDER_DISABLE</a> by <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga1d95f2379d3521583246b962818f35d3">DL_SYSCTL_setMCLKDivider</a>.</p>
<p>If MCLK source is not SYSOSC, MCLK frequency must be &gt;=32MHz for correct operation of MFCLK.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga1d95f2379d3521583246b962818f35d3" title="Set the Main Clock (MCLK) divider (MDIV) ">DL_SYSCTL_setMCLKDivider</a> </dd>
<dd>
<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga1593a733c8f1982417ae0b30f7c9297c" title="Get the source for the Main Clock (MCLK) ">DL_SYSCTL_getMCLKSource</a> </dd>
<dd>
DL_SYSCTL_getMCLKFreq </dd></dl>

</div>
</div>
<a id="ga78c88e3044b7101bb2d38762cbc1c3ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78c88e3044b7101bb2d38762cbc1c3ee">&sect;&nbsp;</a></span>DL_SYSCTL_enableMFPCLK()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_enableMFPCLK </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the Middle Frequency Precision Clock (MFPCLK) </p>
<p>MFPCLK provides a continuous 4MHz clock to the DAC.</p>
<p>MFPCLK can be sources from either SYSOSC or HFCLK (HFXT or HFCLK_IN).</p>
<p>The DAC does not have a clock selection mux. Its clock source is selected by configuring MFPCLK.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga56c2fec5e1322ea838a19f6ff34e1b10" title="Disable the Middle Frequency Precision Clock (MFPCLK) ">DL_SYSCTL_disableMFPCLK</a> </dd></dl>

</div>
</div>
<a id="ga56c2fec5e1322ea838a19f6ff34e1b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56c2fec5e1322ea838a19f6ff34e1b10">&sect;&nbsp;</a></span>DL_SYSCTL_disableMFPCLK()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_disableMFPCLK </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the Middle Frequency Precision Clock (MFPCLK) </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga78c88e3044b7101bb2d38762cbc1c3ee" title="Enable the Middle Frequency Precision Clock (MFPCLK) ">DL_SYSCTL_enableMFPCLK</a> </dd></dl>

</div>
</div>
<a id="ga9561095907a62e45aff6a7d25cf3d106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9561095907a62e45aff6a7d25cf3d106">&sect;&nbsp;</a></span>DL_SYSCTL_setHFCLKDividerForMFPCLK()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_setHFCLKDividerForMFPCLK </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaeec66a871ef0d069fc54f791abbfb84e">DL_SYSCTL_HFCLK_MFPCLK_DIVIDER</a>&#160;</td>
          <td class="paramname"><em>divider</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the divider for HFCLK when HFCLK is used as the MFPCLK source. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">divider</td><td>The divider of HFCLK for MFPCLK One of <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaeec66a871ef0d069fc54f791abbfb84e">DL_SYSCTL_HFCLK_MFPCLK_DIVIDER</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga30945b87ed22b61047209e8f6f3986eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30945b87ed22b61047209e8f6f3986eb">&sect;&nbsp;</a></span>DL_SYSCTL_getHFCLKDividerForMFPCLK()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaeec66a871ef0d069fc54f791abbfb84e">DL_SYSCTL_HFCLK_MFPCLK_DIVIDER</a> DL_SYSCTL_getHFCLKDividerForMFPCLK </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the divider for HFCLK when HFCLK is used as the MFPCLK source. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the divider for HFCLK for MFPCLK</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaeec66a871ef0d069fc54f791abbfb84e">DL_SYSCTL_HFCLK_MFPCLK_DIVIDER</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac17c9e77ba1b2ff630fc5ea449a38695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac17c9e77ba1b2ff630fc5ea449a38695">&sect;&nbsp;</a></span>DL_SYSCTL_enableExternalClock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_enableExternalClock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga4345c30b25b31b0a0baba36fbcedceed">DL_SYSCTL_CLK_OUT_SOURCE</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga981fe3602bfb00a63911e2e14f82f1bf">DL_SYSCTL_CLK_OUT_DIVIDE</a>&#160;</td>
          <td class="paramname"><em>divider</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the External Clock (CLK_OUT) </p>
<p>CLK_OUT is provided for pushing out digital clocks to external circuits, such as an external ADC which does not have its own clock source.</p>
<p>IOMUX setting for CLK_OUT must be configured before using this function.</p>
<p>CLK_OUT has a typical duty cycle of 50% if clock source is HFCLK, SYSOSC, or LFCLK. If source is MCLK, ULPCLK, or MFCLK, duty cycle is not guaranteed to be 50%.</p>
<p>This function performs multiple operations: 1) Sets the CLK_OUT source 2) Sets the CLK_OUT divider value 3) Enables the CLK_OUT divider, which can be disabled by <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaca52ca0f8f1ca52a3115cfd3a7ac9645">DL_SYSCTL_disableExternalClockDivider</a> 4) Enables the CLK_OUT, which can be disabled by <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga296ed5001418143d4c334728094a7221">DL_SYSCTL_disableExternalClock</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>The source of CLK_OUT. One of <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga4345c30b25b31b0a0baba36fbcedceed">DL_SYSCTL_CLK_OUT_SOURCE</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">divider</td><td>The divider of CLK_OUT. One of <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga981fe3602bfb00a63911e2e14f82f1bf">DL_SYSCTL_CLK_OUT_DIVIDE</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga296ed5001418143d4c334728094a7221" title="Disable the External Clock (CLK_OUT) ">DL_SYSCTL_disableExternalClock</a> </dd>
<dd>
<a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gaca52ca0f8f1ca52a3115cfd3a7ac9645" title="Disable the External Clock (CLK_OUT) Divider. ">DL_SYSCTL_disableExternalClockDivider</a> </dd></dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga296ed5001418143d4c334728094a7221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga296ed5001418143d4c334728094a7221">&sect;&nbsp;</a></span>DL_SYSCTL_disableExternalClock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_disableExternalClock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the External Clock (CLK_OUT) </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gac17c9e77ba1b2ff630fc5ea449a38695" title="Enable the External Clock (CLK_OUT) ">DL_SYSCTL_enableExternalClock</a> </dd></dl>

</div>
</div>
<a id="gaca52ca0f8f1ca52a3115cfd3a7ac9645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca52ca0f8f1ca52a3115cfd3a7ac9645">&sect;&nbsp;</a></span>DL_SYSCTL_disableExternalClockDivider()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_disableExternalClockDivider </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the External Clock (CLK_OUT) Divider. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gac17c9e77ba1b2ff630fc5ea449a38695" title="Enable the External Clock (CLK_OUT) ">DL_SYSCTL_enableExternalClock</a> </dd></dl>

</div>
</div>
<a id="ga449282c13007199d5d46284f369766dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga449282c13007199d5d46284f369766dc">&sect;&nbsp;</a></span>DL_SYSCTL_blockAllAsyncFastClockRequests()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_blockAllAsyncFastClockRequests </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks all asynchronous fast clock requests. </p>
<p>To block specific async fast clock requests on certain IP, refer to their individual driverlib. Examples include: RTC, UART, SPI, I2C. </p>

</div>
</div>
<a id="ga89f44149aa50423b0a37240235a38a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89f44149aa50423b0a37240235a38a71">&sect;&nbsp;</a></span>DL_SYSCTL_allowAllAsyncFastClockRequests()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_allowAllAsyncFastClockRequests </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows all asynchronous fast clock requests. </p>
<p>Although this allows all async fast clock requests, individual IPs may still be blocking theirs.</p>
<p>To allow specific async fast clock requests on certain IP, refer to their individual driverlib. Examples include: RTC, UART, SPI, I2C, GPIO. </p>

</div>
</div>
<a id="ga3b4ec4f609664cf4e4be7818a730d7d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b4ec4f609664cf4e4be7818a730d7d2">&sect;&nbsp;</a></span>DL_SYSCTL_enableFastCPUEventHandling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_enableFastCPUEventHandling </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates an asynchronous fast clock request upon any IRQ request to CPU. </p>
<p>Provides lowest latency interrupt handling regardless of system clock speed. Blockable by <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga449282c13007199d5d46284f369766dc">DL_SYSCTL_blockAllAsyncFastClockRequests</a></p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga449282c13007199d5d46284f369766dc" title="Blocks all asynchronous fast clock requests. ">DL_SYSCTL_blockAllAsyncFastClockRequests</a> </dd></dl>

</div>
</div>
<a id="gaeeb976e93dce87431582f90277c8d2ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeeb976e93dce87431582f90277c8d2ac">&sect;&nbsp;</a></span>DL_SYSCTL_disableFastCPUEventHandling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_disableFastCPUEventHandling </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maintains current system clock speed for IRQ request to CPU. </p>
<p>Latency for interrupt handling will be higher at lower system clock speeds. </p>

</div>
</div>
<a id="ga7beee417ca0bdccc26483e11e9943e59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7beee417ca0bdccc26483e11e9943e59">&sect;&nbsp;</a></span>DL_SYSCTL_setSRAMBoundaryAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_setSRAMBoundaryAddress </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the SRAM boundary address to act as partition for read-execute permission. </p>
<p>Specify the SRAM partition address to protect the code region of SRAM from being written to, and prevent the RW ("data") region of SRAM from being used for code execution. The SRAM partition address creates lower and higher partitions:</p><ul>
<li>Lower partition is Read-Write only, no execute</li>
<li>Upper partition is Read-Execute only, no write A partition address of 0x0 is a special case and indicates that all SRAM is configured with RWX (read-write-execute) permissions. This is the default value.</li>
</ul>
<p>The address is set with a 32-byte resolution. The address written is the system memory map address of the partition (0x200X_XXXX).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Address to act as the SRAM partition address. Value is a valid 32-bit SRAM address. Only address bits [19:5] i.e. bit 5 to bit 19 are used for the boundary address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3dc3f7fb33dacb281fc578b6a5bbdca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3dc3f7fb33dacb281fc578b6a5bbdca6">&sect;&nbsp;</a></span>DL_SYSCTL_getSRAMBoundaryAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_SYSCTL_getSRAMBoundaryAddress </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the SRAM boundary address. </p>
<p>Get the SRAM partition address The SRAM partition address creates lower and higher partitions:</p><ul>
<li>Lower partition is Read-Write only, no execute</li>
<li>Upper partition is Read-Execute only, no write A partition address of 0x0 is a special case and indicates that all SRAM is configured with RWX (read-write-execute) permissions.</li>
</ul>
<p>The address is set with a 32-byte granularity. The address written is the system memory map address of the partition (0x200X_XXXX).</p>
<dl class="section return"><dt>Returns</dt><dd>The SRAM partition address offset from the SRAM base address</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>is range in [0x0, 0x000FFFE0] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga192193cab933ec53c22d47cd69c5adc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga192193cab933ec53c22d47cd69c5adc6">&sect;&nbsp;</a></span>DL_SYSCTL_setFlashWaitState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_setFlashWaitState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga7b893ce5af5fab09fed655808c393c92">DL_SYSCTL_FLASH_WAIT_STATE</a>&#160;</td>
          <td class="paramname"><em>waitState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set flash wait state. </p>
<dl class="section note"><dt>Note</dt><dd>Flash wait states are managed automatically by SYSCTL when MCLK is running from SYSOSC or LFCLK. </dd>
<dd>
This wait state is only applied if MCLK running from HFXT, or HFCLK_IN.</dd></dl>
<p>Consult device specific datasheet for proper values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">waitState</td><td>Desired number of flash wait states. One of <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga7b893ce5af5fab09fed655808c393c92">DL_SYSCTL_FLASH_WAIT_STATE</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga528655371e502e1afae771af169e4a69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga528655371e502e1afae771af169e4a69">&sect;&nbsp;</a></span>DL_SYSCTL_getFlashWaitState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga7b893ce5af5fab09fed655808c393c92">DL_SYSCTL_FLASH_WAIT_STATE</a> DL_SYSCTL_getFlashWaitState </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get flash wait state. </p>
<dl class="section note"><dt>Note</dt><dd>Flash wait states are managed automatically by SYSCTL when MCLK is running from SYSOSC or LFCLK. </dd>
<dd>
This wait state is only applied if MCLK running from HFXT, or HFCLK_IN.</dd></dl>
<p>Consult device specific datasheet for proper values.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of flash wait states. One of <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga7b893ce5af5fab09fed655808c393c92">DL_SYSCTL_FLASH_WAIT_STATE</a>. </dd></dl>

</div>
</div>
<a id="ga3d9e793740c9501a14647715e2f9313a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d9e793740c9501a14647715e2f9313a">&sect;&nbsp;</a></span>DL_SYSCTL_readFCC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_SYSCTL_readFCC </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read Frequency Clock Counter (FCC) </p>
<dl class="section return"><dt>Returns</dt><dd>22-bit value of Frequency Clock Counter (FCC) </dd></dl>

</div>
</div>
<a id="gac7df43169548c7515fc5352790ec226e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7df43169548c7515fc5352790ec226e">&sect;&nbsp;</a></span>DL_SYSCTL_startFCC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_startFCC </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start Frequency Clock Counter (FCC) </p>
<p>If FCC_IN is already logic high, counting starts immediately. When using level trigger, FCC_IN should be low when GO is set, and trigger pulse should be sent to FCC_IN after starting FCC. </p>

</div>
</div>
<a id="ga1c359b196e7bee473007998b4342a541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c359b196e7bee473007998b4342a541">&sect;&nbsp;</a></span>DL_SYSCTL_isFCCDone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_SYSCTL_isFCCDone </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether FCC is done capturing. </p>
<p>When capture completes, FCCDONE is set by hardware. FCCDONE is read-only and is automatically cleared by hardware when a new capture is started.</p>
<dl class="section return"><dt>Returns</dt><dd>Whether FCC is done or not </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>or false (boolean) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gabc3a566bffa1f7cb61c94dddc2ad7870">DL_SYSCTL_configFCC()</a>, and <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gabc4dead61fdff7cac031224790efb999">DL_SYSCTL_getClockStatus()</a>.</p>

</div>
</div>
<a id="gabc3a566bffa1f7cb61c94dddc2ad7870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc3a566bffa1f7cb61c94dddc2ad7870">&sect;&nbsp;</a></span>DL_SYSCTL_configFCC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_SYSCTL_configFCC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gade1fd3f998053938225af73b519f695d">DL_SYSCTL_FCC_TRIG_TYPE</a>&#160;</td>
          <td class="paramname"><em>trigLvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gad56cf7d1f7fe634c4575f18669403887">DL_SYSCTL_FCC_TRIG_SOURCE</a>&#160;</td>
          <td class="paramname"><em>trigSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga088842c40b39b18edd2e81f898deea08">DL_SYSCTL_FCC_CLOCK_SOURCE</a>&#160;</td>
          <td class="paramname"><em>clkSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the Frequency Clock Counter (FCC) </p>
<p>FCC enables flexible in-system testing and calibration of a variety of oscillators and clocks on the device. The FCC counts the number of clock periods seen on the selected clock source within a known fixed trigger period (derived from a secondary reference source) to provide an estimation of the frequency of the source clock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trigLvl</td><td>Determines if active high level trigger or rising-edge to rising-edge. One of <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gade1fd3f998053938225af73b519f695d">DL_SYSCTL_FCC_TRIG_TYPE</a> . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trigSrc</td><td>Determines which clock source to trigger FCC from. One of <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gad56cf7d1f7fe634c4575f18669403887">DL_SYSCTL_FCC_TRIG_SOURCE</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clkSrc</td><td>Which clock source to capture and measure frequency of. One of <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga088842c40b39b18edd2e81f898deea08">DL_SYSCTL_FCC_CLOCK_SOURCE</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga1c359b196e7bee473007998b4342a541">DL_SYSCTL_isFCCDone()</a>.</p>

</div>
</div>
<a id="ga04566c3fe45eed79d9d05248c3173b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04566c3fe45eed79d9d05248c3173b16">&sect;&nbsp;</a></span>DL_SYSCTL_setFCCPeriods()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_setFCCPeriods </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga919e05d2b9725602984a9ae8bee98b09">DL_SYSCTL_FCC_TRIG_CNT</a>&#160;</td>
          <td class="paramname"><em>periods</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets number of rising-edge to rising-edge period for Frequency Clock Counter (FCC) </p>
<p>Set the number of rising-edge to rising-edge period for Frequency Clock Counter (FCC)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">periods</td><td>One of <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga919e05d2b9725602984a9ae8bee98b09">DL_SYSCTL_FCC_TRIG_CNT</a> </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga5c3f461bd82d8f9dc1f3eb380502ab25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c3f461bd82d8f9dc1f3eb380502ab25">&sect;&nbsp;</a></span>DL_SYSCTL_getFCCPeriods()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga919e05d2b9725602984a9ae8bee98b09">DL_SYSCTL_FCC_TRIG_CNT</a> DL_SYSCTL_getFCCPeriods </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets number of rising-edge to rising-edge period for Frequency Clock Counter (FCC) </p>
<dl class="section return"><dt>Returns</dt><dd>One of <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga919e05d2b9725602984a9ae8bee98b09">DL_SYSCTL_FCC_TRIG_CNT</a> </dd></dl>

</div>
</div>
<a id="ga8209173a763a90618c126b4f3a0a533a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8209173a763a90618c126b4f3a0a533a">&sect;&nbsp;</a></span>DL_SYSCTL_enableSYSOSCFCL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_enableSYSOSCFCL </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable Frequency Correction Loop (FCL) in Internal Resistor Mode. </p>
<p>Once FCL is enable, it cannot be disabled by software. A BOOTRST is required. </p>

</div>
</div>
<a id="ga3974b94a8e546a7d399b77a90657f680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3974b94a8e546a7d399b77a90657f680">&sect;&nbsp;</a></span>DL_SYSCTL_enableSYSOSCFCLExternalResistor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_enableSYSOSCFCLExternalResistor </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable Frequency Correction Loop (FCL) in External Resistor Mode. </p>
<p>Used to increase SYSOSC accuracy. An ROSC reference resistor which is suitable to meet application accuracy reqiurements must be placed between ROSC pin and device ground (VSS).</p>
<p>Once FCL is enable, it cannot be disabled by software. A BOOTRST is required.</p>
<p>Power consumption of SYSOSC will be marginally higher with FCL enabled due to reference current which flows through ROSC. Settling time from startup to specified accuracy may also be longer. See device-specific datasheet for startup times. </p>

</div>
</div>
<a id="gae0b1c86e5a0be32ac2238c2a0e2540b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0b1c86e5a0be32ac2238c2a0e2540b2">&sect;&nbsp;</a></span>DL_SYSCTL_enableWriteLock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_enableWriteLock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable write protection of selected SYSCTL registers. </p>
<p>Protecting writes to configuration registers in SYSCTL can add a layer of robustness against unintended changes during runtime.</p>
<dl class="section note"><dt>Note</dt><dd>Does not protect all SYSCTL registers, see TRM for more detail. </dd></dl>

</div>
</div>
<a id="ga277a6e9bb37507630bc258f3d0cbcaed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga277a6e9bb37507630bc258f3d0cbcaed">&sect;&nbsp;</a></span>DL_SYSCTL_disableWriteLock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_disableWriteLock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable write protection of selected SYSCTL registers. </p>
<p>Protecting writes to configuration registers in SYSCTL can add a layer of robustness against unintended changes during runtime.</p>
<dl class="section note"><dt>Note</dt><dd>Does not protect all SYSCTL registers, see TRM for more detail. </dd></dl>

</div>
</div>
<a id="ga5c2c4728010a6f06487971a43b594896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c2c4728010a6f06487971a43b594896">&sect;&nbsp;</a></span>DL_SYSCTL_setVBOOSTConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_setVBOOSTConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga4bac12ff08dc5a074df489d69ae0cc80">DL_SYSCTL_VBOOST</a>&#160;</td>
          <td class="paramname"><em>setting</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets operating mode of VBOOST (analog charge pump) </p>
<p>Active VBOOST circuitry is needed for COMP/OPA/GPAMP (if present on device). VBOOST has a startup time, so consider power consumption versus desired startup time.</p>
<dl class="section note"><dt>Note</dt><dd>Although VBOOST clock source is automatically managed, it is up to application software to ensure certain cases, or else ANACLKERR occurs. See VBOOST section of TRM for more details. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">setting</td><td>One of <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga4bac12ff08dc5a074df489d69ae0cc80">DL_SYSCTL_VBOOST</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga9027ace807fff308872a42ea19283b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9027ace807fff308872a42ea19283b78">&sect;&nbsp;</a></span>DL_SYSCTL_getVBOOSTConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga4bac12ff08dc5a074df489d69ae0cc80">DL_SYSCTL_VBOOST</a> DL_SYSCTL_getVBOOSTConfig </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets operating mode of VBOOST (analog charge pump) </p>
<p>Active VBOOST circuitry is needed for COMP/OPA/GPAMP (if present on device). VBOOST has a startup time, so consider power consumption versus desired startup time.</p>
<dl class="section note"><dt>Note</dt><dd>Although VBOOST clock source is automatically managed, it is up to application software to ensure certain cases, or else ANACLKERR occurs. See VBOOST section of TRM for more details. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>One of <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga4bac12ff08dc5a074df489d69ae0cc80">DL_SYSCTL_VBOOST</a>. </dd></dl>

</div>
</div>
<a id="ga41542df65ab8053c8db5695febe0865b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41542df65ab8053c8db5695febe0865b">&sect;&nbsp;</a></span>DL_SYSCTL_getShutdownStorageByte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint8_t DL_SYSCTL_getShutdownStorageByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gac4ba3ae564f39aac9884ee95b1a4bf50">DL_SYSCTL_SHUTDOWN_STORAGE_BYTE</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return byte that was saved through SHUTDOWN. </p>
<p>Shutdown memory persists beyond BOR, BOOTRST, and SYSRST.</p>
<dl class="section note"><dt>Note</dt><dd>Parity bits and parity fault checking is done by hardware.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>One of <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gac4ba3ae564f39aac9884ee95b1a4bf50">DL_SYSCTL_SHUTDOWN_STORAGE_BYTE</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>8-bit value of Shutdown Storage Byte. </dd></dl>

</div>
</div>
<a id="ga3862a4ee9f928a49e09ab17f77448242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3862a4ee9f928a49e09ab17f77448242">&sect;&nbsp;</a></span>DL_SYSCTL_setShutdownStorageByte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_setShutdownStorageByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gac4ba3ae564f39aac9884ee95b1a4bf50">DL_SYSCTL_SHUTDOWN_STORAGE_BYTE</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a byte to SHUTDOWN memory. </p>
<p>Shutdown memory persists beyond BOR, BOOTRST, and SYSRST.</p>
<dl class="section note"><dt>Note</dt><dd>Parity bits and parity fault checking is done by hardware.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>One of <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gac4ba3ae564f39aac9884ee95b1a4bf50">DL_SYSCTL_SHUTDOWN_STORAGE_BYTE</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>8-bit data to save in memory </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="gaeca20e76a7f28e0623d43a00ae583d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeca20e76a7f28e0623d43a00ae583d80">&sect;&nbsp;</a></span>DL_SYSCTL_releaseShutdownIO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_releaseShutdownIO </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable SHUTDOWN IO Release. </p>
<p>After shutdown, IO is locked in previous state.</p>
<dl class="section note"><dt>Note</dt><dd>Release IO after re-configuring IO to their proper state. </dd></dl>

</div>
</div>
<a id="ga484efea497454075cc913a878804d020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga484efea497454075cc913a878804d020">&sect;&nbsp;</a></span>DL_SYSCTL_disableNRSTPin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_disableNRSTPin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the reset functionality of the NRST pin. </p>
<p>Disabling the NRST pin allows the pin to be configured as a GPIO. Once disabled, the reset functionality can only be re-enabled by a POR.</p>
<dl class="section note"><dt>Note</dt><dd>The register is write-only, so the EXRSTPIN register will always appear as "Disabled" in the debugger </dd></dl>

</div>
</div>
<a id="ga3c76ab08305e09c585144dc3f3d08eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c76ab08305e09c585144dc3f3d08eab">&sect;&nbsp;</a></span>DL_SYSCTL_disableSWD()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_disableSWD </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable Serial Wire Debug (SWD) functionality. </p>
<p>SWD pins are enabled by default after cold start to allow a debug connection. It is possible to disable SWD on these pins to use for other functionality.</p>
<dl class="section post"><dt>Postcondition</dt><dd>SWD is disabled, but pins must be re-configured separately.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Cannot debug the device after disabling SWD. Only re-enabled by POR. </dd></dl>

</div>
</div>
<a id="ga894bf68f6e9bc1f15fc1a8c26e01c0d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga894bf68f6e9bc1f15fc1a8c26e01c0d3">&sect;&nbsp;</a></span>DL_SYSCTL_getResetCause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga72bea3c6a78a3a5c0d389ac78cacce74">DL_SYSCTL_RESET_CAUSE</a> DL_SYSCTL_getResetCause </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return byte that is stored in RSTCAUSE. </p>
<dl class="section return"><dt>Returns</dt><dd>The cause of reset. One of <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga72bea3c6a78a3a5c0d389ac78cacce74">DL_SYSCTL_RESET_CAUSE</a> </dd></dl>

</div>
</div>
<a id="ga0ea033c2a0d0f2e64c3ad4ce7e9b8b66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ea033c2a0d0f2e64c3ad4ce7e9b8b66">&sect;&nbsp;</a></span>DL_SYSCTL_setHFXTStartupTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_setHFXTStartupTime </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>startupTime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the HFXT startup time. </p>
<p>Specify the HFXT startup time in 64us resolution. If the HFCLK startup monitor is enabled (HFCLKFLTCHK), HFXT will be checked after this time expires.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startupTime</td><td>The HFXT startup time to set in ~64us steps. Value between [0x0 (~0s), 0xFF (~16.32ms)]. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga29dbe951600e38179bb36db2090c8bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29dbe951600e38179bb36db2090c8bcc">&sect;&nbsp;</a></span>DL_SYSCTL_getHFXTStartupTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_SYSCTL_getHFXTStartupTime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the HFXT startup time. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the HFXT startup time in ~64us steps</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>between [0x0 (~0s), 0xFF (~16.32ms)] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadea6cf63b237f315f0d02d85d6ec7aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadea6cf63b237f315f0d02d85d6ec7aca">&sect;&nbsp;</a></span>DL_SYSCTL_setHFXTFrequencyRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_setHFXTFrequencyRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gae709a299b57e30a00d2b05c12eaba591">DL_SYSCTL_HFXT_RANGE</a>&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the HFXT frequency range. </p>
<p>The high frequency crystal oscillator (HFXT) can be used with standard crystals and resonators in the 4-48MHz range to generate a stable high-speed reference clock for the system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">range</td><td>One of <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gae709a299b57e30a00d2b05c12eaba591">DL_SYSCTL_HFXT_RANGE</a> </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="gad290b4bb6f05012ce8984e879fe9c5e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad290b4bb6f05012ce8984e879fe9c5e8">&sect;&nbsp;</a></span>DL_SYSCTL_getHFXTFrequencyRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gae709a299b57e30a00d2b05c12eaba591">DL_SYSCTL_HFXT_RANGE</a> DL_SYSCTL_getHFXTFrequencyRange </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the HFXT frequency range. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the HFXT frequency range</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#gae709a299b57e30a00d2b05c12eaba591">DL_SYSCTL_HFXT_RANGE</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga90f01dd71b9d1f8a74bdd08859701269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90f01dd71b9d1f8a74bdd08859701269">&sect;&nbsp;</a></span>DL_SYSCTL_enableHFCLKStartupMonitor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_enableHFCLKStartupMonitor </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the HFCLK startup monitor. </p>
<p>The HFXT takes time to start after being enabled. A startup monitor is provided to indicate to the application software if the HFXT has successfully started, at which point the HFCLK can be selected to source a variety of system functions. The HFCLK startup monitor also supports checking the HFCLK_IN digital clock input for a clock stuck fault. </p>

</div>
</div>
<a id="ga4b827d98ddbc2ba384560e36e12218f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b827d98ddbc2ba384560e36e12218f7">&sect;&nbsp;</a></span>DL_SYSCTL_getTempCalibrationConstant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_SYSCTL_getTempCalibrationConstant </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the calibration constant of the temperature sensor to be used in temperature calculation. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Temperature</td><td>sensor calibration data </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___f_a_c_t_o_r_y_r_e_g_i_o_n.html#gaadca77b3f265865214254f6df3dd1843">DL_FactoryRegion_getTemperatureVoltage()</a>, <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga948875f053637b9177d221a3f9fe564b">DL_SYSCTL_initIPProtectFirewall()</a>, and <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga19d019a22533e245c58eb7df62817565">DL_SYSCTL_initReadExecuteProtectFirewall()</a>.</p>

</div>
</div>
<a id="ga19d019a22533e245c58eb7df62817565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19d019a22533e245c58eb7df62817565">&sect;&nbsp;</a></span>DL_SYSCTL_initReadExecuteProtectFirewall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DL_SYSCTL_initReadExecuteProtectFirewall </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>startAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the Read Execute (RX) Protect Firewall. </p>
<p>The firewall security configuration can only be configured if INITDONE has not been issued by the CSC. This API checks if INITDONE has been issued. If it has not been issued, then the start and end addresses are set, and then it enables the firewall. If INITDONE has been issused, then the API immediately returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startAddr</td><td>The start address of the read execute protect firewall </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endAddr</td><td>The end address of the read execute protect firewall</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the Read Execute Protect Firewall was configured</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If INITDONE was not issued and the firewall was configured </td></tr>
    <tr><td class="paramname">false</td><td>If INITDONE was issued and the firewall was not configured </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga4b827d98ddbc2ba384560e36e12218f7">DL_SYSCTL_getTempCalibrationConstant()</a>.</p>

</div>
</div>
<a id="ga948875f053637b9177d221a3f9fe564b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga948875f053637b9177d221a3f9fe564b">&sect;&nbsp;</a></span>DL_SYSCTL_initIPProtectFirewall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DL_SYSCTL_initIPProtectFirewall </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>startAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the IP Protect Firewall. </p>
<p>The firewall security configuration can only be configured if INITDONE has not been issued by the CSC. This API checks if INITDONE has been issued. If it has not been issued, then the start and end addresses are set, and then it enables the firewall. If INITDONE has been issused, then the API immediately returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startAddr</td><td>The start address of the IP protect firewall </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endAddr</td><td>The end address of the IP protect firewall</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the IP Protect Firewall was configured</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If INITDONE was not issued and the firewall was configured </td></tr>
    <tr><td class="paramname">false</td><td>If INITDONE was issued and the firewall was not configured </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga4b827d98ddbc2ba384560e36e12218f7">DL_SYSCTL_getTempCalibrationConstant()</a>.</p>

</div>
</div>
<a id="gad9db06453c59cb1810344af02182dc3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9db06453c59cb1810344af02182dc3e">&sect;&nbsp;</a></span>DL_SYSCTL_setWriteProtectFirewallAddrRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_setWriteProtectFirewallAddrRange </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addrMask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the address range of the Write Protect Firewall. </p>
<p>Set Write Protection starting at 0x0 of flash, for the first 32KB at 1KB granularity. Setting a bit to 1 enables write protection, and setting a bit to 0 allows write.</p>
<dl class="section note"><dt>Note</dt><dd>This bit can be written only before INITDONE. At INITDONE, this configuration gets locked and stays locked until the next BOOTRST.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addrMask</td><td>The mask to set the address range for the Write Protect Firewall </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga98aa82f207eb441076f6d77f75c100a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98aa82f207eb441076f6d77f75c100a0">&sect;&nbsp;</a></span>DL_SYSCTL_getWriteProtectFirewallAddrRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_SYSCTL_getWriteProtectFirewallAddrRange </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the address range of the Write Protect Firewall. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>address range for the Write Protect Firewall </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1d878647af29356ab0e2d83ff1cbb2c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d878647af29356ab0e2d83ff1cbb2c2">&sect;&nbsp;</a></span>DL_SYSCTL_setReadExecuteProtectFirewallAddrStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_setReadExecuteProtectFirewallAddrStart </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>startAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the start address of the Read Execute (RX) Protect Firewall. </p>
<p>Set the start of the range of Flash MAIN memory that needs to be guarded from both read and execute accesses. The firewall is configured as an address range.</p>
<p>The start and end addresses are specified at 64B sector granularity, so the 6 LSBs are don't cares. If the start address is equal to the end address, then one sector is RX protected. If the end address is equal to the start address + 1, then two sectors are protected, and so on. If the end address is less than the start address, the no sectors are RX protected. The hardware does not perform any checks on the addresses.</p>
<dl class="section note"><dt>Note</dt><dd>This bit can be written only before INITDONE. At INITDONE, this configuration gets locked and stays locked until the next BOOTRST.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startAddr</td><td>The start address of the read execute protect firewall. The 6 LSBs are don't cares. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6ea8fa7a283057d47127c18a4ff433d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ea8fa7a283057d47127c18a4ff433d7">&sect;&nbsp;</a></span>DL_SYSCTL_getReadExecuteProtectFirewallAddrStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_SYSCTL_getReadExecuteProtectFirewallAddrStart </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the start address of the Read Execute (RX) Protect Firewall. </p>
<p>The start and end addresses are specified at 64B sector granularity, so the 6 LSBs are don't cares.</p>
<dl class="section return"><dt>Returns</dt><dd>The start address of the read execute protect firewall </dd></dl>

</div>
</div>
<a id="ga3295c299836bb72c482de842aaf584b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3295c299836bb72c482de842aaf584b3">&sect;&nbsp;</a></span>DL_SYSCTL_setReadExecuteProtectFirewallAddrEnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_setReadExecuteProtectFirewallAddrEnd </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the end address of the Read Execute (RX) Protect Firewall. </p>
<p>Set the end of the range of Flash MAIN memory that needs to be guarded from both read and execute accesses. The firewall is configured as an address range.</p>
<p>The start and end addresses are specified at 64B sector granularity, so the 6 LSBs are don't cares. If the start address is equal to the end address, then one sector is RX protected. If the end address is equal to the start address + 1, then two sectors are protected, and so on. If the end address is less than the start address, the no sectors are RX protected. The hardware does not perform any checks on the addresses.</p>
<dl class="section note"><dt>Note</dt><dd>This bit can be written only before INITDONE. At INITDONE, this configuration gets locked and stays locked until the next BOOTRST.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">endAddr</td><td>The end address of the read execute protect firewall. The 6 LSBs are don't cares. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7c60d5560c2003f12004862834f16470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c60d5560c2003f12004862834f16470">&sect;&nbsp;</a></span>DL_SYSCTL_getReadExecuteProtectFirewallAddrEnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_SYSCTL_getReadExecuteProtectFirewallAddrEnd </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the end address of the Read Execute (RX) Protect Firewall. </p>
<p>The start and end addresses are specified at 64B sector granularity, so the 6 LSBs are don't cares.</p>
<dl class="section return"><dt>Returns</dt><dd>The end address of the Read Execute Protect Firewall </dd></dl>

</div>
</div>
<a id="ga137cc4c74b4e7705b1f61d8bbac0b7fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga137cc4c74b4e7705b1f61d8bbac0b7fa">&sect;&nbsp;</a></span>DL_SYSCTL_setIPProtectFirewallAddrStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_setIPProtectFirewallAddrStart </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>startAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the start address of the IP Protect Firewall. </p>
<p>Set the end of the range of Flash MAIN memory that needs to be guarded from read access, allowing only execute accesses. The firewall is configured as an address range.</p>
<p>The start and end addresses are specified at 64B sector granularity, so the 6 LSBs are don't cares. If the start address is equal to the end address, then one sector is IP protected. If the end address is equal to the start address + 1, then two sectors are protected, and so on. If the end address is less than the start address, the no sectors are IP protected. The hardware does not perform any checks on the addresses.</p>
<dl class="section note"><dt>Note</dt><dd>This bit can be written only before INITDONE. At INITDONE, this configuration gets locked and stays locked until the next BOOTRST.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startAddr</td><td>The start address of the IP Protect Firewall </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9307cba882dafded10d4b5e2c40fea34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9307cba882dafded10d4b5e2c40fea34">&sect;&nbsp;</a></span>DL_SYSCTL_getIPProtectFirewallAddrStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_SYSCTL_getIPProtectFirewallAddrStart </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the start address of the IP Protect Firewall. </p>
<dl class="section return"><dt>Returns</dt><dd>The start address of the IP Protect Firewall </dd></dl>

</div>
</div>
<a id="gad9d96c3d1ccaec65df43f9a4f32b079d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9d96c3d1ccaec65df43f9a4f32b079d">&sect;&nbsp;</a></span>DL_SYSCTL_setIPProtectFirewallAddrEnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_setIPProtectFirewallAddrEnd </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the end address of the IP Protect firewall. </p>
<p>Set the end of the range of Flash MAIN memory that needs to be guarded from read access, allowing only execute accesses. The firewall is configured as an address range.</p>
<p>The start and end addresses are specified at 64B sector granularity, so the 6 LSBs are don't cares. If the start address is equal to the end address, then one sector is IP protected. If the end address is equal to the start address + 1, then two sectors are protected, and so on. If the end address is less than the start address, the no sectors are IP protected. The hardware does not perform any checks on the addresses.</p>
<dl class="section note"><dt>Note</dt><dd>This bit can be written only before INITDONE. At INITDONE, this configuration gets locked and stays locked until the next BOOTRST.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">endAddr</td><td>The end address of the IP Protect firewall </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga48caf7ed99261c82a96effdf4cd1b891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48caf7ed99261c82a96effdf4cd1b891">&sect;&nbsp;</a></span>DL_SYSCTL_getIPProtectFirewallAddrEnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_SYSCTL_getIPProtectFirewallAddrEnd </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the end address of the IP Protect Firewall. </p>
<dl class="section return"><dt>Returns</dt><dd>The end address of the IP Protect Firewall </dd></dl>

</div>
</div>
<a id="gae11d79a48531e1add5af74bc4e144570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae11d79a48531e1add5af74bc4e144570">&sect;&nbsp;</a></span>DL_SYSCTL_enableFlashBankSwap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_enableFlashBankSwap </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the policy to allow flash bank swapping. </p>
<p>The bank swap policy needs to be configured ahead of any bank swapping or firewall configurations. In dual/quad-bank devices, this policy can be set to either</p><ul>
<li>CSC allows bank swapping</li>
<li>CSC does not allow bank swapping</li>
</ul>
<p>By default, bank swapping is enabled to ensure a high security state if the system boot execution was glitched. Defaulting the system as allowing bank swapping ensures that firewall protections get mirrored to both flash banks. Additionally, when bank swapping is enabled, SYSCTL enforces write-excute mutual exclusion across the two banks (or bank-pairs).</p>
<dl class="section note"><dt>Note</dt><dd>This is a write-once bit. This bit can only be written to before INITDONE. At INITDONE, this bit becomes a read-only bit until next BOOTRST. </dd></dl>

</div>
</div>
<a id="ga571b235e2377a6cbf4272afb5c7b1d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga571b235e2377a6cbf4272afb5c7b1d86">&sect;&nbsp;</a></span>DL_SYSCTL_disableFlashBankSwap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_disableFlashBankSwap </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the policy to allow flash bank swapping. </p>
<p>The bank swap policy needs to be configured ahead of any bank swapping or firewall configurations. In dual/quad-bank devices, this policy can be set to either</p><ul>
<li>CSC allows bank swapping</li>
<li>CSC does not allow bank swapping</li>
</ul>
<p>By default, bank swapping is enabled to ensure a high security state if the system boot execution was glitched. Defaulting the system as allowing bank swapping ensures that firewall protections get mirrored to both flash banks. Additionally, when bank swapping is enabled, SYSCTL enforces write-excute mutual exclusion across the two banks (or bank-pairs).</p>
<dl class="section note"><dt>Note</dt><dd>This is a write-once bit. This bit can only be written to before INITDONE. At INITDONE, this bit becomes a read-only bit until next BOOTRST. </dd></dl>

</div>
</div>
<a id="ga41a8a9766d3a093f2fe159e2e303a869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41a8a9766d3a093f2fe159e2e303a869">&sect;&nbsp;</a></span>DL_SYSCTL_executeFromUpperFlashBank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_executeFromUpperFlashBank </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform bank swap and execute from the Upper Flash Bank. </p>
<p>The upper physical bank maps to logical 0x0, and gets RX permission. The lower physical bank gets RW permission.</p>
<dl class="section note"><dt>Note</dt><dd>This bit can only be written to before INITDONE. At INITDONE, this bit becomes a read-only bit until next BOOTRST.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>DL_SYSCTL_enableFlashBankSwap </dd></dl>

</div>
</div>
<a id="ga5c85a96966b32d1958d5d2826343e395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c85a96966b32d1958d5d2826343e395">&sect;&nbsp;</a></span>DL_SYSCTL_executeFromLowerFlashBank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_executeFromLowerFlashBank </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform bank swap and execute from the Lower Flash Bank. </p>
<p>The lower physical bank maps to logical 0x0, and gets RX permission. The upper physical bank gets RW permission.</p>
<dl class="section note"><dt>Note</dt><dd>This bit can only be written to before INITDONE. At INITDONE, this bit becomes a read-only bit until next BOOTRST.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>DL_SYSCTL_enableFlashBankSwap </dd></dl>

</div>
</div>
<a id="gad4011eeeeb356cbba8baaa538446519c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4011eeeeb356cbba8baaa538446519c">&sect;&nbsp;</a></span>DL_SYSCTL_enableReadExecuteProtectFirewall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_enableReadExecuteProtectFirewall </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable Read Execute (RX) Protect Firewall. </p>
<p>Enables the Read Execute Protect Firewall before INITDONE.</p>
<dl class="section note"><dt>Note</dt><dd>This bit can be written only before INITDONE. At INITDONE, this configuration gets locked and stays locked until the next BOOTRST </dd></dl>

</div>
</div>
<a id="ga65d27a7b90a1a15683f82c1cfa1776c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65d27a7b90a1a15683f82c1cfa1776c7">&sect;&nbsp;</a></span>DL_SYSCTL_enableIPProtectFirewall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_enableIPProtectFirewall </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable IP Protect Firewall. </p>
<p>Enables the IP Protect Firewall before INITDONE. After INITDONE, this configuration gets locked until the next BOOTRST.</p>
<dl class="section note"><dt>Note</dt><dd>This bit can be written only before INITDONE. At INITDONE, this configuration gets locked and stays locked until the next BOOTRST </dd></dl>

</div>
</div>
<a id="ga39c018eec70c3968558ac32300a69b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39c018eec70c3968558ac32300a69b0b">&sect;&nbsp;</a></span>DL_SYSCTL_enableSRAMBoundaryLock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_enableSRAMBoundaryLock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable SRAM Boundary Lock. </p>
<p>When SRAM Boundary Lock is enabled, the SRAMBOUNDARY register is only writeable only until INITDONE. After INITDONE, the SRAMBOUNDARY register cannot be written.</p>
<p>When disabled, the SRAMBOUNDARY register is writeable throughout the application, even after INITDONE.</p>
<dl class="section note"><dt>Note</dt><dd>This bit can be written only before INITDONE. At INITDONE, this configuration gets locked and stays locked until the next BOOTRST</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_y_s_c_t_l___m_s_p_m0_l122_x___l222_x.html#ga7beee417ca0bdccc26483e11e9943e59" title="Set the SRAM boundary address to act as partition for read-execute permission. ">DL_SYSCTL_setSRAMBoundaryAddress</a> </dd></dl>

</div>
</div>
<a id="gae13f129230a2aa0792c4bb6b0b7bca5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae13f129230a2aa0792c4bb6b0b7bca5f">&sect;&nbsp;</a></span>DL_SYSCTL_isINITDONEIssued()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_SYSCTL_isINITDONEIssued </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if INITDONE has been issued by the CSC. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether INITDONE has been issued or not</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If INITDONE has been issued </td></tr>
    <tr><td class="paramname">false</td><td>If INITDONE has not been issued </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7b3fdfac4c06261311a6aa9cf842215a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b3fdfac4c06261311a6aa9cf842215a">&sect;&nbsp;</a></span>DL_SYSCTL_ifCSCExists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_SYSCTL_ifCSCExists </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if Customer Startup Code (CSC) exists in system. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether CSC exists in system</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If CSC exists in system </td></tr>
    <tr><td class="paramname">false</td><td>If CSC does not exist in system </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga671e7e6af56965ed0b7235852e8c2f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga671e7e6af56965ed0b7235852e8c2f84">&sect;&nbsp;</a></span>DL_SYSCTL_isReadExecuteProtectFirewallEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_SYSCTL_isReadExecuteProtectFirewallEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if Read Execute (RX) Protect Firewall is enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether Read Execute Protect Firewall is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If Read Execute Protect Firewall is enabled </td></tr>
    <tr><td class="paramname">false</td><td>If Read Execute Protect Firewall is not enabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0a69123e3a00e6fabfab28115dc05d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a69123e3a00e6fabfab28115dc05d0e">&sect;&nbsp;</a></span>DL_SYSCTL_isIPProtectFirewallEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_SYSCTL_isIPProtectFirewallEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if IP Protect Firewall is enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether IP Protect Firewall is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If IP Protect Firewall is enabled </td></tr>
    <tr><td class="paramname">false</td><td>If IP Protect Firewall is not enabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaa8b0ce6cc91389e1a7d25ef48ab4db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa8b0ce6cc91389e1a7d25ef48ab4db9">&sect;&nbsp;</a></span>DL_SYSCTL_isSRAMBoundaryLocked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_SYSCTL_isSRAMBoundaryLocked </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if SRAM Boundary Lock is enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether SRAM Boundary Lock is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If SRAM Boundary Lock is enabled </td></tr>
    <tr><td class="paramname">false</td><td>If SRAM Boundary Lock is not enabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3b61e3a92f4be62b70cdb43e03866b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b61e3a92f4be62b70cdb43e03866b19">&sect;&nbsp;</a></span>DL_SYSCTL_isFlashBankSwapEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_SYSCTL_isFlashBankSwapEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if Flash Bank swapping is enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether Flash Bank swap is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If Flash Bank swap is enabled </td></tr>
    <tr><td class="paramname">false</td><td>If Flash Bank swap is not enabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafaf14ccfbcd9f94da7e6fd6c2602e290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafaf14ccfbcd9f94da7e6fd6c2602e290">&sect;&nbsp;</a></span>DL_SYSCTL_isExecuteFromUpperFlashBank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_SYSCTL_isExecuteFromUpperFlashBank </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if executing from upper flash bank. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether executing from upper flash bank</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If executing from upper flash bank </td></tr>
    <tr><td class="paramname">false</td><td>If not executing from upper flash bank </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac9277fcfa0fe871174a7fbac755aa5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9277fcfa0fe871174a7fbac755aa5d5">&sect;&nbsp;</a></span>DL_SYSCTL_isExecuteFromLowerFlashBank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_SYSCTL_isExecuteFromLowerFlashBank </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if executing from lower flash bank. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether executing from lower flash bank</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If executing from lower flash bank </td></tr>
    <tr><td class="paramname">false</td><td>If not executing from lower flash bank </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac4146b44f3a171973a9e4e601756dc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4146b44f3a171973a9e4e601756dc4f">&sect;&nbsp;</a></span>DL_SYSCTL_issueINITDONE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_issueINITDONE </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicate that INIT is done. </p>
<p>After INITDONE is issued, the security configuration is locked and enforced. A SYSRST will occur, restarting startup code execution, and the main application is launched.</p>
<p>There is no hardware support to enforce a timeout if INITDONE is not issued in a reasonable period of time. It is recommended that the CSC use a watchdog to ensure that INITDONE is issued in a timely manner. </p>

</div>
</div>
<a id="gaf4b18c2097c46a7239bff4729b5f926e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4b18c2097c46a7239bff4729b5f926e">&sect;&nbsp;</a></span>DL_SYSCTL_enableSuperCapacitor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_enableSuperCapacitor </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables super capacitor function. </p>
<p>Allows battery backup system to be powered by a super capacitor </p>

</div>
</div>
<a id="ga52ad1c1dc4bb33d1ad49e20f09ca7341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52ad1c1dc4bb33d1ad49e20f09ca7341">&sect;&nbsp;</a></span>DL_SYSCTL_disableSuperCapacitor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_SYSCTL_disableSuperCapacitor </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables super capacitor function. </p>
<p>Prevents battery backup system from being powered by a super capacitor </p>

</div>
</div>
<a id="gaa9d509fefc4781f67086d9dac367fbb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9d509fefc4781f67086d9dac367fbb4">&sect;&nbsp;</a></span>DL_SYSCTL_isSuperCapacitorEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_SYSCTL_isSuperCapacitorEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if super capacitor function is enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>returns the state of the super capacitor bit</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The super capacitor function is enabled </td></tr>
    <tr><td class="paramname">false</td><td>The super capacitor function is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">© Copyright 1995-2025</a>, Texas Instruments Incorporated. All rights reserved. <br/>
  <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
