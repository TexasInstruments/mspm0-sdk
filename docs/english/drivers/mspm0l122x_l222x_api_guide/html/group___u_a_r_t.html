<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>MSPM0L122X_L222X TI-Driver Library: Universal Asynchronous Receiver-Transmitter (UART)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MSPM0L122X_L222X TI-Driver Library
   &#160;<span id="projectnumber">2.05.01.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Universal Asynchronous Receiver-Transmitter (UART)</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Universal Asynchronous Receiver-Transmitter (UART):</div>
<div class="dyncontent">
<center><table><tr><td><img src="group___u_a_r_t.png" border="0" alt="" usemap="#group______u__a__r__t"/>
<map name="group______u__a__r__t" id="group______u__a__r__t">
<area shape="rect" id="node1" href="group___u_a_r_t_support_m_s_p_m0.html" title="UART driver supporting APIs" alt="" coords="232,5,436,32"/>
<area shape="rect" id="node2" href="group___u_a_r_t_m_s_p_m0.html" title="UART driver APIs" alt="" coords="269,56,399,83"/>
<area shape="rect" id="node3" href="group___u_a_r_t___s_t_a_t_u_s.html" title="UART status codes" alt="" coords="263,107,405,133"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group___u_a_r_t_m_s_p_m0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t_m_s_p_m0.html">UART driver APIs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___u_a_r_t_support_m_s_p_m0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t_support_m_s_p_m0.html">UART driver supporting APIs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___u_a_r_t___s_t_a_t_u_s"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html">UART status codes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___params.html">UART_Params</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART Parameters.  <a href="struct_u_a_r_t___params.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gab69886c7119a5054a972d8c735f15928"><td class="memItemLeft" align="right" valign="top"><a id="gab69886c7119a5054a972d8c735f15928"></a>
typedef struct <a class="el" href="struct_u_a_r_t___config__.html">UART_Config_</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a></td></tr>
<tr class="memdesc:gab69886c7119a5054a972d8c735f15928"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle that is returned from a <a class="el" href="group___u_a_r_t.html#gab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a> call. <br /></td></tr>
<tr class="separator:gab69886c7119a5054a972d8c735f15928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad76c76927ec6631b4866dad2aad1a65f"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gad76c76927ec6631b4866dad2aad1a65f">UART_Callback</a>) (<a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle, void *buf, size_t count, void *userArg, int_fast16_t status)</td></tr>
<tr class="memdesc:gad76c76927ec6631b4866dad2aad1a65f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a callback function used by the UART driver when used in <a class="el" href="group___u_a_r_t.html#gga2507a620dba95cd20885c52494d19e90ac3b9a056e3ff09ece6ffc77bd2cc73cd">UART_Mode_CALLBACK</a>. The callback can occur in task or interrupt context.  <a href="#gad76c76927ec6631b4866dad2aad1a65f">More...</a><br /></td></tr>
<tr class="separator:gad76c76927ec6631b4866dad2aad1a65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73ea5d30bfa43c6989d0526453835570"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga73ea5d30bfa43c6989d0526453835570">UART_EventCallback</a>) (<a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle, uint32_t event, uint32_t data, void *userArg)</td></tr>
<tr class="memdesc:ga73ea5d30bfa43c6989d0526453835570"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a callback function used by the UART driver. The callback can occur in task or interrupt context.  <a href="#ga73ea5d30bfa43c6989d0526453835570">More...</a><br /></td></tr>
<tr class="separator:ga73ea5d30bfa43c6989d0526453835570"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga2507a620dba95cd20885c52494d19e90"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga2507a620dba95cd20885c52494d19e90">UART_Mode</a> { <br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga2507a620dba95cd20885c52494d19e90a09c2d5349786d1199eb87dc040f3d724">UART_Mode_BLOCKING</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga2507a620dba95cd20885c52494d19e90ac3b9a056e3ff09ece6ffc77bd2cc73cd">UART_Mode_CALLBACK</a>, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga2507a620dba95cd20885c52494d19e90aae3d94ffdc69f8502e9b77368b551d6d">UART_Mode_NONBLOCKING</a>
<br />
 }<tr class="memdesc:ga2507a620dba95cd20885c52494d19e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART mode settings.  <a href="group___u_a_r_t.html#ga2507a620dba95cd20885c52494d19e90">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga2507a620dba95cd20885c52494d19e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed1c183ba0f637f74802cd791c618699"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gaed1c183ba0f637f74802cd791c618699">UART_ReadReturnMode</a> { <br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#ggaed1c183ba0f637f74802cd791c618699ac94c79c5434492f93835d1cd4becf634">UART_ReadReturnMode_FULL</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#ggaed1c183ba0f637f74802cd791c618699ad9b96a0d8982193a33746823022620b3">UART_ReadReturnMode_PARTIAL</a>
<br />
 }<tr class="memdesc:gaed1c183ba0f637f74802cd791c618699"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART return mode settings.  <a href="group___u_a_r_t.html#gaed1c183ba0f637f74802cd791c618699">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gaed1c183ba0f637f74802cd791c618699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa425797a2c950b9861fd62a11397b927"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gaa425797a2c950b9861fd62a11397b927">UART_DataLen</a> { <br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#ggaa425797a2c950b9861fd62a11397b927ab7cfd7ccebeb03dbfa9a41aa81ea08f0">UART_DataLen_5</a> = DL_UART_WORD_LENGTH_5_BITS, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#ggaa425797a2c950b9861fd62a11397b927a013ef018fd7e410c7c23a29569c15fbf">UART_DataLen_6</a> = DL_UART_WORD_LENGTH_6_BITS, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#ggaa425797a2c950b9861fd62a11397b927a4e332707b975b874c541438df19324d7">UART_DataLen_7</a> = DL_UART_WORD_LENGTH_7_BITS, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#ggaa425797a2c950b9861fd62a11397b927af5e26b46165112ab3553311fc7dbd6ce">UART_DataLen_8</a> = DL_UART_WORD_LENGTH_8_BITS
<br />
 }<tr class="memdesc:gaa425797a2c950b9861fd62a11397b927"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART data length settings.  <a href="group___u_a_r_t.html#gaa425797a2c950b9861fd62a11397b927">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gaa425797a2c950b9861fd62a11397b927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga134ee767f3eaf8d26f6d0dd96d982f70"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga134ee767f3eaf8d26f6d0dd96d982f70">UART_StopBits</a> { <br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga134ee767f3eaf8d26f6d0dd96d982f70aaedac7fd9efece6190fa462208163bc1">UART_StopBits_1</a> = DL_UART_STOP_BITS_ONE, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga134ee767f3eaf8d26f6d0dd96d982f70a36fcdab28dabe4a95c0b024a3c0e217e">UART_StopBits_2</a> = DL_UART_STOP_BITS_TWO
<br />
 }<tr class="memdesc:ga134ee767f3eaf8d26f6d0dd96d982f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART stop bit settings.  <a href="group___u_a_r_t.html#ga134ee767f3eaf8d26f6d0dd96d982f70">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga134ee767f3eaf8d26f6d0dd96d982f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdde0d1dd91ce599c9df7327b45986cc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gafdde0d1dd91ce599c9df7327b45986cc">UART_Parity</a> { <br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#ggafdde0d1dd91ce599c9df7327b45986cca0986d9690afff86b48a566979e805f28">UART_Parity_NONE</a> = DL_UART_PARITY_NONE, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#ggafdde0d1dd91ce599c9df7327b45986ccaae142664e6e4376544af63eacc40ed88">UART_Parity_EVEN</a> = DL_UART_PARITY_EVEN, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#ggafdde0d1dd91ce599c9df7327b45986ccaf64f4b5c56a26f95ca696a38a7775465">UART_Parity_ODD</a> = DL_UART_PARITY_ODD, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#ggafdde0d1dd91ce599c9df7327b45986ccaada41a0008a9205bab9197d28ddd3006">UART_Parity_ZERO</a> = DL_UART_PARITY_STICK_ZERO, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#ggafdde0d1dd91ce599c9df7327b45986cca43196da1132245b83886ef66bd6cd5e3">UART_Parity_ONE</a> = DL_UART_PARITY_STICK_ONE
<br />
 }<tr class="memdesc:gafdde0d1dd91ce599c9df7327b45986cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART parity type settings.  <a href="group___u_a_r_t.html#gafdde0d1dd91ce599c9df7327b45986cc">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gafdde0d1dd91ce599c9df7327b45986cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga40e5c0823bb7ffd2e8fbf19f9f20b399"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga40e5c0823bb7ffd2e8fbf19f9f20b399">UART_Params_init</a> (<a class="el" href="struct_u_a_r_t___params.html">UART_Params</a> *params)</td></tr>
<tr class="memdesc:ga40e5c0823bb7ffd2e8fbf19f9f20b399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize the <a class="el" href="struct_u_a_r_t___params.html">UART_Params</a> struct to its defaults.  <a href="#ga40e5c0823bb7ffd2e8fbf19f9f20b399">More...</a><br /></td></tr>
<tr class="separator:ga40e5c0823bb7ffd2e8fbf19f9f20b399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6d1d6b7b1f9922484f9b8a0f78ed030"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gab6d1d6b7b1f9922484f9b8a0f78ed030">UART_open</a> (uint_least8_t index, <a class="el" href="struct_u_a_r_t___params.html">UART_Params</a> *params)</td></tr>
<tr class="memdesc:gab6d1d6b7b1f9922484f9b8a0f78ed030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize a given UART peripheral.  <a href="#gab6d1d6b7b1f9922484f9b8a0f78ed030">More...</a><br /></td></tr>
<tr class="separator:gab6d1d6b7b1f9922484f9b8a0f78ed030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b49b65f3db709c408dc4db23a68895d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga6b49b65f3db709c408dc4db23a68895d">UART_close</a> (<a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:ga6b49b65f3db709c408dc4db23a68895d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to close a UART peripheral specified by the UART handle.  <a href="#ga6b49b65f3db709c408dc4db23a68895d">More...</a><br /></td></tr>
<tr class="separator:ga6b49b65f3db709c408dc4db23a68895d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad50d1543185c1821e7536f7ccc7b354"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gaad50d1543185c1821e7536f7ccc7b354">UART_read</a> (<a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle, void *buf, size_t size, size_t *bytesRead)</td></tr>
<tr class="memdesc:gaad50d1543185c1821e7536f7ccc7b354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that reads data from a UART.  <a href="#gaad50d1543185c1821e7536f7ccc7b354">More...</a><br /></td></tr>
<tr class="separator:gaad50d1543185c1821e7536f7ccc7b354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecade38d5a49d876b2374ae314d30fbe"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gaecade38d5a49d876b2374ae314d30fbe">UART_write</a> (<a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle, const void *buf, size_t size, size_t *bytesWritten)</td></tr>
<tr class="memdesc:gaecade38d5a49d876b2374ae314d30fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that writes data to a UART.  <a href="#gaecade38d5a49d876b2374ae314d30fbe">More...</a><br /></td></tr>
<tr class="separator:gaecade38d5a49d876b2374ae314d30fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4bcbefb657b0e77f04c941102f6f1b9"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gae4bcbefb657b0e77f04c941102f6f1b9">UART_readTimeout</a> (<a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle, void *buf, size_t size, size_t *bytesRead, uint32_t timeout)</td></tr>
<tr class="memdesc:gae4bcbefb657b0e77f04c941102f6f1b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART read with timeout. Note that the timeout parameter is different from the hardware read timeout.  <a href="#gae4bcbefb657b0e77f04c941102f6f1b9">More...</a><br /></td></tr>
<tr class="separator:gae4bcbefb657b0e77f04c941102f6f1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad673f06c7ed88bb011daa56f33f0dc31"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gad673f06c7ed88bb011daa56f33f0dc31">UART_writeTimeout</a> (<a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle, const void *buf, size_t size, size_t *bytesWritten, uint32_t timeout)</td></tr>
<tr class="memdesc:gad673f06c7ed88bb011daa56f33f0dc31"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART write with timeout. Note that the timeout parameter is different from the hardware read timeout.  <a href="#gad673f06c7ed88bb011daa56f33f0dc31">More...</a><br /></td></tr>
<tr class="separator:gad673f06c7ed88bb011daa56f33f0dc31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51ed7e94d5b409ca1fcb2d65c5a25c3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga51ed7e94d5b409ca1fcb2d65c5a25c3c">UART_readCancel</a> (<a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:ga51ed7e94d5b409ca1fcb2d65c5a25c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that cancels a <a class="el" href="group___u_a_r_t.html#gaad50d1543185c1821e7536f7ccc7b354" title="Function that reads data from a UART. ">UART_read()</a> function call.  <a href="#ga51ed7e94d5b409ca1fcb2d65c5a25c3c">More...</a><br /></td></tr>
<tr class="separator:ga51ed7e94d5b409ca1fcb2d65c5a25c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0482cd0ab9ee7e802c8e785a5754d16d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga0482cd0ab9ee7e802c8e785a5754d16d">UART_writeCancel</a> (<a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:ga0482cd0ab9ee7e802c8e785a5754d16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that cancels a <a class="el" href="group___u_a_r_t.html#gaecade38d5a49d876b2374ae314d30fbe" title="Function that writes data to a UART. ">UART_write()</a> function call.  <a href="#ga0482cd0ab9ee7e802c8e785a5754d16d">More...</a><br /></td></tr>
<tr class="separator:ga0482cd0ab9ee7e802c8e785a5754d16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b22c82e2eb2ec5d570cd22b2ec87608"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga8b22c82e2eb2ec5d570cd22b2ec87608">UART_rxDisable</a> (<a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:ga8b22c82e2eb2ec5d570cd22b2ec87608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that disables collecting of RX data into the circular buffer.  <a href="#ga8b22c82e2eb2ec5d570cd22b2ec87608">More...</a><br /></td></tr>
<tr class="separator:ga8b22c82e2eb2ec5d570cd22b2ec87608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga880f05af6177130937c36af9bb536e28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga880f05af6177130937c36af9bb536e28">UART_rxEnable</a> (<a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:ga880f05af6177130937c36af9bb536e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that enables collecting of RX data into the circular buffer.  <a href="#ga880f05af6177130937c36af9bb536e28">More...</a><br /></td></tr>
<tr class="separator:ga880f05af6177130937c36af9bb536e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1183c78e6a927e9aac41fd3bdb0d822d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga1183c78e6a927e9aac41fd3bdb0d822d">UART_flushRx</a> (<a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:ga1183c78e6a927e9aac41fd3bdb0d822d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to flush data in the UART RX FIFO.  <a href="#ga1183c78e6a927e9aac41fd3bdb0d822d">More...</a><br /></td></tr>
<tr class="separator:ga1183c78e6a927e9aac41fd3bdb0d822d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1203f59384eb903f7b903f52038115dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga1203f59384eb903f7b903f52038115dd">UART_getRxCount</a> (<a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:ga1203f59384eb903f7b903f52038115dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bytes available in the circular buffer.  <a href="#ga1203f59384eb903f7b903f52038115dd">More...</a><br /></td></tr>
<tr class="separator:ga1203f59384eb903f7b903f52038115dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The UART header file should be included in an application as follows: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_u_a_r_t_8h.html">ti/drivers/UART.h</a>&gt;</span></div></div><!-- fragment --><p><a class="anchor" id="ti_drivers_UART_Overview"></a></p><h1>Overview</h1>
<p>UART has both RX and TX ring buffers for receiving/sending data. UART uses DMA to transfer data between the UART FIFOs and the RX and TX ring buffers in blocking mode. In callback mode, DMA will transfer data straight between the hardware FIFO and the source/destination buffer supplied by the application. NOTE: If the source-buffer for a TX operation resides in flash, the driver will constrain the flash to remain on during idle. The UART APIs for reading and writing data have been made more posix-like. UART provides for event notification, allowing the application to receive TX start and completion events, and RX error events. </p><dl class="section note"><dt>Note</dt><dd>These events are synchronous to what can be observed on the data lines. A UART_STAT_TXFE_SET event will for example only occur after all data has been shifted from the hardware FIFO out onto the TX-pin. In contrast, read and write-callbacks are invoked when the driver has finished writing data into the hardware FIFO.</dd></dl>
<p>To use the UART driver, ensure that the correct driver library for your device is linked in and include this header file as follows: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_u_a_r_t_8h.html">ti/drivers/UART.h</a>&gt;</span></div></div><!-- fragment --> <h2 class="groupheader">Typedef Documentation</h2>
<a id="gad76c76927ec6631b4866dad2aad1a65f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad76c76927ec6631b4866dad2aad1a65f">&sect;&nbsp;</a></span>UART_Callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* UART_Callback) (<a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle, void *buf, size_t count, void *userArg, int_fast16_t status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The definition of a callback function used by the UART driver when used in <a class="el" href="group___u_a_r_t.html#gga2507a620dba95cd20885c52494d19e90ac3b9a056e3ff09ece6ffc77bd2cc73cd">UART_Mode_CALLBACK</a>. The callback can occur in task or interrupt context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UART_Handle</td><td>UART_Handle.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Pointer to read/write buffer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements read/written.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userArg</td><td>A user supplied argument specified in <a class="el" href="struct_u_a_r_t___params.html">UART_Params</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>A <a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html">UART status codes</a> code indicating success or failure of the transfer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga73ea5d30bfa43c6989d0526453835570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73ea5d30bfa43c6989d0526453835570">&sect;&nbsp;</a></span>UART_EventCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* UART_EventCallback) (<a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle, uint32_t event, uint32_t data, void *userArg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The definition of a callback function used by the UART driver. The callback can occur in task or interrupt context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UART_Handle</td><td>UART_Handle.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>UART_EVENT that has occurred.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>One of the following<ul>
<li>UART_EVENT_OVERRUN: accumulated count</li>
<li>UART_EVENT_BREAK: unused</li>
<li>UART_EVENT_PARITY: unused</li>
<li>UART_EVENT_FRAMING: unused</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userArg</td><td>A user supplied argument specified in <a class="el" href="struct_u_a_r_t___params.html">UART_Params</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>A UART_STATUS code indicating success or failure of the transfer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga2507a620dba95cd20885c52494d19e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2507a620dba95cd20885c52494d19e90">&sect;&nbsp;</a></span>UART_Mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t.html#ga2507a620dba95cd20885c52494d19e90">UART_Mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART mode settings. </p>
<p>This enum defines the read and write modes for the configured UART. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga2507a620dba95cd20885c52494d19e90a09c2d5349786d1199eb87dc040f3d724"></a>UART_Mode_BLOCKING&#160;</td><td class="fielddoc"><p><a class="el" href="group___u_a_r_t.html#gaecade38d5a49d876b2374ae314d30fbe" title="Function that writes data to a UART. ">UART_write()</a> will block the calling task until all of the data can be accepted by the device driver. <a class="el" href="group___u_a_r_t.html#gaad50d1543185c1821e7536f7ccc7b354" title="Function that reads data from a UART. ">UART_read()</a> will block until some data becomes available. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2507a620dba95cd20885c52494d19e90ac3b9a056e3ff09ece6ffc77bd2cc73cd"></a>UART_Mode_CALLBACK&#160;</td><td class="fielddoc"><p>Non-blocking, <a class="el" href="group___u_a_r_t.html#gaecade38d5a49d876b2374ae314d30fbe" title="Function that writes data to a UART. ">UART_write()</a> or <a class="el" href="group___u_a_r_t.html#gaad50d1543185c1821e7536f7ccc7b354" title="Function that reads data from a UART. ">UART_read()</a> will return immediately. When the transfer has finished, the callback function is called from either the caller's context or from an interrupt context. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2507a620dba95cd20885c52494d19e90aae3d94ffdc69f8502e9b77368b551d6d"></a>UART_Mode_NONBLOCKING&#160;</td><td class="fielddoc"><p>Non-blocking, <a class="el" href="group___u_a_r_t.html#gaecade38d5a49d876b2374ae314d30fbe" title="Function that writes data to a UART. ">UART_write()</a> or <a class="el" href="group___u_a_r_t.html#gaad50d1543185c1821e7536f7ccc7b354" title="Function that reads data from a UART. ">UART_read()</a> will return immediately. <a class="el" href="group___u_a_r_t.html#gaecade38d5a49d876b2374ae314d30fbe" title="Function that writes data to a UART. ">UART_write()</a> will copy as much data into the transmit buffer as space allows. <a class="el" href="group___u_a_r_t.html#gaad50d1543185c1821e7536f7ccc7b354" title="Function that reads data from a UART. ">UART_read()</a> will copy as much data from the receive buffer as is immediately available. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaed1c183ba0f637f74802cd791c618699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed1c183ba0f637f74802cd791c618699">&sect;&nbsp;</a></span>UART_ReadReturnMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t.html#gaed1c183ba0f637f74802cd791c618699">UART_ReadReturnMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART return mode settings. </p>
<p>This enumeration defines the return modes for <a class="el" href="group___u_a_r_t.html#gaad50d1543185c1821e7536f7ccc7b354" title="Function that reads data from a UART. ">UART_read()</a>.</p>
<p><a class="el" href="group___u_a_r_t.html#ggaed1c183ba0f637f74802cd791c618699ac94c79c5434492f93835d1cd4becf634">UART_ReadReturnMode_FULL</a> unblocks or performs a callback when the read buffer has been filled with the number of bytes passed to <a class="el" href="group___u_a_r_t.html#gaad50d1543185c1821e7536f7ccc7b354" title="Function that reads data from a UART. ">UART_read()</a>. <a class="el" href="group___u_a_r_t.html#ggaed1c183ba0f637f74802cd791c618699ad9b96a0d8982193a33746823022620b3">UART_ReadReturnMode_PARTIAL</a> unblocks or performs a callback whenever a read timeout error occurs on the UART peripheral. This timeout error is not the same as the blocking read timeout in the <a class="el" href="struct_u_a_r_t___params.html">UART_Params</a>; the read timeout occurs if the read FIFO is non-empty and no new data has been received for a device/baudrate dependent number of clock cycles. This mode can be used when the exact number of bytes to be read is not known. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaed1c183ba0f637f74802cd791c618699ac94c79c5434492f93835d1cd4becf634"></a>UART_ReadReturnMode_FULL&#160;</td><td class="fielddoc"><p>Unblock/callback when buffer is full. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaed1c183ba0f637f74802cd791c618699ad9b96a0d8982193a33746823022620b3"></a>UART_ReadReturnMode_PARTIAL&#160;</td><td class="fielddoc"><p>Unblock/callback when no new data comes in. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaa425797a2c950b9861fd62a11397b927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa425797a2c950b9861fd62a11397b927">&sect;&nbsp;</a></span>UART_DataLen</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t.html#gaa425797a2c950b9861fd62a11397b927">UART_DataLen</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART data length settings. </p>
<p>This enumeration defines the UART data lengths. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa425797a2c950b9861fd62a11397b927ab7cfd7ccebeb03dbfa9a41aa81ea08f0"></a>UART_DataLen_5&#160;</td><td class="fielddoc"><p>Data length is 5 bits </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa425797a2c950b9861fd62a11397b927a013ef018fd7e410c7c23a29569c15fbf"></a>UART_DataLen_6&#160;</td><td class="fielddoc"><p>Data length is 6 bits </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa425797a2c950b9861fd62a11397b927a4e332707b975b874c541438df19324d7"></a>UART_DataLen_7&#160;</td><td class="fielddoc"><p>Data length is 7 bits </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa425797a2c950b9861fd62a11397b927af5e26b46165112ab3553311fc7dbd6ce"></a>UART_DataLen_8&#160;</td><td class="fielddoc"><p>Data length is 8 bits </p>
</td></tr>
</table>

</div>
</div>
<a id="ga134ee767f3eaf8d26f6d0dd96d982f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga134ee767f3eaf8d26f6d0dd96d982f70">&sect;&nbsp;</a></span>UART_StopBits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t.html#ga134ee767f3eaf8d26f6d0dd96d982f70">UART_StopBits</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART stop bit settings. </p>
<p>This enumeration defines the UART stop bits. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga134ee767f3eaf8d26f6d0dd96d982f70aaedac7fd9efece6190fa462208163bc1"></a>UART_StopBits_1&#160;</td><td class="fielddoc"><p>One stop bit </p>
</td></tr>
<tr><td class="fieldname"><a id="gga134ee767f3eaf8d26f6d0dd96d982f70a36fcdab28dabe4a95c0b024a3c0e217e"></a>UART_StopBits_2&#160;</td><td class="fielddoc"><p>Two stop bits </p>
</td></tr>
</table>

</div>
</div>
<a id="gafdde0d1dd91ce599c9df7327b45986cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdde0d1dd91ce599c9df7327b45986cc">&sect;&nbsp;</a></span>UART_Parity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t.html#gafdde0d1dd91ce599c9df7327b45986cc">UART_Parity</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART parity type settings. </p>
<p>This enumeration defines the UART parity types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggafdde0d1dd91ce599c9df7327b45986cca0986d9690afff86b48a566979e805f28"></a>UART_Parity_NONE&#160;</td><td class="fielddoc"><p>No parity </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafdde0d1dd91ce599c9df7327b45986ccaae142664e6e4376544af63eacc40ed88"></a>UART_Parity_EVEN&#160;</td><td class="fielddoc"><p>Parity bit is even </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafdde0d1dd91ce599c9df7327b45986ccaf64f4b5c56a26f95ca696a38a7775465"></a>UART_Parity_ODD&#160;</td><td class="fielddoc"><p>Parity bit is odd </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafdde0d1dd91ce599c9df7327b45986ccaada41a0008a9205bab9197d28ddd3006"></a>UART_Parity_ZERO&#160;</td><td class="fielddoc"><p>Parity bit is always zero </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafdde0d1dd91ce599c9df7327b45986cca43196da1132245b83886ef66bd6cd5e3"></a>UART_Parity_ONE&#160;</td><td class="fielddoc"><p>Parity bit is always one </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga40e5c0823bb7ffd2e8fbf19f9f20b399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40e5c0823bb7ffd2e8fbf19f9f20b399">&sect;&nbsp;</a></span>UART_Params_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_Params_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_a_r_t___params.html">UART_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize the <a class="el" href="struct_u_a_r_t___params.html">UART_Params</a> struct to its defaults. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>A pointer to <a class="el" href="struct_u_a_r_t___params.html">UART_Params</a> structure for initialization.</td></tr>
  </table>
  </dd>
</dl>
<p>Defaults values are: </p><ul>
<li>readMode = UART_Mode_BLOCKING; </li>
<li>writeMode = UART_Mode_BLOCKING; </li>
<li>eventCallback = NULL; </li>
<li>eventMask = 0; </li>
<li>readCallback = NULL; </li>
<li>writeCallback = NULL; </li>
<li>readReturnMode = UART_ReadReturnMode_PARTIAL; </li>
<li>baudRate = 9600; </li>
<li>dataLength = UART_DataLen_8; </li>
<li>stopBits = UART_StopBits_1; </li>
<li>parityType = UART_Parity_NONE; </li>
<li>userArg = NULL; </li>
</ul>

</div>
</div>
<a id="gab6d1d6b7b1f9922484f9b8a0f78ed030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6d1d6b7b1f9922484f9b8a0f78ed030">&sect;&nbsp;</a></span>UART_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a> UART_open </td>
          <td>(</td>
          <td class="paramtype">uint_least8_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_u_a_r_t___params.html">UART_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize a given UART peripheral. </p>
<p>Function to initialize a given UART peripheral specified by the particular index value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Logical peripheral number for the UART indexed into the UART_config table.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Pointer to a <a class="el" href="struct_u_a_r_t___params.html">UART_Params</a> structure. If NULL, default parameter values will be used. All the fields in this structure are read-only. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UART handle </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t.html#ga6b49b65f3db709c408dc4db23a68895d" title="Function to close a UART peripheral specified by the UART handle. ">UART_close()</a> </dd></dl>

</div>
</div>
<a id="ga6b49b65f3db709c408dc4db23a68895d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b49b65f3db709c408dc4db23a68895d">&sect;&nbsp;</a></span>UART_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to close a UART peripheral specified by the UART handle. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group___u_a_r_t.html#gab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a> has been called. </dd>
<dd>
There are no ongoing read or write calls. Any ongoing read or write calls can be cancelled with <a class="el" href="group___u_a_r_t.html#ga51ed7e94d5b409ca1fcb2d65c5a25c3c" title="Function that cancels a UART_read() function call. ">UART_readCancel()</a> or <a class="el" href="group___u_a_r_t.html#ga0482cd0ab9ee7e802c8e785a5754d16d" title="Function that cancels a UART_write() function call. ">UART_writeCancel()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>A <a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928" title="A handle that is returned from a UART_open() call. ">UART_Handle</a> returned from <a class="el" href="group___u_a_r_t.html#gab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t.html#gab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a> </dd></dl>

</div>
</div>
<a id="gaad50d1543185c1821e7536f7ccc7b354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad50d1543185c1821e7536f7ccc7b354">&sect;&nbsp;</a></span>UART_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t UART_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>bytesRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that reads data from a UART. </p>
<p><a class="el" href="group___u_a_r_t.html#gaad50d1543185c1821e7536f7ccc7b354">UART_read()</a> reads data from a UART controller. The destination is specified by <em>buffer</em> and the number of bytes to read is given by <em>size</em>.</p>
<p>In <a class="el" href="group___u_a_r_t.html#gga2507a620dba95cd20885c52494d19e90a09c2d5349786d1199eb87dc040f3d724">UART_Mode_BLOCKING</a>, <a class="el" href="group___u_a_r_t.html#gaad50d1543185c1821e7536f7ccc7b354">UART_read()</a> blocks task execution until all the data in buffer has been read, if the read return mode is <a class="el" href="group___u_a_r_t.html#ggaed1c183ba0f637f74802cd791c618699ac94c79c5434492f93835d1cd4becf634">UART_ReadReturnMode_FULL</a>. If the read return mode is <a class="el" href="group___u_a_r_t.html#ggaed1c183ba0f637f74802cd791c618699ad9b96a0d8982193a33746823022620b3">UART_ReadReturnMode_PARTIAL</a>, <a class="el" href="group___u_a_r_t.html#gaad50d1543185c1821e7536f7ccc7b354">UART_read()</a> returns before all the data has been read, if some data has been received, but reception has been inactive sufficiently long for a hardware read timeout to occur (e.g., for a 32-bit period). If a receive error occurs (e.g., framing, FIFO overrun), <a class="el" href="group___u_a_r_t.html#gaad50d1543185c1821e7536f7ccc7b354">UART_read()</a> will return with the number of bytes read up to the occurrence of the error.</p>
<p>In <a class="el" href="group___u_a_r_t.html#gga2507a620dba95cd20885c52494d19e90ac3b9a056e3ff09ece6ffc77bd2cc73cd">UART_Mode_CALLBACK</a>, <a class="el" href="group___u_a_r_t.html#gaad50d1543185c1821e7536f7ccc7b354">UART_read()</a> does not block task execution. Instead, a callback function specified by <a class="el" href="struct_u_a_r_t___params.html#a5457b86b6793f1c4757457b9b22e379d">UART_Params::readCallback</a> is called when the transfer is finished (<a class="el" href="group___u_a_r_t.html#ggaed1c183ba0f637f74802cd791c618699ac94c79c5434492f93835d1cd4becf634">UART_ReadReturnMode_FULL</a>), or reception has become inactive (<a class="el" href="group___u_a_r_t.html#ggaed1c183ba0f637f74802cd791c618699ad9b96a0d8982193a33746823022620b3">UART_ReadReturnMode_PARTIAL</a>). The callback function can occur in the caller's context or in SWI context, depending on the device-specific implementation. An unfinished asynchronous read operation must always be cancelled using <a class="el" href="group___u_a_r_t.html#ga51ed7e94d5b409ca1fcb2d65c5a25c3c" title="Function that cancels a UART_read() function call. ">UART_readCancel()</a> before calling <a class="el" href="group___u_a_r_t.html#ga6b49b65f3db709c408dc4db23a68895d" title="Function to close a UART peripheral specified by the UART handle. ">UART_close()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>It is ok to call <a class="el" href="group___u_a_r_t.html#gaad50d1543185c1821e7536f7ccc7b354">UART_read()</a> from its own callback function when in <a class="el" href="group___u_a_r_t.html#gga2507a620dba95cd20885c52494d19e90ac3b9a056e3ff09ece6ffc77bd2cc73cd">UART_Mode_CALLBACK</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>A <a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928" title="A handle that is returned from a UART_open() call. ">UART_Handle</a> returned by <a class="el" href="group___u_a_r_t.html#gab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>A pointer to an empty buffer to which received data should be read.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of bytes to be read into buffer.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bytesRead</td><td>If non-NULL, the location to store the number of bytes actually read into the buffer. If NULL, this parameter will be ignored. In callback mode, NULL could be passed in for this parameter, since the callback function will be passed the number of bytes read. In blocking mode, NULL can be passed, however, status should be checked in case the number of bytes requested was not received due to errors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status indicating success or failure of the read.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#ga101b7761f89b3ec49f0c6726669acfed" title="Successful status code returned by UART APIs. ">UART_STATUS_SUCCESS</a></td><td>The call was successful. </td></tr>
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#gaa658b16955ceabc4e33e31cab6444b3e" title="The UART is currently in use. ">UART_STATUS_EINUSE</a></td><td>Another read from the UART is currently ongoing. </td></tr>
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#ga69975d5ab5731732cb732df574ca11e2" title="A UART_write() or UART_read() operation was cancelled. ">UART_STATUS_ECANCELLED</a></td><td>In <a class="el" href="group___u_a_r_t.html#gga2507a620dba95cd20885c52494d19e90a09c2d5349786d1199eb87dc040f3d724">UART_Mode_BLOCKING</a>, the read was canceled by a call to <a class="el" href="group___u_a_r_t.html#ga51ed7e94d5b409ca1fcb2d65c5a25c3c" title="Function that cancels a UART_read() function call. ">UART_readCancel()</a> before any data could be received. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaecade38d5a49d876b2374ae314d30fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecade38d5a49d876b2374ae314d30fbe">&sect;&nbsp;</a></span>UART_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t UART_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>bytesWritten</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that writes data to a UART. </p>
<p><a class="el" href="group___u_a_r_t.html#gaecade38d5a49d876b2374ae314d30fbe">UART_write()</a> writes data from a memory buffer to the UART interface. The source is specified by <em>buffer</em> and the number of bytes to write is given by <em>size</em>.</p>
<p>In <a class="el" href="group___u_a_r_t.html#gga2507a620dba95cd20885c52494d19e90a09c2d5349786d1199eb87dc040f3d724">UART_Mode_BLOCKING</a>, <a class="el" href="group___u_a_r_t.html#gaecade38d5a49d876b2374ae314d30fbe" title="Function that writes data to a UART. ">UART_write()</a> blocks task execution until all the data in buffer has been transmitted onto the TX pin.</p>
<p>In <a class="el" href="group___u_a_r_t.html#gga2507a620dba95cd20885c52494d19e90ac3b9a056e3ff09ece6ffc77bd2cc73cd">UART_Mode_CALLBACK</a>, <a class="el" href="group___u_a_r_t.html#gaecade38d5a49d876b2374ae314d30fbe">UART_write()</a> does not block task execution. Instead, a callback function specified by <a class="el" href="struct_u_a_r_t___params.html#a0497d8a55aea66d3ab2118f8966e8e33">UART_Params::writeCallback</a> is called when all data has been written to the hardware FIFO. This means that that driver is ready to accept another call to <a class="el" href="group___u_a_r_t.html#gaecade38d5a49d876b2374ae314d30fbe" title="Function that writes data to a UART. ">UART_write()</a>. </p><dl class="section note"><dt>Note</dt><dd>In contrast to <a class="el" href="group___u_a_r_t.html#gga2507a620dba95cd20885c52494d19e90a09c2d5349786d1199eb87dc040f3d724">UART_Mode_BLOCKING</a>, it is not guaranteed that all data has been transmitted onto the TX pin when callback is invoked.</dd></dl>
<p>The buffer passed to <a class="el" href="group___u_a_r_t.html#gaecade38d5a49d876b2374ae314d30fbe" title="Function that writes data to a UART. ">UART_write()</a> in <a class="el" href="group___u_a_r_t.html#gga2507a620dba95cd20885c52494d19e90ac3b9a056e3ff09ece6ffc77bd2cc73cd">UART_Mode_CALLBACK</a> is not copied. The buffer must remain coherent until all the characters have been sent (ie until the write callback has been called with a byte count equal to that passed to <a class="el" href="group___u_a_r_t.html#gaecade38d5a49d876b2374ae314d30fbe" title="Function that writes data to a UART. ">UART_write()</a>). The callback function can occur in the caller's task context or in interrupt context, depending on the device implementation. An unfinished asynchronous write operation must always be cancelled using <a class="el" href="group___u_a_r_t.html#ga0482cd0ab9ee7e802c8e785a5754d16d" title="Function that cancels a UART_write() function call. ">UART_writeCancel()</a> before calling <a class="el" href="group___u_a_r_t.html#ga6b49b65f3db709c408dc4db23a68895d" title="Function to close a UART peripheral specified by the UART handle. ">UART_close()</a>.</p>
<p>The bytesWritten parameter should not be NULL so the application can determine the number of bytes actually written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>A <a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928" title="A handle that is returned from a UART_open() call. ">UART_Handle</a> returned by <a class="el" href="group___u_a_r_t.html#gab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>A read-only pointer to buffer containing data to be written to the UART.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of bytes in the buffer that should be written to the UART.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bytesWritten</td><td>If non-NULL, the location to store the number of bytes actually written to the UART in UART_Mode_BLOCKING. In UART_Mode_CALLBACK, bytesWritten will be set to 0. If bytesWritten is NULL, this parameter will be ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status indicating success or failure of the write.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#ga101b7761f89b3ec49f0c6726669acfed" title="Successful status code returned by UART APIs. ">UART_STATUS_SUCCESS</a></td><td>The call was successful. </td></tr>
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#gaa658b16955ceabc4e33e31cab6444b3e" title="The UART is currently in use. ">UART_STATUS_EINUSE</a></td><td>Another write to the UART is currently ongoing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae4bcbefb657b0e77f04c941102f6f1b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4bcbefb657b0e77f04c941102f6f1b9">&sect;&nbsp;</a></span>UART_readTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t UART_readTimeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>bytesRead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART read with timeout. Note that the timeout parameter is different from the hardware read timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>UART_Handle instance from <a class="el" href="group___u_a_r_t.html#gab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>location where the data to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>amount of data to write in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bytesRead</td><td>If non-NULL, the location to store the number of bytes actually read into the buffer. If NULL, this parameter will be ignored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>The number of system clock ticks to wait until all data is received. If not all requested data was received within the timeout period, an error of UART_STATUS_ETIMEOUT will be returned. This parameter is only applicable to <a class="el" href="group___u_a_r_t.html#gga2507a620dba95cd20885c52494d19e90a09c2d5349786d1199eb87dc040f3d724">UART_Mode_BLOCKING</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status indicating success or failure of the read.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#ga101b7761f89b3ec49f0c6726669acfed" title="Successful status code returned by UART APIs. ">UART_STATUS_SUCCESS</a></td><td>The call was successful. </td></tr>
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#gaa658b16955ceabc4e33e31cab6444b3e" title="The UART is currently in use. ">UART_STATUS_EINUSE</a></td><td>Another read from the UART is currently ongoing. </td></tr>
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#ga69975d5ab5731732cb732df574ca11e2" title="A UART_write() or UART_read() operation was cancelled. ">UART_STATUS_ECANCELLED</a></td><td>In <a class="el" href="group___u_a_r_t.html#gga2507a620dba95cd20885c52494d19e90a09c2d5349786d1199eb87dc040f3d724">UART_Mode_BLOCKING</a>, the read was canceled by a call to <a class="el" href="group___u_a_r_t.html#ga51ed7e94d5b409ca1fcb2d65c5a25c3c" title="Function that cancels a UART_read() function call. ">UART_readCancel()</a> before any data could be received. </td></tr>
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#gadf2c0d2a0415c62c147a736424028f9a" title="A timeout occurred for a blocking UART_read or UART_write call. ">UART_STATUS_ETIMEOUT</a></td><td>The read operation timed out. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad673f06c7ed88bb011daa56f33f0dc31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad673f06c7ed88bb011daa56f33f0dc31">&sect;&nbsp;</a></span>UART_writeTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t UART_writeTimeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>bytesWritten</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART write with timeout. Note that the timeout parameter is different from the hardware read timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>UART_Handle instance from <a class="el" href="group___u_a_r_t.html#gab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>location to write data from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>amount of data to write in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bytesWritten</td><td>If non-NULL, the location to store the number of bytes actually written into the buffer. If NULL, this parameter will be ignored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>The number of system clock ticks to wait for the write to complete (<a class="el" href="group___u_a_r_t.html#gga2507a620dba95cd20885c52494d19e90a09c2d5349786d1199eb87dc040f3d724">UART_Mode_BLOCKING</a> only). If the timeout expires before all bytes are written, a status of UART_STATUS_ETIMEOUT will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status indicating success or failure of the write.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#ga101b7761f89b3ec49f0c6726669acfed" title="Successful status code returned by UART APIs. ">UART_STATUS_SUCCESS</a></td><td>The call was successful. </td></tr>
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#gaa658b16955ceabc4e33e31cab6444b3e" title="The UART is currently in use. ">UART_STATUS_EINUSE</a></td><td>Another write to the UART is currently ongoing. </td></tr>
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#gadf2c0d2a0415c62c147a736424028f9a" title="A timeout occurred for a blocking UART_read or UART_write call. ">UART_STATUS_ETIMEOUT</a></td><td>The write operation timed out. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga51ed7e94d5b409ca1fcb2d65c5a25c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51ed7e94d5b409ca1fcb2d65c5a25c3c">&sect;&nbsp;</a></span>UART_readCancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_readCancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that cancels a <a class="el" href="group___u_a_r_t.html#gaad50d1543185c1821e7536f7ccc7b354" title="Function that reads data from a UART. ">UART_read()</a> function call. </p>
<p>This function cancels an asynchronous <a class="el" href="group___u_a_r_t.html#gaad50d1543185c1821e7536f7ccc7b354" title="Function that reads data from a UART. ">UART_read()</a> operation in in <a class="el" href="group___u_a_r_t.html#gga2507a620dba95cd20885c52494d19e90ac3b9a056e3ff09ece6ffc77bd2cc73cd">UART_Mode_CALLBACK</a>, or unblocks a <a class="el" href="group___u_a_r_t.html#gaad50d1543185c1821e7536f7ccc7b354" title="Function that reads data from a UART. ">UART_read()</a> call in <a class="el" href="group___u_a_r_t.html#gga2507a620dba95cd20885c52494d19e90a09c2d5349786d1199eb87dc040f3d724">UART_Mode_BLOCKING</a>. In <a class="el" href="group___u_a_r_t.html#gga2507a620dba95cd20885c52494d19e90ac3b9a056e3ff09ece6ffc77bd2cc73cd">UART_Mode_CALLBACK</a>, <a class="el" href="group___u_a_r_t.html#ga51ed7e94d5b409ca1fcb2d65c5a25c3c" title="Function that cancels a UART_read() function call. ">UART_readCancel()</a> calls the registered read callback function with the number of bytes received so far. It is the application's responsibility to check the count argument in the callback function and handle the case where only a subset of the bytes were received. The callback function will be passed a status of <a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#ga69975d5ab5731732cb732df574ca11e2" title="A UART_write() or UART_read() operation was cancelled. ">UART_STATUS_ECANCELLED</a>.</p>
<p>In <a class="el" href="group___u_a_r_t.html#gga2507a620dba95cd20885c52494d19e90a09c2d5349786d1199eb87dc040f3d724">UART_Mode_BLOCKING</a>, <a class="el" href="group___u_a_r_t.html#gaad50d1543185c1821e7536f7ccc7b354" title="Function that reads data from a UART. ">UART_read()</a> will return <a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#ga69975d5ab5731732cb732df574ca11e2" title="A UART_write() or UART_read() operation was cancelled. ">UART_STATUS_ECANCELLED</a>, and the bytesRead parameter will be set to the number of bytes received so far.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>A <a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928" title="A handle that is returned from a UART_open() call. ">UART_Handle</a> returned by <a class="el" href="group___u_a_r_t.html#gab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0482cd0ab9ee7e802c8e785a5754d16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0482cd0ab9ee7e802c8e785a5754d16d">&sect;&nbsp;</a></span>UART_writeCancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_writeCancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that cancels a <a class="el" href="group___u_a_r_t.html#gaecade38d5a49d876b2374ae314d30fbe" title="Function that writes data to a UART. ">UART_write()</a> function call. </p>
<p>This function cancels an asynchronous <a class="el" href="group___u_a_r_t.html#gaecade38d5a49d876b2374ae314d30fbe" title="Function that writes data to a UART. ">UART_write()</a> operation when write mode is <a class="el" href="group___u_a_r_t.html#gga2507a620dba95cd20885c52494d19e90ac3b9a056e3ff09ece6ffc77bd2cc73cd">UART_Mode_CALLBACK</a>. In callback mode, <a class="el" href="group___u_a_r_t.html#ga0482cd0ab9ee7e802c8e785a5754d16d" title="Function that cancels a UART_write() function call. ">UART_writeCancel()</a> calls the registered write callback function no matter how many bytes were sent. It is the application's responsibility to check the count argument in the callback function and handle cases where only a subset of the bytes were sent. The callback function will be passed a status of <a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#ga69975d5ab5731732cb732df574ca11e2" title="A UART_write() or UART_read() operation was cancelled. ">UART_STATUS_ECANCELLED</a>. In blocking mode, <a class="el" href="group___u_a_r_t.html#gaecade38d5a49d876b2374ae314d30fbe" title="Function that writes data to a UART. ">UART_write()</a> will return <a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#ga69975d5ab5731732cb732df574ca11e2" title="A UART_write() or UART_read() operation was cancelled. ">UART_STATUS_ECANCELLED</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The above applies to <a class="el" href="group___u_a_r_t.html#gad673f06c7ed88bb011daa56f33f0dc31">UART_writeTimeout()</a> as well.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>A <a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928" title="A handle that is returned from a UART_open() call. ">UART_Handle</a> returned by <a class="el" href="group___u_a_r_t.html#gab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8b22c82e2eb2ec5d570cd22b2ec87608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b22c82e2eb2ec5d570cd22b2ec87608">&sect;&nbsp;</a></span>UART_rxDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_rxDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that disables collecting of RX data into the circular buffer. </p>
<p>The driver implementation uses a circular buffer to collect RX data while a <a class="el" href="group___u_a_r_t.html#gaad50d1543185c1821e7536f7ccc7b354" title="Function that reads data from a UART. ">UART_read()</a> is not in progress. This function will disable buffering of RX data into the circular buffer. <a class="el" href="group___u_a_r_t.html#gaad50d1543185c1821e7536f7ccc7b354" title="Function that reads data from a UART. ">UART_read()</a> will read directly from the UART driver's RX buffer. Disabling the circular buffer will also allow the device to go into low power modes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>A <a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928" title="A handle that is returned from a UART_open() call. ">UART_Handle</a> returned by <a class="el" href="group___u_a_r_t.html#gab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t.html#ga880f05af6177130937c36af9bb536e28" title="Function that enables collecting of RX data into the circular buffer. ">UART_rxEnable()</a> </dd></dl>

</div>
</div>
<a id="ga880f05af6177130937c36af9bb536e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga880f05af6177130937c36af9bb536e28">&sect;&nbsp;</a></span>UART_rxEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_rxEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that enables collecting of RX data into the circular buffer. </p>
<p>The driver implementation uses a circular buffer to collect RX data while a <a class="el" href="group___u_a_r_t.html#gaad50d1543185c1821e7536f7ccc7b354" title="Function that reads data from a UART. ">UART_read()</a> is not in progress. This function will enable buffering of RX data into the circular buffer. <a class="el" href="group___u_a_r_t.html#gaad50d1543185c1821e7536f7ccc7b354" title="Function that reads data from a UART. ">UART_read()</a> will read directly from the UART drivers RX buffer. Enabling the circular buffer will also prevent the device from going into low power modes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>A <a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928" title="A handle that is returned from a UART_open() call. ">UART_Handle</a> returned by <a class="el" href="group___u_a_r_t.html#gab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t.html#ga8b22c82e2eb2ec5d570cd22b2ec87608" title="Function that disables collecting of RX data into the circular buffer. ">UART_rxDisable()</a> </dd></dl>

</div>
</div>
<a id="ga1183c78e6a927e9aac41fd3bdb0d822d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1183c78e6a927e9aac41fd3bdb0d822d">&sect;&nbsp;</a></span>UART_flushRx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_flushRx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to flush data in the UART RX FIFO. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group___u_a_r_t.html#gab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a> has been called.</dd></dl>
<p>This function can be called to remove all data from the RX FIFO, for example, after a UART read error has occurred. All data in the RX circular buffer will be discarded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>A <a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928" title="A handle that is returned from a UART_open() call. ">UART_Handle</a> returned from <a class="el" href="group___u_a_r_t.html#gab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1203f59384eb903f7b903f52038115dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1203f59384eb903f7b903f52038115dd">&sect;&nbsp;</a></span>UART_getRxCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_getRxCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of bytes available in the circular buffer. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group___u_a_r_t.html#gab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a> has been called.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>A <a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928" title="A handle that is returned from a UART_open() call. ">UART_Handle</a> returned from <a class="el" href="group___u_a_r_t.html#gab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes available in the RX circular buffer.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t.html#ga880f05af6177130937c36af9bb536e28" title="Function that enables collecting of RX data into the circular buffer. ">UART_rxEnable()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">© Copyright 1995-2025</a>, Texas Instruments Incorporated. All rights reserved. <br/>
  <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
