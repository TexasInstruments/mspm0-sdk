<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>MSPM0L122X_L222X TI-Driver Library: SPI driver APIs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MSPM0L122X_L222X TI-Driver Library
   &#160;<span id="projectnumber">2.05.01.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">SPI driver APIs<div class="ingroups"><a class="el" href="group___s_p_i.html">Serial Peripheral Interface (SPI)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for SPI driver APIs:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group___s_p_i_m_s_p_m0.png" border="0" alt="" usemap="#group______s__p__i__m__s__p__m0"/>
<map name="group______s__p__i__m__s__p__m0" id="group______s__p__i__m__s__p__m0">
<area shape="rect" id="node1" href="group___s_p_i_m_s_p_m0___c_m_d.html" title="SPIMSPM0_CMD" alt="" coords="417,5,545,32"/>
<area shape="rect" id="node2" href="group___s_p_i.html" title="Serial Peripheral Interface\l (SPI)" alt="" coords="5,23,196,65"/>
<area shape="rect" id="node4" href="group___s_p_i_m_s_p_m0___s_t_a_t_u_s.html" title="SPIMSPM0_STATUS" alt="" coords="408,56,555,83"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group___s_p_i_m_s_p_m0___s_t_a_t_u_s"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i_m_s_p_m0___s_t_a_t_u_s.html">SPIMSPM0_STATUS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___s_p_i_m_s_p_m0___c_m_d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i_m_s_p_m0___c_m_d.html">SPIMSPM0_CMD</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i_m_s_p_m0___h_w_attrs.html">SPIMSPM0_HWAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPIMSPM0 Hardware attributes.  <a href="struct_s_p_i_m_s_p_m0___h_w_attrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i_m_s_p_m0___object.html">SPIMSPM0_Object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPIMSPM0 Object.  <a href="struct_s_p_i_m_s_p_m0___object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga19d7d203a1e73d4fdf18add8e6bda371"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i_m_s_p_m0.html#ga19d7d203a1e73d4fdf18add8e6bda371">SPIMSPM0_FrameSize</a> { <br />
&#160;&#160;<a class="el" href="group___s_p_i_m_s_p_m0.html#gga19d7d203a1e73d4fdf18add8e6bda371af1079c2402b17c3529d9c42a42d31e00">SPIMSPM0_8bit</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i_m_s_p_m0.html#gga19d7d203a1e73d4fdf18add8e6bda371a54bb8a176ef256dcc8672cb52c1f6e82">SPIMSPM0_16bit</a> = 1
<br />
 }<tr class="memdesc:ga19d7d203a1e73d4fdf18add8e6bda371"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPIMSPM0 data frame size is used to determine how to configure the DMA data transfers. This field is to be only used internally.  <a href="group___s_p_i_m_s_p_m0.html#ga19d7d203a1e73d4fdf18add8e6bda371">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga19d7d203a1e73d4fdf18add8e6bda371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fba94adf8e4fc2252260108d1097e76"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i_m_s_p_m0.html#ga7fba94adf8e4fc2252260108d1097e76">SPIMSPM0_ReturnPartial</a> { <br />
&#160;&#160;<a class="el" href="group___s_p_i_m_s_p_m0.html#gga7fba94adf8e4fc2252260108d1097e76a6c70e9cb9b6f2bc190272c740d9f16ee">SPIMSPM0_retPartDisabled</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i_m_s_p_m0.html#gga7fba94adf8e4fc2252260108d1097e76aba17e0035fe92196aa47f57c28972c78">SPIMSPM0_retPartEnabledIntNotSet</a> = 1, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i_m_s_p_m0.html#gga7fba94adf8e4fc2252260108d1097e76a967c890f4b33974e0a40f88b958ba762">SPIMSPM0_retPartEnabledIntSet</a> = 2
<br />
 }<tr class="memdesc:ga7fba94adf8e4fc2252260108d1097e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPIMSPM0 return partial field indicates the status of the return partial mode and the associated pin interrupt. This field is for internal use only.  <a href="group___s_p_i_m_s_p_m0.html#ga7fba94adf8e4fc2252260108d1097e76">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga7fba94adf8e4fc2252260108d1097e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga87b97d9d108f5880b21f2242ad937fff"><td class="memItemLeft" align="right" valign="top"><a id="ga87b97d9d108f5880b21f2242ad937fff"></a>
const <a class="el" href="struct_s_p_i___fxn_table.html">SPI_FxnTable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i_m_s_p_m0.html#ga87b97d9d108f5880b21f2242ad937fff">SPIMSPM0_fxnTable</a></td></tr>
<tr class="memdesc:ga87b97d9d108f5880b21f2242ad937fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI function table pointer. <br /></td></tr>
<tr class="separator:ga87b97d9d108f5880b21f2242ad937fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h1>Driver include</h1>
<p>The SPI header file should be included in an application as follows: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_s_p_i_8h.html">ti/drivers/SPI.h</a>&gt;</span> #include &lt;ti/drivers/spi/SPIMSPM0.h&gt; #include</div><div class="line">&lt;ti/drivers/dma/DMAMSPM0.h&gt;</div></div><!-- fragment --><p>Refer to <a class="el" href="_s_p_i_8h.html">SPI.h</a> for a complete description of APIs.</p>
<p>Note that the user also needs to include the <a class="el" href="_d_m_a_m_s_p_m0_8h.html" title="DMA driver implementation for MSPM0. ">DMAMSPM0.h</a> driver since the SPI uses DMA in order to improve throughput.</p>
<h1>Overview</h1>
<p>The general SPI API should be used in application code, i.e. <a class="el" href="group___s_p_i.html#ga9c9022decfb136991d6b53f7dd2ae2fc" title="This function opens a given SPI peripheral. ">SPI_open()</a> should be used instead of SPIMSPM0_open(). The configuration file will define the device specific config, and casting in the general API will ensure that the correct device specific functions are called. This is also reflected in the example code.</p>
<h1>General Behavior</h1>
<p>Before using SPI on MSPM0 devices:</p><ul>
<li>The SPI driver is initialized by calling <a class="el" href="group___s_p_i.html#gafd9b09f58917f0e2d14c61b956eba214" title="This function initializes the SPI module. ">SPI_init()</a>.</li>
<li>The SPI HW is configured and flags system dependencies (e.g. IOs, power, etc.) by calling <a class="el" href="group___s_p_i.html#ga9c9022decfb136991d6b53f7dd2ae2fc" title="This function opens a given SPI peripheral. ">SPI_open()</a>.</li>
<li>The SPI driver makes use of DMA in order to optimize throughput. This is handled directly by the SPI driver, so the application should never make any calls directly to the <a class="el" href="_d_m_a_m_s_p_m0_8h.html" title="DMA driver implementation for MSPM0. ">DMAMSPM0.h</a> driver.</li>
<li>This implementation supports queueing multiple transactions in callback mode. See the <a class="el" href="group___s_p_i_m_s_p_m0.html#USE_CASE_QUEUE">queueing example.</a></li>
<li>When queueing multiple transactions that should transfer one after the other, it is recommended to use the driver in 'manual start' mode by using the <a class="el" href="group___s_p_i_m_s_p_m0___c_m_d.html#ga2a5a217cdeadd965d7e6a222698776ec" title="Command used by SPI_control() to enable manual start mode. ">SPIMSPM0_CMD_SET_MANUAL</a> command. In this mode, the driver will not start any queued transfers until <a class="el" href="group___s_p_i.html#ga1b3fafc9892141b7bab1bc9c19ede9ef" title="Function performs implementation specific features on a given SPI_Handle. ">SPI_control()</a> is called with the <a class="el" href="group___s_p_i_m_s_p_m0___c_m_d.html#ga243ecdc4c5cdc1215ae0e9cc4c824988" title="Command used by SPI_control() to enable manual start mode. ">SPIMSPM0_CMD_MANUAL_START</a> command. This mode is off by default and can be disabled by using command <a class="el" href="group___s_p_i_m_s_p_m0___c_m_d.html#ga6635712259b8c67d51bc97acbfdbbc68" title="Command used by SPI_control() to disable manual start mode. ">SPIMSPM0_CMD_CLR_MANUAL</a>. See the <a class="el" href="group___s_p_i_m_s_p_m0.html#USE_CASE_MANUAL_START">Manual Start Example</a>.</li>
</ul>
<p>The following is true for peripheral operation:</p><ul>
<li>RX overrun IRQ, SPI and DMA modules are enabled by calling <a class="el" href="group___s_p_i.html#ga989e17f96b54fcc3dc2cac5f8ac6bdb2" title="Function to perform SPI transactions. ">SPI_transfer()</a>.</li>
<li>All received bytes are ignored after <a class="el" href="group___s_p_i.html#ga9c9022decfb136991d6b53f7dd2ae2fc" title="This function opens a given SPI peripheral. ">SPI_open()</a> is called, until the first <a class="el" href="group___s_p_i.html#ga989e17f96b54fcc3dc2cac5f8ac6bdb2" title="Function to perform SPI transactions. ">SPI_transfer()</a>.</li>
<li>If an RX overrun occurs or if <a class="el" href="group___s_p_i.html#ga6819f7761fc3505c4f885653ff8121f0" title="Function to cancel SPI transactions. ">SPI_transferCancel()</a> is called, RX overrun IRQ, SPI and DMA modules are disabled, TX and RX FIFOs are flushed and all bytes are ignored.</li>
<li>After a successful transfer, RX overrun IRQ and SPI module remains enabled and DMA module is disabled. <a class="el" href="group___s_p_i.html#ga989e17f96b54fcc3dc2cac5f8ac6bdb2" title="Function to perform SPI transactions. ">SPI_transfer()</a> must be called again before RX FIFO fills up in order to avoid overflow. If the TX buffer overflows, zeros will be output. It is safe to call another <a class="el" href="group___s_p_i.html#ga989e17f96b54fcc3dc2cac5f8ac6bdb2" title="Function to perform SPI transactions. ">SPI_transfer()</a> from the transfer callback, see <a class="el" href="group___s_p_i_m_s_p_m0.html#USE_CASE_CST">Continuous Peripheral</a> Transfer" use case below.</li>
<li>The SPI driver supports partial return, that can be used if the transfer size is unknown. If <a class="el" href="group___s_p_i_m_s_p_m0___c_m_d.html#ga0f4cca3db31c6b6fc8fee5a979696353" title="Command used by SPI_control() to enable partial return. ">SPIMSPM0_CMD_RETURN_PARTIAL_ENABLE</a> is passed to <a class="el" href="group___s_p_i.html#ga1b3fafc9892141b7bab1bc9c19ede9ef" title="Function performs implementation specific features on a given SPI_Handle. ">SPI_control()</a>, the transfer will end when chip select is deasserted. The <a class="el" href="struct_s_p_i___transaction.html#aa244504b2384411f7de17340be62128a">SPI_Transaction.status</a> and the <a class="el" href="struct_s_p_i___transaction.html#ad049d6a900c4bdb59a5ee8ce3d5bced2">SPI_Transaction.count</a> will be updated to indicate whether the transfer ended due to a chip select deassertion and how many bytes were transferred. See <a class="el" href="group___s_p_i_m_s_p_m0.html#USE_CASE_RP">Peripheral Mode With Return</a> Partial" use case below.</li>
<li>When queueing several transactions if the first is a 'short' transaction (8 or fewer frames), it is required to use <a class="el" href="group___s_p_i_m_s_p_m0.html#USE_CASE_MANUAL_START">Manual Start mode.</a></li>
</ul>
<p>The following apply for controller operation:</p><ul>
<li>SPI and DMA modules are enabled by calling <a class="el" href="group___s_p_i.html#ga989e17f96b54fcc3dc2cac5f8ac6bdb2" title="Function to perform SPI transactions. ">SPI_transfer()</a>.</li>
<li>If the <a class="el" href="group___s_p_i.html#ga989e17f96b54fcc3dc2cac5f8ac6bdb2" title="Function to perform SPI transactions. ">SPI_transfer()</a> succeeds, SPI module is enabled and DMA module is disabled.</li>
<li>If <a class="el" href="group___s_p_i.html#ga6819f7761fc3505c4f885653ff8121f0" title="Function to cancel SPI transactions. ">SPI_transferCancel()</a> is called, SPI and DMA modules are disabled and TX and RX FIFOs are flushed.</li>
</ul>
<p>After SPI operation has ended:</p><ul>
<li>Release system dependencies for SPI by calling <a class="el" href="group___s_p_i.html#ga0e3448b30b88609fa120915e49560601" title="Function to close a SPI peripheral specified by the SPI handle. ">SPI_close()</a>.</li>
</ul>
<p>The callback function is always called in a SWI context.</p>
<h1>Error handling</h1>
<p>If an RX overrun occurs during peripheral operation:</p><ul>
<li>If a transfer is ongoing, all bytes received up until the error occurs will be returned, with the error signaled in the <a class="el" href="struct_s_p_i___transaction.html#aa244504b2384411f7de17340be62128a">SPI_Transaction.status</a> field. RX overrun IRQ, SPI and DMA modules are then disabled, TX and RX FIFOs are flushed and all bytes will be ignored until a new transfer is issued.</li>
<li>If a transfer is not ongoing, RX overrun IRQ, SPI and DMA modules are disabled, TX and RX FIFOs are flushed and all bytes will be ignored until a new transfer is issued.</li>
</ul>
<h1>Timeout</h1>
<p>Timeout can occur in <a class="el" href="group___s_p_i.html#ggab9ea76c6529d6076eee5e1c4a5a92c6fa0dfb2358e008316426895e7237c398e8">SPI_MODE_BLOCKING</a>, there's no timeout in <a class="el" href="group___s_p_i.html#ggab9ea76c6529d6076eee5e1c4a5a92c6fa5631e69925c47a62a261c78ebbda39fb">SPI_MODE_CALLBACK</a>. When in <a class="el" href="group___s_p_i.html#ggab9ea76c6529d6076eee5e1c4a5a92c6fa5631e69925c47a62a261c78ebbda39fb">SPI_MODE_CALLBACK</a>, the transfer must be cancelled by calling <a class="el" href="group___s_p_i.html#ga6819f7761fc3505c4f885653ff8121f0" title="Function to cancel SPI transactions. ">SPI_transferCancel()</a>.<br />
 If a timeout happens in either <a class="el" href="group___s_p_i.html#gga60a7e3d74577b38aa79ea6983362f942adf4cb39226caf2dcd726e13d39546393">SPI_PERIPHERAL</a> or <a class="el" href="group___s_p_i.html#gga60a7e3d74577b38aa79ea6983362f942a061361eeeb9e87265edcc0c70868111a">SPI_CONTROLLER</a> mode, the receive buffer will contain the bytes received up until the timeout occurred. The SPI transaction status will be set to <a class="el" href="group___s_p_i.html#gga913c57c335166de9caa54b7eb9ad95fbac01b83da31c34da13025a5b987ef013f">SPI_TRANSFER_FAILED</a>. The SPI transaction count will be set to the number of bytes sent/received before timeout. The remaining bytes will be flushed from the TX FIFO so that the subsequent transfer can be executed correctly. Note that specifying a timeout prevents the driver from performing a polling transfer when in peripheral mode.</p>
<h1>Power Management</h1>
<p>The power management framework will try to put the device into the most power efficient mode whenever possible. Please see the technical reference manual for further details on each power mode.</p>
<p>The <a class="el" href="_s_p_i_m_s_p_m0_8h.html" title="SPI driver implementation for MSPM0 SPI controller using the DMA controller. ">SPIMSPM0.h</a> driver is setting a power constraint during transfers to keep the device out of standby. When the transfer has finished, the power constraint is released. The following statements are valid:</p><ul>
<li>After <a class="el" href="group___s_p_i.html#ga9c9022decfb136991d6b53f7dd2ae2fc" title="This function opens a given SPI peripheral. ">SPI_open()</a>: the device is still allowed to enter standby.</li>
<li>In peripheral mode:<ul>
<li>During <a class="el" href="group___s_p_i.html#ga989e17f96b54fcc3dc2cac5f8ac6bdb2" title="Function to perform SPI transactions. ">SPI_transfer()</a>: the device cannot enter standby, only idle.</li>
<li>After an RX overflow: device is allowed to enter standby.</li>
<li>After a successful <a class="el" href="group___s_p_i.html#ga989e17f96b54fcc3dc2cac5f8ac6bdb2" title="Function to perform SPI transactions. ">SPI_transfer()</a>: the device is allowed to enter standby, but SPI module remains enabled.<ul>
<li><em>Note</em>: In peripheral mode, the device might enter standby while a byte is being transferred if <a class="el" href="group___s_p_i.html#ga989e17f96b54fcc3dc2cac5f8ac6bdb2" title="Function to perform SPI transactions. ">SPI_transfer()</a> is not called again after a successful transfer. This could result in corrupt data being transferred.</li>
</ul>
</li>
<li>Application thread should typically either issue another transfer after <a class="el" href="group___s_p_i.html#ga989e17f96b54fcc3dc2cac5f8ac6bdb2" title="Function to perform SPI transactions. ">SPI_transfer()</a> completes successfully, or call <a class="el" href="group___s_p_i.html#ga6819f7761fc3505c4f885653ff8121f0" title="Function to cancel SPI transactions. ">SPI_transferCancel()</a> to disable the SPI module and thus assuring that no data is received while entering standby.</li>
</ul>
</li>
<li>In controller mode:<ul>
<li>During <a class="el" href="group___s_p_i.html#ga989e17f96b54fcc3dc2cac5f8ac6bdb2" title="Function to perform SPI transactions. ">SPI_transfer()</a>: the device cannot enter standby, only idle.</li>
<li>After <a class="el" href="group___s_p_i.html#ga989e17f96b54fcc3dc2cac5f8ac6bdb2" title="Function to perform SPI transactions. ">SPI_transfer()</a> succeeds: the device can enter standby.</li>
<li>If <a class="el" href="group___s_p_i.html#ga6819f7761fc3505c4f885653ff8121f0" title="Function to cancel SPI transactions. ">SPI_transferCancel()</a> is called: the device can enter standby.</li>
</ul>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The external hardware connected to the SPI might have some pull configured on the SPI lines. When the SPI is inactive, this might cause leakage on the IO and the current consumption to increase. The application must configure a pull configuration that aligns with the external hardware. See <a class="el" href="group___s_p_i_m_s_p_m0.html#USE_CASE_LPWR">Ensure low power during inactive periods</a> for code example.</dd></dl>
<h1>SPI details</h1>
<h2>Chip Select</h2>
<p>This SPI controller supports a hardware chip select pin. Refer to the user manual on how this hardware chip select pin behaves in regards to the SPI frame format.</p>
<table class="doxtable">
<tr>
<th>Chip select type </th><th>SPI_CONTROLLER mode </th><th>SPI_PERIPHERAL mode  </th></tr>
<tr>
<td>Hardware chip select </td><td>No action is needed by the application to select the peripheral. </td><td>See the device documentation on it's chip select requirements.  </td></tr>
<tr>
<td>Software chip select </td><td>The application is responsible to ensure that correct SPI peripheral is selected before performing a <a class="el" href="group___s_p_i.html#ga989e17f96b54fcc3dc2cac5f8ac6bdb2" title="Function to perform SPI transactions. ">SPI_transfer()</a>. </td><td>See the device documentation on it's chip select requirements.  </td></tr>
</table>
<h3>Multiple peripherals when operating in controller mode</h3>
<p>In a scenario where the SPI module is operating in controller mode with multiple SPI peripherals, the chip select pin can be reallocated at runtime to select the appropriate peripheral device. See <a class="el" href="group___s_p_i_m_s_p_m0.html#USE_CASE_MMMS">Controller Mode With</a> Multiple Peripherals" use case below. This is only relevant when chip select is a hardware chip select. Otherwise the application can control the chip select pins directly using the GPIO driver.</p>
<h2>Data Frames</h2>
<p>SPI data frames can be any size from 4-bits to 16-bits. If the dataSize in <a class="el" href="struct_s_p_i___params.html" title="SPI Parameters. ">SPI_Params</a> is greater that 8-bits, then the SPIMSPM0 driver implementation will assume that the <a class="el" href="struct_s_p_i___transaction.html" title="A SPI_Transaction data structure is used with SPI_transfer(). It indicates how many SPI_FrameFormat f...">SPI_Transaction</a> txBuf and rxBuf point to an array of 16-bit uint16_t elements.</p>
<table class="doxtable">
<tr>
<th>dataSize </th><th>buffer element size  </th></tr>
<tr>
<td>4-8 bits </td><td>uint8_t </td></tr>
<tr>
<td>9-16 bits </td><td>uint16_t </td></tr>
</table>
<h2>DMA</h2>
<h3>Interrupts</h3>
<p>The DMA module generates IRQs on the SPI interrupt vector. This driver automatically installs a DMA aware Hwi (interrupt) to service the assigned DMA channels.</p>
<h3>Transfer Size Limit</h3>
<p>The DMA controller only supports data transfers of up to 1024 data frames. A transfer with more than 1024 frames will be transmitted/received in multiple 1024 sized portions until all data has been transmitted/received. A data frame can be 4 to 16 bits in length.</p>
<h3>Scratch Buffers</h3>
<p>A uint16_t scratch buffer is used to allow SPI_transfers where txBuf or rxBuf are NULL. Rather than requiring txBuf or rxBuf to have a dummy buffer of size of the transfer count, a single-word DMA accessible uint16_t scratch buffer is used. When rxBuf is NULL, the DMA will transfer all the received SPI data into the scratch buffer as a "bit-bucket". When txBuf is NULL, the scratch buffer is initialized to defaultTxBufValue so the DMA will send some known value. Each SPI driver instance uses its own scratch buffer.</p>
<h3>TX and RX buffers</h3>
<p>Before SPI_transfer, txBuf should be filled with the outgoing SPI data. These data are sent out during the transfer, while the incoming data are received into rxBuf. To save memory space, txBuf and rxBuf can be assigned to the same buffer location. At the beginning of the transfer, this buffer holds outgoing data. At the end of the transfer, the outgoing data are overwritten and the buffer holds the received SPI data.</p>
<h2>Polling SPI transfers</h2>
<p>When used in blocking mode small SPI transfers are can be done by polling the peripheral &amp; sending data frame-by-frame. A controller device can perform the transfer immediately and return, but a peripheral will block until it receives the number of frames specified in the SPI_Transfer() call. The minDmaTransferSize field in the hardware attributes is the threshold; if the transaction count is below the threshold a polling transfer is performed; otherwise a DMA transfer is done. This is intended to reduce the overhead of setting up a DMA transfer to only send a few data frames.</p>
<p>Notes:</p><ul>
<li>Specifying a timeout prevents peripheral devices from using polling transfers.</li>
<li>Keep in mind that during polling transfers the current task is still being executed; there is no context switch to another task.</li>
</ul>
<h1>Supported Functions</h1>
<table class="doxtable">
<tr>
<th>Generic API function </th><th>API function </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="group___s_p_i.html#gafd9b09f58917f0e2d14c61b956eba214" title="This function initializes the SPI module. ">SPI_init()</a> </td><td>SPIMSPM0_init() </td><td>Initialize SPI driver </td></tr>
<tr>
<td><a class="el" href="group___s_p_i.html#ga9c9022decfb136991d6b53f7dd2ae2fc" title="This function opens a given SPI peripheral. ">SPI_open()</a> </td><td>SPIMSPM0_open() </td><td>Initialize SPI HW and set system dependencies </td></tr>
<tr>
<td><a class="el" href="group___s_p_i.html#ga0e3448b30b88609fa120915e49560601" title="Function to close a SPI peripheral specified by the SPI handle. ">SPI_close()</a> </td><td>SPIMSPM0_close() </td><td>Disable SPI and DMA HW and release system dependencies </td></tr>
<tr>
<td><a class="el" href="group___s_p_i.html#ga1b3fafc9892141b7bab1bc9c19ede9ef" title="Function performs implementation specific features on a given SPI_Handle. ">SPI_control()</a> </td><td>SPIMSPM0_control() </td><td>Configure an already opened SPI handle </td></tr>
<tr>
<td><a class="el" href="group___s_p_i.html#ga989e17f96b54fcc3dc2cac5f8ac6bdb2" title="Function to perform SPI transactions. ">SPI_transfer()</a> </td><td>SPIMSPM0_transfer() </td><td>Start transfer from SPI </td></tr>
<tr>
<td><a class="el" href="group___s_p_i.html#ga6819f7761fc3505c4f885653ff8121f0" title="Function to cancel SPI transactions. ">SPI_transferCancel()</a> </td><td>SPIMSPM0_transferCancel() </td><td>Cancel ongoing transfer from SPI </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>All calls should go through the generic API</dd></dl>
<h2>Use Cases<a class="anchor" id="USE_CASES_SPI"></a></h2>
<h3>Basic Peripheral Mode</h3>
<p>Receive 100 bytes over SPI in <a class="el" href="group___s_p_i.html#ggab9ea76c6529d6076eee5e1c4a5a92c6fa0dfb2358e008316426895e7237c398e8">SPI_MODE_BLOCKING</a>. </p><div class="fragment"><div class="line"><a class="code" href="struct_s_p_i___config__.html">SPI_Handle</a> handle; <a class="code" href="struct_s_p_i___params.html">SPI_Params</a> params; <a class="code" href="struct_s_p_i___transaction.html">SPI_Transaction</a> transaction; uint8_t</div><div class="line">rxBuf[100];     <span class="comment">// Receive buffer</span></div><div class="line"></div><div class="line"><span class="comment">// Init SPI and specify non-default parameters SPI_Params_init(&amp;params);</span></div><div class="line">params.<a class="code" href="struct_s_p_i___params.html#ab3f035044fdbe75adac8c1d729d8cf20">bitRate</a>     = 500000; params.<a class="code" href="struct_s_p_i___params.html#a67b5ebb8ec72796a0260c427c91cc093">frameFormat</a> = SPI_POL1_PHA1;</div><div class="line">params.<a class="code" href="struct_s_p_i___params.html#abe5eca64adf4ca96bed206a271d9b157">mode</a>        = <a class="code" href="group___s_p_i.html#gga60a7e3d74577b38aa79ea6983362f942adf4cb39226caf2dcd726e13d39546393">SPI_PERIPHERAL</a>;</div><div class="line"></div><div class="line"><span class="comment">// Configure the transaction transaction.count = 100; transaction.txBuf =</span></div><div class="line">NULL; transaction.<a class="code" href="struct_s_p_i___transaction.html#a214f57d7809c875fb9456a62a406e041">rxBuf</a> = rxBuf;</div><div class="line"></div><div class="line"><span class="comment">// Open the SPI and perform the transfer handle = SPI_open(CONFIG_SPI,</span></div><div class="line">&amp;params); <a class="code" href="group___s_p_i.html#ga989e17f96b54fcc3dc2cac5f8ac6bdb2">SPI_transfer</a>(handle, &amp;transaction);</div></div><!-- fragment --><h3>Peripheral Mode With Return Partial<a class="anchor" id="USE_CASE_RP"></a></h3>
<p>This use case will perform a transfer in <a class="el" href="group___s_p_i.html#ggab9ea76c6529d6076eee5e1c4a5a92c6fa0dfb2358e008316426895e7237c398e8">SPI_MODE_BLOCKING</a> until the wanted amount of bytes is transferred or until chip select is deasserted by the SPI controller. This <a class="el" href="group___s_p_i.html#ga989e17f96b54fcc3dc2cac5f8ac6bdb2" title="Function to perform SPI transactions. ">SPI_transfer()</a> call can be used when unknown amount of bytes shall be transferred. Note: The partial return is also possible in <a class="el" href="group___s_p_i.html#ggab9ea76c6529d6076eee5e1c4a5a92c6fa5631e69925c47a62a261c78ebbda39fb">SPI_MODE_CALLBACK</a> mode. Note: Polling transfers are not available when using return partial mode. </p><div class="fragment"><div class="line"><a class="code" href="struct_s_p_i___config__.html">SPI_Handle</a> handle; <a class="code" href="struct_s_p_i___params.html">SPI_Params</a> params; <a class="code" href="struct_s_p_i___transaction.html">SPI_Transaction</a> transaction; uint8_t</div><div class="line">rxBuf[100];     <span class="comment">// Receive buffer</span></div><div class="line"></div><div class="line"><span class="comment">// Init SPI and specify non-default parameters SPI_Params_init(&amp;params);</span></div><div class="line">params.<a class="code" href="struct_s_p_i___params.html#ab3f035044fdbe75adac8c1d729d8cf20">bitRate</a>     = 500000; params.<a class="code" href="struct_s_p_i___params.html#a67b5ebb8ec72796a0260c427c91cc093">frameFormat</a> = SPI_POL1_PHA1;</div><div class="line">params.<a class="code" href="struct_s_p_i___params.html#abe5eca64adf4ca96bed206a271d9b157">mode</a>        = <a class="code" href="group___s_p_i.html#gga60a7e3d74577b38aa79ea6983362f942adf4cb39226caf2dcd726e13d39546393">SPI_PERIPHERAL</a>;</div><div class="line"></div><div class="line"><span class="comment">// Configure the transaction transaction.count = 100; transaction.txBuf =</span></div><div class="line">NULL; transaction.<a class="code" href="struct_s_p_i___transaction.html#a214f57d7809c875fb9456a62a406e041">rxBuf</a> = rxBuf;</div><div class="line"></div><div class="line"><span class="comment">// Open the SPI and initiate the partial read handle = SPI_open(CONFIG_SPI,</span></div><div class="line">&amp;params);</div><div class="line"></div><div class="line"><span class="comment">// Enable RETURN_PARTIAL SPI_control(handle,</span></div><div class="line"><a class="code" href="group___s_p_i_m_s_p_m0___c_m_d.html#ga0f4cca3db31c6b6fc8fee5a979696353">SPIMSPM0_CMD_RETURN_PARTIAL_ENABLE</a>, NULL);</div><div class="line"></div><div class="line"><span class="comment">// Begin transfer SPI_transfer(handle, &amp;transaction);</span></div></div><!-- fragment --><h3>Continuous Peripheral Transfer In <a class="el" href="group___s_p_i.html#ggab9ea76c6529d6076eee5e1c4a5a92c6fa5631e69925c47a62a261c78ebbda39fb">SPI_MODE_CALLBACK</a><a class="anchor" id="USE_CASE_CST"></a></h3>
<p>This use case will configure the SPI driver to transfer continuously in <a class="el" href="group___s_p_i.html#ggab9ea76c6529d6076eee5e1c4a5a92c6fa5631e69925c47a62a261c78ebbda39fb">SPI_MODE_CALLBACK</a>, 16 bytes at the time and echoing received data after every 16 bytes. </p><div class="fragment"><div class="line"><span class="comment">// Callback function static void transferCallback(SPI_Handle handle,</span></div><div class="line"><a class="code" href="struct_s_p_i___transaction.html">SPI_Transaction</a> *transaction)</div><div class="line">{</div><div class="line">    <span class="comment">// Start another transfer</span></div><div class="line">    <a class="code" href="group___s_p_i.html#ga989e17f96b54fcc3dc2cac5f8ac6bdb2">SPI_transfer</a>(handle, transaction);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> taskFxn(uintptr_t a0, uintptr_t a1)</div><div class="line">{</div><div class="line">    <a class="code" href="struct_s_p_i___config__.html">SPI_Handle</a> handle;</div><div class="line">    <a class="code" href="struct_s_p_i___params.html">SPI_Params</a> params;</div><div class="line">    <a class="code" href="struct_s_p_i___transaction.html">SPI_Transaction</a> transaction;</div><div class="line">    uint8_t buf[16];                  <span class="comment">// Receive and transmit buffer</span></div><div class="line"></div><div class="line">    <span class="comment">// Init SPI and specify non-default parameters</span></div><div class="line">    <a class="code" href="group___s_p_i.html#ga9c3dd1748332fd6e31c79a6538a71642">SPI_Params_init</a>(&amp;params);</div><div class="line">    params.<a class="code" href="struct_s_p_i___params.html#ab3f035044fdbe75adac8c1d729d8cf20">bitRate</a>             = 500000;</div><div class="line">    params.<a class="code" href="struct_s_p_i___params.html#a67b5ebb8ec72796a0260c427c91cc093">frameFormat</a>         = SPI_POL1_PHA1;</div><div class="line">    params.<a class="code" href="struct_s_p_i___params.html#abe5eca64adf4ca96bed206a271d9b157">mode</a>                = <a class="code" href="group___s_p_i.html#gga60a7e3d74577b38aa79ea6983362f942adf4cb39226caf2dcd726e13d39546393">SPI_PERIPHERAL</a>;</div><div class="line">    params.<a class="code" href="struct_s_p_i___params.html#a16dbcc3768a01fb7deae25b48fc0d69c">transferMode</a>        = <a class="code" href="group___s_p_i.html#ggab9ea76c6529d6076eee5e1c4a5a92c6fa5631e69925c47a62a261c78ebbda39fb">SPI_MODE_CALLBACK</a>;</div><div class="line">    params.<a class="code" href="struct_s_p_i___params.html#a68d1d610da6a6bf299121b939ef2a352">transferCallbackFxn</a> = transferCallback;</div><div class="line"></div><div class="line">    <span class="comment">// Configure the transaction</span></div><div class="line">    transaction.<a class="code" href="struct_s_p_i___transaction.html#ad049d6a900c4bdb59a5ee8ce3d5bced2">count</a> = 16;</div><div class="line">    transaction.<a class="code" href="struct_s_p_i___transaction.html#a9461a248f1cceb4048668d44b323a0b8">txBuf</a> = buf;</div><div class="line">    transaction.<a class="code" href="struct_s_p_i___transaction.html#a214f57d7809c875fb9456a62a406e041">rxBuf</a> = buf;</div><div class="line"></div><div class="line">    <span class="comment">// Open the SPI and initiate the first transfer</span></div><div class="line">    handle = <a class="code" href="group___s_p_i.html#ga9c9022decfb136991d6b53f7dd2ae2fc">SPI_open</a>(CONFIG_SPI, &amp;params);</div><div class="line">    <a class="code" href="group___s_p_i.html#ga989e17f96b54fcc3dc2cac5f8ac6bdb2">SPI_transfer</a>(handle, &amp;transaction);</div><div class="line"></div><div class="line">    <span class="comment">// Wait forever</span></div><div class="line">    <span class="keywordflow">while</span>(<span class="keyword">true</span>);</div><div class="line">}</div></div><!-- fragment --><h3>Basic Controller Mode</h3>
<p>This use case will configure a SPI controller to send the data in txBuf while receiving data to rxBuf in BLOCKING_MODE. </p><div class="fragment"><div class="line"><a class="code" href="struct_s_p_i___config__.html">SPI_Handle</a> handle; <a class="code" href="struct_s_p_i___params.html">SPI_Params</a> params; <a class="code" href="struct_s_p_i___transaction.html">SPI_Transaction</a> transaction; uint8_t</div><div class="line">txBuf[] = <span class="stringliteral">&quot;Hello World&quot;</span>;    <span class="comment">// Transmit buffer uint8_t rxBuf[11];</span></div><div class="line"><span class="comment">// Receive buffer</span></div><div class="line"></div><div class="line"><span class="comment">// Init SPI and specify non-default parameters SPI_Params_init(&amp;params);</span></div><div class="line">params.<a class="code" href="struct_s_p_i___params.html#ab3f035044fdbe75adac8c1d729d8cf20">bitRate</a>     = 500000; params.<a class="code" href="struct_s_p_i___params.html#a67b5ebb8ec72796a0260c427c91cc093">frameFormat</a> = SPI_POL1_PHA1;</div><div class="line">params.<a class="code" href="struct_s_p_i___params.html#abe5eca64adf4ca96bed206a271d9b157">mode</a>        = <a class="code" href="group___s_p_i.html#gga60a7e3d74577b38aa79ea6983362f942a061361eeeb9e87265edcc0c70868111a">SPI_CONTROLLER</a>;</div><div class="line"></div><div class="line"><span class="comment">// Configure the transaction transaction.count = sizeof(txBuf);</span></div><div class="line">transaction.<a class="code" href="struct_s_p_i___transaction.html#a9461a248f1cceb4048668d44b323a0b8">txBuf</a> = txBuf; transaction.<a class="code" href="struct_s_p_i___transaction.html#a214f57d7809c875fb9456a62a406e041">rxBuf</a> = rxBuf;</div><div class="line"></div><div class="line"><span class="comment">// Open the SPI and perform the transfer handle = SPI_open(CONFIG_SPI,</span></div><div class="line">&amp;params); <a class="code" href="group___s_p_i.html#ga989e17f96b54fcc3dc2cac5f8ac6bdb2">SPI_transfer</a>(handle, &amp;transaction);</div></div><!-- fragment --><h3>Controller Mode With Multiple Peripherals<a class="anchor" id="USE_CASE_MMMS"></a></h3>
<p>This use case will configure a SPI controller to send data to one peripheral and then to another in BLOCKING_MODE. It is assumed that SysConfig is configured so that the two chip select pins have a default setting of a high output and that the <a class="el" href="struct_s_p_i_m_s_p_m0___h_w_attrs.html" title="SPIMSPM0 Hardware attributes. ">SPIMSPM0_HWAttrs</a> used points to one of them since the SPI driver will revert to this default setting when switching the chip select pin.</p>
<div class="fragment"><div class="line"> <span class="comment">// From ti_drivers_config.c // Use the sysconfig settings to make sure both</span></div><div class="line"> pins are <span class="keyword">set</span> to HIGH when not in use <a class="code" href="group___g_p_i_o.html#ga7f5d979226db633309b3fdc0f4a8aef6">GPIO_PinConfig</a> gpioPinConfigs[31] = {</div><div class="line">     ...</div><div class="line">     <a class="code" href="group___g_p_i_o___pin_config_settings.html#gac52528c42a8eb3be193f49de5ed7d820">GPIO_CFG_OUT_STD</a> | <a class="code" href="group___g_p_i_o___pin_config_settings.html#gae86eb6dc677c962a9ad94bdad6752dc0">GPIO_CFG_OUT_HIGH</a>, <span class="comment">// CONFIG_CSN_0</span></div><div class="line">     ...</div><div class="line">     <a class="code" href="group___g_p_i_o___pin_config_settings.html#gac52528c42a8eb3be193f49de5ed7d820">GPIO_CFG_OUT_STD</a> | <a class="code" href="group___g_p_i_o___pin_config_settings.html#gae86eb6dc677c962a9ad94bdad6752dc0">GPIO_CFG_OUT_HIGH</a>, <span class="comment">// CONFIG_CSN_1</span></div><div class="line"> }</div><div class="line">                                                                                          </div><div class="line"><span class="keyword">const</span> <a class="code" href="struct_s_p_i_m_s_p_m0___h_w_attrs.html">SPIMSPM0_HWAttrs</a> SPIMSPM0HWAttrs[CONFIG_SPI_COUNT] =</div><div class="line">{</div><div class="line">   {</div><div class="line">      .<a class="code" href="struct_s_p_i_m_s_p_m0___h_w_attrs.html#abd53cd1b93ac1a35fee572ea5a274501">spi</a> = SPI_1_INST,</div><div class="line">      .intNum = SPI_1_INST_INT_IRQN,</div><div class="line">      .intPriority = (~0),</div><div class="line">      .clockSource = DL_SPI_CLOCK_BUSCLK,</div><div class="line">      .clockDivider = DL_SPI_CLOCK_DIVIDE_RATIO_1,</div><div class="line">      .defaultTxBufValue = 0xFF,</div><div class="line"></div><div class="line">      .pociPin = GPIO_SPI_1_POCI_PIN,</div><div class="line">      .pociPincm = GPIO_SPI_1_IOMUX_POCI,</div><div class="line">      .pociPinMux = GPIO_SPI_1_IOMUX_POCI_FUNC,</div><div class="line"></div><div class="line">      .picoPin = GPIO_SPI_1_PICO_PIN,</div><div class="line">      .picoPincm = GPIO_SPI_1_IOMUX_PICO,</div><div class="line">      .picoPinMux = GPIO_SPI_1_IOMUX_PICO_FUNC,</div><div class="line"></div><div class="line">      .sclkPin = GPIO_SPI_1_SCLK_PIN,</div><div class="line">      .sclkPincm = GPIO_SPI_1_IOMUX_SCLK,</div><div class="line">      .sclkPinMux = GPIO_SPI_1_IOMUX_SCLK_FUNC,</div><div class="line"></div><div class="line">      .csnPin = GPIO_SPI_1_CS0_PIN,</div><div class="line">      .csnPincm = GPIO_SPI_1_IOMUX_CS0,</div><div class="line">      .csnPinMux = GPIO_SPI_1_IOMUX_CS0_FUNC,</div><div class="line"></div><div class="line">      .txFifoThreshold = DL_SPI_TX_FIFO_LEVEL_ONE_FRAME,</div><div class="line">      .rxFifoThreshold = DL_SPI_RX_FIFO_LEVEL_ONE_FRAME,</div><div class="line">      .cssel = 0,</div><div class="line">      .noOfDMAChannels = 2,</div><div class="line">   },</div><div class="line">};</div><div class="line"></div><div class="line"> <span class="comment">// From your_application.c static void taskFxn(uintptr_t a0, uintptr_t a1)</span></div><div class="line"> {</div><div class="line">     <a class="code" href="struct_s_p_i___config__.html">SPI_Handle</a> handle;</div><div class="line">     <a class="code" href="struct_s_p_i___params.html">SPI_Params</a> params;</div><div class="line">     <a class="code" href="struct_s_p_i___transaction.html">SPI_Transaction</a> transaction;</div><div class="line">     uint_least8_t csnPin1 = CONFIG_CSN_1;</div><div class="line">     uint8_t txBuf[] = <span class="stringliteral">&quot;Hello World&quot;</span>;    <span class="comment">// Transmit buffer</span></div><div class="line"></div><div class="line">     <span class="comment">// Init SPI and specify non-default parameters</span></div><div class="line">     <a class="code" href="group___s_p_i.html#ga9c3dd1748332fd6e31c79a6538a71642">SPI_Params_init</a>(&amp;params);</div><div class="line">     params.<a class="code" href="struct_s_p_i___params.html#ab3f035044fdbe75adac8c1d729d8cf20">bitRate</a>     = 500000;</div><div class="line">     params.<a class="code" href="struct_s_p_i___params.html#a67b5ebb8ec72796a0260c427c91cc093">frameFormat</a> = SPI_POL1_PHA1;</div><div class="line">     params.<a class="code" href="struct_s_p_i___params.html#abe5eca64adf4ca96bed206a271d9b157">mode</a>        = <a class="code" href="group___s_p_i.html#gga60a7e3d74577b38aa79ea6983362f942a061361eeeb9e87265edcc0c70868111a">SPI_CONTROLLER</a>;</div><div class="line"></div><div class="line">     <span class="comment">// Configure the transaction</span></div><div class="line">     transaction.<a class="code" href="struct_s_p_i___transaction.html#ad049d6a900c4bdb59a5ee8ce3d5bced2">count</a> = <span class="keyword">sizeof</span>(txBuf);</div><div class="line">     transaction.<a class="code" href="struct_s_p_i___transaction.html#a9461a248f1cceb4048668d44b323a0b8">txBuf</a> = txBuf;</div><div class="line">     transaction.<a class="code" href="struct_s_p_i___transaction.html#a214f57d7809c875fb9456a62a406e041">rxBuf</a> = NULL;</div><div class="line"></div><div class="line">     <span class="comment">// Open the SPI and perform transfer to the first peripheral</span></div><div class="line">     handle = <a class="code" href="group___s_p_i.html#ga9c9022decfb136991d6b53f7dd2ae2fc">SPI_open</a>(CONFIG_SPI, &amp;params);</div><div class="line">     <a class="code" href="group___s_p_i.html#ga989e17f96b54fcc3dc2cac5f8ac6bdb2">SPI_transfer</a>(handle, &amp;transaction);</div><div class="line"></div><div class="line">     <span class="comment">// Then switch chip select pin and perform transfer to the second</span></div><div class="line">     peripheral</div><div class="line">     <a class="code" href="group___s_p_i.html#ga1b3fafc9892141b7bab1bc9c19ede9ef">SPI_control</a>(handle, <a class="code" href="group___s_p_i_m_s_p_m0___c_m_d.html#gab4714c9b484cb394d114880133ce5d39">SPIMSPM0_CMD_SET_CSN_PIN</a>, &amp;csnPin1);</div><div class="line">     <a class="code" href="group___s_p_i.html#ga989e17f96b54fcc3dc2cac5f8ac6bdb2">SPI_transfer</a>(handle, &amp;transaction);</div><div class="line"> }</div></div><!-- fragment --><h3>Queueing Transactions in Callback Mode</h3>
<p><a class="anchor" id="USE_CASE_QUEUE"></a>Below is an example of queueing three transactions </p><div class="fragment"><div class="line"><span class="comment">// SPI already opened in callback mode SPI_Transaction t0, t1, t2;</span></div><div class="line"></div><div class="line">t0.txBuf = txBuff0; t0.rxBuf = rxBuff0; t0.count = 2000;</div><div class="line"></div><div class="line">t1.txBuf = txBuff1; t1.rxBuf = rxBuff1; t1.count = 1000;</div><div class="line"></div><div class="line">t2.txBuf = txBuff2; t2.rxBuf = NULL; t2.count = 1000;</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> transferOk = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="group___s_p_i.html#ga989e17f96b54fcc3dc2cac5f8ac6bdb2">SPI_transfer</a>(spiHandle, &amp;t0)) { <span class="keywordflow">if</span> (<a class="code" href="group___s_p_i.html#ga989e17f96b54fcc3dc2cac5f8ac6bdb2">SPI_transfer</a>(spiHandle, &amp;t1)) {</div><div class="line">    transferOk = <a class="code" href="group___s_p_i.html#ga989e17f96b54fcc3dc2cac5f8ac6bdb2">SPI_transfer</a>(spiHandle, &amp;t2);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h3>Queueing in Manual Start Mode</h3>
<p>This example shows a peripheral device queueing two transactions that will complete one after the other. From the controller's perspective there will be one long transfer. </p><dl class="section note"><dt>Note</dt><dd>Manual mode also works while the device is in <a class="el" href="group___s_p_i.html#gga60a7e3d74577b38aa79ea6983362f942a061361eeeb9e87265edcc0c70868111a">SPI_CONTROLLER</a> mode. The control call to MANUAL_START will start the transfers.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Manual start mode should not be enabled or disabled while a transaction is in progress.</dd></dl>
<p><a class="anchor" id="USE_CASE_MANUAL_START"></a></p><div class="fragment"><div class="line"><a class="code" href="struct_s_p_i___config__.html">SPI_Handle</a> spi; <a class="code" href="struct_s_p_i___params.html">SPI_Params</a> params; <a class="code" href="struct_s_p_i___transaction.html">SPI_Transaction</a> t0, t1; uint8_t status =</div><div class="line"><a class="code" href="group___s_p_i___s_t_a_t_u_s.html#gab38fa90ff62128dbc98b2ecd84ca106f">SPI_STATUS_SUCCESS</a>;</div><div class="line"></div><div class="line"><a class="code" href="group___s_p_i.html#ga9c3dd1748332fd6e31c79a6538a71642">SPI_Params_init</a>(&amp;params); params.<a class="code" href="struct_s_p_i___params.html#abe5eca64adf4ca96bed206a271d9b157">mode</a> = <a class="code" href="group___s_p_i.html#gga60a7e3d74577b38aa79ea6983362f942adf4cb39226caf2dcd726e13d39546393">SPI_PERIPHERAL</a>; spi =</div><div class="line"><a class="code" href="group___s_p_i.html#ga9c9022decfb136991d6b53f7dd2ae2fc">SPI_open</a>(CONFIG_SPI, &amp;params);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (spi == NULL) { exit(0);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Enable manual start mode SPI_control(spi, SPIMSPM0_CMD_SET_MANUAL,</span></div><div class="line">NULL);</div><div class="line"></div><div class="line"><span class="comment">// Queue transactions t0.txBuf = txBuff0; t0.rxBuf = rxBuff0; t0.count =</span></div><div class="line">2000; <span class="keywordflow">if</span> (!<a class="code" href="group___s_p_i.html#ga989e17f96b54fcc3dc2cac5f8ac6bdb2">SPI_transfer</a>(spi, &amp;t0)) { status = SPI_STATUS_FAIL;</div><div class="line">}</div><div class="line"></div><div class="line">t1.<a class="code" href="struct_s_p_i___transaction.html#a9461a248f1cceb4048668d44b323a0b8">txBuf</a> = txBuff1; t1.<a class="code" href="struct_s_p_i___transaction.html#a214f57d7809c875fb9456a62a406e041">rxBuf</a> = rxBuff1; t1.<a class="code" href="struct_s_p_i___transaction.html#ad049d6a900c4bdb59a5ee8ce3d5bced2">count</a> = 1000; <span class="keywordflow">if</span></div><div class="line">(!<a class="code" href="group___s_p_i.html#ga989e17f96b54fcc3dc2cac5f8ac6bdb2">SPI_transfer</a>(spi, &amp;t1)) { status = SPI_STATUS_FAIL;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Enable the transfers if (status == SPI_STATUS_SUCCESS) { SPI_control(spi,</span></div><div class="line"><a class="code" href="group___s_p_i_m_s_p_m0___c_m_d.html#ga243ecdc4c5cdc1215ae0e9cc4c824988">SPIMSPM0_CMD_MANUAL_START</a>, NULL);</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span> { status = SPI_STATUS_FAILURE;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// At this point the peripheral is ready for the controller to start the</span></div><div class="line">transfer <span class="comment">// Assume the callback implementation (not shown) posts a semaphore</span></div><div class="line">when <span class="comment">// the last transaction completes sem_wait(&amp;spiSemaphore);</span></div><div class="line"></div><div class="line"><span class="comment">// Disable manual start mode SPI_control(spi, SPIMSPM0_CMD_CLR_MANUAL,</span></div><div class="line">NULL);</div></div><!-- fragment --><h3>Ensure low power during inactive periods<a class="anchor" id="USE_CASE_LPWR"></a></h3>
<p>External hardware connected on the SPI, i.e. SPI controller/peripheral, might have configured a pull on one or more of the SPI lines. Dependent on the hardware, it might conflict with the pull used for the device SPI. To avoid increased leakage and ensure the lowest possible power consumption when the SPI is inactive, the application must configure a matching pull on the SPI IOs. An example of how this can be done is shown below.</p>
<div class="fragment"><div class="line"><a class="code" href="struct_s_p_i___params.html">SPI_Params</a> params; <a class="code" href="struct_s_p_i___transaction.html">SPI_Transaction</a> transaction; uint8_t txBuf[] =</div><div class="line"><span class="stringliteral">&quot;Heartbeat&quot;</span>;    <span class="comment">// Transmit buffer uint8_t rxBuf[9];                 //</span></div><div class="line">Receive buffer uint32_t standbyDurationMs = 100;</div><div class="line"></div><div class="line"><span class="comment">// Init SPI and specify non-default parameters SPI_Params_init(&amp;params);</span></div><div class="line">params.<a class="code" href="struct_s_p_i___params.html#ab3f035044fdbe75adac8c1d729d8cf20">bitRate</a>     = 500000; params.<a class="code" href="struct_s_p_i___params.html#a67b5ebb8ec72796a0260c427c91cc093">frameFormat</a> = SPI_POL1_PHA1;</div><div class="line">params.<a class="code" href="struct_s_p_i___params.html#abe5eca64adf4ca96bed206a271d9b157">mode</a>        = <a class="code" href="group___s_p_i.html#gga60a7e3d74577b38aa79ea6983362f942a061361eeeb9e87265edcc0c70868111a">SPI_CONTROLLER</a>;</div><div class="line"></div><div class="line"><span class="comment">// Configure the transaction transaction.count = sizeof(txBuf);</span></div><div class="line">transaction.<a class="code" href="struct_s_p_i___transaction.html#a9461a248f1cceb4048668d44b323a0b8">txBuf</a> = txBuf; transaction.<a class="code" href="struct_s_p_i___transaction.html#a214f57d7809c875fb9456a62a406e041">rxBuf</a> = rxBuf;</div><div class="line"></div><div class="line"><span class="comment">// Open the SPI and perform the transfer handle = SPI_open(CONFIG_SPI_0,</span></div><div class="line">&amp;params);</div><div class="line"></div><div class="line"><span class="comment">// Apply low power sleep pull config for POCI</span></div><div class="line"><a class="code" href="group___g_p_i_o.html#ga015b75143cc3b8914cc298c5c4fc097e">GPIO_setConfig</a>(CONFIG_GPIO_SPI_0_POCI, <a class="code" href="group___g_p_i_o___pin_config_settings.html#ga4fb7b60751481b6988049fe8fa94a7d7">GPIO_CFG_IN_PU</a>);</div><div class="line"></div><div class="line"><span class="comment">// Do forever while(1) { // Transfer data SPI_transfer(handle,</span></div><div class="line">&amp;transaction); <span class="comment">// Sleep Task_sleep(standbyDurationMs*100);</span></div><div class="line">}</div></div><!-- fragment --><h3>Wake Up On Chip Select Deassertion In Peripheral Mode Using <a class="el" href="group___s_p_i.html#ggab9ea76c6529d6076eee5e1c4a5a92c6fa5631e69925c47a62a261c78ebbda39fb">SPI_MODE_CALLBACK</a></h3>
<p>This example demonstrates using a GPIO callback on Chip Select to wake up the device to allow low power modes while waiting for a chip select edge.</p>
<p>In sysconfig or the board file, the CSN GPIO should be configured as input/pull up with an interrupt on falling edge. Otherwise, <a class="el" href="group___s_p_i.html#ga0e3448b30b88609fa120915e49560601" title="Function to close a SPI peripheral specified by the SPI handle. ">SPI_close()</a> will reset the pin to the wrong settings and you may see line glitches.</p>
<p>*Note: The SPI controller must allow enough time between deasserting the chip select and the start of the transaction for the SPI peripheral to wake up and open up the SPI driver.</p>
<div class="fragment"><div class="line"><span class="comment">// Global variables SPI_Handle spiHandle SPI_Params spiParams;</span></div><div class="line"><a class="code" href="struct_s_p_i___transaction.html">SPI_Transaction</a> spiTransaction; <span class="keyword">const</span> uint8_t transferSize = 8; uint8_t</div><div class="line">txBuf[8];</div><div class="line"></div><div class="line"><span class="comment">// Chip select callback static void chipSelectCallback(uint_least8_t)</span></div><div class="line">{</div><div class="line">    <span class="comment">// Open SPI driver, which will override any previous GPIO configuration</span></div><div class="line">    spiHandle = <a class="code" href="group___s_p_i.html#ga9c9022decfb136991d6b53f7dd2ae2fc">SPI_open</a>(CONFIG_SPI, &amp;spiParams);</div><div class="line">    <span class="comment">// Issue the transfer</span></div><div class="line">    <a class="code" href="group___s_p_i.html#ga989e17f96b54fcc3dc2cac5f8ac6bdb2">SPI_transfer</a>(spiHandle, &amp;spiTransaction);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// SPI transfer callback static void transferCallback(SPI_Handle handle,</span></div><div class="line"><a class="code" href="struct_s_p_i___transaction.html">SPI_Transaction</a> *transaction)</div><div class="line">{</div><div class="line">    <span class="comment">// Close the SPI driver</span></div><div class="line">    <a class="code" href="group___s_p_i.html#ga0e3448b30b88609fa120915e49560601">SPI_close</a>(handle);</div><div class="line"></div><div class="line">    <span class="comment">// Note: SPI_close() will reset the pin configuration, so it is</span></div><div class="line">    important to</div><div class="line">    <span class="comment">// set the default values correctly in sysconfig. We just need to set</span></div><div class="line">    the</div><div class="line">    <span class="comment">// callback and enable the falling edge interrupt</span></div><div class="line"></div><div class="line">    <a class="code" href="group___g_p_i_o.html#ga24c401f32e65f60f11a1594fdafb9d2a">GPIO_setCallback</a>(CS_PIN_INDEX, chipSelectCallback);</div><div class="line">    <a class="code" href="group___g_p_i_o.html#ga31c4e65b3855424418262e35521c7051">GPIO_enableInt</a>(CS_PIN_INDEX);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// From your_application.c static void taskFxn(uintptr_t a0, uintptr_t a1)</span></div><div class="line">{</div><div class="line">    uint8_t i;</div><div class="line"></div><div class="line">    <span class="comment">// Setup SPI params</span></div><div class="line">    <a class="code" href="group___s_p_i.html#ga9c3dd1748332fd6e31c79a6538a71642">SPI_Params_init</a>(&amp;spiParams);</div><div class="line">    spiParams.bitRate     = 1000000;</div><div class="line">    spiParams.frameFormat = SPI_POL1_PHA1;</div><div class="line">    spiParams.mode        = <a class="code" href="group___s_p_i.html#gga60a7e3d74577b38aa79ea6983362f942adf4cb39226caf2dcd726e13d39546393">SPI_PERIPHERAL</a>;</div><div class="line">    spiParams.dataSize    = transferSize;</div><div class="line">    spiParams.transferMode = <a class="code" href="group___s_p_i.html#ggab9ea76c6529d6076eee5e1c4a5a92c6fa5631e69925c47a62a261c78ebbda39fb">SPI_MODE_CALLBACK</a>;</div><div class="line">    spiParams.transferCallbackFxn = transferCallback;</div><div class="line"></div><div class="line">    <span class="comment">// Setup SPI transaction</span></div><div class="line">    spiTransaction.<a class="code" href="struct_s_p_i___transaction.html#ac47daaa10705d748ace918a098aa1945">arg</a> = NULL;</div><div class="line">    spiTransaction.<a class="code" href="struct_s_p_i___transaction.html#ad049d6a900c4bdb59a5ee8ce3d5bced2">count</a> = transferSize;</div><div class="line">    spiTransaction.<a class="code" href="struct_s_p_i___transaction.html#a9461a248f1cceb4048668d44b323a0b8">txBuf</a> = txBuf;</div><div class="line">    spiTransaction.<a class="code" href="struct_s_p_i___transaction.html#a214f57d7809c875fb9456a62a406e041">rxBuf</a> = txBuf;</div><div class="line"></div><div class="line">    <span class="comment">// First echo message</span></div><div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; transferSize; i++) {</div><div class="line">        txBuf[i] = i;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Configure chip select callback</span></div><div class="line">    <a class="code" href="group___g_p_i_o.html#ga24c401f32e65f60f11a1594fdafb9d2a">GPIO_setCallback</a>(CS_PIN_INDEX, chipSelectCallback);</div><div class="line">    <a class="code" href="group___g_p_i_o.html#ga31c4e65b3855424418262e35521c7051">GPIO_enableInt</a>(CS_PIN_INDEX);</div><div class="line"></div><div class="line">    <span class="comment">// Wait forever</span></div><div class="line">    <span class="keywordflow">while</span>(<span class="keyword">true</span>);</div><div class="line">}</div></div><!-- fragment --><hr/>
 <h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga19d7d203a1e73d4fdf18add8e6bda371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19d7d203a1e73d4fdf18add8e6bda371">&sect;&nbsp;</a></span>SPIMSPM0_FrameSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_p_i_m_s_p_m0.html#ga19d7d203a1e73d4fdf18add8e6bda371">SPIMSPM0_FrameSize</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPIMSPM0 data frame size is used to determine how to configure the DMA data transfers. This field is to be only used internally. </p>
<ul>
<li>SPIMSPM0_8bit: txBuf and rxBuf are arrays of uint8_t elements</li>
<li>SPIMSPM0_16bit: txBuf and rxBuf are arrays of uint16_t elements </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga19d7d203a1e73d4fdf18add8e6bda371af1079c2402b17c3529d9c42a42d31e00"></a>SPIMSPM0_8bit&#160;</td><td class="fielddoc"><p>Frame size 8bit </p>
</td></tr>
<tr><td class="fieldname"><a id="gga19d7d203a1e73d4fdf18add8e6bda371a54bb8a176ef256dcc8672cb52c1f6e82"></a>SPIMSPM0_16bit&#160;</td><td class="fielddoc"><p>Frame size 8bit </p>
</td></tr>
</table>

</div>
</div>
<a id="ga7fba94adf8e4fc2252260108d1097e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fba94adf8e4fc2252260108d1097e76">&sect;&nbsp;</a></span>SPIMSPM0_ReturnPartial</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_p_i_m_s_p_m0.html#ga7fba94adf8e4fc2252260108d1097e76">SPIMSPM0_ReturnPartial</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPIMSPM0 return partial field indicates the status of the return partial mode and the associated pin interrupt. This field is for internal use only. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga7fba94adf8e4fc2252260108d1097e76a6c70e9cb9b6f2bc190272c740d9f16ee"></a>SPIMSPM0_retPartDisabled&#160;</td><td class="fielddoc"><p>Return partial disabled </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7fba94adf8e4fc2252260108d1097e76aba17e0035fe92196aa47f57c28972c78"></a>SPIMSPM0_retPartEnabledIntNotSet&#160;</td><td class="fielddoc"><p>Return partial enable interrupt is not set </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7fba94adf8e4fc2252260108d1097e76a967c890f4b33974e0a40f88b958ba762"></a>SPIMSPM0_retPartEnabledIntSet&#160;</td><td class="fielddoc"><p>Return partial enable interrupt is set </p>
</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">© Copyright 1995-2025</a>, Texas Instruments Incorporated. All rights reserved. <br/>
  <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
