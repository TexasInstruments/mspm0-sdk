<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>MSPM0C1105_C1106 Driver Library: Flash Controller (FLASHCTL)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MSPM0C1105_C1106 Driver Library
   &#160;<span id="projectnumber">2.05.01.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Flash Controller (FLASHCTL)</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Flash Controller (FLASHCTL):</div>
<div class="dyncontent">
<center><table><tr><td><img src="group___f_l_a_s_h_c_t_l.png" border="0" alt="" usemap="#group______f__l__a__s__h__c__t__l"/>
<map name="group______f__l__a__s__h__c__t__l" id="group______f__l__a__s__h__c__t__l">
<area shape="rect" id="node1" href="group___d_l___f_l_a_s_h_c_t_l___c_o_m_m_a_n_d___t_y_p_e.html" title="DL_FLASHCTL_COMMAND_TYPE" alt="" coords="260,5,491,32"/>
<area shape="rect" id="node2" href="group___d_l___f_l_a_s_h_c_t_l___i_n_t_e_r_r_u_p_t.html" title="DL_FLASHCTL_INTERRUPT" alt="" coords="278,56,473,83"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group___d_l___f_l_a_s_h_c_t_l___i_n_t_e_r_r_u_p_t"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_l___f_l_a_s_h_c_t_l___i_n_t_e_r_r_u_p_t.html">DL_FLASHCTL_INTERRUPT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___d_l___f_l_a_s_h_c_t_l___c_o_m_m_a_n_d___t_y_p_e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_l___f_l_a_s_h_c_t_l___c_o_m_m_a_n_d___t_y_p_e.html">DL_FLASHCTL_COMMAND_TYPE</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga1fbc2d1db2bec0ea44c58a1dcde072bb"><td class="memItemLeft" align="right" valign="top"><a id="ga1fbc2d1db2bec0ea44c58a1dcde072bb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga1fbc2d1db2bec0ea44c58a1dcde072bb">DEVICE_HAS_NO_CMDWEPROTA</a></td></tr>
<tr class="memdesc:ga1fbc2d1db2bec0ea44c58a1dcde072bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device does not have CMDWEPROTA. <br /></td></tr>
<tr class="separator:ga1fbc2d1db2bec0ea44c58a1dcde072bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3deb3bf1642e247a461ed82407086e3c"><td class="memItemLeft" align="right" valign="top"><a id="ga3deb3bf1642e247a461ed82407086e3c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga3deb3bf1642e247a461ed82407086e3c">FLASHCTL_BANK0_ADDRESS</a>&#160;&#160;&#160;(0x00000000)</td></tr>
<tr class="memdesc:ga3deb3bf1642e247a461ed82407086e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Address for Bank 0. <br /></td></tr>
<tr class="separator:ga3deb3bf1642e247a461ed82407086e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bb2935fff71f76119f77b221e8318a8"><td class="memItemLeft" align="right" valign="top"><a id="ga7bb2935fff71f76119f77b221e8318a8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga7bb2935fff71f76119f77b221e8318a8">FLASHCTL_MAIN_ADDRESS</a>&#160;&#160;&#160;(0x00000000)</td></tr>
<tr class="memdesc:ga7bb2935fff71f76119f77b221e8318a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Address for MAIN memory region. <br /></td></tr>
<tr class="separator:ga7bb2935fff71f76119f77b221e8318a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa232fcaa2594403eca8a196d91fb418e"><td class="memItemLeft" align="right" valign="top"><a id="gaa232fcaa2594403eca8a196d91fb418e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gaa232fcaa2594403eca8a196d91fb418e">FLASHCTL_NONMAIN_ADDRESS</a>&#160;&#160;&#160;(0x41c00000)</td></tr>
<tr class="memdesc:gaa232fcaa2594403eca8a196d91fb418e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Address for NONMAIN memory region. <br /></td></tr>
<tr class="separator:gaa232fcaa2594403eca8a196d91fb418e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf0bf0d8889b1ca8d7073a67cff7c391"><td class="memItemLeft" align="right" valign="top"><a id="gadf0bf0d8889b1ca8d7073a67cff7c391"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gadf0bf0d8889b1ca8d7073a67cff7c391">NUMBER_OF_NONMAIN_SECTORS</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:gadf0bf0d8889b1ca8d7073a67cff7c391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of NONMAIN sectors. <br /></td></tr>
<tr class="separator:gadf0bf0d8889b1ca8d7073a67cff7c391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga392705d339fddbc783a53d53643022be"><td class="memItemLeft" align="right" valign="top"><a id="ga392705d339fddbc783a53d53643022be"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga392705d339fddbc783a53d53643022be">FLASHCTL_DATA_ADDRESS</a>&#160;&#160;&#160;(0x41d00000)</td></tr>
<tr class="memdesc:ga392705d339fddbc783a53d53643022be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Address for DATA memory region. <br /></td></tr>
<tr class="separator:ga392705d339fddbc783a53d53643022be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac37215b452881babe46dd71bcd74f40e"><td class="memItemLeft" align="right" valign="top"><a id="gac37215b452881babe46dd71bcd74f40e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gac37215b452881babe46dd71bcd74f40e">DL_FLASHCTL_PROGRAM_8_WITHOUT_ECC</a>&#160;&#160;&#160;(0x00000001)</td></tr>
<tr class="memdesc:gac37215b452881babe46dd71bcd74f40e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable programming 8 bits without ECC enabled. <br /></td></tr>
<tr class="separator:gac37215b452881babe46dd71bcd74f40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd8c0b18b625a4c29f82b58a1bd9aa28"><td class="memItemLeft" align="right" valign="top"><a id="gabd8c0b18b625a4c29f82b58a1bd9aa28"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gabd8c0b18b625a4c29f82b58a1bd9aa28">DL_FLASHCTL_PROGRAM_16_WITHOUT_ECC</a>&#160;&#160;&#160;(0x00000003)</td></tr>
<tr class="memdesc:gabd8c0b18b625a4c29f82b58a1bd9aa28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable programming 16 bits without ECC enabled. <br /></td></tr>
<tr class="separator:gabd8c0b18b625a4c29f82b58a1bd9aa28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac64cbad891c3ef3c3e2b36a1a88eb931"><td class="memItemLeft" align="right" valign="top"><a id="gac64cbad891c3ef3c3e2b36a1a88eb931"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gac64cbad891c3ef3c3e2b36a1a88eb931">DL_FLASHCTL_PROGRAM_32_WITHOUT_ECC</a>&#160;&#160;&#160;(0x0000000F)</td></tr>
<tr class="memdesc:gac64cbad891c3ef3c3e2b36a1a88eb931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable programming 32 bits without ECC enabled. <br /></td></tr>
<tr class="separator:gac64cbad891c3ef3c3e2b36a1a88eb931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2816869cc6b6faf40fe2969fc02fa7bc"><td class="memItemLeft" align="right" valign="top"><a id="ga2816869cc6b6faf40fe2969fc02fa7bc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga2816869cc6b6faf40fe2969fc02fa7bc">DL_FLASHCTL_PROGRAM_64_WITHOUT_ECC</a>&#160;&#160;&#160;(0x000000FF)</td></tr>
<tr class="memdesc:ga2816869cc6b6faf40fe2969fc02fa7bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable programming 64 bits without ECC enabled. <br /></td></tr>
<tr class="separator:ga2816869cc6b6faf40fe2969fc02fa7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c31b12c0ce40c0f1162e3742d11df06"><td class="memItemLeft" align="right" valign="top"><a id="ga8c31b12c0ce40c0f1162e3742d11df06"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga8c31b12c0ce40c0f1162e3742d11df06">DL_FLASHCTL_PROGRAM_8_WITH_ECC</a>&#160;&#160;&#160;(0x00000101)</td></tr>
<tr class="memdesc:ga8c31b12c0ce40c0f1162e3742d11df06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable programming 8 bits with ECC enabled. <br /></td></tr>
<tr class="separator:ga8c31b12c0ce40c0f1162e3742d11df06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9018618a1480835633fad37550de183f"><td class="memItemLeft" align="right" valign="top"><a id="ga9018618a1480835633fad37550de183f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga9018618a1480835633fad37550de183f">DL_FLASHCTL_PROGRAM_16_WITH_ECC</a>&#160;&#160;&#160;(0x00000103)</td></tr>
<tr class="memdesc:ga9018618a1480835633fad37550de183f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable programming 16 bits with ECC enabled. <br /></td></tr>
<tr class="separator:ga9018618a1480835633fad37550de183f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3acb428f8d553755d36d433c3a8f98b9"><td class="memItemLeft" align="right" valign="top"><a id="ga3acb428f8d553755d36d433c3a8f98b9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga3acb428f8d553755d36d433c3a8f98b9">DL_FLASHCTL_PROGRAM_32_WITH_ECC</a>&#160;&#160;&#160;(0x0000010F)</td></tr>
<tr class="memdesc:ga3acb428f8d553755d36d433c3a8f98b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable programming 32 bits with ECC enabled. <br /></td></tr>
<tr class="separator:ga3acb428f8d553755d36d433c3a8f98b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e5fc4d084ac9e4949c216107b8a1b68"><td class="memItemLeft" align="right" valign="top"><a id="ga0e5fc4d084ac9e4949c216107b8a1b68"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga0e5fc4d084ac9e4949c216107b8a1b68">DL_FLASHCTL_PROGRAM_64_WITH_ECC</a>&#160;&#160;&#160;(0x000001FF)</td></tr>
<tr class="memdesc:ga0e5fc4d084ac9e4949c216107b8a1b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable programming 64 bits with ECC enabled. <br /></td></tr>
<tr class="separator:ga0e5fc4d084ac9e4949c216107b8a1b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f63f81a174fe730a93c957c53c88b4c"><td class="memItemLeft" align="right" valign="top"><a id="ga9f63f81a174fe730a93c957c53c88b4c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga9f63f81a174fe730a93c957c53c88b4c">DL_FLASHCTL_READ_VERIFY_8_WITHOUT_ECC</a>&#160;&#160;&#160;(0x00000001)</td></tr>
<tr class="memdesc:ga9f63f81a174fe730a93c957c53c88b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable programming 64 bits with ECC enabled. <br /></td></tr>
<tr class="separator:ga9f63f81a174fe730a93c957c53c88b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf95ce3a27208a98a79dcf5dd02a90f1"><td class="memItemLeft" align="right" valign="top"><a id="gadf95ce3a27208a98a79dcf5dd02a90f1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gadf95ce3a27208a98a79dcf5dd02a90f1">DL_FLASHCTL_READ_VERIFY_16_WITHOUT_ECC</a>&#160;&#160;&#160;(0x00000003)</td></tr>
<tr class="memdesc:gadf95ce3a27208a98a79dcf5dd02a90f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable programming 64 bits with ECC enabled. <br /></td></tr>
<tr class="separator:gadf95ce3a27208a98a79dcf5dd02a90f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4a3e46deb854d77c9eb7b45ec744050"><td class="memItemLeft" align="right" valign="top"><a id="gaa4a3e46deb854d77c9eb7b45ec744050"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gaa4a3e46deb854d77c9eb7b45ec744050">DL_FLASHCTL_READ_VERIFY_32_WITHOUT_ECC</a>&#160;&#160;&#160;(0x0000000F)</td></tr>
<tr class="memdesc:gaa4a3e46deb854d77c9eb7b45ec744050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable programming 64 bits with ECC enabled. <br /></td></tr>
<tr class="separator:gaa4a3e46deb854d77c9eb7b45ec744050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01c509cfb556f175801c2d4bd00fe95b"><td class="memItemLeft" align="right" valign="top"><a id="ga01c509cfb556f175801c2d4bd00fe95b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga01c509cfb556f175801c2d4bd00fe95b">DL_FLASHCTL_READ_VERIFY_64_WITHOUT_ECC</a>&#160;&#160;&#160;(0x000000FF)</td></tr>
<tr class="memdesc:ga01c509cfb556f175801c2d4bd00fe95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable programming 64 bits with ECC enabled. <br /></td></tr>
<tr class="separator:ga01c509cfb556f175801c2d4bd00fe95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab51c578d4ca9aeae6339c6fcedcd507f"><td class="memItemLeft" align="right" valign="top"><a id="gab51c578d4ca9aeae6339c6fcedcd507f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gab51c578d4ca9aeae6339c6fcedcd507f">DL_FLASHCTL_READ_VERIFY_8_WITH_ECC</a>&#160;&#160;&#160;(0x00000101)</td></tr>
<tr class="memdesc:gab51c578d4ca9aeae6339c6fcedcd507f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable programming 64 bits with ECC enabled. <br /></td></tr>
<tr class="separator:gab51c578d4ca9aeae6339c6fcedcd507f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f16c970b798b6050e15b3e6af3b0d97"><td class="memItemLeft" align="right" valign="top"><a id="ga6f16c970b798b6050e15b3e6af3b0d97"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga6f16c970b798b6050e15b3e6af3b0d97">DL_FLASHCTL_READ_VERIFY_16_WITH_ECC</a>&#160;&#160;&#160;(0x00000103)</td></tr>
<tr class="memdesc:ga6f16c970b798b6050e15b3e6af3b0d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable programming 64 bits with ECC enabled. <br /></td></tr>
<tr class="separator:ga6f16c970b798b6050e15b3e6af3b0d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0a3cb01a1c85b93704e38e4bd3a8cfc"><td class="memItemLeft" align="right" valign="top"><a id="gae0a3cb01a1c85b93704e38e4bd3a8cfc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gae0a3cb01a1c85b93704e38e4bd3a8cfc">DL_FLASHCTL_READ_VERIFY_32_WITH_ECC</a>&#160;&#160;&#160;(0x0000010F)</td></tr>
<tr class="memdesc:gae0a3cb01a1c85b93704e38e4bd3a8cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable programming 64 bits with ECC enabled. <br /></td></tr>
<tr class="separator:gae0a3cb01a1c85b93704e38e4bd3a8cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa29cba255afe27ff6d3c37a92bd1ca51"><td class="memItemLeft" align="right" valign="top"><a id="gaa29cba255afe27ff6d3c37a92bd1ca51"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gaa29cba255afe27ff6d3c37a92bd1ca51">DL_FLASHCTL_READ_VERIFY_64_WITH_ECC</a>&#160;&#160;&#160;(0x000001FF)</td></tr>
<tr class="memdesc:gaa29cba255afe27ff6d3c37a92bd1ca51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable programming 64 bits with ECC enabled. <br /></td></tr>
<tr class="separator:gaa29cba255afe27ff6d3c37a92bd1ca51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39de6b05e60ebfe83038fb3ff273d81e"><td class="memItemLeft" align="right" valign="top"><a id="ga39de6b05e60ebfe83038fb3ff273d81e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga39de6b05e60ebfe83038fb3ff273d81e">DL_FLASHCTL_SECTOR_SIZE</a>&#160;&#160;&#160;(1024)</td></tr>
<tr class="memdesc:ga39de6b05e60ebfe83038fb3ff273d81e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of one flash sector. <br /></td></tr>
<tr class="separator:ga39de6b05e60ebfe83038fb3ff273d81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga987c2ff9232d4205c98af65ff7d7c2e2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga987c2ff9232d4205c98af65ff7d7c2e2">DL_FLASHCTL_COMMAND_SIZE</a> { <br />
&#160;&#160;<a class="el" href="group___f_l_a_s_h_c_t_l.html#gga987c2ff9232d4205c98af65ff7d7c2e2adf1053097cc9922b5182155e01255b15">DL_FLASHCTL_COMMAND_SIZE_ONE_WORD</a> = FLASHCTL_CMDTYPE_SIZE_ONEWORD, 
<br />
&#160;&#160;<a class="el" href="group___f_l_a_s_h_c_t_l.html#gga987c2ff9232d4205c98af65ff7d7c2e2abb50257fbb0d576fef26a5d2112b4e24">DL_FLASHCTL_COMMAND_SIZE_TWO_WORDS</a> = FLASHCTL_CMDTYPE_SIZE_TWOWORD, 
<br />
&#160;&#160;<a class="el" href="group___f_l_a_s_h_c_t_l.html#gga987c2ff9232d4205c98af65ff7d7c2e2a28b17ae7f6c070c932e5c535b0763cf5">DL_FLASHCTL_COMMAND_SIZE_FOUR_WORDS</a> = FLASHCTL_CMDTYPE_SIZE_FOURWORD, 
<br />
&#160;&#160;<a class="el" href="group___f_l_a_s_h_c_t_l.html#gga987c2ff9232d4205c98af65ff7d7c2e2a34f344faced02509aa3d2a03f402b193">DL_FLASHCTL_COMMAND_SIZE_EIGHT_WORDS</a> = FLASHCTL_CMDTYPE_SIZE_EIGHTWORD, 
<br />
&#160;&#160;<a class="el" href="group___f_l_a_s_h_c_t_l.html#gga987c2ff9232d4205c98af65ff7d7c2e2a93756d02007450e02e9745f92d139faa">DL_FLASHCTL_COMMAND_SIZE_SECTOR</a> = FLASHCTL_CMDTYPE_SIZE_SECTOR, 
<br />
&#160;&#160;<a class="el" href="group___f_l_a_s_h_c_t_l.html#gga987c2ff9232d4205c98af65ff7d7c2e2a503c9f595f41a0efc5581cbf1c681a0e">DL_FLASHCTL_COMMAND_SIZE_BANK</a> = FLASHCTL_CMDTYPE_SIZE_BANK
<br />
 }</td></tr>
<tr class="separator:ga987c2ff9232d4205c98af65ff7d7c2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8b5345481dd655cbd20dadc84e7621b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gad8b5345481dd655cbd20dadc84e7621b">DL_FLASHCTL_REGION_SELECT</a> { <br />
&#160;&#160;<a class="el" href="group___f_l_a_s_h_c_t_l.html#ggad8b5345481dd655cbd20dadc84e7621ba992837cf4fe4e551a02fdf985f83d977">DL_FLASHCTL_REGION_SELECT_MAIN</a> = FLASHCTL_CMDCTL_REGIONSEL_MAIN, 
<br />
&#160;&#160;<a class="el" href="group___f_l_a_s_h_c_t_l.html#ggad8b5345481dd655cbd20dadc84e7621ba68ba353b3fa5fee3f6bac5da4ad66aa2">DL_FLASHCTL_REGION_SELECT_NONMAIN</a> = FLASHCTL_CMDCTL_REGIONSEL_NONMAIN
<br />
 }</td></tr>
<tr class="separator:gad8b5345481dd655cbd20dadc84e7621b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab85614b8c0ccf0edbede3f8e67a805ab"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gab85614b8c0ccf0edbede3f8e67a805ab">DL_FLASHCTL_BANK_SELECT</a> { <br />
&#160;&#160;<a class="el" href="group___f_l_a_s_h_c_t_l.html#ggab85614b8c0ccf0edbede3f8e67a805aba469d493dea13302d213e20befce7b94a">DL_FLASHCTL_BANK_SELECT_0</a> = FLASHCTL_CMDCTL_BANKSEL_BANK0, 
<br />
&#160;&#160;<a class="el" href="group___f_l_a_s_h_c_t_l.html#ggab85614b8c0ccf0edbede3f8e67a805abaf267fa2c57968390c6449a6a2bc6107e">DL_FLASHCTL_BANK_SELECT_1</a> = FLASHCTL_CMDCTL_BANKSEL_BANK1, 
<br />
&#160;&#160;<a class="el" href="group___f_l_a_s_h_c_t_l.html#ggab85614b8c0ccf0edbede3f8e67a805aba7d7882342a37aa042f78cf6732ee51d1">DL_FLASHCTL_BANK_SELECT_2</a> = FLASHCTL_CMDCTL_BANKSEL_BANK2, 
<br />
&#160;&#160;<a class="el" href="group___f_l_a_s_h_c_t_l.html#ggab85614b8c0ccf0edbede3f8e67a805aba5dc6e5f89e2e9c78517859ed2f27d5c4">DL_FLASHCTL_BANK_SELECT_3</a> = FLASHCTL_CMDCTL_BANKSEL_BANK3, 
<br />
&#160;&#160;<a class="el" href="group___f_l_a_s_h_c_t_l.html#ggab85614b8c0ccf0edbede3f8e67a805aba3644c8b23ed91301a575d23923ac95a3">DL_FLASHCTL_BANK_SELECT_4</a> = FLASHCTL_CMDCTL_BANKSEL_BANK4
<br />
 }</td></tr>
<tr class="separator:gab85614b8c0ccf0edbede3f8e67a805ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga148c247b2058dd33c0dba6912fe5786d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga148c247b2058dd33c0dba6912fe5786d">DL_FLASHCTL_FAIL_TYPE</a> { <br />
&#160;&#160;<a class="el" href="group___f_l_a_s_h_c_t_l.html#gga148c247b2058dd33c0dba6912fe5786da7bcfa6d4196d07b0067781185e554222">DL_FLASHCTL_FAIL_TYPE_NO_FAILURE</a> = 0x0, 
<br />
&#160;&#160;<a class="el" href="group___f_l_a_s_h_c_t_l.html#gga148c247b2058dd33c0dba6912fe5786da3693c465277bb8947a26833098c01a07">DL_FLASHCTL_FAIL_TYPE_WRITE_ERASE_PROTECT</a>, 
<br />
&#160;&#160;<a class="el" href="group___f_l_a_s_h_c_t_l.html#gga148c247b2058dd33c0dba6912fe5786dad7b8a08caa79cf5b5efed26bfd9017a7">DL_FLASHCTL_FAIL_TYPE_VERIFY_ERROR</a> = FLASHCTL_STATCMD_FAILVERIFY_STATFAIL, 
<br />
&#160;&#160;<a class="el" href="group___f_l_a_s_h_c_t_l.html#gga148c247b2058dd33c0dba6912fe5786daec821c206bcdc07e76ede93d67145cdb">DL_FLASHCTL_FAIL_TYPE_ILLEGAL_ADDRESS</a>, 
<br />
&#160;&#160;<a class="el" href="group___f_l_a_s_h_c_t_l.html#gga148c247b2058dd33c0dba6912fe5786da7c63943cf22c972a22388a1cfe5cc6f7">DL_FLASHCTL_FAIL_TYPE_WRONG_BANK_MODE</a> = FLASHCTL_STATCMD_FAILMODE_STATFAIL, 
<br />
&#160;&#160;<a class="el" href="group___f_l_a_s_h_c_t_l.html#gga148c247b2058dd33c0dba6912fe5786da0342be3257c9488dc0e1da5472836d9d">DL_FLASHCTL_FAIL_TYPE_MISCELLANEOUS</a> = FLASHCTL_STATCMD_FAILMISC_STATFAIL
<br />
 }</td></tr>
<tr class="separator:ga148c247b2058dd33c0dba6912fe5786d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81a568bc9c0c10f386e22832683db339"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a> { <br />
&#160;&#160;<a class="el" href="group___f_l_a_s_h_c_t_l.html#gga81a568bc9c0c10f386e22832683db339ab949d825efba5be4a2b2bae18e22d674">DL_FLASHCTL_COMMAND_STATUS_PASSED</a>, 
<br />
&#160;&#160;<a class="el" href="group___f_l_a_s_h_c_t_l.html#gga81a568bc9c0c10f386e22832683db339ac935ccce01e97c83b69ce849da44597d">DL_FLASHCTL_COMMAND_STATUS_FAILED</a>, 
<br />
&#160;&#160;<a class="el" href="group___f_l_a_s_h_c_t_l.html#gga81a568bc9c0c10f386e22832683db339a8cfd0b0cd5b76a5ce243f3baf6bf07a0">DL_FLASHCTL_COMMAND_STATUS_IN_PROGRESS</a>
<br />
 }</td></tr>
<tr class="separator:ga81a568bc9c0c10f386e22832683db339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61f98ec6fb62e3ecfb573819e96147a8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga61f98ec6fb62e3ecfb573819e96147a8">DL_FLASHCTL_IIDX</a> { <a class="el" href="group___f_l_a_s_h_c_t_l.html#gga61f98ec6fb62e3ecfb573819e96147a8a833d62cb187f2ae4d9c5770eccecb8af">DL_FLASHCTL_IIDX_DONE</a> = FLASHCTL_IIDX_STAT_DONE
 }</td></tr>
<tr class="separator:ga61f98ec6fb62e3ecfb573819e96147a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gafb7776d53f6157a156ee71f57f4b4bb5"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gafb7776d53f6157a156ee71f57f4b4bb5">DL_FlashCTL_enableInterrupt</a> (FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:gafb7776d53f6157a156ee71f57f4b4bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable flash interrupt.  <a href="#gafb7776d53f6157a156ee71f57f4b4bb5">More...</a><br /></td></tr>
<tr class="separator:gafb7776d53f6157a156ee71f57f4b4bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacd2cbcae3f85821039020ff8d3c9c70"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gaacd2cbcae3f85821039020ff8d3c9c70">DL_FlashCTL_disableInterrupt</a> (FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:gaacd2cbcae3f85821039020ff8d3c9c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable flash interrupt.  <a href="#gaacd2cbcae3f85821039020ff8d3c9c70">More...</a><br /></td></tr>
<tr class="separator:gaacd2cbcae3f85821039020ff8d3c9c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e6e76dd093da9a1badf89866ef8cc38"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga3e6e76dd093da9a1badf89866ef8cc38">DL_FlashCTL_isInterruptEnabled</a> (const FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:ga3e6e76dd093da9a1badf89866ef8cc38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the flash interrupt is enabled.  <a href="#ga3e6e76dd093da9a1badf89866ef8cc38">More...</a><br /></td></tr>
<tr class="separator:ga3e6e76dd093da9a1badf89866ef8cc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7513eea8dcb21dec9965a66ca47befe1"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga7513eea8dcb21dec9965a66ca47befe1">DL_FlashCTL_getEnabledInterruptStatus</a> (const FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:ga7513eea8dcb21dec9965a66ca47befe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check interrupt flag of enabled flash interrupt.  <a href="#ga7513eea8dcb21dec9965a66ca47befe1">More...</a><br /></td></tr>
<tr class="separator:ga7513eea8dcb21dec9965a66ca47befe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa13a422ce58fa23d6137a967c7dd81ed"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gaa13a422ce58fa23d6137a967c7dd81ed">DL_FlashCTL_getRawInterruptStatus</a> (const FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:gaa13a422ce58fa23d6137a967c7dd81ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check interrupt flag of the flash interrupt.  <a href="#gaa13a422ce58fa23d6137a967c7dd81ed">More...</a><br /></td></tr>
<tr class="separator:gaa13a422ce58fa23d6137a967c7dd81ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc497fb4a0ea4e57fc318a67cac08dfb"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gadc497fb4a0ea4e57fc318a67cac08dfb">DL_FlashCTL_getPendingInterrupt</a> (const FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:gadc497fb4a0ea4e57fc318a67cac08dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get highest priority pending flash interrupt.  <a href="#gadc497fb4a0ea4e57fc318a67cac08dfb">More...</a><br /></td></tr>
<tr class="separator:gadc497fb4a0ea4e57fc318a67cac08dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9477a883130a6cf81440d69c33cf002"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gab9477a883130a6cf81440d69c33cf002">DL_FlashCTL_clearInterruptStatus</a> (FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:gab9477a883130a6cf81440d69c33cf002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear pending flash interrupt.  <a href="#gab9477a883130a6cf81440d69c33cf002">More...</a><br /></td></tr>
<tr class="separator:gab9477a883130a6cf81440d69c33cf002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1118a3433d32d2a7f0731090a9fd9ef"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gab1118a3433d32d2a7f0731090a9fd9ef">DL_FlashCTL_isCommandExecuted</a> (const FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:gab1118a3433d32d2a7f0731090a9fd9ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a command execution has been initiated.  <a href="#gab1118a3433d32d2a7f0731090a9fd9ef">More...</a><br /></td></tr>
<tr class="separator:gab1118a3433d32d2a7f0731090a9fd9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb3e1c28dd9c81317fb0b2d364f81b8b"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gadb3e1c28dd9c81317fb0b2d364f81b8b">DL_FlashCTL_setCommandExecute</a> (FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:gadb3e1c28dd9c81317fb0b2d364f81b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates a command execution.  <a href="#gadb3e1c28dd9c81317fb0b2d364f81b8b">More...</a><br /></td></tr>
<tr class="separator:gadb3e1c28dd9c81317fb0b2d364f81b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e38b8715f307800221bf9f2b8eb5dc8"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5e38b8715f307800221bf9f2b8eb5dc8">DL_FlashCTL_disbleStairStepErase</a> (FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:ga5e38b8715f307800221bf9f2b8eb5dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable Stair-Step Erase.  <a href="#ga5e38b8715f307800221bf9f2b8eb5dc8">More...</a><br /></td></tr>
<tr class="separator:ga5e38b8715f307800221bf9f2b8eb5dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f47360383fbcc574cc8a03088c0e226"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga0f47360383fbcc574cc8a03088c0e226">DL_FlashCTL_isStairStepEraseDisabled</a> (const FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:ga0f47360383fbcc574cc8a03088c0e226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if stair-step erase is disabled.  <a href="#ga0f47360383fbcc574cc8a03088c0e226">More...</a><br /></td></tr>
<tr class="separator:ga0f47360383fbcc574cc8a03088c0e226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8f3f63de6bd64d7e1b7e55cf831be14"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gac8f3f63de6bd64d7e1b7e55cf831be14">DL_FlashCTL_enableStairStepErase</a> (FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:gac8f3f63de6bd64d7e1b7e55cf831be14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable Stair-Step Erase.  <a href="#gac8f3f63de6bd64d7e1b7e55cf831be14">More...</a><br /></td></tr>
<tr class="separator:gac8f3f63de6bd64d7e1b7e55cf831be14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e4f99d3c28d5cc863d7287e0283a835"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga4e4f99d3c28d5cc863d7287e0283a835">DL_FlashCTL_enableAddressOverrideMode</a> (FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:ga4e4f99d3c28d5cc863d7287e0283a835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable address override mode.  <a href="#ga4e4f99d3c28d5cc863d7287e0283a835">More...</a><br /></td></tr>
<tr class="separator:ga4e4f99d3c28d5cc863d7287e0283a835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8694858cba97bc17128586d1aa39f2e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gad8694858cba97bc17128586d1aa39f2e">DL_FlashCTL_isAddressOverrideModeEnabled</a> (const FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:gad8694858cba97bc17128586d1aa39f2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if address override mode is enabled.  <a href="#gad8694858cba97bc17128586d1aa39f2e">More...</a><br /></td></tr>
<tr class="separator:gad8694858cba97bc17128586d1aa39f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9abd4b91d2a27a2389384ef5711275ab"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga9abd4b91d2a27a2389384ef5711275ab">DL_FlashCTL_disableAddressOverrideMode</a> (FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:ga9abd4b91d2a27a2389384ef5711275ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable address override mode.  <a href="#ga9abd4b91d2a27a2389384ef5711275ab">More...</a><br /></td></tr>
<tr class="separator:ga9abd4b91d2a27a2389384ef5711275ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf328d7e267b95496ff4e0d7b37e831a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gacf328d7e267b95496ff4e0d7b37e831a">DL_FlashCTL_enableOverrideHardwareGeneratedECC</a> (FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:gacf328d7e267b95496ff4e0d7b37e831a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable overriding hardware generation of ECC code.  <a href="#gacf328d7e267b95496ff4e0d7b37e831a">More...</a><br /></td></tr>
<tr class="separator:gacf328d7e267b95496ff4e0d7b37e831a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8921b213267180bf65d50c64e0fb4f27"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga8921b213267180bf65d50c64e0fb4f27">DL_FlashCTL_isOverrideHardwareGeneratedECCEnabled</a> (const FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:ga8921b213267180bf65d50c64e0fb4f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if overriding hardware generation of ECC code is enabled.  <a href="#ga8921b213267180bf65d50c64e0fb4f27">More...</a><br /></td></tr>
<tr class="separator:ga8921b213267180bf65d50c64e0fb4f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga425a9da6de8a129833b47834093f34fb"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga425a9da6de8a129833b47834093f34fb">DL_FlashCTL_disableOverrideHardwareGeneratedECC</a> (FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:ga425a9da6de8a129833b47834093f34fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable overriding hardware generation of ECC code.  <a href="#ga425a9da6de8a129833b47834093f34fb">More...</a><br /></td></tr>
<tr class="separator:ga425a9da6de8a129833b47834093f34fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bb1ecbfe03fc31018af12c1046e4dab"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5bb1ecbfe03fc31018af12c1046e4dab">DL_FlashCTL_setRegionSelect</a> (FLASHCTL_Regs *flashctl, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gad8b5345481dd655cbd20dadc84e7621b">DL_FLASHCTL_REGION_SELECT</a> region)</td></tr>
<tr class="memdesc:ga5bb1ecbfe03fc31018af12c1046e4dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the region select.  <a href="#ga5bb1ecbfe03fc31018af12c1046e4dab">More...</a><br /></td></tr>
<tr class="separator:ga5bb1ecbfe03fc31018af12c1046e4dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga574d42757557fc8e652c3a337c2b3760"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___f_l_a_s_h_c_t_l.html#gad8b5345481dd655cbd20dadc84e7621b">DL_FLASHCTL_REGION_SELECT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga574d42757557fc8e652c3a337c2b3760">DL_FlashCTL_getRegionSelect</a> (const FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:ga574d42757557fc8e652c3a337c2b3760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the region select.  <a href="#ga574d42757557fc8e652c3a337c2b3760">More...</a><br /></td></tr>
<tr class="separator:ga574d42757557fc8e652c3a337c2b3760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2681fd5db3e7c951d44b3ef0d6dff7ec"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga2681fd5db3e7c951d44b3ef0d6dff7ec">DL_FlashCTL_setBankSelect</a> (FLASHCTL_Regs *flashctl, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gab85614b8c0ccf0edbede3f8e67a805ab">DL_FLASHCTL_BANK_SELECT</a> bank)</td></tr>
<tr class="memdesc:ga2681fd5db3e7c951d44b3ef0d6dff7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the bank select.  <a href="#ga2681fd5db3e7c951d44b3ef0d6dff7ec">More...</a><br /></td></tr>
<tr class="separator:ga2681fd5db3e7c951d44b3ef0d6dff7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga138c067ca038b6c098ddea659da6c8ce"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___f_l_a_s_h_c_t_l.html#gab85614b8c0ccf0edbede3f8e67a805ab">DL_FLASHCTL_BANK_SELECT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga138c067ca038b6c098ddea659da6c8ce">DL_FlashCTL_getBankSelect</a> (const FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:ga138c067ca038b6c098ddea659da6c8ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bank select.  <a href="#ga138c067ca038b6c098ddea659da6c8ce">More...</a><br /></td></tr>
<tr class="separator:ga138c067ca038b6c098ddea659da6c8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cbae37dc3a2fa67f121f4f5e1395705"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga3cbae37dc3a2fa67f121f4f5e1395705">DL_FlashCTL_setCommandByteEnable</a> (FLASHCTL_Regs *flashctl, uint32_t byteMask)</td></tr>
<tr class="memdesc:ga3cbae37dc3a2fa67f121f4f5e1395705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the bytes to enable for programming data.  <a href="#ga3cbae37dc3a2fa67f121f4f5e1395705">More...</a><br /></td></tr>
<tr class="separator:ga3cbae37dc3a2fa67f121f4f5e1395705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bfd7733edd162a9470fd055b1380f50"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga7bfd7733edd162a9470fd055b1380f50">DL_FlashCTL_getCommandByteEnable</a> (const FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:ga7bfd7733edd162a9470fd055b1380f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bytes that are enabled for programming data.  <a href="#ga7bfd7733edd162a9470fd055b1380f50">More...</a><br /></td></tr>
<tr class="separator:ga7bfd7733edd162a9470fd055b1380f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1fd2784d1bfd7f49c6651391e120680"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gab1fd2784d1bfd7f49c6651391e120680">DL_FlashCTL_setCommandData</a> (FLASHCTL_Regs *flashctl, uint8_t index, const uint32_t *data)</td></tr>
<tr class="memdesc:gab1fd2784d1bfd7f49c6651391e120680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the data for a command data register.  <a href="#gab1fd2784d1bfd7f49c6651391e120680">More...</a><br /></td></tr>
<tr class="separator:gab1fd2784d1bfd7f49c6651391e120680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48ccc7de469db2d960dcdb254f613f2e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga48ccc7de469db2d960dcdb254f613f2e">DL_FlashCTL_getCommandData</a> (FLASHCTL_Regs *flashctl, uint8_t index)</td></tr>
<tr class="memdesc:ga48ccc7de469db2d960dcdb254f613f2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data from a command data register.  <a href="#ga48ccc7de469db2d960dcdb254f613f2e">More...</a><br /></td></tr>
<tr class="separator:ga48ccc7de469db2d960dcdb254f613f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77c94b92134bf40c5170468edfd04c62"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga77c94b92134bf40c5170468edfd04c62">DL_FlashCTL_setCommandDataECC</a> (FLASHCTL_Regs *flashctl, uint8_t index, const uint8_t *data)</td></tr>
<tr class="memdesc:ga77c94b92134bf40c5170468edfd04c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the ECC code in the command data ECC register.  <a href="#ga77c94b92134bf40c5170468edfd04c62">More...</a><br /></td></tr>
<tr class="separator:ga77c94b92134bf40c5170468edfd04c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cdcc7b95fc24fcda9558886090dc4db"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5cdcc7b95fc24fcda9558886090dc4db">DL_FlashCTL_getCommandDataECC</a> (FLASHCTL_Regs *flashctl, uint8_t index)</td></tr>
<tr class="memdesc:ga5cdcc7b95fc24fcda9558886090dc4db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ECC code in the command data ECC register.  <a href="#ga5cdcc7b95fc24fcda9558886090dc4db">More...</a><br /></td></tr>
<tr class="separator:ga5cdcc7b95fc24fcda9558886090dc4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8495c14d057e452ecb27f68455d34514"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga8495c14d057e452ecb27f68455d34514">DL_FlashCTL_setCommandAddress</a> (FLASHCTL_Regs *flashctl, uint32_t address)</td></tr>
<tr class="memdesc:ga8495c14d057e452ecb27f68455d34514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the target address for a command.  <a href="#ga8495c14d057e452ecb27f68455d34514">More...</a><br /></td></tr>
<tr class="separator:ga8495c14d057e452ecb27f68455d34514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa03088df9bedddc7a9f013d183565121"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gaa03088df9bedddc7a9f013d183565121">DL_FlashCTL_getCommandStatus</a> (const FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:gaa03088df9bedddc7a9f013d183565121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the status of the current command.  <a href="#gaa03088df9bedddc7a9f013d183565121">More...</a><br /></td></tr>
<tr class="separator:gaa03088df9bedddc7a9f013d183565121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5909153bc16bfa44a51bab33a82262c3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga148c247b2058dd33c0dba6912fe5786d">DL_FLASHCTL_FAIL_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5909153bc16bfa44a51bab33a82262c3">DL_FlashCTL_getFailureStatus</a> (const FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:ga5909153bc16bfa44a51bab33a82262c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the reason a command failed.  <a href="#ga5909153bc16bfa44a51bab33a82262c3">More...</a><br /></td></tr>
<tr class="separator:ga5909153bc16bfa44a51bab33a82262c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5261cbd42cb4a724bc1dc1543cd24631"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> (const FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:ga5261cbd42cb4a724bc1dc1543cd24631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking function that waits for a command execution to finish.  <a href="#ga5261cbd42cb4a724bc1dc1543cd24631">More...</a><br /></td></tr>
<tr class="separator:ga5261cbd42cb4a724bc1dc1543cd24631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbd4eaed6070854f2691339142ca9397"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gacbd4eaed6070854f2691339142ca9397">DL_FlashCTL_executeClearStatus</a> (FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:gacbd4eaed6070854f2691339142ca9397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets clear status bit and executes command.  <a href="#gacbd4eaed6070854f2691339142ca9397">More...</a><br /></td></tr>
<tr class="separator:gacbd4eaed6070854f2691339142ca9397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aeadf2178f1a939be163efedbeec566"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga7aeadf2178f1a939be163efedbeec566">DL_FlashCTL_getFlashSectorNumber</a> (FLASHCTL_Regs *flashctl, uint32_t addr)</td></tr>
<tr class="memdesc:ga7aeadf2178f1a939be163efedbeec566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sector number of the input address over the whole memory map.  <a href="#ga7aeadf2178f1a939be163efedbeec566">More...</a><br /></td></tr>
<tr class="separator:ga7aeadf2178f1a939be163efedbeec566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec5c6d11afcd6bcac2db0e2789892b5d"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gaec5c6d11afcd6bcac2db0e2789892b5d">DL_FlashCTL_getFlashSectorNumberInBank</a> (FLASHCTL_Regs *flashctl, uint32_t addr)</td></tr>
<tr class="memdesc:gaec5c6d11afcd6bcac2db0e2789892b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sector number of the input address relative to the bank of the address.  <a href="#gaec5c6d11afcd6bcac2db0e2789892b5d">More...</a><br /></td></tr>
<tr class="separator:gaec5c6d11afcd6bcac2db0e2789892b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2df0ed388d831b60b05b484767af9da6"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga2df0ed388d831b60b05b484767af9da6">DL_FlashCTL_setWaitState</a> (FLASHCTL_Regs *flashctl, uint32_t waitState)</td></tr>
<tr class="memdesc:ga2df0ed388d831b60b05b484767af9da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of wait states used by the Flash.  <a href="#ga2df0ed388d831b60b05b484767af9da6">More...</a><br /></td></tr>
<tr class="separator:ga2df0ed388d831b60b05b484767af9da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc7476e6bbc482257af980476a9316d6"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState</a> (const FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:gafc7476e6bbc482257af980476a9316d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of wait states used by the Flash.  <a href="#gafc7476e6bbc482257af980476a9316d6">More...</a><br /></td></tr>
<tr class="separator:gafc7476e6bbc482257af980476a9316d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2d0a45785ecf6057a9fb76899150819"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gad2d0a45785ecf6057a9fb76899150819">DL_FlashCTL_eraseMemory</a> (FLASHCTL_Regs *flashctl, uint32_t address, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga987c2ff9232d4205c98af65ff7d7c2e2">DL_FLASHCTL_COMMAND_SIZE</a> memorySize)</td></tr>
<tr class="memdesc:gad2d0a45785ecf6057a9fb76899150819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an erase on unprotected memory.  <a href="#gad2d0a45785ecf6057a9fb76899150819">More...</a><br /></td></tr>
<tr class="separator:gad2d0a45785ecf6057a9fb76899150819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08dca5922bc739dd8e4439f7d4882a39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga08dca5922bc739dd8e4439f7d4882a39">DL_FlashCTL_eraseMemoryFromRAM</a> (FLASHCTL_Regs *flashctl, uint32_t address, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga987c2ff9232d4205c98af65ff7d7c2e2">DL_FLASHCTL_COMMAND_SIZE</a> memorySize)</td></tr>
<tr class="memdesc:ga08dca5922bc739dd8e4439f7d4882a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an erase on unprotected memory, and executes command from RAM.  <a href="#ga08dca5922bc739dd8e4439f7d4882a39">More...</a><br /></td></tr>
<tr class="separator:ga08dca5922bc739dd8e4439f7d4882a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0a7add5d14c16c7b8f470457dbac991"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gad0a7add5d14c16c7b8f470457dbac991">DL_FlashCTL_massErase</a> (FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:gad0a7add5d14c16c7b8f470457dbac991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a mass erase on main memory on one bank.  <a href="#gad0a7add5d14c16c7b8f470457dbac991">More...</a><br /></td></tr>
<tr class="separator:gad0a7add5d14c16c7b8f470457dbac991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb4228a5e605be29f26f0ca96d006e0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gafb4228a5e605be29f26f0ca96d006e0b">DL_FlashCTL_massEraseFromRAM</a> (FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:gafb4228a5e605be29f26f0ca96d006e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a mass erase on main memory, and executes command from RAM.  <a href="#gafb4228a5e605be29f26f0ca96d006e0b">More...</a><br /></td></tr>
<tr class="separator:gafb4228a5e605be29f26f0ca96d006e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc2373933a2ffc87984143c33aa8e671"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gadc2373933a2ffc87984143c33aa8e671">DL_FlashCTL_massEraseMultiBank</a> (FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:gadc2373933a2ffc87984143c33aa8e671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a mass erase on main memory, and erases all flash banks.  <a href="#gadc2373933a2ffc87984143c33aa8e671">More...</a><br /></td></tr>
<tr class="separator:gadc2373933a2ffc87984143c33aa8e671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4de77451a9f9825d5598be8def66081"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gac4de77451a9f9825d5598be8def66081">DL_FlashCTL_factoryReset</a> (FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:gac4de77451a9f9825d5598be8def66081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a factory reset erase on main and non-main memory.  <a href="#gac4de77451a9f9825d5598be8def66081">More...</a><br /></td></tr>
<tr class="separator:gac4de77451a9f9825d5598be8def66081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9560031f2dc8b370e3991ec67c1a126e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga9560031f2dc8b370e3991ec67c1a126e">DL_FlashCTL_factoryResetFromRAM</a> (FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:ga9560031f2dc8b370e3991ec67c1a126e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a factory reset erase on main and non-main memory, and executes command from RAM.  <a href="#ga9560031f2dc8b370e3991ec67c1a126e">More...</a><br /></td></tr>
<tr class="separator:ga9560031f2dc8b370e3991ec67c1a126e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68b9b8090c318278b40fad8fbb7f446c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga68b9b8090c318278b40fad8fbb7f446c">DL_FlashCTL_factoryResetMultiBank</a> (FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:ga68b9b8090c318278b40fad8fbb7f446c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a factory reset erase on main and non-main memory.  <a href="#ga68b9b8090c318278b40fad8fbb7f446c">More...</a><br /></td></tr>
<tr class="separator:ga68b9b8090c318278b40fad8fbb7f446c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga901335b104e5cc54a5d05fa310676217"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga901335b104e5cc54a5d05fa310676217">DL_FlashCTL_programMemory8</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint8_t *data)</td></tr>
<tr class="memdesc:ga901335b104e5cc54a5d05fa310676217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs 8 bit data to unprotected memory at the given address.  <a href="#ga901335b104e5cc54a5d05fa310676217">More...</a><br /></td></tr>
<tr class="separator:ga901335b104e5cc54a5d05fa310676217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44fe6a364f21423893dce7f051e38f53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga44fe6a364f21423893dce7f051e38f53">DL_FlashCTL_programMemoryFromRAM8</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint8_t *data)</td></tr>
<tr class="memdesc:ga44fe6a364f21423893dce7f051e38f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs 8 bit data to unprotected memory at the given address, and executes command from RAM.  <a href="#ga44fe6a364f21423893dce7f051e38f53">More...</a><br /></td></tr>
<tr class="separator:ga44fe6a364f21423893dce7f051e38f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc6aaa3dc48e49c84d0d9a433fb66f8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gabc6aaa3dc48e49c84d0d9a433fb66f8d">DL_FlashCTL_programMemory16</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint16_t *data)</td></tr>
<tr class="memdesc:gabc6aaa3dc48e49c84d0d9a433fb66f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs 16 bit data to unprotected memory at the given address.  <a href="#gabc6aaa3dc48e49c84d0d9a433fb66f8d">More...</a><br /></td></tr>
<tr class="separator:gabc6aaa3dc48e49c84d0d9a433fb66f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b63595169bf9e9c75948b7e34a008c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga6b63595169bf9e9c75948b7e34a008c1">DL_FlashCTL_programMemoryFromRAM16</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint16_t *data)</td></tr>
<tr class="memdesc:ga6b63595169bf9e9c75948b7e34a008c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs 16 bit data to unprotected memory at the given address, and executes command from RAM.  <a href="#ga6b63595169bf9e9c75948b7e34a008c1">More...</a><br /></td></tr>
<tr class="separator:ga6b63595169bf9e9c75948b7e34a008c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b57a5818313fd322c643ea1b3ff3b4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga2b57a5818313fd322c643ea1b3ff3b4b">DL_FlashCTL_programMemory32</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint32_t *data)</td></tr>
<tr class="memdesc:ga2b57a5818313fd322c643ea1b3ff3b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs 32 bit data to unprotected memory at the given address.  <a href="#ga2b57a5818313fd322c643ea1b3ff3b4b">More...</a><br /></td></tr>
<tr class="separator:ga2b57a5818313fd322c643ea1b3ff3b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa024d88df7a9f69060dfb006f7b4df5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gaa024d88df7a9f69060dfb006f7b4df5f">DL_FlashCTL_programMemoryFromRAM32</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint32_t *data)</td></tr>
<tr class="memdesc:gaa024d88df7a9f69060dfb006f7b4df5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs 32 bit data to unprotected memory at the given address, and executes command from RAM.  <a href="#gaa024d88df7a9f69060dfb006f7b4df5f">More...</a><br /></td></tr>
<tr class="separator:gaa024d88df7a9f69060dfb006f7b4df5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85c242871e8559bacdc133eb7972889d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga85c242871e8559bacdc133eb7972889d">DL_FlashCTL_programMemory64</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint32_t *data)</td></tr>
<tr class="memdesc:ga85c242871e8559bacdc133eb7972889d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs 64 bit data to unprotected memory at the given address.  <a href="#ga85c242871e8559bacdc133eb7972889d">More...</a><br /></td></tr>
<tr class="separator:ga85c242871e8559bacdc133eb7972889d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8249cc8d333fe100bd0845f2ceba8ae2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga8249cc8d333fe100bd0845f2ceba8ae2">DL_FlashCTL_programMemoryFromRAM64</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint32_t *data)</td></tr>
<tr class="memdesc:ga8249cc8d333fe100bd0845f2ceba8ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs 64 bit data to unprotected memory at the given address, and executes command from RAM.  <a href="#ga8249cc8d333fe100bd0845f2ceba8ae2">More...</a><br /></td></tr>
<tr class="separator:ga8249cc8d333fe100bd0845f2ceba8ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9283e69a72f7de9bf4e3d0126e5464bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga9283e69a72f7de9bf4e3d0126e5464bc">DL_FlashCTL_programMemory8WithECCGenerated</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint8_t *data)</td></tr>
<tr class="memdesc:ga9283e69a72f7de9bf4e3d0126e5464bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs 8 bit data with hardware generated ECC code.  <a href="#ga9283e69a72f7de9bf4e3d0126e5464bc">More...</a><br /></td></tr>
<tr class="separator:ga9283e69a72f7de9bf4e3d0126e5464bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac768f9a334a3ad8796e31ffc6b0002e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gac768f9a334a3ad8796e31ffc6b0002e9">DL_FlashCTL_programMemoryFromRAM8WithECCGenerated</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint8_t *data)</td></tr>
<tr class="memdesc:gac768f9a334a3ad8796e31ffc6b0002e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs 8 bit data with hardware generated ECC code, and executes command from RAM.  <a href="#gac768f9a334a3ad8796e31ffc6b0002e9">More...</a><br /></td></tr>
<tr class="separator:gac768f9a334a3ad8796e31ffc6b0002e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga272050a9943419cb0149f7f936337861"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga272050a9943419cb0149f7f936337861">DL_FlashCTL_programMemory16WithECCGenerated</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint16_t *data)</td></tr>
<tr class="memdesc:ga272050a9943419cb0149f7f936337861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs 16 bit data with hardware generated ECC code.  <a href="#ga272050a9943419cb0149f7f936337861">More...</a><br /></td></tr>
<tr class="separator:ga272050a9943419cb0149f7f936337861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ad0a914a44ca9a016afeec4ac010756"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga1ad0a914a44ca9a016afeec4ac010756">DL_FlashCTL_programMemoryFromRAM16WithECCGenerated</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint16_t *data)</td></tr>
<tr class="memdesc:ga1ad0a914a44ca9a016afeec4ac010756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs 16 bit data with hardware generated ECC code, and executes command from RAM.  <a href="#ga1ad0a914a44ca9a016afeec4ac010756">More...</a><br /></td></tr>
<tr class="separator:ga1ad0a914a44ca9a016afeec4ac010756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10e1550de79bcce6df3042ba995b1780"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga10e1550de79bcce6df3042ba995b1780">DL_FlashCTL_programMemory32WithECCGenerated</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint32_t *data)</td></tr>
<tr class="memdesc:ga10e1550de79bcce6df3042ba995b1780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs 32 bit data with hardware generated ECC code.  <a href="#ga10e1550de79bcce6df3042ba995b1780">More...</a><br /></td></tr>
<tr class="separator:ga10e1550de79bcce6df3042ba995b1780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5981511a622102266cd0f383813da4d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5981511a622102266cd0f383813da4d6">DL_FlashCTL_programMemoryFromRAM32WithECCGenerated</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint32_t *data)</td></tr>
<tr class="memdesc:ga5981511a622102266cd0f383813da4d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs 32 bit data with hardware generated ECC code, and executes command from RAM.  <a href="#ga5981511a622102266cd0f383813da4d6">More...</a><br /></td></tr>
<tr class="separator:ga5981511a622102266cd0f383813da4d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5040ae1f581f8359a902585a3d1abf71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5040ae1f581f8359a902585a3d1abf71">DL_FlashCTL_programMemory64WithECCGenerated</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint32_t *data)</td></tr>
<tr class="memdesc:ga5040ae1f581f8359a902585a3d1abf71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs 64 bit data with hardware generated ECC code.  <a href="#ga5040ae1f581f8359a902585a3d1abf71">More...</a><br /></td></tr>
<tr class="separator:ga5040ae1f581f8359a902585a3d1abf71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17ed9d9ae7260b3c754e527c24de901e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga17ed9d9ae7260b3c754e527c24de901e">DL_FlashCTL_programMemoryFromRAM64WithECCGenerated</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint32_t *data)</td></tr>
<tr class="memdesc:ga17ed9d9ae7260b3c754e527c24de901e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs 64 bit data with hardware generated ECC code, and executes command from RAM.  <a href="#ga17ed9d9ae7260b3c754e527c24de901e">More...</a><br /></td></tr>
<tr class="separator:ga17ed9d9ae7260b3c754e527c24de901e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46c3f9272bcd36868812a31fb092a72b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga46c3f9272bcd36868812a31fb092a72b">DL_FlashCTL_programMemory8WithECCManual</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint8_t *data, const uint8_t *eccCode)</td></tr>
<tr class="memdesc:ga46c3f9272bcd36868812a31fb092a72b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs 8 bit data with user provided ECC code.  <a href="#ga46c3f9272bcd36868812a31fb092a72b">More...</a><br /></td></tr>
<tr class="separator:ga46c3f9272bcd36868812a31fb092a72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d24d3b01b0306dd8abd9f60039a7c69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5d24d3b01b0306dd8abd9f60039a7c69">DL_FlashCTL_programMemoryFromRAM8WithECCManual</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint8_t *data, const uint8_t *eccCode)</td></tr>
<tr class="memdesc:ga5d24d3b01b0306dd8abd9f60039a7c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs 8 bit data with user provided ECC code, and executes command from RAM.  <a href="#ga5d24d3b01b0306dd8abd9f60039a7c69">More...</a><br /></td></tr>
<tr class="separator:ga5d24d3b01b0306dd8abd9f60039a7c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a395feddcfd61d07314c68d20de7bef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga4a395feddcfd61d07314c68d20de7bef">DL_FlashCTL_programMemory16WithECCManual</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint16_t *data, const uint8_t *eccCode)</td></tr>
<tr class="memdesc:ga4a395feddcfd61d07314c68d20de7bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs 16 bit data with user provided ECC code.  <a href="#ga4a395feddcfd61d07314c68d20de7bef">More...</a><br /></td></tr>
<tr class="separator:ga4a395feddcfd61d07314c68d20de7bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf90c1b387a1f1e4c89f2f2dd3c9d04b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gaaf90c1b387a1f1e4c89f2f2dd3c9d04b">DL_FlashCTL_programMemoryFromRAM16WithECCManual</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint16_t *data, const uint8_t *eccCode)</td></tr>
<tr class="memdesc:gaaf90c1b387a1f1e4c89f2f2dd3c9d04b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs 16 bit data with user provided ECC code, and executes command from RAM.  <a href="#gaaf90c1b387a1f1e4c89f2f2dd3c9d04b">More...</a><br /></td></tr>
<tr class="separator:gaaf90c1b387a1f1e4c89f2f2dd3c9d04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36abe0765d95d555d6e90b058e0df53c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga36abe0765d95d555d6e90b058e0df53c">DL_FlashCTL_programMemory32WithECCManual</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint32_t *data, const uint8_t *eccCode)</td></tr>
<tr class="memdesc:ga36abe0765d95d555d6e90b058e0df53c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs 32 bit data with user provided ECC code.  <a href="#ga36abe0765d95d555d6e90b058e0df53c">More...</a><br /></td></tr>
<tr class="separator:ga36abe0765d95d555d6e90b058e0df53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83ceb7b89e55b8a1c899e8218cbcc4bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga83ceb7b89e55b8a1c899e8218cbcc4bc">DL_FlashCTL_programMemoryFromRAM32WithECCManual</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint32_t *data, const uint8_t *eccCode)</td></tr>
<tr class="memdesc:ga83ceb7b89e55b8a1c899e8218cbcc4bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs 32 bit data with user provided ECC code, and executes command from RAM.  <a href="#ga83ceb7b89e55b8a1c899e8218cbcc4bc">More...</a><br /></td></tr>
<tr class="separator:ga83ceb7b89e55b8a1c899e8218cbcc4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaea9cb0c24c2935af10797a1b3aa997d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gaaea9cb0c24c2935af10797a1b3aa997d">DL_FlashCTL_programMemory64WithECCManual</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint32_t *data, const uint8_t *eccCode)</td></tr>
<tr class="memdesc:gaaea9cb0c24c2935af10797a1b3aa997d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs 64 bit data with user provided ECC code.  <a href="#gaaea9cb0c24c2935af10797a1b3aa997d">More...</a><br /></td></tr>
<tr class="separator:gaaea9cb0c24c2935af10797a1b3aa997d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac307a33adef09fa0534f70d5d42743ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gac307a33adef09fa0534f70d5d42743ba">DL_FlashCTL_programMemoryFromRAM64WithECCManual</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint32_t *data, const uint8_t *eccCode)</td></tr>
<tr class="memdesc:gac307a33adef09fa0534f70d5d42743ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs 64 bit data with user provided ECC code, and executes command from RAM.  <a href="#gac307a33adef09fa0534f70d5d42743ba">More...</a><br /></td></tr>
<tr class="separator:gac307a33adef09fa0534f70d5d42743ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a01864fe9815f1117cbda07c38e0de5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5a01864fe9815f1117cbda07c38e0de5">DL_FlashCTL_programMemoryBlocking64WithECCGenerated</a> (FLASHCTL_Regs *flashctl, uint32_t address, uint32_t *data, uint32_t dataSize, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gad8b5345481dd655cbd20dadc84e7621b">DL_FLASHCTL_REGION_SELECT</a> regionSelect)</td></tr>
<tr class="memdesc:ga5a01864fe9815f1117cbda07c38e0de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs provided data with hardware generated ECC code.  <a href="#ga5a01864fe9815f1117cbda07c38e0de5">More...</a><br /></td></tr>
<tr class="separator:ga5a01864fe9815f1117cbda07c38e0de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf27b130aecc263d4a4cce6b54346e4cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gaf27b130aecc263d4a4cce6b54346e4cf">DL_FlashCTL_programMemoryBlockingFromRAM64WithECCGenerated</a> (FLASHCTL_Regs *flashctl, uint32_t address, uint32_t *data, uint32_t dataSize, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gad8b5345481dd655cbd20dadc84e7621b">DL_FLASHCTL_REGION_SELECT</a> regionSelect)</td></tr>
<tr class="memdesc:gaf27b130aecc263d4a4cce6b54346e4cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs provided data with hardware generated ECC code, and executes command from RAM.  <a href="#gaf27b130aecc263d4a4cce6b54346e4cf">More...</a><br /></td></tr>
<tr class="separator:gaf27b130aecc263d4a4cce6b54346e4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ea23446748b9a1eddc96b199b55e4f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga9ea23446748b9a1eddc96b199b55e4f6">DL_FlashCTL_programMemoryBlocking64WithECCManual</a> (FLASHCTL_Regs *flashctl, uint32_t address, uint32_t *data, uint8_t *eccCode, uint32_t dataSize, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gad8b5345481dd655cbd20dadc84e7621b">DL_FLASHCTL_REGION_SELECT</a> regionSelect)</td></tr>
<tr class="memdesc:ga9ea23446748b9a1eddc96b199b55e4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs provided data with user provided ECC code.  <a href="#ga9ea23446748b9a1eddc96b199b55e4f6">More...</a><br /></td></tr>
<tr class="separator:ga9ea23446748b9a1eddc96b199b55e4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f19934f5b5861ea8454a799ceaa642f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga7f19934f5b5861ea8454a799ceaa642f">DL_FlashCTL_programMemoryBlockingFromRAM64WithECCManual</a> (FLASHCTL_Regs *flashctl, uint32_t address, uint32_t *data, uint8_t *eccCode, uint32_t dataSize, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gad8b5345481dd655cbd20dadc84e7621b">DL_FLASHCTL_REGION_SELECT</a> regionSelect)</td></tr>
<tr class="memdesc:ga7f19934f5b5861ea8454a799ceaa642f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs provided data with user provided ECC code, and executes command from RAM.  <a href="#ga7f19934f5b5861ea8454a799ceaa642f">More...</a><br /></td></tr>
<tr class="separator:ga7f19934f5b5861ea8454a799ceaa642f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5644da91bdbf6df26ea6550da3dbc226"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5644da91bdbf6df26ea6550da3dbc226">DL_FlashCTL_programMemoryBlocking</a> (FLASHCTL_Regs *flashctl, uint32_t address, uint32_t *data, uint32_t dataSize, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gad8b5345481dd655cbd20dadc84e7621b">DL_FLASHCTL_REGION_SELECT</a> regionSelect)</td></tr>
<tr class="memdesc:ga5644da91bdbf6df26ea6550da3dbc226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs provided data to unprotected memory at a given address.  <a href="#ga5644da91bdbf6df26ea6550da3dbc226">More...</a><br /></td></tr>
<tr class="separator:ga5644da91bdbf6df26ea6550da3dbc226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8a38f51d18afd14036b7e83b431a8c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gab8a38f51d18afd14036b7e83b431a8c9">DL_FlashCTL_programMemoryFromRAM</a> (FLASHCTL_Regs *flashctl, uint32_t address, uint32_t *data, uint32_t dataSize, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gad8b5345481dd655cbd20dadc84e7621b">DL_FLASHCTL_REGION_SELECT</a> regionSelect)</td></tr>
<tr class="memdesc:gab8a38f51d18afd14036b7e83b431a8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs provided data to unprotected memory at a given address, and executes command from RAM.  <a href="#gab8a38f51d18afd14036b7e83b431a8c9">More...</a><br /></td></tr>
<tr class="separator:gab8a38f51d18afd14036b7e83b431a8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12f380dc9c7ead7114cabd8a35391c08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga12f380dc9c7ead7114cabd8a35391c08">DL_FlashCTL_unprotectMainMemory</a> (FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:ga12f380dc9c7ead7114cabd8a35391c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unprotects all main memory from erase/program.  <a href="#ga12f380dc9c7ead7114cabd8a35391c08">More...</a><br /></td></tr>
<tr class="separator:ga12f380dc9c7ead7114cabd8a35391c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga199e8316ff42b06115435a8fa7fe786b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga199e8316ff42b06115435a8fa7fe786b">DL_FlashCTL_unprotectDataMemory</a> (FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:ga199e8316ff42b06115435a8fa7fe786b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unprotects all data memory from erase/program.  <a href="#ga199e8316ff42b06115435a8fa7fe786b">More...</a><br /></td></tr>
<tr class="separator:ga199e8316ff42b06115435a8fa7fe786b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga043bf21b804a375035999cf54693ac93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga043bf21b804a375035999cf54693ac93">DL_FlashCTL_protectMainMemory</a> (FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:ga043bf21b804a375035999cf54693ac93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protects all main memory from erase/program.  <a href="#ga043bf21b804a375035999cf54693ac93">More...</a><br /></td></tr>
<tr class="separator:ga043bf21b804a375035999cf54693ac93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4b4326886983e1a9eedb3a8f723a031"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gab4b4326886983e1a9eedb3a8f723a031">DL_FlashCTL_unprotectNonMainMemory</a> (FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:gab4b4326886983e1a9eedb3a8f723a031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unprotects all non-main memory from erase/program.  <a href="#gab4b4326886983e1a9eedb3a8f723a031">More...</a><br /></td></tr>
<tr class="separator:gab4b4326886983e1a9eedb3a8f723a031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga487b9695b457dda8eb0d3375e9db8288"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga487b9695b457dda8eb0d3375e9db8288">DL_FlashCTL_protectNonMainMemory</a> (FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:ga487b9695b457dda8eb0d3375e9db8288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protects all non-main memory from erase/program.  <a href="#ga487b9695b457dda8eb0d3375e9db8288">More...</a><br /></td></tr>
<tr class="separator:ga487b9695b457dda8eb0d3375e9db8288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8da907b919959d7ca3d7af48dcd930d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gac8da907b919959d7ca3d7af48dcd930d">DL_FlashCTL_unprotectAllMemory</a> (FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:gac8da907b919959d7ca3d7af48dcd930d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unprotects all user memory from erase/program.  <a href="#gac8da907b919959d7ca3d7af48dcd930d">More...</a><br /></td></tr>
<tr class="separator:gac8da907b919959d7ca3d7af48dcd930d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07a63c746838aa5d38068d3257902130"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga07a63c746838aa5d38068d3257902130">DL_FlashCTL_protectAllMemory</a> (FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:ga07a63c746838aa5d38068d3257902130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protects all user memory from erase/program.  <a href="#ga07a63c746838aa5d38068d3257902130">More...</a><br /></td></tr>
<tr class="separator:ga07a63c746838aa5d38068d3257902130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff740a4d3903a5813bdcf631e24389cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gaff740a4d3903a5813bdcf631e24389cb">DL_FlashCTL_unprotectSector</a> (FLASHCTL_Regs *flashctl, uint32_t addr, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gad8b5345481dd655cbd20dadc84e7621b">DL_FLASHCTL_REGION_SELECT</a> regionSelect)</td></tr>
<tr class="memdesc:gaff740a4d3903a5813bdcf631e24389cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a given sector to unprotected from erase/program.  <a href="#gaff740a4d3903a5813bdcf631e24389cb">More...</a><br /></td></tr>
<tr class="separator:gaff740a4d3903a5813bdcf631e24389cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbb4906e8dc971d484af8ea532857c2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gabbb4906e8dc971d484af8ea532857c2a">DL_FlashCTL_protectSector</a> (FLASHCTL_Regs *flashctl, uint32_t addr, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gad8b5345481dd655cbd20dadc84e7621b">DL_FLASHCTL_REGION_SELECT</a> regionSelect)</td></tr>
<tr class="memdesc:gabbb4906e8dc971d484af8ea532857c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a given sector to protected from erase/program.  <a href="#gabbb4906e8dc971d484af8ea532857c2a">More...</a><br /></td></tr>
<tr class="separator:gabbb4906e8dc971d484af8ea532857c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bc534914795112833e002912bb71cae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga6bc534914795112833e002912bb71cae">DL_FlashCTL_readVerify8</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint8_t *data)</td></tr>
<tr class="memdesc:ga6bc534914795112833e002912bb71cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies 8-bit data in specified address.  <a href="#ga6bc534914795112833e002912bb71cae">More...</a><br /></td></tr>
<tr class="separator:ga6bc534914795112833e002912bb71cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3694eca18dc6136034957b9925f0509"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gaf3694eca18dc6136034957b9925f0509">DL_FlashCTL_readVerifyFromRAM8</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint8_t *data)</td></tr>
<tr class="memdesc:gaf3694eca18dc6136034957b9925f0509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies 8-bit data in specified address, and executes command from RAM.  <a href="#gaf3694eca18dc6136034957b9925f0509">More...</a><br /></td></tr>
<tr class="separator:gaf3694eca18dc6136034957b9925f0509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca5117d8a1b42e5ebe08f10be97a7948"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gaca5117d8a1b42e5ebe08f10be97a7948">DL_FlashCTL_readVerify16</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint16_t *data)</td></tr>
<tr class="memdesc:gaca5117d8a1b42e5ebe08f10be97a7948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies 16-bit data in specified address.  <a href="#gaca5117d8a1b42e5ebe08f10be97a7948">More...</a><br /></td></tr>
<tr class="separator:gaca5117d8a1b42e5ebe08f10be97a7948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga417c76df74c19349056920c2eadbde95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga417c76df74c19349056920c2eadbde95">DL_FlashCTL_readVerifyFromRAM16</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint16_t *data)</td></tr>
<tr class="memdesc:ga417c76df74c19349056920c2eadbde95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies 16-bit data in specified address, and executes command from RAM.  <a href="#ga417c76df74c19349056920c2eadbde95">More...</a><br /></td></tr>
<tr class="separator:ga417c76df74c19349056920c2eadbde95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7118c359b6c8a470a5e36067392458ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga7118c359b6c8a470a5e36067392458ad">DL_FlashCTL_readVerify32</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint32_t *data)</td></tr>
<tr class="memdesc:ga7118c359b6c8a470a5e36067392458ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies 32-bit data in specified address.  <a href="#ga7118c359b6c8a470a5e36067392458ad">More...</a><br /></td></tr>
<tr class="separator:ga7118c359b6c8a470a5e36067392458ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97997721be98f9773e6469e8bbf64e06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga97997721be98f9773e6469e8bbf64e06">DL_FlashCTL_readVerifyFromRAM32</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint32_t *data)</td></tr>
<tr class="memdesc:ga97997721be98f9773e6469e8bbf64e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies 32-bit data in specified address, and executes command from RAM.  <a href="#ga97997721be98f9773e6469e8bbf64e06">More...</a><br /></td></tr>
<tr class="separator:ga97997721be98f9773e6469e8bbf64e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabff25ac0682e62b0bb4de738c6b4d834"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gabff25ac0682e62b0bb4de738c6b4d834">DL_FlashCTL_readVerify64</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint32_t *data)</td></tr>
<tr class="memdesc:gabff25ac0682e62b0bb4de738c6b4d834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies 64-bit data in specified address.  <a href="#gabff25ac0682e62b0bb4de738c6b4d834">More...</a><br /></td></tr>
<tr class="separator:gabff25ac0682e62b0bb4de738c6b4d834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa568538d6891bd4d64576bf498ca1fb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gaa568538d6891bd4d64576bf498ca1fb5">DL_FlashCTL_readVerifyFromRAM64</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint32_t *data)</td></tr>
<tr class="memdesc:gaa568538d6891bd4d64576bf498ca1fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies 64-bit data in specified address, and executes command from RAM.  <a href="#gaa568538d6891bd4d64576bf498ca1fb5">More...</a><br /></td></tr>
<tr class="separator:gaa568538d6891bd4d64576bf498ca1fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc12a971702c1e447c1e94a77355ef04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gacc12a971702c1e447c1e94a77355ef04">DL_FlashCTL_readVerify8WithECCGenerated</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint8_t *data)</td></tr>
<tr class="memdesc:gacc12a971702c1e447c1e94a77355ef04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies 8-bit data in specified address with hardware generated ECC code.  <a href="#gacc12a971702c1e447c1e94a77355ef04">More...</a><br /></td></tr>
<tr class="separator:gacc12a971702c1e447c1e94a77355ef04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c952c5d1657b6c9b70cabfb5e61888d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5c952c5d1657b6c9b70cabfb5e61888d">DL_FlashCTL_readVerifyFromRAM8WithECCGenerated</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint8_t *data)</td></tr>
<tr class="memdesc:ga5c952c5d1657b6c9b70cabfb5e61888d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies 8-bit data in specified address with hardware generated ECC code, and executes command from RAM.  <a href="#ga5c952c5d1657b6c9b70cabfb5e61888d">More...</a><br /></td></tr>
<tr class="separator:ga5c952c5d1657b6c9b70cabfb5e61888d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac84b570f4c80811cd2b0d4bbd52ff102"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gac84b570f4c80811cd2b0d4bbd52ff102">DL_FlashCTL_readVerify16WithECCGenerated</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint16_t *data)</td></tr>
<tr class="memdesc:gac84b570f4c80811cd2b0d4bbd52ff102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies 16-bit data in specified address with hardware generated ECC code.  <a href="#gac84b570f4c80811cd2b0d4bbd52ff102">More...</a><br /></td></tr>
<tr class="separator:gac84b570f4c80811cd2b0d4bbd52ff102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf36894f80f8c5022274d51c164b0190"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gacf36894f80f8c5022274d51c164b0190">DL_FlashCTL_readVerifyFromRAM16WithECCGenerated</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint16_t *data)</td></tr>
<tr class="memdesc:gacf36894f80f8c5022274d51c164b0190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies 16-bit data in specified address with hardware generated ECC code, and executes command from RAM.  <a href="#gacf36894f80f8c5022274d51c164b0190">More...</a><br /></td></tr>
<tr class="separator:gacf36894f80f8c5022274d51c164b0190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1fcf7b3155939db21d87ebaf0d5763d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gaa1fcf7b3155939db21d87ebaf0d5763d">DL_FlashCTL_readVerify32WithECCGenerated</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint32_t *data)</td></tr>
<tr class="memdesc:gaa1fcf7b3155939db21d87ebaf0d5763d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies 32-bit data in specified address with hardware generated ECC code.  <a href="#gaa1fcf7b3155939db21d87ebaf0d5763d">More...</a><br /></td></tr>
<tr class="separator:gaa1fcf7b3155939db21d87ebaf0d5763d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9614efd432e0ca9bc408eab08a8bf064"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga9614efd432e0ca9bc408eab08a8bf064">DL_FlashCTL_readVerifyFromRAM32WithECCGenerated</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint32_t *data)</td></tr>
<tr class="memdesc:ga9614efd432e0ca9bc408eab08a8bf064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies 32-bit data in specified address with hardware generated ECC code, and executes command from RAM.  <a href="#ga9614efd432e0ca9bc408eab08a8bf064">More...</a><br /></td></tr>
<tr class="separator:ga9614efd432e0ca9bc408eab08a8bf064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3858f77a08b8bfb84f23bc827605a67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gac3858f77a08b8bfb84f23bc827605a67">DL_FlashCTL_readVerify64WithECCGenerated</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint32_t *data)</td></tr>
<tr class="memdesc:gac3858f77a08b8bfb84f23bc827605a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies 64-bit data in specified address with hardware generated ECC code.  <a href="#gac3858f77a08b8bfb84f23bc827605a67">More...</a><br /></td></tr>
<tr class="separator:gac3858f77a08b8bfb84f23bc827605a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae26e21cc4860554736d6f96ce341b32f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gae26e21cc4860554736d6f96ce341b32f">DL_FlashCTL_readVerifyFromRAM64WithECCGenerated</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint32_t *data)</td></tr>
<tr class="memdesc:gae26e21cc4860554736d6f96ce341b32f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies 32-bit data in specified address with hardware generated ECC code, and executes command from RAM.  <a href="#gae26e21cc4860554736d6f96ce341b32f">More...</a><br /></td></tr>
<tr class="separator:gae26e21cc4860554736d6f96ce341b32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8156f3b7ccca7e41976d38f1d3b732dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga8156f3b7ccca7e41976d38f1d3b732dd">DL_FlashCTL_readVerify8WithECCManual</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint8_t *data, const uint8_t *eccCode)</td></tr>
<tr class="memdesc:ga8156f3b7ccca7e41976d38f1d3b732dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies 8-bit data in specified address with user provided ECC code.  <a href="#ga8156f3b7ccca7e41976d38f1d3b732dd">More...</a><br /></td></tr>
<tr class="separator:ga8156f3b7ccca7e41976d38f1d3b732dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b8b8ec1471b11dd1753d5908bc8d673"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga0b8b8ec1471b11dd1753d5908bc8d673">DL_FlashCTL_readVerifyFromRAM8WithECCManual</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint8_t *data, const uint8_t *eccCode)</td></tr>
<tr class="memdesc:ga0b8b8ec1471b11dd1753d5908bc8d673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies 8-bit data in specified address with user provided ECC code, and executes command from RAM.  <a href="#ga0b8b8ec1471b11dd1753d5908bc8d673">More...</a><br /></td></tr>
<tr class="separator:ga0b8b8ec1471b11dd1753d5908bc8d673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8fd46e653b358bc86f08fd84105b914"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gaa8fd46e653b358bc86f08fd84105b914">DL_FlashCTL_readVerify16WithECCManual</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint16_t *data, const uint8_t *eccCode)</td></tr>
<tr class="memdesc:gaa8fd46e653b358bc86f08fd84105b914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies 16-bit data in specified address with user provided ECC code.  <a href="#gaa8fd46e653b358bc86f08fd84105b914">More...</a><br /></td></tr>
<tr class="separator:gaa8fd46e653b358bc86f08fd84105b914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga173111fb0ec1809fa9ec2d3968aa2a6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga173111fb0ec1809fa9ec2d3968aa2a6b">DL_FlashCTL_readVerifyFromRAM16WithECCManual</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint16_t *data, const uint8_t *eccCode)</td></tr>
<tr class="memdesc:ga173111fb0ec1809fa9ec2d3968aa2a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies 16-bit data in specified address with user provided ECC code, and executes command from RAM.  <a href="#ga173111fb0ec1809fa9ec2d3968aa2a6b">More...</a><br /></td></tr>
<tr class="separator:ga173111fb0ec1809fa9ec2d3968aa2a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cdbdde8412bbf4210700c2a7df69c21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga6cdbdde8412bbf4210700c2a7df69c21">DL_FlashCTL_readVerify32WithECCManual</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint32_t *data, const uint8_t *eccCode)</td></tr>
<tr class="memdesc:ga6cdbdde8412bbf4210700c2a7df69c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies 32-bit data in specified address with user provided ECC code.  <a href="#ga6cdbdde8412bbf4210700c2a7df69c21">More...</a><br /></td></tr>
<tr class="separator:ga6cdbdde8412bbf4210700c2a7df69c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab364e11206b2601873e683bc866e6150"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gab364e11206b2601873e683bc866e6150">DL_FlashCTL_readVerifyFromRAM32WithECCManual</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint32_t *data, const uint8_t *eccCode)</td></tr>
<tr class="memdesc:gab364e11206b2601873e683bc866e6150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies 32-bit data in specified address with user provided ECC code, and executes command from RAM.  <a href="#gab364e11206b2601873e683bc866e6150">More...</a><br /></td></tr>
<tr class="separator:gab364e11206b2601873e683bc866e6150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec0a8b00d03c4f25f00cbda948c35018"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gaec0a8b00d03c4f25f00cbda948c35018">DL_FlashCTL_readVerify64WithECCManual</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint32_t *data, const uint8_t *eccCode)</td></tr>
<tr class="memdesc:gaec0a8b00d03c4f25f00cbda948c35018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies 64-bit data in specified address with user provided ECC code.  <a href="#gaec0a8b00d03c4f25f00cbda948c35018">More...</a><br /></td></tr>
<tr class="separator:gaec0a8b00d03c4f25f00cbda948c35018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3324d5cc56c79da12792dec45e0ef96d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga3324d5cc56c79da12792dec45e0ef96d">DL_FlashCTL_readVerifyFromRAM64WithECCManual</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint32_t *data, const uint8_t *eccCode)</td></tr>
<tr class="memdesc:ga3324d5cc56c79da12792dec45e0ef96d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies 64-bit data in specified address with user provided ECC code, and executes command from RAM.  <a href="#ga3324d5cc56c79da12792dec45e0ef96d">More...</a><br /></td></tr>
<tr class="separator:ga3324d5cc56c79da12792dec45e0ef96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7efeda684bcd5d2e0e3b908f3ea47774"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga7efeda684bcd5d2e0e3b908f3ea47774">DL_FlashCTL_blankVerify</a> (FLASHCTL_Regs *flashctl, uint32_t address)</td></tr>
<tr class="memdesc:ga7efeda684bcd5d2e0e3b908f3ea47774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies that a flash word is blank.  <a href="#ga7efeda684bcd5d2e0e3b908f3ea47774">More...</a><br /></td></tr>
<tr class="separator:ga7efeda684bcd5d2e0e3b908f3ea47774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6228a63118743a5bdfdd1e743fbca011"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga6228a63118743a5bdfdd1e743fbca011">DL_FlashCTL_blankVerifyFromRAM</a> (FLASHCTL_Regs *flashctl, uint32_t address)</td></tr>
<tr class="memdesc:ga6228a63118743a5bdfdd1e743fbca011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies that a flash word is blank, and executes command from RAM.  <a href="#ga6228a63118743a5bdfdd1e743fbca011">More...</a><br /></td></tr>
<tr class="separator:ga6228a63118743a5bdfdd1e743fbca011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga858f486d680a6870e43c646b211b4a3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga858f486d680a6870e43c646b211b4a3b">DL_FlashCTL_programMemory128</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint32_t *data)</td></tr>
<tr class="memdesc:ga858f486d680a6870e43c646b211b4a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs 128 bit data to unprotected memory at the given address.  <a href="#ga858f486d680a6870e43c646b211b4a3b">More...</a><br /></td></tr>
<tr class="separator:ga858f486d680a6870e43c646b211b4a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga004279c27149448c253b2bc562f4024c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga004279c27149448c253b2bc562f4024c">DL_FlashCTL_programMemory128WithECCGenerated</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint32_t *data)</td></tr>
<tr class="memdesc:ga004279c27149448c253b2bc562f4024c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs 128 bit data with hardware generated ECC code.  <a href="#ga004279c27149448c253b2bc562f4024c">More...</a><br /></td></tr>
<tr class="separator:ga004279c27149448c253b2bc562f4024c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52a86bd0757db1edbe4a6407c077b77b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga52a86bd0757db1edbe4a6407c077b77b">DL_FlashCTL_programMemory128WithECCManual</a> (FLASHCTL_Regs *flashctl, uint32_t address, const uint32_t *data, const uint8_t *eccCode)</td></tr>
<tr class="memdesc:ga52a86bd0757db1edbe4a6407c077b77b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs 128 bit data with hardware generated ECC code.  <a href="#ga52a86bd0757db1edbe4a6407c077b77b">More...</a><br /></td></tr>
<tr class="separator:ga52a86bd0757db1edbe4a6407c077b77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec5d51f9e035e2846289fd948e267cfe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gaec5d51f9e035e2846289fd948e267cfe">DL_FlashCTL_programMemoryBlocking128WithECCGenerated</a> (FLASHCTL_Regs *flashctl, uint32_t address, uint32_t *data, uint32_t dataSize, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gad8b5345481dd655cbd20dadc84e7621b">DL_FLASHCTL_REGION_SELECT</a> regionSelect)</td></tr>
<tr class="memdesc:gaec5d51f9e035e2846289fd948e267cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs provided data up to 128-bits with ECC generated while blocking between writes.  <a href="#gaec5d51f9e035e2846289fd948e267cfe">More...</a><br /></td></tr>
<tr class="separator:gaec5d51f9e035e2846289fd948e267cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d8baaa47934cdb852dcfcd0a1645d90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga0d8baaa47934cdb852dcfcd0a1645d90">DL_FlashCTL_eraseDataBank</a> (FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:ga0d8baaa47934cdb852dcfcd0a1645d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an erase on DATA bank.  <a href="#ga0d8baaa47934cdb852dcfcd0a1645d90">More...</a><br /></td></tr>
<tr class="separator:ga0d8baaa47934cdb852dcfcd0a1645d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6a81dc3536f56ce1a552f2102fca181"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gad6a81dc3536f56ce1a552f2102fca181">DL_FlashCTL_eraseDataBankFromRAM</a> (FLASHCTL_Regs *flashctl)</td></tr>
<tr class="memdesc:gad6a81dc3536f56ce1a552f2102fca181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an erase on DATA bank, and executes command from RAM.  <a href="#gad6a81dc3536f56ce1a552f2102fca181">More...</a><br /></td></tr>
<tr class="separator:gad6a81dc3536f56ce1a552f2102fca181"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><a class="anchor" id="ti_dl_dl_flashctl_Overview"></a></p><h1>Overview</h1>
<p>The Flash Controller Driver Library allows full configuration of the MSPM0 Non-Volatile memory system. The non-volatile memory (NVM) system provides nonvolatile flash memory for storing executable code and data.</p>
<hr/>
 <h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga987c2ff9232d4205c98af65ff7d7c2e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga987c2ff9232d4205c98af65ff7d7c2e2">&sect;&nbsp;</a></span>DL_FLASHCTL_COMMAND_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga987c2ff9232d4205c98af65ff7d7c2e2">DL_FLASHCTL_COMMAND_SIZE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga987c2ff9232d4205c98af65ff7d7c2e2adf1053097cc9922b5182155e01255b15"></a>DL_FLASHCTL_COMMAND_SIZE_ONE_WORD&#160;</td><td class="fielddoc"><p>Flash Command size is one word </p>
</td></tr>
<tr><td class="fieldname"><a id="gga987c2ff9232d4205c98af65ff7d7c2e2abb50257fbb0d576fef26a5d2112b4e24"></a>DL_FLASHCTL_COMMAND_SIZE_TWO_WORDS&#160;</td><td class="fielddoc"><p>Flash Command size is two words </p>
</td></tr>
<tr><td class="fieldname"><a id="gga987c2ff9232d4205c98af65ff7d7c2e2a28b17ae7f6c070c932e5c535b0763cf5"></a>DL_FLASHCTL_COMMAND_SIZE_FOUR_WORDS&#160;</td><td class="fielddoc"><p>Flash Command size is four words </p>
</td></tr>
<tr><td class="fieldname"><a id="gga987c2ff9232d4205c98af65ff7d7c2e2a34f344faced02509aa3d2a03f402b193"></a>DL_FLASHCTL_COMMAND_SIZE_EIGHT_WORDS&#160;</td><td class="fielddoc"><p>Flash Command size is eight words </p>
</td></tr>
<tr><td class="fieldname"><a id="gga987c2ff9232d4205c98af65ff7d7c2e2a93756d02007450e02e9745f92d139faa"></a>DL_FLASHCTL_COMMAND_SIZE_SECTOR&#160;</td><td class="fielddoc"><p>Flash Command size is a sector </p>
</td></tr>
<tr><td class="fieldname"><a id="gga987c2ff9232d4205c98af65ff7d7c2e2a503c9f595f41a0efc5581cbf1c681a0e"></a>DL_FLASHCTL_COMMAND_SIZE_BANK&#160;</td><td class="fielddoc"><p>Flash Command size is a bank </p>
</td></tr>
</table>

</div>
</div>
<a id="gad8b5345481dd655cbd20dadc84e7621b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8b5345481dd655cbd20dadc84e7621b">&sect;&nbsp;</a></span>DL_FLASHCTL_REGION_SELECT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___f_l_a_s_h_c_t_l.html#gad8b5345481dd655cbd20dadc84e7621b">DL_FLASHCTL_REGION_SELECT</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad8b5345481dd655cbd20dadc84e7621ba992837cf4fe4e551a02fdf985f83d977"></a>DL_FLASHCTL_REGION_SELECT_MAIN&#160;</td><td class="fielddoc"><p>Flash Region Select Main </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad8b5345481dd655cbd20dadc84e7621ba68ba353b3fa5fee3f6bac5da4ad66aa2"></a>DL_FLASHCTL_REGION_SELECT_NONMAIN&#160;</td><td class="fielddoc"><p>Flash Region Select Non-Main </p>
</td></tr>
</table>

</div>
</div>
<a id="gab85614b8c0ccf0edbede3f8e67a805ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab85614b8c0ccf0edbede3f8e67a805ab">&sect;&nbsp;</a></span>DL_FLASHCTL_BANK_SELECT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___f_l_a_s_h_c_t_l.html#gab85614b8c0ccf0edbede3f8e67a805ab">DL_FLASHCTL_BANK_SELECT</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab85614b8c0ccf0edbede3f8e67a805aba469d493dea13302d213e20befce7b94a"></a>DL_FLASHCTL_BANK_SELECT_0&#160;</td><td class="fielddoc"><p>Bank 0 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab85614b8c0ccf0edbede3f8e67a805abaf267fa2c57968390c6449a6a2bc6107e"></a>DL_FLASHCTL_BANK_SELECT_1&#160;</td><td class="fielddoc"><p>Bank 1 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab85614b8c0ccf0edbede3f8e67a805aba7d7882342a37aa042f78cf6732ee51d1"></a>DL_FLASHCTL_BANK_SELECT_2&#160;</td><td class="fielddoc"><p>Bank 2 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab85614b8c0ccf0edbede3f8e67a805aba5dc6e5f89e2e9c78517859ed2f27d5c4"></a>DL_FLASHCTL_BANK_SELECT_3&#160;</td><td class="fielddoc"><p>Bank 3 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab85614b8c0ccf0edbede3f8e67a805aba3644c8b23ed91301a575d23923ac95a3"></a>DL_FLASHCTL_BANK_SELECT_4&#160;</td><td class="fielddoc"><p>Bank 4 </p>
</td></tr>
</table>

</div>
</div>
<a id="ga148c247b2058dd33c0dba6912fe5786d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga148c247b2058dd33c0dba6912fe5786d">&sect;&nbsp;</a></span>DL_FLASHCTL_FAIL_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga148c247b2058dd33c0dba6912fe5786d">DL_FLASHCTL_FAIL_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga148c247b2058dd33c0dba6912fe5786da7bcfa6d4196d07b0067781185e554222"></a>DL_FLASHCTL_FAIL_TYPE_NO_FAILURE&#160;</td><td class="fielddoc"><p>Flash Command did not fail during execution </p>
</td></tr>
<tr><td class="fieldname"><a id="gga148c247b2058dd33c0dba6912fe5786da3693c465277bb8947a26833098c01a07"></a>DL_FLASHCTL_FAIL_TYPE_WRITE_ERASE_PROTECT&#160;</td><td class="fielddoc"><p>Flash Command failed due to write/erase protect sector violation </p>
</td></tr>
<tr><td class="fieldname"><a id="gga148c247b2058dd33c0dba6912fe5786dad7b8a08caa79cf5b5efed26bfd9017a7"></a>DL_FLASHCTL_FAIL_TYPE_VERIFY_ERROR&#160;</td><td class="fielddoc"><p>Flash Command failed due to verify error </p>
</td></tr>
<tr><td class="fieldname"><a id="gga148c247b2058dd33c0dba6912fe5786daec821c206bcdc07e76ede93d67145cdb"></a>DL_FLASHCTL_FAIL_TYPE_ILLEGAL_ADDRESS&#160;</td><td class="fielddoc"><p>Flash Command failed due to the use of an illegal address </p>
</td></tr>
<tr><td class="fieldname"><a id="gga148c247b2058dd33c0dba6912fe5786da7c63943cf22c972a22388a1cfe5cc6f7"></a>DL_FLASHCTL_FAIL_TYPE_WRONG_BANK_MODE&#160;</td><td class="fielddoc"><p>Flash Command failed because a bank has been set to a mode other than READ </p>
</td></tr>
<tr><td class="fieldname"><a id="gga148c247b2058dd33c0dba6912fe5786da0342be3257c9488dc0e1da5472836d9d"></a>DL_FLASHCTL_FAIL_TYPE_MISCELLANEOUS&#160;</td><td class="fielddoc"><p>Flash Command failed due to an undefined error </p>
</td></tr>
</table>

</div>
</div>
<a id="ga81a568bc9c0c10f386e22832683db339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81a568bc9c0c10f386e22832683db339">&sect;&nbsp;</a></span>DL_FLASHCTL_COMMAND_STATUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga81a568bc9c0c10f386e22832683db339ab949d825efba5be4a2b2bae18e22d674"></a>DL_FLASHCTL_COMMAND_STATUS_PASSED&#160;</td><td class="fielddoc"><p>Flash Command passed </p>
</td></tr>
<tr><td class="fieldname"><a id="gga81a568bc9c0c10f386e22832683db339ac935ccce01e97c83b69ce849da44597d"></a>DL_FLASHCTL_COMMAND_STATUS_FAILED&#160;</td><td class="fielddoc"><p>Flash Command failed </p>
</td></tr>
<tr><td class="fieldname"><a id="gga81a568bc9c0c10f386e22832683db339a8cfd0b0cd5b76a5ce243f3baf6bf07a0"></a>DL_FLASHCTL_COMMAND_STATUS_IN_PROGRESS&#160;</td><td class="fielddoc"><p>Flash Command is still in progress </p>
</td></tr>
</table>

</div>
</div>
<a id="ga61f98ec6fb62e3ecfb573819e96147a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61f98ec6fb62e3ecfb573819e96147a8">&sect;&nbsp;</a></span>DL_FLASHCTL_IIDX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga61f98ec6fb62e3ecfb573819e96147a8">DL_FLASHCTL_IIDX</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga61f98ec6fb62e3ecfb573819e96147a8a833d62cb187f2ae4d9c5770eccecb8af"></a>DL_FLASHCTL_IIDX_DONE&#160;</td><td class="fielddoc"><p>DONE Interrupt Pending </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gafb7776d53f6157a156ee71f57f4b4bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb7776d53f6157a156ee71f57f4b4bb5">&sect;&nbsp;</a></span>DL_FlashCTL_enableInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_FlashCTL_enableInterrupt </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable flash interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaacd2cbcae3f85821039020ff8d3c9c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacd2cbcae3f85821039020ff8d3c9c70">&sect;&nbsp;</a></span>DL_FlashCTL_disableInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_FlashCTL_disableInterrupt </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable flash interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3e6e76dd093da9a1badf89866ef8cc38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e6e76dd093da9a1badf89866ef8cc38">&sect;&nbsp;</a></span>DL_FlashCTL_isInterruptEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_FlashCTL_isInterruptEnabled </td>
          <td>(</td>
          <td class="paramtype">const FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the flash interrupt is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the flash interrupt is enabled</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>if interrupt is disabled </td></tr>
    <tr><td class="paramname">true</td><td>if interrupt is enabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7513eea8dcb21dec9965a66ca47befe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7513eea8dcb21dec9965a66ca47befe1">&sect;&nbsp;</a></span>DL_FlashCTL_getEnabledInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_FlashCTL_getEnabledInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">const FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check interrupt flag of enabled flash interrupt. </p>
<p>Checks if the flash interrupt that was previously enabled is pending.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the flash interrupt is pending</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if no interrupt is enabled </td></tr>
    <tr><td class="paramname">The</td><td>value of <a class="el" href="group___d_l___f_l_a_s_h_c_t_l___i_n_t_e_r_r_u_p_t.html">DL_FLASHCTL_INTERRUPT</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa13a422ce58fa23d6137a967c7dd81ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa13a422ce58fa23d6137a967c7dd81ed">&sect;&nbsp;</a></span>DL_FlashCTL_getRawInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_FlashCTL_getRawInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">const FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check interrupt flag of the flash interrupt. </p>
<p>Checks if the flash interrupt is pending. Interrupts do not have to be previously enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the flash interrupt is pending</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if no interrupt is enabled </td></tr>
    <tr><td class="paramname">The</td><td>value of <a class="el" href="group___d_l___f_l_a_s_h_c_t_l___i_n_t_e_r_r_u_p_t.html">DL_FLASHCTL_INTERRUPT</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadc497fb4a0ea4e57fc318a67cac08dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc497fb4a0ea4e57fc318a67cac08dfb">&sect;&nbsp;</a></span>DL_FlashCTL_getPendingInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_FlashCTL_getPendingInterrupt </td>
          <td>(</td>
          <td class="paramtype">const FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get highest priority pending flash interrupt. </p>
<p>Checks if the flash interrupt is pending. Interrupts do not have to be previously enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The highest priority pending FLASH interrupt </dd></dl>

</div>
</div>
<a id="gab9477a883130a6cf81440d69c33cf002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9477a883130a6cf81440d69c33cf002">&sect;&nbsp;</a></span>DL_FlashCTL_clearInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_FlashCTL_clearInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear pending flash interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab1118a3433d32d2a7f0731090a9fd9ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1118a3433d32d2a7f0731090a9fd9ef">&sect;&nbsp;</a></span>DL_FlashCTL_isCommandExecuted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_FlashCTL_isCommandExecuted </td>
          <td>(</td>
          <td class="paramtype">const FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a command execution has been initiated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If a command has been set to execute </dd></dl>

</div>
</div>
<a id="gadb3e1c28dd9c81317fb0b2d364f81b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb3e1c28dd9c81317fb0b2d364f81b8b">&sect;&nbsp;</a></span>DL_FlashCTL_setCommandExecute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_FlashCTL_setCommandExecute </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates a command execution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5e38b8715f307800221bf9f2b8eb5dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e38b8715f307800221bf9f2b8eb5dc8">&sect;&nbsp;</a></span>DL_FlashCTL_disbleStairStepErase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_FlashCTL_disbleStairStepErase </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable Stair-Step Erase. </p>
<p>The default VHV trim voltage setting will be used for all erase pulses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0f47360383fbcc574cc8a03088c0e226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f47360383fbcc574cc8a03088c0e226">&sect;&nbsp;</a></span>DL_FlashCTL_isStairStepEraseDisabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_FlashCTL_isStairStepEraseDisabled </td>
          <td>(</td>
          <td class="paramtype">const FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if stair-step erase is disabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If stair-step erase is disabled </dd></dl>

</div>
</div>
<a id="gac8f3f63de6bd64d7e1b7e55cf831be14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8f3f63de6bd64d7e1b7e55cf831be14">&sect;&nbsp;</a></span>DL_FlashCTL_enableStairStepErase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_FlashCTL_enableStairStepErase </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable Stair-Step Erase. </p>
<p>The VHV voltage will be stepped during successive erase pulses. The step count, step voltage, begin and end voltages are all hard-wired. This is enabled by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4e4f99d3c28d5cc863d7287e0283a835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e4f99d3c28d5cc863d7287e0283a835">&sect;&nbsp;</a></span>DL_FlashCTL_enableAddressOverrideMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_FlashCTL_enableAddressOverrideMode </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable address override mode. </p>
<p>This overrides hardware address translation in CMDADDR from a system address to a bank address and bank ID. Use data written to CMDADDR directly as the bank address. Use the value written to CMDCTL.BANKSEL directly as the bank ID. Use the value written to CMDCTL.REGIONSEL directly as the region ID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga8495c14d057e452ecb27f68455d34514" title="Sets the target address for a command. ">DL_FlashCTL_setCommandAddress</a> </dd>
<dd>
<a class="el" href="group___f_l_a_s_h_c_t_l.html#ga2681fd5db3e7c951d44b3ef0d6dff7ec" title="Set the bank select. ">DL_FlashCTL_setBankSelect</a> </dd>
<dd>
<a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5bb1ecbfe03fc31018af12c1046e4dab" title="Set the region select. ">DL_FlashCTL_setRegionSelect</a> </dd></dl>

</div>
</div>
<a id="gad8694858cba97bc17128586d1aa39f2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8694858cba97bc17128586d1aa39f2e">&sect;&nbsp;</a></span>DL_FlashCTL_isAddressOverrideModeEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_FlashCTL_isAddressOverrideModeEnabled </td>
          <td>(</td>
          <td class="paramtype">const FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if address override mode is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If address override mode is enabled </dd></dl>

</div>
</div>
<a id="ga9abd4b91d2a27a2389384ef5711275ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9abd4b91d2a27a2389384ef5711275ab">&sect;&nbsp;</a></span>DL_FlashCTL_disableAddressOverrideMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_FlashCTL_disableAddressOverrideMode </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable address override mode. </p>
<p>Disable address override mode and return to system addressed mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacf328d7e267b95496ff4e0d7b37e831a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf328d7e267b95496ff4e0d7b37e831a">&sect;&nbsp;</a></span>DL_FlashCTL_enableOverrideHardwareGeneratedECC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_FlashCTL_enableOverrideHardwareGeneratedECC </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable overriding hardware generation of ECC code. </p>
<p>Override hardware ECC code generation by the flash controller. When enabled, the user can then manually set the ECC code to be programmed by calling <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga77c94b92134bf40c5170468edfd04c62">DL_FlashCTL_setCommandDataECC</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga77c94b92134bf40c5170468edfd04c62" title="Set the ECC code in the command data ECC register. ">DL_FlashCTL_setCommandDataECC</a> </dd></dl>

</div>
</div>
<a id="ga8921b213267180bf65d50c64e0fb4f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8921b213267180bf65d50c64e0fb4f27">&sect;&nbsp;</a></span>DL_FlashCTL_isOverrideHardwareGeneratedECCEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_FlashCTL_isOverrideHardwareGeneratedECCEnabled </td>
          <td>(</td>
          <td class="paramtype">const FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if overriding hardware generation of ECC code is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If overriding hardware generation of ECC code is enabled </dd></dl>

</div>
</div>
<a id="ga425a9da6de8a129833b47834093f34fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga425a9da6de8a129833b47834093f34fb">&sect;&nbsp;</a></span>DL_FlashCTL_disableOverrideHardwareGeneratedECC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_FlashCTL_disableOverrideHardwareGeneratedECC </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable overriding hardware generation of ECC code. </p>
<p>Disable overriding hardware generation of ECC code, so the flash controller will handle generating the needed ECC bits from the data</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5bb1ecbfe03fc31018af12c1046e4dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bb1ecbfe03fc31018af12c1046e4dab">&sect;&nbsp;</a></span>DL_FlashCTL_setRegionSelect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_FlashCTL_setRegionSelect </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gad8b5345481dd655cbd20dadc84e7621b">DL_FLASHCTL_REGION_SELECT</a>&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the region select. </p>
<p>A specific region ID can be written to this field to indicate to which region an operation should be applied if CMDCTL.ADDRXLATEOVR is set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">region</td><td>Region to select. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#gad8b5345481dd655cbd20dadc84e7621b">DL_FLASHCTL_REGION_SELECT</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga4e4f99d3c28d5cc863d7287e0283a835" title="Enable address override mode. ">DL_FlashCTL_enableAddressOverrideMode</a> </dd></dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga574d42757557fc8e652c3a337c2b3760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga574d42757557fc8e652c3a337c2b3760">&sect;&nbsp;</a></span>DL_FlashCTL_getRegionSelect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___f_l_a_s_h_c_t_l.html#gad8b5345481dd655cbd20dadc84e7621b">DL_FLASHCTL_REGION_SELECT</a> DL_FlashCTL_getRegionSelect </td>
          <td>(</td>
          <td class="paramtype">const FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the region select. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The region selected</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___f_l_a_s_h_c_t_l.html#gad8b5345481dd655cbd20dadc84e7621b">DL_FLASHCTL_REGION_SELECT</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2681fd5db3e7c951d44b3ef0d6dff7ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2681fd5db3e7c951d44b3ef0d6dff7ec">&sect;&nbsp;</a></span>DL_FlashCTL_setBankSelect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_FlashCTL_setBankSelect </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gab85614b8c0ccf0edbede3f8e67a805ab">DL_FLASHCTL_BANK_SELECT</a>&#160;</td>
          <td class="paramname"><em>bank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the bank select. </p>
<p>A specific bank ID can be written to this field to indicate which bank an operation should be applied if CMDCTL.ADDRXLATEOVR is set.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to the device datasheet for the number of banks that are available on your device.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bank</td><td>Bank to select. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#gab85614b8c0ccf0edbede3f8e67a805ab">DL_FLASHCTL_BANK_SELECT</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga4e4f99d3c28d5cc863d7287e0283a835" title="Enable address override mode. ">DL_FlashCTL_enableAddressOverrideMode</a> </dd></dl>

<p>References <a class="el" href="group___d_l_common.html#ga37cb77ac2e81fdb12f6a95ad02cbb0e4">DL_Common_updateReg()</a>.</p>

</div>
</div>
<a id="ga138c067ca038b6c098ddea659da6c8ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga138c067ca038b6c098ddea659da6c8ce">&sect;&nbsp;</a></span>DL_FlashCTL_getBankSelect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___f_l_a_s_h_c_t_l.html#gab85614b8c0ccf0edbede3f8e67a805ab">DL_FLASHCTL_BANK_SELECT</a> DL_FlashCTL_getBankSelect </td>
          <td>(</td>
          <td class="paramtype">const FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the bank select. </p>
<dl class="section note"><dt>Note</dt><dd>Refer to the device datasheet for the number of banks that are available on your device.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bank selected</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___f_l_a_s_h_c_t_l.html#gab85614b8c0ccf0edbede3f8e67a805ab">DL_FLASHCTL_BANK_SELECT</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3cbae37dc3a2fa67f121f4f5e1395705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cbae37dc3a2fa67f121f4f5e1395705">&sect;&nbsp;</a></span>DL_FlashCTL_setCommandByteEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_FlashCTL_setCommandByteEnable </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>byteMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the bytes to enable for programming data. </p>
<p>This register forms a per-byte enable for programming data. Each bit in CMDBYTEN corresponds to a byte in the addressed flash word to be programmed, including the ECC byte. This allows sub-word programming (programming of less than the full 64 or 72 bit flash word) if desired.</p>
<p>ECC data bytes are protected by the MSB bits in this register, depending on the presence of ECC and the flash word data width. Note: Refer to the TRM on how to correctly handle ECC for sub-word programs. You cannot correctly program the ECC bits if the whole 64 bits of the data word is not programmed, so the ECC byte should not be enabled until all 64 bits of the flash word are programmed.</p>
<p>This register is written to all 0 after the completion of all FLASHCTL commands.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">byteMask</td><td>Mask of bytes to enable. Between [0,0x1FF]. For example:<ul>
<li>byteMask = 0x0, Disable all bytes for programming</li>
<li>byteMask = 0x1, Enable 8-bit programming</li>
<li>byteMask = 0x3, Enable 16-bit programming</li>
<li>byteMask = 0xF, Enable 32-bit programming</li>
<li>byteMask = 0xFF, Enable 64-bit programming</li>
<li>byteMask = 0x1FF, Enable 64-bit programming with ECC enabled </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7bfd7733edd162a9470fd055b1380f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bfd7733edd162a9470fd055b1380f50">&sect;&nbsp;</a></span>DL_FlashCTL_getCommandByteEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_FlashCTL_getCommandByteEnable </td>
          <td>(</td>
          <td class="paramtype">const FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the bytes that are enabled for programming data. </p>
<p>This register forms a per-byte enable for programming data. Each bit in CMDBYTEN corresponds to a byte in the addressed flash word to be programmed, including the ECC byte. This allows sub-word programming (programming of less than the full 64 or 72 bit flash word) if desired.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The enabled bytes</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>between [0,0x1FF]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab1fd2784d1bfd7f49c6651391e120680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1fd2784d1bfd7f49c6651391e120680">&sect;&nbsp;</a></span>DL_FlashCTL_setCommandData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_FlashCTL_setCommandData </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the data for a command data register. </p>
<p>The command data registers, CMDDATAx, are used to form the data for a command. For devices which only support single word programming, only the CMDDATA0 and CMDDATA1 registers are used to load data to be programmed to the flash memory. CMDDATA0 is always loaded with BIT31-BIT0 of the target data, and CMDDATA1 is always loaded with BIT63-BIT32 of the target data. If fewer than 64 data bits are being programmed, see the special handling requirements section in the device TRM for programming less than one flash word.</p>
<dl class="section note"><dt>Note</dt><dd>Ensure that you have enabled the correct bytes for programming enabled with <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga3cbae37dc3a2fa67f121f4f5e1395705">DL_FlashCTL_setCommandByteEnable</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Select the command data register to write to. Please see the device TRM for the number of CMDDATA registers. For example:<ul>
<li>index = 0, Select CMDDATA0</li>
<li>index = 1, Select CMDDATA1 </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data to write to the command data register. Value between [0,0xFFFFFFFF] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga48ccc7de469db2d960dcdb254f613f2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48ccc7de469db2d960dcdb254f613f2e">&sect;&nbsp;</a></span>DL_FlashCTL_getCommandData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_FlashCTL_getCommandData </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the data from a command data register. </p>
<p>For devices which only support single word programming, only the CMDDATA0 and CMDDATA1 registers are used to load data to be programmed to the flash memory. CMDDATA0 is always loaded with BIT31-BIT0 of the target data, and CMDDATA1 is always loaded with BIT63-BIT32 of the target data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Select the command data register to write to. Please see the device TRM for the number of CMDDATA registers. For example:<ul>
<li>index = 0, Select CMDDATA0</li>
<li>index = 1, Select CMDDATA1</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data in the command data register</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>between [0,0xFFFFFFFF]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga77c94b92134bf40c5170468edfd04c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77c94b92134bf40c5170468edfd04c62">&sect;&nbsp;</a></span>DL_FlashCTL_setCommandDataECC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_FlashCTL_setCommandDataECC </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the ECC code in the command data ECC register. </p>
<p>This register forms the ECC portion of the data for a command.</p>
<dl class="section note"><dt>Note</dt><dd>The ECC data can be manually set only when hardware ECC code generation is disabled with <a class="el" href="group___f_l_a_s_h_c_t_l.html#gacf328d7e267b95496ff4e0d7b37e831a">DL_FlashCTL_enableOverrideHardwareGeneratedECC</a></dd>
<dd>
Ensure that you have enabled the correct bytes for programming ECC enabled with <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga3cbae37dc3a2fa67f121f4f5e1395705">DL_FlashCTL_setCommandByteEnable</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Select the command data ECC register to write to. Please see the device TRM for the number of CMDDATAECC registers. For example:<ul>
<li>index = 0, Select CMDDATAECC0</li>
<li>index = 1, Select CMDDATAECC1 </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data to write to the command data ECC register. Value between [0, 0xFF] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5cdcc7b95fc24fcda9558886090dc4db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cdcc7b95fc24fcda9558886090dc4db">&sect;&nbsp;</a></span>DL_FlashCTL_getCommandDataECC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint8_t DL_FlashCTL_getCommandDataECC </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the ECC code in the command data ECC register. </p>
<p>This register forms the ECC portion of the data for a command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Select the command data register ECC to write to. Please see the device TRM for the number of CMDDATAECC registers. For example:<ul>
<li>index = 0, Select CMDDATAECC0</li>
<li>index = 1, Select CMDDATAECC1</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data in the command data ECC register</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>between [0,0xFF]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8495c14d057e452ecb27f68455d34514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8495c14d057e452ecb27f68455d34514">&sect;&nbsp;</a></span>DL_FlashCTL_setCommandAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_FlashCTL_setCommandAddress </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the target address for a command. </p>
<p>The target address for a command must be flash word (64-bit) aligned. This means that the target address must be aligned to a 0b000 boundary (for example, the 3 LSBs in the address must be zero).</p>
<p>1) For single-word program, this address indicates the flash bank word to be programmed. 2) For multi-word program, this address indicates the first flash bank address for the program. The address will be incremented 3) For sector and bank erase, this address indicates the sector or bank to be erased. 4) For read verify, this address forms the start address for the verify operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Destination address to program/erase/read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa03088df9bedddc7a9f013d183565121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa03088df9bedddc7a9f013d183565121">&sect;&nbsp;</a></span>DL_FlashCTL_getCommandStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a> DL_FlashCTL_getCommandStatus </td>
          <td>(</td>
          <td class="paramtype">const FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the status of the current command. </p>
<p>Checks if the command is still in progress or finished and if it passed or failed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status of the current command</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a> values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5909153bc16bfa44a51bab33a82262c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5909153bc16bfa44a51bab33a82262c3">&sect;&nbsp;</a></span>DL_FlashCTL_getFailureStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga148c247b2058dd33c0dba6912fe5786d">DL_FLASHCTL_FAIL_TYPE</a> DL_FlashCTL_getFailureStatus </td>
          <td>(</td>
          <td class="paramtype">const FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the reason a command failed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The type of command failure</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">One</td><td>of <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga148c247b2058dd33c0dba6912fe5786d">DL_FLASHCTL_FAIL_TYPE</a> values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5261cbd42cb4a724bc1dc1543cd24631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5261cbd42cb4a724bc1dc1543cd24631">&sect;&nbsp;</a></span>DL_FlashCTL_waitForCmdDone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool DL_FlashCTL_waitForCmdDone </td>
          <td>(</td>
          <td class="paramtype">const FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocking function that waits for a command execution to finish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the command was successful</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>if command didn't succeed </td></tr>
    <tr><td class="paramname">true</td><td>if command was successful </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacbd4eaed6070854f2691339142ca9397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbd4eaed6070854f2691339142ca9397">&sect;&nbsp;</a></span>DL_FlashCTL_executeClearStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_FlashCTL_executeClearStatus </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets clear status bit and executes command. </p>
<p>This will clear the STATCMD register and re-apply max protection to the CMDWEPROTx registers</p>
<dl class="section pre"><dt>Precondition</dt><dd>This command should be called before <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaff740a4d3903a5813bdcf631e24389cb">DL_FlashCTL_unprotectSector</a> to ensure that memory is not re-protected after unprotecting it.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___d_l___f_l_a_s_h_c_t_l___c_o_m_m_a_n_d___t_y_p_e.html#ga0dc1855e5deb8366972d3b0ebc1842a1">DL_FLASHCTL_COMMAND_TYPE_CLEAR_STATUS</a>.</p>

</div>
</div>
<a id="ga7aeadf2178f1a939be163efedbeec566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7aeadf2178f1a939be163efedbeec566">&sect;&nbsp;</a></span>DL_FlashCTL_getFlashSectorNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_FlashCTL_getFlashSectorNumber </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the sector number of the input address over the whole memory map. </p>
<p>If the device has two 128KB banks, and the input address is 0x20000, then this API will return the sector number as 128. To get the sector number over the whole memory map of the device, refer to <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaec5c6d11afcd6bcac2db0e2789892b5d">DL_FlashCTL_getFlashSectorNumberInBank</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Memory address within the desired sector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sector number that contains the input address </dd></dl>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaec5c6d11afcd6bcac2db0e2789892b5d">DL_FlashCTL_getFlashSectorNumberInBank()</a>.</p>

</div>
</div>
<a id="gaec5c6d11afcd6bcac2db0e2789892b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec5c6d11afcd6bcac2db0e2789892b5d">&sect;&nbsp;</a></span>DL_FlashCTL_getFlashSectorNumberInBank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_FlashCTL_getFlashSectorNumberInBank </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the sector number of the input address relative to the bank of the address. </p>
<p>If the device has two 128KB banks, and the input address is 0x20000, then this API will return the sector number as 0. This is because 0x20000 is in Sector 0 of Bank 1. To get the sector number over the whole memory map of the device, refer to <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga7aeadf2178f1a939be163efedbeec566">DL_FlashCTL_getFlashSectorNumber</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Memory address within the desired sector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sector number in the current bank that contains the address </dd></dl>

<p>References <a class="el" href="group___f_a_c_t_o_r_y_r_e_g_i_o_n.html#ga40ce96a6b6a3f1174104010cc8abc028">DL_FactoryRegion_getMAINFlashSize()</a>, <a class="el" href="group___f_a_c_t_o_r_y_r_e_g_i_o_n.html#ga5ad34be0c975f04010e1b85e31a1cd5c">DL_FactoryRegion_getNumBanks()</a>, and <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga7aeadf2178f1a939be163efedbeec566">DL_FlashCTL_getFlashSectorNumber()</a>.</p>

</div>
</div>
<a id="ga2df0ed388d831b60b05b484767af9da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2df0ed388d831b60b05b484767af9da6">&sect;&nbsp;</a></span>DL_FlashCTL_setWaitState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void DL_FlashCTL_setWaitState </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>waitState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the number of wait states used by the Flash. </p>
<p>Changes the number of wait states used by the Flash controller. When changing the frequency of the clock, the number of wait states may need to be updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">waitState</td><td>Number of wait states to set. Recommended values are based on the system clock speed:<ul>
<li>0MHz-24MHz: 0 wait state</li>
<li>24MHz-48MHz: 1 wait state</li>
<li>48MHz-72MHz: 2 wait states</li>
<li>72MHz-80MHz: 3 wait states </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafc7476e6bbc482257af980476a9316d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc7476e6bbc482257af980476a9316d6">&sect;&nbsp;</a></span>DL_FlashCTL_getWaitState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t DL_FlashCTL_getWaitState </td>
          <td>(</td>
          <td class="paramtype">const FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of wait states used by the Flash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of wait states used by the Flash </dd></dl>

<p>References <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga7efeda684bcd5d2e0e3b908f3ea47774">DL_FlashCTL_blankVerify()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga6228a63118743a5bdfdd1e743fbca011">DL_FlashCTL_blankVerifyFromRAM()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga0d8baaa47934cdb852dcfcd0a1645d90">DL_FlashCTL_eraseDataBank()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gad6a81dc3536f56ce1a552f2102fca181">DL_FlashCTL_eraseDataBankFromRAM()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gad2d0a45785ecf6057a9fb76899150819">DL_FlashCTL_eraseMemory()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga08dca5922bc739dd8e4439f7d4882a39">DL_FlashCTL_eraseMemoryFromRAM()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gac4de77451a9f9825d5598be8def66081">DL_FlashCTL_factoryReset()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga9560031f2dc8b370e3991ec67c1a126e">DL_FlashCTL_factoryResetFromRAM()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga68b9b8090c318278b40fad8fbb7f446c">DL_FlashCTL_factoryResetMultiBank()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gad0a7add5d14c16c7b8f470457dbac991">DL_FlashCTL_massErase()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafb4228a5e605be29f26f0ca96d006e0b">DL_FlashCTL_massEraseFromRAM()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gadc2373933a2ffc87984143c33aa8e671">DL_FlashCTL_massEraseMultiBank()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga858f486d680a6870e43c646b211b4a3b">DL_FlashCTL_programMemory128()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga004279c27149448c253b2bc562f4024c">DL_FlashCTL_programMemory128WithECCGenerated()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga52a86bd0757db1edbe4a6407c077b77b">DL_FlashCTL_programMemory128WithECCManual()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gabc6aaa3dc48e49c84d0d9a433fb66f8d">DL_FlashCTL_programMemory16()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga272050a9943419cb0149f7f936337861">DL_FlashCTL_programMemory16WithECCGenerated()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga4a395feddcfd61d07314c68d20de7bef">DL_FlashCTL_programMemory16WithECCManual()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga2b57a5818313fd322c643ea1b3ff3b4b">DL_FlashCTL_programMemory32()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga10e1550de79bcce6df3042ba995b1780">DL_FlashCTL_programMemory32WithECCGenerated()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga36abe0765d95d555d6e90b058e0df53c">DL_FlashCTL_programMemory32WithECCManual()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga85c242871e8559bacdc133eb7972889d">DL_FlashCTL_programMemory64()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5040ae1f581f8359a902585a3d1abf71">DL_FlashCTL_programMemory64WithECCGenerated()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaaea9cb0c24c2935af10797a1b3aa997d">DL_FlashCTL_programMemory64WithECCManual()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga901335b104e5cc54a5d05fa310676217">DL_FlashCTL_programMemory8()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga9283e69a72f7de9bf4e3d0126e5464bc">DL_FlashCTL_programMemory8WithECCGenerated()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga46c3f9272bcd36868812a31fb092a72b">DL_FlashCTL_programMemory8WithECCManual()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5644da91bdbf6df26ea6550da3dbc226">DL_FlashCTL_programMemoryBlocking()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaec5d51f9e035e2846289fd948e267cfe">DL_FlashCTL_programMemoryBlocking128WithECCGenerated()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5a01864fe9815f1117cbda07c38e0de5">DL_FlashCTL_programMemoryBlocking64WithECCGenerated()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga9ea23446748b9a1eddc96b199b55e4f6">DL_FlashCTL_programMemoryBlocking64WithECCManual()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaf27b130aecc263d4a4cce6b54346e4cf">DL_FlashCTL_programMemoryBlockingFromRAM64WithECCGenerated()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga7f19934f5b5861ea8454a799ceaa642f">DL_FlashCTL_programMemoryBlockingFromRAM64WithECCManual()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gab8a38f51d18afd14036b7e83b431a8c9">DL_FlashCTL_programMemoryFromRAM()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga6b63595169bf9e9c75948b7e34a008c1">DL_FlashCTL_programMemoryFromRAM16()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga1ad0a914a44ca9a016afeec4ac010756">DL_FlashCTL_programMemoryFromRAM16WithECCGenerated()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaaf90c1b387a1f1e4c89f2f2dd3c9d04b">DL_FlashCTL_programMemoryFromRAM16WithECCManual()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaa024d88df7a9f69060dfb006f7b4df5f">DL_FlashCTL_programMemoryFromRAM32()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5981511a622102266cd0f383813da4d6">DL_FlashCTL_programMemoryFromRAM32WithECCGenerated()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga83ceb7b89e55b8a1c899e8218cbcc4bc">DL_FlashCTL_programMemoryFromRAM32WithECCManual()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga8249cc8d333fe100bd0845f2ceba8ae2">DL_FlashCTL_programMemoryFromRAM64()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga17ed9d9ae7260b3c754e527c24de901e">DL_FlashCTL_programMemoryFromRAM64WithECCGenerated()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gac307a33adef09fa0534f70d5d42743ba">DL_FlashCTL_programMemoryFromRAM64WithECCManual()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga44fe6a364f21423893dce7f051e38f53">DL_FlashCTL_programMemoryFromRAM8()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gac768f9a334a3ad8796e31ffc6b0002e9">DL_FlashCTL_programMemoryFromRAM8WithECCGenerated()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5d24d3b01b0306dd8abd9f60039a7c69">DL_FlashCTL_programMemoryFromRAM8WithECCManual()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga07a63c746838aa5d38068d3257902130">DL_FlashCTL_protectAllMemory()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga043bf21b804a375035999cf54693ac93">DL_FlashCTL_protectMainMemory()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga487b9695b457dda8eb0d3375e9db8288">DL_FlashCTL_protectNonMainMemory()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gabbb4906e8dc971d484af8ea532857c2a">DL_FlashCTL_protectSector()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaca5117d8a1b42e5ebe08f10be97a7948">DL_FlashCTL_readVerify16()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gac84b570f4c80811cd2b0d4bbd52ff102">DL_FlashCTL_readVerify16WithECCGenerated()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaa8fd46e653b358bc86f08fd84105b914">DL_FlashCTL_readVerify16WithECCManual()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga7118c359b6c8a470a5e36067392458ad">DL_FlashCTL_readVerify32()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaa1fcf7b3155939db21d87ebaf0d5763d">DL_FlashCTL_readVerify32WithECCGenerated()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga6cdbdde8412bbf4210700c2a7df69c21">DL_FlashCTL_readVerify32WithECCManual()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gabff25ac0682e62b0bb4de738c6b4d834">DL_FlashCTL_readVerify64()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gac3858f77a08b8bfb84f23bc827605a67">DL_FlashCTL_readVerify64WithECCGenerated()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaec0a8b00d03c4f25f00cbda948c35018">DL_FlashCTL_readVerify64WithECCManual()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga6bc534914795112833e002912bb71cae">DL_FlashCTL_readVerify8()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gacc12a971702c1e447c1e94a77355ef04">DL_FlashCTL_readVerify8WithECCGenerated()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga8156f3b7ccca7e41976d38f1d3b732dd">DL_FlashCTL_readVerify8WithECCManual()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga417c76df74c19349056920c2eadbde95">DL_FlashCTL_readVerifyFromRAM16()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gacf36894f80f8c5022274d51c164b0190">DL_FlashCTL_readVerifyFromRAM16WithECCGenerated()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga173111fb0ec1809fa9ec2d3968aa2a6b">DL_FlashCTL_readVerifyFromRAM16WithECCManual()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga97997721be98f9773e6469e8bbf64e06">DL_FlashCTL_readVerifyFromRAM32()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga9614efd432e0ca9bc408eab08a8bf064">DL_FlashCTL_readVerifyFromRAM32WithECCGenerated()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gab364e11206b2601873e683bc866e6150">DL_FlashCTL_readVerifyFromRAM32WithECCManual()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaa568538d6891bd4d64576bf498ca1fb5">DL_FlashCTL_readVerifyFromRAM64()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gae26e21cc4860554736d6f96ce341b32f">DL_FlashCTL_readVerifyFromRAM64WithECCGenerated()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga3324d5cc56c79da12792dec45e0ef96d">DL_FlashCTL_readVerifyFromRAM64WithECCManual()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaf3694eca18dc6136034957b9925f0509">DL_FlashCTL_readVerifyFromRAM8()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5c952c5d1657b6c9b70cabfb5e61888d">DL_FlashCTL_readVerifyFromRAM8WithECCGenerated()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga0b8b8ec1471b11dd1753d5908bc8d673">DL_FlashCTL_readVerifyFromRAM8WithECCManual()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gac8da907b919959d7ca3d7af48dcd930d">DL_FlashCTL_unprotectAllMemory()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga199e8316ff42b06115435a8fa7fe786b">DL_FlashCTL_unprotectDataMemory()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga12f380dc9c7ead7114cabd8a35391c08">DL_FlashCTL_unprotectMainMemory()</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#gab4b4326886983e1a9eedb3a8f723a031">DL_FlashCTL_unprotectNonMainMemory()</a>, and <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaff740a4d3903a5813bdcf631e24389cb">DL_FlashCTL_unprotectSector()</a>.</p>

</div>
</div>
<a id="gad2d0a45785ecf6057a9fb76899150819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2d0a45785ecf6057a9fb76899150819">&sect;&nbsp;</a></span>DL_FlashCTL_eraseMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_eraseMemory </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga987c2ff9232d4205c98af65ff7d7c2e2">DL_FLASHCTL_COMMAND_SIZE</a>&#160;</td>
          <td class="paramname"><em>memorySize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs an erase on unprotected memory. </p>
<p>Performs an erase on unprotected memory within a sector or bank of memory containing the input memory address.</p>
<p>NOTE: The user is responsible for unprotecting the regions of memory prior to calling this API. Memory will be automatically protected following the command execution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Memory address within desired sector or bank to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memorySize</td><td>The size of the memory block to erase. One of: <ul>
<li>DL_FLASHCTL_COMMAND_SIZE_BANK </li>
<li>DL_FLASHCTL_COMMAND_SIZE_SECTOR</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the erase process. Check the result of it using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga08dca5922bc739dd8e4439f7d4882a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08dca5922bc739dd8e4439f7d4882a39">&sect;&nbsp;</a></span>DL_FlashCTL_eraseMemoryFromRAM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a> DL_FlashCTL_eraseMemoryFromRAM </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga987c2ff9232d4205c98af65ff7d7c2e2">DL_FLASHCTL_COMMAND_SIZE</a>&#160;</td>
          <td class="paramname"><em>memorySize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs an erase on unprotected memory, and executes command from RAM. </p>
<p>Performs an erase on unprotected memory within a sector or bank of memory containing the input memory address.</p>
<p>The command is executed from RAM, and blocks until the command is finished.</p>
<p>NOTE: The user is responsible for unprotecting the regions of memory prior to calling this API. Memory will be automatically protected following the command execution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Memory address within desired sector or bank to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memorySize</td><td>The size of the memory block to erase. One of: <ul>
<li>DL_FLASHCTL_COMMAND_SIZE_BANK </li>
<li>DL_FLASHCTL_COMMAND_SIZE_SECTOR</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the command was successful. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_FAILED</td><td>if command didn't succeed </td></tr>
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_PASSED</td><td>if command was successful</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the erase process. Check the result of it using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="gad0a7add5d14c16c7b8f470457dbac991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0a7add5d14c16c7b8f470457dbac991">&sect;&nbsp;</a></span>DL_FlashCTL_massErase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DL_FlashCTL_massErase </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a mass erase on main memory on one bank. </p>
<p>Performs a mass erase on main memory on Bank 0 only. This API should be used on single bank devices.</p>
<p>NOTE: This API sets all main memory to unprotected from erase/program</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the erase succeeded</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>if erase didn't succeed </td></tr>
    <tr><td class="paramname">true</td><td>if erase was successful</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="gafb4228a5e605be29f26f0ca96d006e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb4228a5e605be29f26f0ca96d006e0b">&sect;&nbsp;</a></span>DL_FlashCTL_massEraseFromRAM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a> DL_FlashCTL_massEraseFromRAM </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a mass erase on main memory, and executes command from RAM. </p>
<p>Performs a mass erase on main memory on Bank 0 only. This API should be used on single bank devices.</p>
<p>The command is executed from RAM, and blocks until the command is finished.</p>
<p>NOTE: This API sets all main memory to unprotected from erase/program</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the command was successful. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_FAILED</td><td>if command didn't succeed </td></tr>
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_PASSED</td><td>if command was successful</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="gadc2373933a2ffc87984143c33aa8e671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc2373933a2ffc87984143c33aa8e671">&sect;&nbsp;</a></span>DL_FlashCTL_massEraseMultiBank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DL_FlashCTL_massEraseMultiBank </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a mass erase on main memory, and erases all flash banks. </p>
<p>Performs a mass erase on main memory within each flash bank.</p>
<p>NOTE: This API sets all main memory to unprotected from erase/program</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the erase succeeded</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>if erase didn't succeed </td></tr>
    <tr><td class="paramname">true</td><td>if erase was successful</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="gac4de77451a9f9825d5598be8def66081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4de77451a9f9825d5598be8def66081">&sect;&nbsp;</a></span>DL_FlashCTL_factoryReset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DL_FlashCTL_factoryReset </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a factory reset erase on main and non-main memory. </p>
<p>Performs an erase on Bank 0 of main memory and non-main memory on the device. This API should be used on single bank devices.</p>
<p>NOTE: This API sets all main memory to protected from erase/program if successful. If unsuccessful, all memory will be unprotected</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the erase succeeded</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>if erase didn't succeed </td></tr>
    <tr><td class="paramname">true</td><td>if erase was successful</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga9560031f2dc8b370e3991ec67c1a126e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9560031f2dc8b370e3991ec67c1a126e">&sect;&nbsp;</a></span>DL_FlashCTL_factoryResetFromRAM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a> DL_FlashCTL_factoryResetFromRAM </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a factory reset erase on main and non-main memory, and executes command from RAM. </p>
<p>Performs an erase on Bank 0 of main memory and non-main memory on the device. This API should be used on single bank devices.</p>
<p>The command is executed from RAM, and blocks until the command is finished.</p>
<p>NOTE: This API sets all main memory to protected from erase/program if successful. If unsuccessful, all memory will be unprotected</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the command was successful. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_FAILED</td><td>if command didn't succeed </td></tr>
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_PASSED</td><td>if command was successful</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga68b9b8090c318278b40fad8fbb7f446c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68b9b8090c318278b40fad8fbb7f446c">&sect;&nbsp;</a></span>DL_FlashCTL_factoryResetMultiBank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DL_FlashCTL_factoryResetMultiBank </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a factory reset erase on main and non-main memory. </p>
<p>Performs an erase on all flash banks of main memory and non-main memory on the device.</p>
<p>NOTE: This API sets all main memory to protected from erase/program if successful. If unsuccessful, all memory will be unprotected</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the erase succeeded</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>if erase didn't succeed </td></tr>
    <tr><td class="paramname">true</td><td>if erase was successful</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga901335b104e5cc54a5d05fa310676217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga901335b104e5cc54a5d05fa310676217">&sect;&nbsp;</a></span>DL_FlashCTL_programMemory8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_programMemory8 </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs 8 bit data to unprotected memory at the given address. </p>
<p>The device datasheet specifies a maximum limit on program operations per word line before erasure of the sector containing the word line is required. Exceeding this maximum may result in data corruption within the word line. If 8-bit (byte) program operations are performed, or the same memory locations are programmed more than once, the max program limit per word line must be considered and not exceeded. Because of that, it is better to buffer data and use the <a class="el" href="group___f_l_a_s_h_c_t_l.html#gabc6aaa3dc48e49c84d0d9a433fb66f8d">DL_FlashCTL_programMemory16</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga2b57a5818313fd322c643ea1b3ff3b4b">DL_FlashCTL_programMemory32</a> or <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga85c242871e8559bacdc133eb7972889d">DL_FlashCTL_programMemory64</a> APIs to program memory to reduce in the number of program operations in a wordline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Destination memory address to program data. The address must be flash word (64-bit) aligned i.e. aligned to a 0b000 boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the 8-bit source data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Before programming memory, the user must unprotect the region of memory to program. Refer to <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaff740a4d3903a5813bdcf631e24389cb">DL_FlashCTL_unprotectSector</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the program process. Check the result of it using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. NOTE: This API does not enable programming the ECC code. </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga44fe6a364f21423893dce7f051e38f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44fe6a364f21423893dce7f051e38f53">&sect;&nbsp;</a></span>DL_FlashCTL_programMemoryFromRAM8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a> DL_FlashCTL_programMemoryFromRAM8 </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs 8 bit data to unprotected memory at the given address, and executes command from RAM. </p>
<p>The device datasheet specifies a maximum limit on program operations per word line before erasure of the sector containing the word line is required. Exceeding this maximum may result in data corruption within the word line. If 8-bit (byte) program operations are performed, or the same memory locations are programmed more than once, the max program limit per word line must be considered and not exceeded. Because of that, it is better to buffer data and use the <a class="el" href="group___f_l_a_s_h_c_t_l.html#gabc6aaa3dc48e49c84d0d9a433fb66f8d">DL_FlashCTL_programMemory16</a>, <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga2b57a5818313fd322c643ea1b3ff3b4b">DL_FlashCTL_programMemory32</a> or <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga85c242871e8559bacdc133eb7972889d">DL_FlashCTL_programMemory64</a> APIs to program memory to reduce in the number of program operations in a wordline.</p>
<p>The command is executed from RAM, and blocks until the command is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Destination memory address to program data. The address must be flash word (64-bit) aligned i.e. aligned to a 0b000 boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the 8-bit source data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the command was successful. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_FAILED</td><td>if command didn't succeed </td></tr>
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_PASSED</td><td>if command was successful</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Before programming memory, the user must unprotect the region of memory to program. Refer to <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaff740a4d3903a5813bdcf631e24389cb">DL_FlashCTL_unprotectSector</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the program process. Check the result of it using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. NOTE: This API does not enable programming the ECC code. </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="gabc6aaa3dc48e49c84d0d9a433fb66f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc6aaa3dc48e49c84d0d9a433fb66f8d">&sect;&nbsp;</a></span>DL_FlashCTL_programMemory16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_programMemory16 </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs 16 bit data to unprotected memory at the given address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Destination memory address to program data. The address must be flash word (64-bit) aligned i.e. aligned to a 0b000 boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the 16-bit source data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Before programming memory, the user must unprotect the region of memory to program. Refer to <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaff740a4d3903a5813bdcf631e24389cb">DL_FlashCTL_unprotectSector</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the program process. Check the result of it using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. NOTE: This API does not enable programming the ECC code. </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga6b63595169bf9e9c75948b7e34a008c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b63595169bf9e9c75948b7e34a008c1">&sect;&nbsp;</a></span>DL_FlashCTL_programMemoryFromRAM16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a> DL_FlashCTL_programMemoryFromRAM16 </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs 16 bit data to unprotected memory at the given address, and executes command from RAM. </p>
<p>The command is executed from RAM, and blocks until the command is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Destination memory address to program data. The address must be flash word (64-bit) aligned i.e. aligned to a 0b000 boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the 16-bit source data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the command was successful. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_FAILED</td><td>if command didn't succeed </td></tr>
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_PASSED</td><td>if command was successful</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Before programming memory, the user must unprotect the region of memory to program. Refer to <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaff740a4d3903a5813bdcf631e24389cb">DL_FlashCTL_unprotectSector</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the program process. Check the result of it using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. NOTE: This API does not enable programming the ECC code. </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga2b57a5818313fd322c643ea1b3ff3b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b57a5818313fd322c643ea1b3ff3b4b">&sect;&nbsp;</a></span>DL_FlashCTL_programMemory32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_programMemory32 </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs 32 bit data to unprotected memory at the given address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Destination memory address to program data. The address must be flash word (64-bit) aligned i.e. aligned to a 0b000 boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the 32-bit source data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Before programming memory, the user must unprotect the region of memory to program. Refer to <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaff740a4d3903a5813bdcf631e24389cb">DL_FlashCTL_unprotectSector</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the program process. Check the result of it using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. NOTE: This API does not enable programming the ECC code. </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="gaa024d88df7a9f69060dfb006f7b4df5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa024d88df7a9f69060dfb006f7b4df5f">&sect;&nbsp;</a></span>DL_FlashCTL_programMemoryFromRAM32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a> DL_FlashCTL_programMemoryFromRAM32 </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs 32 bit data to unprotected memory at the given address, and executes command from RAM. </p>
<p>The command is executed from RAM, and blocks until the command is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Destination memory address to program data. The address must be flash word (64-bit) aligned i.e. aligned to a 0b000 boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the 32-bit source data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the command was successful. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_FAILED</td><td>if command didn't succeed </td></tr>
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_PASSED</td><td>if command was successful</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Before programming memory, the user must unprotect the region of memory to program. Refer to <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaff740a4d3903a5813bdcf631e24389cb">DL_FlashCTL_unprotectSector</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the program process. Check the result of it using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. NOTE: This API does not enable programming the ECC code. </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga85c242871e8559bacdc133eb7972889d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85c242871e8559bacdc133eb7972889d">&sect;&nbsp;</a></span>DL_FlashCTL_programMemory64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_programMemory64 </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs 64 bit data to unprotected memory at the given address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Destination memory address to program data. The address must be flash word (64-bit) aligned i.e. aligned to a 0b000 boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the 32-bit source data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Before programming memory, the user must unprotect the region of memory to program. Refer to <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaff740a4d3903a5813bdcf631e24389cb">DL_FlashCTL_unprotectSector</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the program process. Check the result of it using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. NOTE: This API does not enable programming the ECC code. </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga8249cc8d333fe100bd0845f2ceba8ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8249cc8d333fe100bd0845f2ceba8ae2">&sect;&nbsp;</a></span>DL_FlashCTL_programMemoryFromRAM64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a> DL_FlashCTL_programMemoryFromRAM64 </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs 64 bit data to unprotected memory at the given address, and executes command from RAM. </p>
<p>The command is executed from RAM, and blocks until the command is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Destination memory address to program data. The address must be flash word (64-bit) aligned i.e. aligned to a 0b000 boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the 32-bit source data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the command was successful. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_FAILED</td><td>if command didn't succeed </td></tr>
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_PASSED</td><td>if command was successful</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Before programming memory, the user must unprotect the region of memory to program. Refer to <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaff740a4d3903a5813bdcf631e24389cb">DL_FlashCTL_unprotectSector</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the program process. Check the result of it using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. NOTE: This API does not enable programming the ECC code. </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga9283e69a72f7de9bf4e3d0126e5464bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9283e69a72f7de9bf4e3d0126e5464bc">&sect;&nbsp;</a></span>DL_FlashCTL_programMemory8WithECCGenerated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_programMemory8WithECCGenerated </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs 8 bit data with hardware generated ECC code. </p>
<p>Programs 8 bit data, along with the 8 ECC bits which correspond to the 8-bit data word, to unprotected memory at the given address. This API assumes that hardware generation of the ECC code has NOT been disabled, and so the flash controller will generate the ECC bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Destination memory address to program data. The address must be flash word (64-bit) aligned i.e. aligned to a 0b000 boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the 8-bit source data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Before programming memory, the user must unprotect the region of memory to program. Refer to <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaff740a4d3903a5813bdcf631e24389cb">DL_FlashCTL_unprotectSector</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the program process. Check the result of it using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided). </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="gac768f9a334a3ad8796e31ffc6b0002e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac768f9a334a3ad8796e31ffc6b0002e9">&sect;&nbsp;</a></span>DL_FlashCTL_programMemoryFromRAM8WithECCGenerated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a> DL_FlashCTL_programMemoryFromRAM8WithECCGenerated </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs 8 bit data with hardware generated ECC code, and executes command from RAM. </p>
<p>Programs 8 bit data, along with the 8 ECC bits which correspond to the 8-bit data word, to unprotected memory at the given address. This API assumes that hardware generation of the ECC code has NOT been disabled, and so the flash controller will generate the ECC bits.</p>
<p>The command is executed from RAM, and blocks until the command is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Destination memory address to program data. The address must be flash word (64-bit) aligned i.e. aligned to a 0b000 boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the 8-bit source data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the command was successful. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_FAILED</td><td>if command didn't succeed </td></tr>
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_PASSED</td><td>if command was successful</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Before programming memory, the user must unprotect the region of memory to program. Refer to <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaff740a4d3903a5813bdcf631e24389cb">DL_FlashCTL_unprotectSector</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the program process. Check the result of it using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided). </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga272050a9943419cb0149f7f936337861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga272050a9943419cb0149f7f936337861">&sect;&nbsp;</a></span>DL_FlashCTL_programMemory16WithECCGenerated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_programMemory16WithECCGenerated </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs 16 bit data with hardware generated ECC code. </p>
<p>Programs 16 bit data, along with the 8 ECC bits which correspond to the 16-bit data word, to unprotected memory at the given address. This API assumes that hardware generation of the ECC code has NOT been disabled, and so the flash controller will generate the ECC bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Destination memory address to program data. The address must be flash word (64-bit) aligned i.e. aligned to a 0b000 boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the 16-bit source data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Before programming memory, the user must unprotect the region of memory to program. Refer to <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaff740a4d3903a5813bdcf631e24389cb">DL_FlashCTL_unprotectSector</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the program process. Check the result of it using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided). </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga1ad0a914a44ca9a016afeec4ac010756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ad0a914a44ca9a016afeec4ac010756">&sect;&nbsp;</a></span>DL_FlashCTL_programMemoryFromRAM16WithECCGenerated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a> DL_FlashCTL_programMemoryFromRAM16WithECCGenerated </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs 16 bit data with hardware generated ECC code, and executes command from RAM. </p>
<p>Programs 16 bit data, along with the 8 ECC bits which correspond to the 16-bit data word, to unprotected memory at the given address. This API assumes that hardware generation of the ECC code has NOT been disabled, and so the flash controller will generate the ECC bits.</p>
<p>The command is executed from RAM, and blocks until the command is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Destination memory address to program data. The address must be flash word (64-bit) aligned i.e. aligned to a 0b000 boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the 16-bit source data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the command was successful. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_FAILED</td><td>if command didn't succeed </td></tr>
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_PASSED</td><td>if command was successful</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Before programming memory, the user must unprotect the region of memory to program. Refer to <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaff740a4d3903a5813bdcf631e24389cb">DL_FlashCTL_unprotectSector</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the program process. Check the result of it using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided). </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga10e1550de79bcce6df3042ba995b1780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10e1550de79bcce6df3042ba995b1780">&sect;&nbsp;</a></span>DL_FlashCTL_programMemory32WithECCGenerated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_programMemory32WithECCGenerated </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs 32 bit data with hardware generated ECC code. </p>
<p>Programs 32 bit data, along with the 8 ECC bits which correspond to the 32-bit data word, to unprotected memory at the given address. This API assumes that hardware generation of the ECC code has NOT been disabled, and so the flash controller will generate the ECC bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Destination memory address to program data. The address must be flash word (64-bit) aligned i.e. aligned to a 0b000 boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the 32-bit source data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Before programming memory, the user must unprotect the region of memory to program. Refer to <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaff740a4d3903a5813bdcf631e24389cb">DL_FlashCTL_unprotectSector</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the program process. Check the result of it using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided). </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga5981511a622102266cd0f383813da4d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5981511a622102266cd0f383813da4d6">&sect;&nbsp;</a></span>DL_FlashCTL_programMemoryFromRAM32WithECCGenerated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a> DL_FlashCTL_programMemoryFromRAM32WithECCGenerated </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs 32 bit data with hardware generated ECC code, and executes command from RAM. </p>
<p>Programs 32 bit data, along with the 8 ECC bits which correspond to the 32-bit data word, to unprotected memory at the given address. This API assumes that hardware generation of the ECC code has NOT been disabled, and so the flash controller will generate the ECC bits.</p>
<p>The command is executed from RAM, and blocks until the command is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Destination memory address to program data. The address must be flash word (64-bit) aligned i.e. aligned to a 0b000 boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the 32-bit source data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the command was successful. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_FAILED</td><td>if command didn't succeed </td></tr>
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_PASSED</td><td>if command was successful</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Before programming memory, the user must unprotect the region of memory to program. Refer to <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaff740a4d3903a5813bdcf631e24389cb">DL_FlashCTL_unprotectSector</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the program process. Check the result of it using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided). </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga5040ae1f581f8359a902585a3d1abf71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5040ae1f581f8359a902585a3d1abf71">&sect;&nbsp;</a></span>DL_FlashCTL_programMemory64WithECCGenerated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_programMemory64WithECCGenerated </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs 64 bit data with hardware generated ECC code. </p>
<p>Programs 64 bit data, along with the 8 ECC bits which correspond to the 64-bit data word, to unprotected memory at the given address. This API assumes that hardware generation of the ECC code has NOT been disabled, and so the flash controller will generate the ECC bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Destination memory address to program data. The address must be flash word (64-bit) aligned i.e. aligned to a 0b000 boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the 32-bit source data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Before programming memory, the user must unprotect the region of memory to program. Refer to <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaff740a4d3903a5813bdcf631e24389cb">DL_FlashCTL_unprotectSector</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the program process. Check the result of it using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided). </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga17ed9d9ae7260b3c754e527c24de901e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17ed9d9ae7260b3c754e527c24de901e">&sect;&nbsp;</a></span>DL_FlashCTL_programMemoryFromRAM64WithECCGenerated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a> DL_FlashCTL_programMemoryFromRAM64WithECCGenerated </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs 64 bit data with hardware generated ECC code, and executes command from RAM. </p>
<p>Programs 16 bit data, along with the 8 ECC bits which correspond to the 16-bit data word, to unprotected memory at the given address. This API assumes that hardware generation of the ECC code has NOT been disabled, and so the flash controller will generate the ECC bits.</p>
<p>The command is executed from RAM, and blocks until the command is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Destination memory address to program data. The address must be flash word (64-bit) aligned i.e. aligned to a 0b000 boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the 32-bit source data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the command was successful. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_FAILED</td><td>if command didn't succeed </td></tr>
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_PASSED</td><td>if command was successful</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Before programming memory, the user must unprotect the region of memory to program. Refer to <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaff740a4d3903a5813bdcf631e24389cb">DL_FlashCTL_unprotectSector</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the program process. Check the result of it using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided). </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga46c3f9272bcd36868812a31fb092a72b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46c3f9272bcd36868812a31fb092a72b">&sect;&nbsp;</a></span>DL_FlashCTL_programMemory8WithECCManual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_programMemory8WithECCManual </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>eccCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs 8 bit data with user provided ECC code. </p>
<p>Programs 8 bit data, along with the 8 ECC bits which correspond to the 8-bit data word, to unprotected memory at the given address. This API assumes that hardware generation of the ECC code HAS been disabled, and so the user must provide the ECC code to program.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Destination memory address to program data. The address must be flash word (64-bit) aligned i.e. aligned to a 0b000 boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the 8-bit source data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eccCode</td><td>Pointer to the ECC code to program</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>User must call <a class="el" href="group___f_l_a_s_h_c_t_l.html#gacf328d7e267b95496ff4e0d7b37e831a">DL_FlashCTL_enableOverrideHardwareGeneratedECC</a> to disable hardware generation of the ECC code, so the ECC code can be manually provided for programming. This override setting will persist through multiple programs, until <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga425a9da6de8a129833b47834093f34fb">DL_FlashCTL_disableOverrideHardwareGeneratedECC</a> is called </dd>
<dd>
Before programming memory, the user must unprotect the region of memory to program. Refer to <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaff740a4d3903a5813bdcf631e24389cb">DL_FlashCTL_unprotectSector</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the program process. Check the result of it using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided). </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga5d24d3b01b0306dd8abd9f60039a7c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d24d3b01b0306dd8abd9f60039a7c69">&sect;&nbsp;</a></span>DL_FlashCTL_programMemoryFromRAM8WithECCManual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a> DL_FlashCTL_programMemoryFromRAM8WithECCManual </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>eccCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs 8 bit data with user provided ECC code, and executes command from RAM. </p>
<p>Programs 8 bit data, along with the 8 ECC bits which correspond to the 8-bit data word, to unprotected memory at the given address. This API assumes that hardware generation of the ECC code HAS been disabled, and so the user must provide the ECC code to program.</p>
<p>The command is executed from RAM, and blocks until the command is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Destination memory address to program data. The address must be flash word (64-bit) aligned i.e. aligned to a 0b000 boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the 8-bit source data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eccCode</td><td>Pointer to the ECC code to program</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the command was successful. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_FAILED</td><td>if command didn't succeed </td></tr>
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_PASSED</td><td>if command was successful</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>User must call <a class="el" href="group___f_l_a_s_h_c_t_l.html#gacf328d7e267b95496ff4e0d7b37e831a">DL_FlashCTL_enableOverrideHardwareGeneratedECC</a> to disable hardware generation of the ECC code, so the ECC code can be manually provided for programming. This override setting will persist through multiple programs, until <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga425a9da6de8a129833b47834093f34fb">DL_FlashCTL_disableOverrideHardwareGeneratedECC</a> is called </dd>
<dd>
Before programming memory, the user must unprotect the region of memory to program. Refer to <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaff740a4d3903a5813bdcf631e24389cb">DL_FlashCTL_unprotectSector</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the program process. Check the result of it using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided). </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga4a395feddcfd61d07314c68d20de7bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a395feddcfd61d07314c68d20de7bef">&sect;&nbsp;</a></span>DL_FlashCTL_programMemory16WithECCManual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_programMemory16WithECCManual </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>eccCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs 16 bit data with user provided ECC code. </p>
<p>Programs 16 bit data, along with the 8 ECC bits which correspond to the 16-bit data word, to unprotected memory at the given address. This API assumes that hardware generation of the ECC code HAS been disabled, and so the user must provide the ECC code to program.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Destination memory address to program data. The address must be flash word (64-bit) aligned i.e. aligned to a 0b000 boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the 16-bit source data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eccCode</td><td>Pointer to the ECC code to program</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>User must call <a class="el" href="group___f_l_a_s_h_c_t_l.html#gacf328d7e267b95496ff4e0d7b37e831a">DL_FlashCTL_enableOverrideHardwareGeneratedECC</a> to disable hardware generation of the ECC code, so the ECC code can be manually provided for programming. This override setting will persist through multiple programs, until <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga425a9da6de8a129833b47834093f34fb">DL_FlashCTL_disableOverrideHardwareGeneratedECC</a> is called </dd>
<dd>
Before programming memory, the user must unprotect the region of memory to program. Refer to <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaff740a4d3903a5813bdcf631e24389cb">DL_FlashCTL_unprotectSector</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the program process. Check the result of it using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided). </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="gaaf90c1b387a1f1e4c89f2f2dd3c9d04b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf90c1b387a1f1e4c89f2f2dd3c9d04b">&sect;&nbsp;</a></span>DL_FlashCTL_programMemoryFromRAM16WithECCManual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a> DL_FlashCTL_programMemoryFromRAM16WithECCManual </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>eccCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs 16 bit data with user provided ECC code, and executes command from RAM. </p>
<p>Programs 16 bit data, along with the 8 ECC bits which correspond to the 16-bit data word, to unprotected memory at the given address. This API assumes that hardware generation of the ECC code HAS been disabled, and so the user must provide the ECC code to program.</p>
<p>The command is executed from RAM, and blocks until the command is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Destination memory address to program data. The address must be flash word (64-bit) aligned i.e. aligned to a 0b000 boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the 16-bit source data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eccCode</td><td>Pointer to the ECC code to program</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the command was successful. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_FAILED</td><td>if command didn't succeed </td></tr>
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_PASSED</td><td>if command was successful</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>User must call <a class="el" href="group___f_l_a_s_h_c_t_l.html#gacf328d7e267b95496ff4e0d7b37e831a">DL_FlashCTL_enableOverrideHardwareGeneratedECC</a> to disable hardware generation of the ECC code, so the ECC code can be manually provided for programming. This override setting will persist through multiple programs, until <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga425a9da6de8a129833b47834093f34fb">DL_FlashCTL_disableOverrideHardwareGeneratedECC</a> is called </dd>
<dd>
Before programming memory, the user must unprotect the region of memory to program. Refer to <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaff740a4d3903a5813bdcf631e24389cb">DL_FlashCTL_unprotectSector</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the program process. Check the result of it using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided). </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga36abe0765d95d555d6e90b058e0df53c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36abe0765d95d555d6e90b058e0df53c">&sect;&nbsp;</a></span>DL_FlashCTL_programMemory32WithECCManual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_programMemory32WithECCManual </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>eccCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs 32 bit data with user provided ECC code. </p>
<p>Programs 32 bit data, along with the 8 ECC bits which correspond to the 32-bit data word, to unprotected memory at the given address. This API assumes that hardware generation of the ECC code HAS been disabled, and so the user must provide the ECC code to program.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Destination memory address to program data. The address must be flash word (64-bit) aligned i.e. aligned to a 0b000 boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the 32-bit source data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eccCode</td><td>Pointer to the ECC code to program</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>User must call <a class="el" href="group___f_l_a_s_h_c_t_l.html#gacf328d7e267b95496ff4e0d7b37e831a">DL_FlashCTL_enableOverrideHardwareGeneratedECC</a> to disable hardware generation of the ECC code, so the ECC code can be manually provided for programming. This override setting will persist through multiple programs, until <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga425a9da6de8a129833b47834093f34fb">DL_FlashCTL_disableOverrideHardwareGeneratedECC</a> is called </dd>
<dd>
Before programming memory, the user must unprotect the region of memory to program. Refer to <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaff740a4d3903a5813bdcf631e24389cb">DL_FlashCTL_unprotectSector</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the program process. Check the result of it using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided). </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga83ceb7b89e55b8a1c899e8218cbcc4bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83ceb7b89e55b8a1c899e8218cbcc4bc">&sect;&nbsp;</a></span>DL_FlashCTL_programMemoryFromRAM32WithECCManual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a> DL_FlashCTL_programMemoryFromRAM32WithECCManual </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>eccCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs 32 bit data with user provided ECC code, and executes command from RAM. </p>
<p>Programs 32 bit data, along with the 8 ECC bits which correspond to the 32-bit data word, to unprotected memory at the given address. This API assumes that hardware generation of the ECC code HAS been disabled, and so the user must provide the ECC code to program.</p>
<p>The command is executed from RAM, and blocks until the command is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Destination memory address to program data. The address must be flash word (64-bit) aligned i.e. aligned to a 0b000 boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the 32-bit source data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eccCode</td><td>Pointer to the ECC code to program</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the command was successful. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_FAILED</td><td>if command didn't succeed </td></tr>
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_PASSED</td><td>if command was successful</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>User must call <a class="el" href="group___f_l_a_s_h_c_t_l.html#gacf328d7e267b95496ff4e0d7b37e831a">DL_FlashCTL_enableOverrideHardwareGeneratedECC</a> to disable hardware generation of the ECC code, so the ECC code can be manually provided for programming. This override setting will persist through multiple programs, until <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga425a9da6de8a129833b47834093f34fb">DL_FlashCTL_disableOverrideHardwareGeneratedECC</a> is called </dd>
<dd>
Before programming memory, the user must unprotect the region of memory to program. Refer to <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaff740a4d3903a5813bdcf631e24389cb">DL_FlashCTL_unprotectSector</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the program process. Check the result of it using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided). </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="gaaea9cb0c24c2935af10797a1b3aa997d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaea9cb0c24c2935af10797a1b3aa997d">&sect;&nbsp;</a></span>DL_FlashCTL_programMemory64WithECCManual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_programMemory64WithECCManual </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>eccCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs 64 bit data with user provided ECC code. </p>
<p>Programs 64 bit data, along with the 8 ECC bits which correspond to the 64-bit data word, to unprotected memory at the given address. This API assumes that hardware generation of the ECC code HAS been disabled, and so the user must provide the ECC code to program.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Destination memory address to program data. The address must be flash word (64-bit) aligned i.e. aligned to a 0b000 boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the 32-bit source data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eccCode</td><td>Pointer to the ECC code to program</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>User must call <a class="el" href="group___f_l_a_s_h_c_t_l.html#gacf328d7e267b95496ff4e0d7b37e831a">DL_FlashCTL_enableOverrideHardwareGeneratedECC</a> to disable hardware generation of the ECC code, so the ECC code can be manually provided for programming. This override setting will persist through multiple programs, until <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga425a9da6de8a129833b47834093f34fb">DL_FlashCTL_disableOverrideHardwareGeneratedECC</a> is called </dd>
<dd>
Before programming memory, the user must unprotect the region of memory to program. Refer to <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaff740a4d3903a5813bdcf631e24389cb">DL_FlashCTL_unprotectSector</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the program process. Check the result of it using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided). </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="gac307a33adef09fa0534f70d5d42743ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac307a33adef09fa0534f70d5d42743ba">&sect;&nbsp;</a></span>DL_FlashCTL_programMemoryFromRAM64WithECCManual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a> DL_FlashCTL_programMemoryFromRAM64WithECCManual </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>eccCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs 64 bit data with user provided ECC code, and executes command from RAM. </p>
<p>Programs 64 bit data, along with the 8 ECC bits which correspond to the 64-bit data word, to unprotected memory at the given address. This API assumes that hardware generation of the ECC code HAS been disabled, and so the user must provide the ECC code to program.</p>
<p>The command is executed from RAM, and blocks until the command is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Destination memory address to program data. The address must be flash word (64-bit) aligned i.e. aligned to a 0b000 boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the 32-bit source data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eccCode</td><td>Pointer to the ECC code to program</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the command was successful. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_FAILED</td><td>if command didn't succeed </td></tr>
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_PASSED</td><td>if command was successful</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>User must call <a class="el" href="group___f_l_a_s_h_c_t_l.html#gacf328d7e267b95496ff4e0d7b37e831a">DL_FlashCTL_enableOverrideHardwareGeneratedECC</a> to disable hardware generation of the ECC code, so the ECC code can be manually provided for programming. This override setting will persist through multiple programs, until <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga425a9da6de8a129833b47834093f34fb">DL_FlashCTL_disableOverrideHardwareGeneratedECC</a> is called </dd>
<dd>
Before programming memory, the user must unprotect the region of memory to program. Refer to <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaff740a4d3903a5813bdcf631e24389cb">DL_FlashCTL_unprotectSector</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the program process. Check the result of it using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided). </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga5a01864fe9815f1117cbda07c38e0de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a01864fe9815f1117cbda07c38e0de5">&sect;&nbsp;</a></span>DL_FlashCTL_programMemoryBlocking64WithECCGenerated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DL_FlashCTL_programMemoryBlocking64WithECCGenerated </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gad8b5345481dd655cbd20dadc84e7621b">DL_FLASHCTL_REGION_SELECT</a>&#160;</td>
          <td class="paramname"><em>regionSelect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs provided data with hardware generated ECC code. </p>
<p>Blocking function that programs a set of data, along with the 8 ECC bits which correspond to the data at the given address. This API assumes that hardware generation of the ECC code has NOT been disabled, and so the flash controller will generate the ECC bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Destination memory address to program data. The address must be flash word (64-bit) aligned i.e. aligned to a 0b000 boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataSize</td><td>The number of 32-bit words to program. Value should be an even number, to ensure data is programmed 64-bits at a time. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data source to program into flash </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regionSelect</td><td>The region of memory to erase. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#gad8b5345481dd655cbd20dadc84e7621b">DL_FLASHCTL_REGION_SELECT</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the program succeeded</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Program didn't succeed, or invalid dataSize </td></tr>
    <tr><td class="paramname">true</td><td>Program was successful</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the program process. Check the result of it using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided). </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="gaf27b130aecc263d4a4cce6b54346e4cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf27b130aecc263d4a4cce6b54346e4cf">&sect;&nbsp;</a></span>DL_FlashCTL_programMemoryBlockingFromRAM64WithECCGenerated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a> DL_FlashCTL_programMemoryBlockingFromRAM64WithECCGenerated </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gad8b5345481dd655cbd20dadc84e7621b">DL_FLASHCTL_REGION_SELECT</a>&#160;</td>
          <td class="paramname"><em>regionSelect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs provided data with hardware generated ECC code, and executes command from RAM. </p>
<p>Blocking function that programs a set of data, along with the 8 ECC bits which correspond to the data at the given address. This API assumes that hardware generation of the ECC code has NOT been disabled, and so the flash controller will generate the ECC bits.</p>
<p>The command is executed from RAM, and blocks until the command is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Destination memory address to program data. The address must be flash word (64-bit) aligned i.e. aligned to a 0b000 boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataSize</td><td>The number of 32-bit words to program. Value should be an even number, to ensure data is programmed 64-bits at a time. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data source to program into flash </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regionSelect</td><td>The region of memory to erase. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#gad8b5345481dd655cbd20dadc84e7621b">DL_FLASHCTL_REGION_SELECT</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the command was successful. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_FAILED</td><td>if command didn't succeed </td></tr>
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_PASSED</td><td>if command was successful</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the program process. Check the result of it using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided). </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga9ea23446748b9a1eddc96b199b55e4f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ea23446748b9a1eddc96b199b55e4f6">&sect;&nbsp;</a></span>DL_FlashCTL_programMemoryBlocking64WithECCManual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DL_FlashCTL_programMemoryBlocking64WithECCManual </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>eccCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gad8b5345481dd655cbd20dadc84e7621b">DL_FLASHCTL_REGION_SELECT</a>&#160;</td>
          <td class="paramname"><em>regionSelect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs provided data with user provided ECC code. </p>
<p>Blocking function that programs a set of data, along with the 8 ECC bits which correspond to the data at the given address. This API assumes that hardware generation of the ECC code HAS been disabled, and so the user must provide the ECC code to program.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Destination memory address to program data. The address must be flash word (64-bit) aligned i.e. aligned to a 0b000 boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataSize</td><td>The number of 32-bit words to program. Value should be an even number, to ensure data is programmed 64-bits at a time. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data source to program into flash </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eccCode</td><td>Pointer to ECC code to program corresponding to data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regionSelect</td><td>The region of memory to erase. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#gad8b5345481dd655cbd20dadc84e7621b">DL_FLASHCTL_REGION_SELECT</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the program succeeded</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Program didn't succeed, or invalid dataSize </td></tr>
    <tr><td class="paramname">true</td><td>Program was successful</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>User must call <a class="el" href="group___f_l_a_s_h_c_t_l.html#gacf328d7e267b95496ff4e0d7b37e831a">DL_FlashCTL_enableOverrideHardwareGeneratedECC</a> to disable hardware generation of the ECC code, so the ECC code can be manually provided for programming. This override setting will persist through multiple programs, until <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga425a9da6de8a129833b47834093f34fb">DL_FlashCTL_disableOverrideHardwareGeneratedECC</a> is called </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the program process. Check the result of it using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided). </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga7f19934f5b5861ea8454a799ceaa642f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f19934f5b5861ea8454a799ceaa642f">&sect;&nbsp;</a></span>DL_FlashCTL_programMemoryBlockingFromRAM64WithECCManual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a> DL_FlashCTL_programMemoryBlockingFromRAM64WithECCManual </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>eccCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gad8b5345481dd655cbd20dadc84e7621b">DL_FLASHCTL_REGION_SELECT</a>&#160;</td>
          <td class="paramname"><em>regionSelect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs provided data with user provided ECC code, and executes command from RAM. </p>
<p>Blocking function that programs a set of data, along with the 8 ECC bits which correspond to the data at the given address. This API assumes that hardware generation of the ECC code HAS been disabled, and so the user must provide the ECC code to program.</p>
<p>The command is executed from RAM, and blocks until the command is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Destination memory address to program data. The address must be flash word (64-bit) aligned i.e. aligned to a 0b000 boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataSize</td><td>The number of 32-bit words to program. Value should be an even number, to ensure data is programmed 64-bits at a time. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data source to program into flash </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eccCode</td><td>Pointer to ECC code to program corresponding to data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regionSelect</td><td>The region of memory to erase. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#gad8b5345481dd655cbd20dadc84e7621b">DL_FLASHCTL_REGION_SELECT</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the command was successful. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_FAILED</td><td>if command didn't succeed </td></tr>
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_PASSED</td><td>if command was successful</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>User must call <a class="el" href="group___f_l_a_s_h_c_t_l.html#gacf328d7e267b95496ff4e0d7b37e831a">DL_FlashCTL_enableOverrideHardwareGeneratedECC</a> to disable hardware generation of the ECC code, so the ECC code can be manually provided for programming. This override setting will persist through multiple programs, until <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga425a9da6de8a129833b47834093f34fb">DL_FlashCTL_disableOverrideHardwareGeneratedECC</a> is called </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the program process. Check the result of it using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided). </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga5644da91bdbf6df26ea6550da3dbc226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5644da91bdbf6df26ea6550da3dbc226">&sect;&nbsp;</a></span>DL_FlashCTL_programMemoryBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DL_FlashCTL_programMemoryBlocking </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gad8b5345481dd655cbd20dadc84e7621b">DL_FLASHCTL_REGION_SELECT</a>&#160;</td>
          <td class="paramname"><em>regionSelect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs provided data to unprotected memory at a given address. </p>
<p>Blocking function that programs a set of data. Data will be programmed as flash words (64-bits). If dataSize is an odd number, then the last word will be programmed as 32-bit data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Destination memory address to program data. The address must be flash word (64-bit) aligned i.e. aligned to a 0b000 boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataSize</td><td>The number of 32-bit words to program </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data source to program into flash </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regionSelect</td><td>The region of memory to erase. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#gad8b5345481dd655cbd20dadc84e7621b">DL_FLASHCTL_REGION_SELECT</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the program succeeded</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Program didn't succeed </td></tr>
    <tr><td class="paramname">true</td><td>Program was successful</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Before programming memory, the user must unprotect the region of memory to program. Refer to <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaff740a4d3903a5813bdcf631e24389cb">DL_FlashCTL_unprotectSector</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the program process. Check the result of it using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. NOTE: This API does not enable programming the ECC code. </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="gab8a38f51d18afd14036b7e83b431a8c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8a38f51d18afd14036b7e83b431a8c9">&sect;&nbsp;</a></span>DL_FlashCTL_programMemoryFromRAM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a> DL_FlashCTL_programMemoryFromRAM </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gad8b5345481dd655cbd20dadc84e7621b">DL_FLASHCTL_REGION_SELECT</a>&#160;</td>
          <td class="paramname"><em>regionSelect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs provided data to unprotected memory at a given address, and executes command from RAM. </p>
<p>Blocking function that programs a set of data. Data will be programmed as flash words (64-bits). If dataSize is an odd number, then the last word will be programmed as 32-bit data.</p>
<p>The command is executed from RAM, and blocks until the command is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Destination memory address to program data. The address must be flash word (64-bit) aligned i.e. aligned to a 0b000 boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataSize</td><td>The number of 32-bit words to program </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data source to program into flash </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regionSelect</td><td>The region of memory to erase. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#gad8b5345481dd655cbd20dadc84e7621b">DL_FLASHCTL_REGION_SELECT</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the command was successful. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_FAILED</td><td>if command didn't succeed </td></tr>
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_PASSED</td><td>if command was successful</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Before programming memory, the user must unprotect the region of memory to program. Refer to <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaff740a4d3903a5813bdcf631e24389cb">DL_FlashCTL_unprotectSector</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the program process. Check the result of it using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. NOTE: This API does not enable programming the ECC code. </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga12f380dc9c7ead7114cabd8a35391c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12f380dc9c7ead7114cabd8a35391c08">&sect;&nbsp;</a></span>DL_FlashCTL_unprotectMainMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_unprotectMainMemory </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unprotects all main memory from erase/program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga199e8316ff42b06115435a8fa7fe786b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga199e8316ff42b06115435a8fa7fe786b">&sect;&nbsp;</a></span>DL_FlashCTL_unprotectDataMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_unprotectDataMemory </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unprotects all data memory from erase/program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga043bf21b804a375035999cf54693ac93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga043bf21b804a375035999cf54693ac93">&sect;&nbsp;</a></span>DL_FlashCTL_protectMainMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_protectMainMemory </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Protects all main memory from erase/program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="gab4b4326886983e1a9eedb3a8f723a031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4b4326886983e1a9eedb3a8f723a031">&sect;&nbsp;</a></span>DL_FlashCTL_unprotectNonMainMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_unprotectNonMainMemory </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unprotects all non-main memory from erase/program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga487b9695b457dda8eb0d3375e9db8288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga487b9695b457dda8eb0d3375e9db8288">&sect;&nbsp;</a></span>DL_FlashCTL_protectNonMainMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_protectNonMainMemory </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Protects all non-main memory from erase/program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="gac8da907b919959d7ca3d7af48dcd930d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8da907b919959d7ca3d7af48dcd930d">&sect;&nbsp;</a></span>DL_FlashCTL_unprotectAllMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_unprotectAllMemory </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unprotects all user memory from erase/program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga07a63c746838aa5d38068d3257902130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07a63c746838aa5d38068d3257902130">&sect;&nbsp;</a></span>DL_FlashCTL_protectAllMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_protectAllMemory </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Protects all user memory from erase/program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="gaff740a4d3903a5813bdcf631e24389cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff740a4d3903a5813bdcf631e24389cb">&sect;&nbsp;</a></span>DL_FlashCTL_unprotectSector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_unprotectSector </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gad8b5345481dd655cbd20dadc84e7621b">DL_FLASHCTL_REGION_SELECT</a>&#160;</td>
          <td class="paramname"><em>regionSelect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a given sector to unprotected from erase/program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Address of sector to unprotect </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regionSelect</td><td>The region of memory to unprotect. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#gad8b5345481dd655cbd20dadc84e7621b">DL_FLASHCTL_REGION_SELECT</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="gabbb4906e8dc971d484af8ea532857c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbb4906e8dc971d484af8ea532857c2a">&sect;&nbsp;</a></span>DL_FlashCTL_protectSector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_protectSector </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gad8b5345481dd655cbd20dadc84e7621b">DL_FLASHCTL_REGION_SELECT</a>&#160;</td>
          <td class="paramname"><em>regionSelect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a given sector to protected from erase/program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Address of sector to protect </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regionSelect</td><td>The region of memory to protect. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#gad8b5345481dd655cbd20dadc84e7621b">DL_FLASHCTL_REGION_SELECT</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga6bc534914795112833e002912bb71cae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bc534914795112833e002912bb71cae">&sect;&nbsp;</a></span>DL_FlashCTL_readVerify8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_readVerify8 </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies 8-bit data in specified address. </p>
<p>The READVERIFY command may be used to read a flash location and compare it to data to be verified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Memory address of flash to verify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data source to verify </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="gaf3694eca18dc6136034957b9925f0509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3694eca18dc6136034957b9925f0509">&sect;&nbsp;</a></span>DL_FlashCTL_readVerifyFromRAM8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a> DL_FlashCTL_readVerifyFromRAM8 </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies 8-bit data in specified address, and executes command from RAM. </p>
<p>The READVERIFY command may be used to read a flash location and compare it to data to be verified.</p>
<p>The command is executed from RAM, and blocks until the command is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Memory address of flash to verify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data source to verify</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the command was successful. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_FAILED</td><td>if command didn't succeed </td></tr>
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_PASSED</td><td>if command was successful </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="gaca5117d8a1b42e5ebe08f10be97a7948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca5117d8a1b42e5ebe08f10be97a7948">&sect;&nbsp;</a></span>DL_FlashCTL_readVerify16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_readVerify16 </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies 16-bit data in specified address. </p>
<p>The READVERIFY command may be used to read a flash location and compare it to data to be verified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Memory address of flash to verify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data source to verify </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga417c76df74c19349056920c2eadbde95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga417c76df74c19349056920c2eadbde95">&sect;&nbsp;</a></span>DL_FlashCTL_readVerifyFromRAM16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a> DL_FlashCTL_readVerifyFromRAM16 </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies 16-bit data in specified address, and executes command from RAM. </p>
<p>The READVERIFY command may be used to read a flash location and compare it to data to be verified.</p>
<p>The command is executed from RAM, and blocks until the command is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Memory address of flash to verify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data source to verify</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the command was successful. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_FAILED</td><td>if command didn't succeed </td></tr>
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_PASSED</td><td>if command was successful </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga7118c359b6c8a470a5e36067392458ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7118c359b6c8a470a5e36067392458ad">&sect;&nbsp;</a></span>DL_FlashCTL_readVerify32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_readVerify32 </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies 32-bit data in specified address. </p>
<p>The READVERIFY command may be used to read a flash location and compare it to data to be verified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Memory address of flash to verify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data source to verify </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga97997721be98f9773e6469e8bbf64e06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97997721be98f9773e6469e8bbf64e06">&sect;&nbsp;</a></span>DL_FlashCTL_readVerifyFromRAM32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a> DL_FlashCTL_readVerifyFromRAM32 </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies 32-bit data in specified address, and executes command from RAM. </p>
<p>The READVERIFY command may be used to read a flash location and compare it to data to be verified.</p>
<p>The command is executed from RAM, and blocks until the command is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Memory address of flash to verify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data source to verify</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the command was successful. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_FAILED</td><td>if command didn't succeed </td></tr>
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_PASSED</td><td>if command was successful </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="gabff25ac0682e62b0bb4de738c6b4d834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabff25ac0682e62b0bb4de738c6b4d834">&sect;&nbsp;</a></span>DL_FlashCTL_readVerify64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_readVerify64 </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies 64-bit data in specified address. </p>
<p>The READVERIFY command may be used to read a flash location and compare it to data to be verified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Memory address of flash to verify. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data source to verify </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="gaa568538d6891bd4d64576bf498ca1fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa568538d6891bd4d64576bf498ca1fb5">&sect;&nbsp;</a></span>DL_FlashCTL_readVerifyFromRAM64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a> DL_FlashCTL_readVerifyFromRAM64 </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies 64-bit data in specified address, and executes command from RAM. </p>
<p>The READVERIFY command may be used to read a flash location and compare it to data to be verified.</p>
<p>The command is executed from RAM, and blocks until the command is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Memory address of flash to verify. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data source to verify</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the command was successful. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_FAILED</td><td>if command didn't succeed </td></tr>
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_PASSED</td><td>if command was successful </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="gacc12a971702c1e447c1e94a77355ef04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc12a971702c1e447c1e94a77355ef04">&sect;&nbsp;</a></span>DL_FlashCTL_readVerify8WithECCGenerated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_readVerify8WithECCGenerated </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies 8-bit data in specified address with hardware generated ECC code. </p>
<p>The READVERIFY command may be used to read a flash location and compare it to data to be verified along with the 8 ECC bits which correspond to the data. This API assumes that hardware generation of the ECC code has NOT been disabled, and so the flash controller will generate the ECC bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Memory address of flash to verify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data source to verify</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided). </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga5c952c5d1657b6c9b70cabfb5e61888d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c952c5d1657b6c9b70cabfb5e61888d">&sect;&nbsp;</a></span>DL_FlashCTL_readVerifyFromRAM8WithECCGenerated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a> DL_FlashCTL_readVerifyFromRAM8WithECCGenerated </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies 8-bit data in specified address with hardware generated ECC code, and executes command from RAM. </p>
<p>The READVERIFY command may be used to read a flash location and compare it to data to be verified along with the 8 ECC bits which correspond to the data. This API assumes that hardware generation of the ECC code has NOT been disabled, and so the flash controller will generate the ECC bits.</p>
<p>The command is executed from RAM, and blocks until the command is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Memory address of flash to verify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data source to verify</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided).</p>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the command was successful. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_FAILED</td><td>if command didn't succeed </td></tr>
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_PASSED</td><td>if command was successful </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="gac84b570f4c80811cd2b0d4bbd52ff102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac84b570f4c80811cd2b0d4bbd52ff102">&sect;&nbsp;</a></span>DL_FlashCTL_readVerify16WithECCGenerated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_readVerify16WithECCGenerated </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies 16-bit data in specified address with hardware generated ECC code. </p>
<p>The READVERIFY command may be used to read a flash location and compare it to data to be verified along with the 8 ECC bits which correspond to the data. This API assumes that hardware generation of the ECC code has NOT been disabled, and so the flash controller will generate the ECC bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Memory address of flash to verify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data source to verify</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided). </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="gacf36894f80f8c5022274d51c164b0190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf36894f80f8c5022274d51c164b0190">&sect;&nbsp;</a></span>DL_FlashCTL_readVerifyFromRAM16WithECCGenerated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a> DL_FlashCTL_readVerifyFromRAM16WithECCGenerated </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies 16-bit data in specified address with hardware generated ECC code, and executes command from RAM. </p>
<p>The READVERIFY command may be used to read a flash location and compare it to data to be verified along with the 8 ECC bits which correspond to the data. This API assumes that hardware generation of the ECC code has NOT been disabled, and so the flash controller will generate the ECC bits.</p>
<p>The command is executed from RAM, and blocks until the command is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Memory address of flash to verify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data source to verify</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided).</p>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the command was successful. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_FAILED</td><td>if command didn't succeed </td></tr>
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_PASSED</td><td>if command was successful </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="gaa1fcf7b3155939db21d87ebaf0d5763d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1fcf7b3155939db21d87ebaf0d5763d">&sect;&nbsp;</a></span>DL_FlashCTL_readVerify32WithECCGenerated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_readVerify32WithECCGenerated </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies 32-bit data in specified address with hardware generated ECC code. </p>
<p>The READVERIFY command may be used to read a flash location and compare it to data to be verified along with the 8 ECC bits which correspond to the data. This API assumes that hardware generation of the ECC code has NOT been disabled, and so the flash controller will generate the ECC bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Memory address of flash to verify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data source to verify</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided). </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga9614efd432e0ca9bc408eab08a8bf064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9614efd432e0ca9bc408eab08a8bf064">&sect;&nbsp;</a></span>DL_FlashCTL_readVerifyFromRAM32WithECCGenerated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a> DL_FlashCTL_readVerifyFromRAM32WithECCGenerated </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies 32-bit data in specified address with hardware generated ECC code, and executes command from RAM. </p>
<p>The READVERIFY command may be used to read a flash location and compare it to data to be verified along with the 8 ECC bits which correspond to the data. This API assumes that hardware generation of the ECC code has NOT been disabled, and so the flash controller will generate the ECC bits.</p>
<p>The command is executed from RAM, and blocks until the command is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Memory address of flash to verify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data source to verify</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided).</p>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the command was successful. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_FAILED</td><td>if command didn't succeed </td></tr>
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_PASSED</td><td>if command was successful </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="gac3858f77a08b8bfb84f23bc827605a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3858f77a08b8bfb84f23bc827605a67">&sect;&nbsp;</a></span>DL_FlashCTL_readVerify64WithECCGenerated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_readVerify64WithECCGenerated </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies 64-bit data in specified address with hardware generated ECC code. </p>
<p>The READVERIFY command may be used to read a flash location and compare it to data to be verified along with the 8 ECC bits which correspond to the data. This API assumes that hardware generation of the ECC code has NOT been disabled, and so the flash controller will generate the ECC bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Memory address of flash to verify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data source to verify</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided). </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="gae26e21cc4860554736d6f96ce341b32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae26e21cc4860554736d6f96ce341b32f">&sect;&nbsp;</a></span>DL_FlashCTL_readVerifyFromRAM64WithECCGenerated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a> DL_FlashCTL_readVerifyFromRAM64WithECCGenerated </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies 32-bit data in specified address with hardware generated ECC code, and executes command from RAM. </p>
<p>The READVERIFY command may be used to read a flash location and compare it to data to be verified along with the 8 ECC bits which correspond to the data. This API assumes that hardware generation of the ECC code has NOT been disabled, and so the flash controller will generate the ECC bits.</p>
<p>The command is executed from RAM, and blocks until the command is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Memory address of flash to verify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data source to verify</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided).</p>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the command was successful. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_FAILED</td><td>if command didn't succeed </td></tr>
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_PASSED</td><td>if command was successful </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga8156f3b7ccca7e41976d38f1d3b732dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8156f3b7ccca7e41976d38f1d3b732dd">&sect;&nbsp;</a></span>DL_FlashCTL_readVerify8WithECCManual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_readVerify8WithECCManual </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>eccCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies 8-bit data in specified address with user provided ECC code. </p>
<p>The READVERIFY command may be used to read a flash location and compare it to data to be verified along with the 8 ECC bits which correspond to the data. This API assumes that hardware generation of the ECC code HAS been disabled, so the user must provide the ECC code to program.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Memory address of flash to verify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data source to verify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eccCode</td><td>Pointer to ECC code to program corresponding to data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>User must call <a class="el" href="group___f_l_a_s_h_c_t_l.html#gacf328d7e267b95496ff4e0d7b37e831a">DL_FlashCTL_enableOverrideHardwareGeneratedECC</a> to disable hardware generation of the ECC code, so the ECC code can be manually provided for programming. This override setting will persist through multiple programs, until <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga425a9da6de8a129833b47834093f34fb">DL_FlashCTL_disableOverrideHardwareGeneratedECC</a> is called</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided). </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga0b8b8ec1471b11dd1753d5908bc8d673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b8b8ec1471b11dd1753d5908bc8d673">&sect;&nbsp;</a></span>DL_FlashCTL_readVerifyFromRAM8WithECCManual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a> DL_FlashCTL_readVerifyFromRAM8WithECCManual </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>eccCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies 8-bit data in specified address with user provided ECC code, and executes command from RAM. </p>
<p>The READVERIFY command may be used to read a flash location and compare it to data to be verified along with the 8 ECC bits which correspond to the data. This API assumes that hardware generation of the ECC code HAS been disabled, so the user must provide the ECC code to program.</p>
<p>The command is executed from RAM, and blocks until the command is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Memory address of flash to verify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data source to verify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eccCode</td><td>Pointer to ECC code to program corresponding to data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>User must call <a class="el" href="group___f_l_a_s_h_c_t_l.html#gacf328d7e267b95496ff4e0d7b37e831a">DL_FlashCTL_enableOverrideHardwareGeneratedECC</a> to disable hardware generation of the ECC code, so the ECC code can be manually provided for programming. This override setting will persist through multiple programs, until <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga425a9da6de8a129833b47834093f34fb">DL_FlashCTL_disableOverrideHardwareGeneratedECC</a> is called</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided).</p>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the command was successful. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_FAILED</td><td>if command didn't succeed </td></tr>
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_PASSED</td><td>if command was successful </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="gaa8fd46e653b358bc86f08fd84105b914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8fd46e653b358bc86f08fd84105b914">&sect;&nbsp;</a></span>DL_FlashCTL_readVerify16WithECCManual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_readVerify16WithECCManual </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>eccCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies 16-bit data in specified address with user provided ECC code. </p>
<p>The READVERIFY command may be used to read a flash location and compare it to data to be verified along with the 8 ECC bits which correspond to the data. This API assumes that hardware generation of the ECC code HAS been disabled, so the user must provide the ECC code to program.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Memory address of flash to verify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data source to verify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eccCode</td><td>Pointer to ECC code to program corresponding to data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>User must call <a class="el" href="group___f_l_a_s_h_c_t_l.html#gacf328d7e267b95496ff4e0d7b37e831a">DL_FlashCTL_enableOverrideHardwareGeneratedECC</a> to disable hardware generation of the ECC code, so the ECC code can be manually provided for programming. This override setting will persist through multiple programs, until <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga425a9da6de8a129833b47834093f34fb">DL_FlashCTL_disableOverrideHardwareGeneratedECC</a> is called</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided). </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga173111fb0ec1809fa9ec2d3968aa2a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga173111fb0ec1809fa9ec2d3968aa2a6b">&sect;&nbsp;</a></span>DL_FlashCTL_readVerifyFromRAM16WithECCManual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a> DL_FlashCTL_readVerifyFromRAM16WithECCManual </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>eccCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies 16-bit data in specified address with user provided ECC code, and executes command from RAM. </p>
<p>The READVERIFY command may be used to read a flash location and compare it to data to be verified along with the 8 ECC bits which correspond to the data. This API assumes that hardware generation of the ECC code HAS been disabled, so the user must provide the ECC code to program.</p>
<p>The command is executed from RAM, and blocks until the command is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Memory address of flash to verify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data source to verify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eccCode</td><td>Pointer to ECC code to program corresponding to data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>User must call <a class="el" href="group___f_l_a_s_h_c_t_l.html#gacf328d7e267b95496ff4e0d7b37e831a">DL_FlashCTL_enableOverrideHardwareGeneratedECC</a> to disable hardware generation of the ECC code, so the ECC code can be manually provided for programming. This override setting will persist through multiple programs, until <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga425a9da6de8a129833b47834093f34fb">DL_FlashCTL_disableOverrideHardwareGeneratedECC</a> is called</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided).</p>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the command was successful. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_FAILED</td><td>if command didn't succeed </td></tr>
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_PASSED</td><td>if command was successful </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga6cdbdde8412bbf4210700c2a7df69c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cdbdde8412bbf4210700c2a7df69c21">&sect;&nbsp;</a></span>DL_FlashCTL_readVerify32WithECCManual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_readVerify32WithECCManual </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>eccCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies 32-bit data in specified address with user provided ECC code. </p>
<p>The READVERIFY command may be used to read a flash location and compare it to data to be verified along with the 8 ECC bits which correspond to the data. This API assumes that hardware generation of the ECC code HAS been disabled, so the user must provide the ECC code to program.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Memory address of flash to verify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data source to verify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eccCode</td><td>Pointer to ECC code to program corresponding to data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>User must call <a class="el" href="group___f_l_a_s_h_c_t_l.html#gacf328d7e267b95496ff4e0d7b37e831a">DL_FlashCTL_enableOverrideHardwareGeneratedECC</a> to disable hardware generation of the ECC code, so the ECC code can be manually provided for programming. This override setting will persist through multiple programs, until <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga425a9da6de8a129833b47834093f34fb">DL_FlashCTL_disableOverrideHardwareGeneratedECC</a> is called</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided). </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="gab364e11206b2601873e683bc866e6150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab364e11206b2601873e683bc866e6150">&sect;&nbsp;</a></span>DL_FlashCTL_readVerifyFromRAM32WithECCManual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a> DL_FlashCTL_readVerifyFromRAM32WithECCManual </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>eccCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies 32-bit data in specified address with user provided ECC code, and executes command from RAM. </p>
<p>The READVERIFY command may be used to read a flash location and compare it to data to be verified along with the 8 ECC bits which correspond to the data. This API assumes that hardware generation of the ECC code HAS been disabled, so the user must provide the ECC code to program.</p>
<p>The command is executed from RAM, and blocks until the command is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Memory address of flash to verify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data source to verify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eccCode</td><td>Pointer to ECC code to program corresponding to data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>User must call <a class="el" href="group___f_l_a_s_h_c_t_l.html#gacf328d7e267b95496ff4e0d7b37e831a">DL_FlashCTL_enableOverrideHardwareGeneratedECC</a> to disable hardware generation of the ECC code, so the ECC code can be manually provided for programming. This override setting will persist through multiple programs, until <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga425a9da6de8a129833b47834093f34fb">DL_FlashCTL_disableOverrideHardwareGeneratedECC</a> is called</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided).</p>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the command was successful. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_FAILED</td><td>if command didn't succeed </td></tr>
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_PASSED</td><td>if command was successful </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="gaec0a8b00d03c4f25f00cbda948c35018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec0a8b00d03c4f25f00cbda948c35018">&sect;&nbsp;</a></span>DL_FlashCTL_readVerify64WithECCManual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_readVerify64WithECCManual </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>eccCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies 64-bit data in specified address with user provided ECC code. </p>
<p>The READVERIFY command may be used to read a flash location and compare it to data to be verified along with the 8 ECC bits which correspond to the data. This API assumes that hardware generation of the ECC code HAS been disabled, so the user must provide the ECC code to program.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Memory address of flash to verify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data source to verify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eccCode</td><td>Pointer to ECC code to program corresponding to data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>User must call <a class="el" href="group___f_l_a_s_h_c_t_l.html#gacf328d7e267b95496ff4e0d7b37e831a">DL_FlashCTL_enableOverrideHardwareGeneratedECC</a> to disable hardware generation of the ECC code, so the ECC code can be manually provided for programming. This override setting will persist through multiple programs, until <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga425a9da6de8a129833b47834093f34fb">DL_FlashCTL_disableOverrideHardwareGeneratedECC</a> is called</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided). </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga3324d5cc56c79da12792dec45e0ef96d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3324d5cc56c79da12792dec45e0ef96d">&sect;&nbsp;</a></span>DL_FlashCTL_readVerifyFromRAM64WithECCManual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a> DL_FlashCTL_readVerifyFromRAM64WithECCManual </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>eccCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies 64-bit data in specified address with user provided ECC code, and executes command from RAM. </p>
<p>The READVERIFY command may be used to read a flash location and compare it to data to be verified along with the 8 ECC bits which correspond to the data. This API assumes that hardware generation of the ECC code HAS been disabled, so the user must provide the ECC code to program.</p>
<p>The command is executed from RAM, and blocks until the command is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Memory address of flash to verify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data source to verify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eccCode</td><td>Pointer to ECC code to program corresponding to data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>User must call <a class="el" href="group___f_l_a_s_h_c_t_l.html#gacf328d7e267b95496ff4e0d7b37e831a">DL_FlashCTL_enableOverrideHardwareGeneratedECC</a> to disable hardware generation of the ECC code, so the ECC code can be manually provided for programming. This override setting will persist through multiple programs, until <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga425a9da6de8a129833b47834093f34fb">DL_FlashCTL_disableOverrideHardwareGeneratedECC</a> is called</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided).</p>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the command was successful. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_FAILED</td><td>if command didn't succeed </td></tr>
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_PASSED</td><td>if command was successful </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga7efeda684bcd5d2e0e3b908f3ea47774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7efeda684bcd5d2e0e3b908f3ea47774">&sect;&nbsp;</a></span>DL_FlashCTL_blankVerify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_blankVerify </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies that a flash word is blank. </p>
<p>A blank flash word is defined as a flash word which has been successfully erased with the ERASE command and not yet programmed away from that non-erased state with the PROGRAM command. The BLANKVERIFY command may be used to test if a flash word is in a blank state, indicating it has not yet been programmed away from an erased state. The BLANKVERIFY command may only be applied to a single flash word at a time.</p>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the command process. Check if the command completed execution using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API. </dd>
<dd>
<a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5909153bc16bfa44a51bab33a82262c3">DL_FlashCTL_getFailureStatus</a> should be called to determine the result of the BLANKVERIFY command. The <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5909153bc16bfa44a51bab33a82262c3">DL_FlashCTL_getFailureStatus</a> API will return <a class="el" href="group___f_l_a_s_h_c_t_l.html#gga148c247b2058dd33c0dba6912fe5786dad7b8a08caa79cf5b5efed26bfd9017a7">DL_FLASHCTL_FAIL_TYPE_VERIFY_ERROR</a> if the flash location has not been erased, and return <a class="el" href="group___f_l_a_s_h_c_t_l.html#gga148c247b2058dd33c0dba6912fe5786da7bcfa6d4196d07b0067781185e554222">DL_FLASHCTL_FAIL_TYPE_NO_FAILURE</a> if the flash location is blank.</dd></dl>
<p>NOTE: After this command is executed, the flash controller will configure all memory to a protected state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Memory address of flash to verify </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga6228a63118743a5bdfdd1e743fbca011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6228a63118743a5bdfdd1e743fbca011">&sect;&nbsp;</a></span>DL_FlashCTL_blankVerifyFromRAM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a> DL_FlashCTL_blankVerifyFromRAM </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies that a flash word is blank, and executes command from RAM. </p>
<p>A blank flash word is defined as a flash word which has been successfully erased with the ERASE command and not yet programmed away from that non-erased state with the PROGRAM command. The BLANKVERIFY command may be used to test if a flash word is in a blank state, indicating it has not yet been programmed away from an erased state. The BLANKVERIFY command may only be applied to a single flash word at a time.</p>
<p>The command is executed from RAM, and blocks until the command is finished.</p>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the command process. Check if the command completed execution using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API. </dd>
<dd>
<a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5909153bc16bfa44a51bab33a82262c3">DL_FlashCTL_getFailureStatus</a> should be called to determine the result of the BLANKVERIFY command. The <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5909153bc16bfa44a51bab33a82262c3">DL_FlashCTL_getFailureStatus</a> API will return <a class="el" href="group___f_l_a_s_h_c_t_l.html#gga148c247b2058dd33c0dba6912fe5786dad7b8a08caa79cf5b5efed26bfd9017a7">DL_FLASHCTL_FAIL_TYPE_VERIFY_ERROR</a> if the flash location has not been erased, and return <a class="el" href="group___f_l_a_s_h_c_t_l.html#gga148c247b2058dd33c0dba6912fe5786da7bcfa6d4196d07b0067781185e554222">DL_FLASHCTL_FAIL_TYPE_NO_FAILURE</a> if the flash location is blank.</dd></dl>
<p>NOTE: After this command is executed, the flash controller will configure all memory to a protected state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Memory address of flash to verify</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the command was successful. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_FAILED</td><td>if command didn't succeed </td></tr>
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_PASSED</td><td>if command was successful </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga858f486d680a6870e43c646b211b4a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga858f486d680a6870e43c646b211b4a3b">&sect;&nbsp;</a></span>DL_FlashCTL_programMemory128()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_programMemory128 </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs 128 bit data to unprotected memory at the given address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Destination memory address to program data. The address must be flash word (64-bit) aligned i.e. aligned to a 0b000 boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the 32-bit source data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Before programming memory, the user must unprotect the region of memory to program. Refer to <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaff740a4d3903a5813bdcf631e24389cb">DL_FlashCTL_unprotectSector</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the program process. Check the result of it using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. NOTE: This API does not enable programming the ECC code. </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga004279c27149448c253b2bc562f4024c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga004279c27149448c253b2bc562f4024c">&sect;&nbsp;</a></span>DL_FlashCTL_programMemory128WithECCGenerated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_programMemory128WithECCGenerated </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs 128 bit data with hardware generated ECC code. </p>
<p>Programs 128 bit data, along with the 16 ECC bits which correspond to the 128-bit data word, to unprotected memory at the given address. This API assumes that hardware generation of the ECC code has NOT been disabled, and so the flash controller will generate the ECC bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Destination memory address to program data. The address must be flash word (64-bit) aligned i.e. aligned to a 0b000 boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the 32-bit source data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Before programming memory, the user must unprotect the region of memory to program. Refer to <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaff740a4d3903a5813bdcf631e24389cb">DL_FlashCTL_unprotectSector</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the program process. Check the result of it using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided). </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga52a86bd0757db1edbe4a6407c077b77b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52a86bd0757db1edbe4a6407c077b77b">&sect;&nbsp;</a></span>DL_FlashCTL_programMemory128WithECCManual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DL_FlashCTL_programMemory128WithECCManual </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>eccCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs 128 bit data with hardware generated ECC code. </p>
<p>Programs 128 bit data, along with the 16 ECC bits which correspond to the 128-bit data word, to unprotected memory at the given address. This API assumes that hardware generation of the ECC code has NOT been disabled, and so the flash controller will generate the ECC bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Destination memory address to program data. The address must be flash word (64-bit) aligned i.e. aligned to a 0b000 boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the 32-bit source data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Before programming memory, the user must unprotect the region of memory to program. Refer to <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaff740a4d3903a5813bdcf631e24389cb">DL_FlashCTL_unprotectSector</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the program process. Check the result of it using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided). Programs 128 bit data with user provided ECC code</p>
<p>Programs 128 bit data, along with the 16 ECC bits which correspond to the 128-bit data word, to unprotected memory at the given address. This API assumes that hardware generation of the ECC code HAS been disabled, and so the user must provide the ECC code to program.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Destination memory address to program data. The address must be flash word (64-bit) aligned i.e. aligned to a 0b000 boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the 32-bit source data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eccCode</td><td>Pointer to the ECC code to program</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>User must call <a class="el" href="group___f_l_a_s_h_c_t_l.html#gacf328d7e267b95496ff4e0d7b37e831a">DL_FlashCTL_enableOverrideHardwareGeneratedECC</a> to disable hardware generation of the ECC code, so the ECC code can be manually provided for programming. This override setting will persist through multiple programs, until <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga425a9da6de8a129833b47834093f34fb">DL_FlashCTL_disableOverrideHardwareGeneratedECC</a> is called </dd>
<dd>
Before programming memory, the user must unprotect the region of memory to program. Refer to <a class="el" href="group___f_l_a_s_h_c_t_l.html#gaff740a4d3903a5813bdcf631e24389cb">DL_FlashCTL_unprotectSector</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>This API just starts the program process. Check the result of it using an interrupt or the <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga5261cbd42cb4a724bc1dc1543cd24631">DL_FlashCTL_waitForCmdDone</a> API</dd></dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. NOTE: After completion of a program operation, the flash controller will disable programming of the ECC code (regardless of whether ECC code is hardware generated or manually provided). </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="gaec5d51f9e035e2846289fd948e267cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec5d51f9e035e2846289fd948e267cfe">&sect;&nbsp;</a></span>DL_FlashCTL_programMemoryBlocking128WithECCGenerated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DL_FlashCTL_programMemoryBlocking128WithECCGenerated </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h_c_t_l.html#gad8b5345481dd655cbd20dadc84e7621b">DL_FLASHCTL_REGION_SELECT</a>&#160;</td>
          <td class="paramname"><em>regionSelect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs provided data up to 128-bits with ECC generated while blocking between writes. </p>
<p>Blocking function that programs a set of data using multi-word programming for up to 2 flash words. Refer to the device datasheet if the device supports multi-word programming. When possible, the data will be programmed as either 64-bit data or as 32-bit data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Destination memory address to program data. The address must be flash word (64-bit) aligned i.e. aligned to a 0b000 boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataSize</td><td>The number of 32-bit words to program </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data source to program into flash </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regionSelect</td><td>The region of memory to erase. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#gad8b5345481dd655cbd20dadc84e7621b">DL_FLASHCTL_REGION_SELECT</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the program succeeded</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Program didn't succeed </td></tr>
    <tr><td class="paramname">true</td><td>Program was successful</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: After completion of a program operation, the flash controller will configure all memory to a protected state. NOTE: This API does not enable programming the ECC code. </p>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="ga0d8baaa47934cdb852dcfcd0a1645d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d8baaa47934cdb852dcfcd0a1645d90">&sect;&nbsp;</a></span>DL_FlashCTL_eraseDataBank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DL_FlashCTL_eraseDataBank </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs an erase on DATA bank. </p>
<p>Performs an erase on DATA bank only. This API should be used on devices with a DATA bank. To determine if device has DATA bank use <a class="el" href="group___f_a_c_t_o_r_y_r_e_g_i_o_n.html#gaf4b4c1374ce1ecd5ca82d58967d74cd1">DL_FactoryRegion_getDATAFlashSize</a> API.</p>
<p>NOTE: This API erases all of DATA bank</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the erase succeeded</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>If erase didn't succeed </td></tr>
    <tr><td class="paramname">true</td><td>If erase was successful </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
<a id="gad6a81dc3536f56ce1a552f2102fca181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6a81dc3536f56ce1a552f2102fca181">&sect;&nbsp;</a></span>DL_FlashCTL_eraseDataBankFromRAM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a> DL_FlashCTL_eraseDataBankFromRAM </td>
          <td>(</td>
          <td class="paramtype">FLASHCTL_Regs *&#160;</td>
          <td class="paramname"><em>flashctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs an erase on DATA bank, and executes command from RAM. </p>
<p>Performs an erase on DATA bank only. This API should be used on devices with a DATA bank. To determine if device has DATA bank use <a class="el" href="group___f_a_c_t_o_r_y_r_e_g_i_o_n.html#gaf4b4c1374ce1ecd5ca82d58967d74cd1">DL_FactoryRegion_getDATAFlashSize</a> API.</p>
<p>The command is executed from RAM, and blocks until the command is finished.</p>
<p>NOTE: This API erases all of DATA bank</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flashctl</td><td>Pointer to the register overlay for the peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the command was successful. One of <a class="el" href="group___f_l_a_s_h_c_t_l.html#ga81a568bc9c0c10f386e22832683db339">DL_FLASHCTL_COMMAND_STATUS</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_FAILED</td><td>if command didn't succeed </td></tr>
    <tr><td class="paramname">DL_FLASHCTL_COMMAND_STATUS_PASSED</td><td>if command was successful </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___f_l_a_s_h_c_t_l.html#gafc7476e6bbc482257af980476a9316d6">DL_FlashCTL_getWaitState()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">© Copyright 1995-2025</a>, Texas Instruments Incorporated. All rights reserved. <br/>
  <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
