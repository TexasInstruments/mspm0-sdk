<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>MSPM0L111X TI-Driver Library: Inter-Integrated Circuit (I2C)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MSPM0L111X TI-Driver Library
   &#160;<span id="projectnumber">2.05.01.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Inter-Integrated Circuit (I2C)</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Inter-Integrated Circuit (I2C):</div>
<div class="dyncontent">
<center><table><tr><td><img src="group___i2_c.png" border="0" alt="" usemap="#group______i2__c"/>
<map name="group______i2__c" id="group______i2__c">
<area shape="rect" id="node1" href="group___i2_c_m_s_p_m0.html" title="I2C driver APIs" alt="" coords="261,5,378,32"/>
<area shape="rect" id="node3" href="group___i2_c_support.html" title="Common helper functions\l for I2C driver" alt="" coords="224,57,415,98"/>
<area shape="rect" id="node4" href="group___i2_c___s_t_a_t_u_s.html" title="I2C status codes" alt="" coords="255,123,384,149"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group___i2_c___s_t_a_t_u_s"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___s_t_a_t_u_s.html">I2C status codes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___i2_c_m_s_p_m0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c_m_s_p_m0.html">I2C driver APIs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___i2_c_support"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c_support.html">Common helper functions for I2C driver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i2_c___transaction.html">I2C_Transaction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a transaction to be used with <a class="el" href="group___i2_c.html#gac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C target peripheral. ">I2C_transfer()</a> or <a class="el" href="group___i2_c.html#gaaee4f0689acbe5f0596e35b18402abf3" title="Perform an I2C transaction with an I2C target peripheral. ">I2C_transferTimeout()</a>.  <a href="struct_i2_c___transaction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i2_c___params.html">I2C_Params</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C parameters used with <a class="el" href="group___i2_c.html#ga2db3461e1e956d9b86af414da2fb05f6" title="Open an I2C driver instance. ">I2C_open()</a>.  <a href="struct_i2_c___params.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i2_c___config__.html">I2C_Config_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C driver's configuration structure.  <a href="struct_i2_c___config__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga4eb2bf76d4186e8752bcd32b32908b6c"><td class="memItemLeft" align="right" valign="top"><a id="ga4eb2bf76d4186e8752bcd32b32908b6c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga4eb2bf76d4186e8752bcd32b32908b6c">I2C_WAIT_FOREVER</a>&#160;&#160;&#160;(~(0U))</td></tr>
<tr class="memdesc:ga4eb2bf76d4186e8752bcd32b32908b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait forever define used to specify timeouts. <br /></td></tr>
<tr class="separator:ga4eb2bf76d4186e8752bcd32b32908b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga1d8718f847129c7aa61dd1c264d8a13c"><td class="memItemLeft" align="right" valign="top"><a id="ga1d8718f847129c7aa61dd1c264d8a13c"></a>
typedef struct <a class="el" href="struct_i2_c___config__.html">I2C_Config_</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a></td></tr>
<tr class="memdesc:ga1d8718f847129c7aa61dd1c264d8a13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle that is returned from an <a class="el" href="group___i2_c.html#ga2db3461e1e956d9b86af414da2fb05f6" title="Open an I2C driver instance. ">I2C_open()</a> call. <br /></td></tr>
<tr class="separator:ga1d8718f847129c7aa61dd1c264d8a13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaa5c99b7c23a00bac52d15a2469764e"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gadaa5c99b7c23a00bac52d15a2469764e">I2C_CallbackFxn</a>) (<a class="el" href="group___i2_c.html#ga1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a> handle, <a class="el" href="struct_i2_c___transaction.html">I2C_Transaction</a> *transaction, bool transferStatus)</td></tr>
<tr class="memdesc:gadaa5c99b7c23a00bac52d15a2469764e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a callback function.  <a href="#gadaa5c99b7c23a00bac52d15a2469764e">More...</a><br /></td></tr>
<tr class="separator:gadaa5c99b7c23a00bac52d15a2469764e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae43e4c7b224a8cc37764acb792182453"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_i2_c___config__.html">I2C_Config_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gae43e4c7b224a8cc37764acb792182453">I2C_Config</a></td></tr>
<tr class="memdesc:gae43e4c7b224a8cc37764acb792182453"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C driver's configuration structure.  <a href="#gae43e4c7b224a8cc37764acb792182453">More...</a><br /></td></tr>
<tr class="separator:gae43e4c7b224a8cc37764acb792182453"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga39f3b9340fc4ee241b0d2da9b2841c26"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga39f3b9340fc4ee241b0d2da9b2841c26">I2C_TransferMode</a> { <br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga39f3b9340fc4ee241b0d2da9b2841c26abe065350be2a0ae5c9beb24624626c75">I2C_MODE_BLOCKING</a>, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga39f3b9340fc4ee241b0d2da9b2841c26a129731a7edeb285f43a54b2cf9f5ac72">I2C_MODE_CALLBACK</a>
<br />
 }<tr class="memdesc:ga39f3b9340fc4ee241b0d2da9b2841c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return behavior of I2C_Transfer() specified in the <a class="el" href="struct_i2_c___params.html" title="I2C parameters used with I2C_open(). ">I2C_Params</a>.  <a href="group___i2_c.html#ga39f3b9340fc4ee241b0d2da9b2841c26">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga39f3b9340fc4ee241b0d2da9b2841c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac954e3197f04c50293db466c4abb6fbe"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gac954e3197f04c50293db466c4abb6fbe">I2C_BitRate</a> { <br />
&#160;&#160;<a class="el" href="group___i2_c.html#ggac954e3197f04c50293db466c4abb6fbea966fd2df13b3a9825615c50335cf1987">I2C_100kHz</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#ggac954e3197f04c50293db466c4abb6fbea83cc3750242e6ae9194cd7ed94f764d9">I2C_400kHz</a> = 1, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#ggac954e3197f04c50293db466c4abb6fbea38a2e32ba65eb0f67b928d181242befa">I2C_1000kHz</a> = 2
<br />
 }<tr class="memdesc:gac954e3197f04c50293db466c4abb6fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit rate for an I2C driver instance specified in the <a class="el" href="struct_i2_c___params.html" title="I2C parameters used with I2C_open(). ">I2C_Params</a>.  <a href="group___i2_c.html#gac954e3197f04c50293db466c4abb6fbe">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gac954e3197f04c50293db466c4abb6fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8cad0c04a9eca0fffc0ffe5586a5179b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga8cad0c04a9eca0fffc0ffe5586a5179b">I2C_cancel</a> (<a class="el" href="group___i2_c.html#ga1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a> handle)</td></tr>
<tr class="memdesc:ga8cad0c04a9eca0fffc0ffe5586a5179b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancels all I2C transfers.  <a href="#ga8cad0c04a9eca0fffc0ffe5586a5179b">More...</a><br /></td></tr>
<tr class="separator:ga8cad0c04a9eca0fffc0ffe5586a5179b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12c86d89a687f2ee1eb980d99c32326d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga12c86d89a687f2ee1eb980d99c32326d">I2C_close</a> (<a class="el" href="group___i2_c.html#ga1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a> handle)</td></tr>
<tr class="memdesc:ga12c86d89a687f2ee1eb980d99c32326d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to close an I2C driver instance.  <a href="#ga12c86d89a687f2ee1eb980d99c32326d">More...</a><br /></td></tr>
<tr class="separator:ga12c86d89a687f2ee1eb980d99c32326d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c74b1b9f8e76ac22bec7608491cb223"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga4c74b1b9f8e76ac22bec7608491cb223">I2C_control</a> (<a class="el" href="group___i2_c.html#ga1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a> handle, uint_fast16_t cmd, void *controlArg)</td></tr>
<tr class="memdesc:ga4c74b1b9f8e76ac22bec7608491cb223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function performs implementation specific features on a driver instance.  <a href="#ga4c74b1b9f8e76ac22bec7608491cb223">More...</a><br /></td></tr>
<tr class="separator:ga4c74b1b9f8e76ac22bec7608491cb223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ff51ddf1d325776fef90cce0223772b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga9ff51ddf1d325776fef90cce0223772b">I2C_init</a> (void)</td></tr>
<tr class="memdesc:ga9ff51ddf1d325776fef90cce0223772b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize the I2C driver.  <a href="#ga9ff51ddf1d325776fef90cce0223772b">More...</a><br /></td></tr>
<tr class="separator:ga9ff51ddf1d325776fef90cce0223772b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2db3461e1e956d9b86af414da2fb05f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___i2_c.html#ga1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga2db3461e1e956d9b86af414da2fb05f6">I2C_open</a> (uint_least8_t index, <a class="el" href="struct_i2_c___params.html">I2C_Params</a> *params)</td></tr>
<tr class="memdesc:ga2db3461e1e956d9b86af414da2fb05f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open an I2C driver instance.  <a href="#ga2db3461e1e956d9b86af414da2fb05f6">More...</a><br /></td></tr>
<tr class="separator:ga2db3461e1e956d9b86af414da2fb05f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab11636302074d67180207ab81ceb323c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gab11636302074d67180207ab81ceb323c">I2C_Params_init</a> (<a class="el" href="struct_i2_c___params.html">I2C_Params</a> *params)</td></tr>
<tr class="memdesc:gab11636302074d67180207ab81ceb323c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an <a class="el" href="struct_i2_c___params.html" title="I2C parameters used with I2C_open(). ">I2C_Params</a> structure to its default values.  <a href="#gab11636302074d67180207ab81ceb323c">More...</a><br /></td></tr>
<tr class="separator:gab11636302074d67180207ab81ceb323c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga999fa1c606163ca9bbb4252a27c8eb9d"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga999fa1c606163ca9bbb4252a27c8eb9d">I2C_setClockTimeout</a> (<a class="el" href="group___i2_c.html#ga1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a> handle, uint32_t timeout)</td></tr>
<tr class="memdesc:ga999fa1c606163ca9bbb4252a27c8eb9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the I2C SCL clock timeout.  <a href="#ga999fa1c606163ca9bbb4252a27c8eb9d">More...</a><br /></td></tr>
<tr class="separator:ga999fa1c606163ca9bbb4252a27c8eb9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5d827b67fe77d7d179026941cc069d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gac5d827b67fe77d7d179026941cc069d7">I2C_transfer</a> (<a class="el" href="group___i2_c.html#ga1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a> handle, <a class="el" href="struct_i2_c___transaction.html">I2C_Transaction</a> *transaction)</td></tr>
<tr class="memdesc:gac5d827b67fe77d7d179026941cc069d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an I2C transaction with an I2C target peripheral.  <a href="#gac5d827b67fe77d7d179026941cc069d7">More...</a><br /></td></tr>
<tr class="separator:gac5d827b67fe77d7d179026941cc069d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaee4f0689acbe5f0596e35b18402abf3"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaaee4f0689acbe5f0596e35b18402abf3">I2C_transferTimeout</a> (<a class="el" href="group___i2_c.html#ga1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a> handle, <a class="el" href="struct_i2_c___transaction.html">I2C_Transaction</a> *transaction, uint32_t timeout)</td></tr>
<tr class="memdesc:gaaee4f0689acbe5f0596e35b18402abf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an I2C transaction with an I2C target peripheral.  <a href="#gaaee4f0689acbe5f0596e35b18402abf3">More...</a><br /></td></tr>
<tr class="separator:gaaee4f0689acbe5f0596e35b18402abf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gaff23dd4a23f45b3bf8b634c56c272ebc"><td class="memItemLeft" align="right" valign="top"><a id="gaff23dd4a23f45b3bf8b634c56c272ebc"></a>
const <a class="el" href="group___i2_c.html#gae43e4c7b224a8cc37764acb792182453">I2C_Config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaff23dd4a23f45b3bf8b634c56c272ebc">I2C_config</a> []</td></tr>
<tr class="memdesc:gaff23dd4a23f45b3bf8b634c56c272ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instance of I2C driver's configuration structure. <br /></td></tr>
<tr class="separator:gaff23dd4a23f45b3bf8b634c56c272ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f7b47492e348b701dc5add470d898e8"><td class="memItemLeft" align="right" valign="top"><a id="ga2f7b47492e348b701dc5add470d898e8"></a>
const uint_least8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga2f7b47492e348b701dc5add470d898e8">I2C_count</a></td></tr>
<tr class="memdesc:ga2f7b47492e348b701dc5add470d898e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of I2C instance. <br /></td></tr>
<tr class="separator:ga2f7b47492e348b701dc5add470d898e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The I2C header file should be included in an application as follows: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_i2_c_8h.html">ti/drivers/I2C.h</a>&gt;</span></div></div><!-- fragment --><p><a class="anchor" id="ti_drivers_I2C_Overview"></a></p><h1>Overview</h1>
<p>The I2C driver is designed to operate as an I2C controller and will not function as an I2C target. Multi-controller arbitration is not supported; therefore, this driver assumes it is the only I2C controller on the bus. This I2C driver's API set provides the ability to transmit and receive data over an I2C bus between the I2C controller and I2C target(s). The application is responsible for manipulating and interpreting the data.</p>
<hr/>
<p> <a class="anchor" id="ti_drivers_I2C_Usage"></a></p><h1>Usage</h1>
<p>This section provides a basic <a class="el" href="group___i2_c.html#ti_drivers_I2C_Synopsis">usage summary</a> and a set of <a class="el" href="group___i2_c.html#ti_drivers_I2C_Examples">examples</a> in the form of commented code fragments. Detailed descriptions of the I2C APIs and their effect are provided in subsequent sections.</p>
<p><a class="anchor" id="ti_drivers_I2C_Synopsis"></a></p><h2>Synopsis</h2>
<p><a class="anchor" id="ti_drivers_I2C_Synopsis_Code"></a></p><div class="fragment"><div class="line"><span class="comment">// Import I2C Driver definitions.</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_i2_c_8h.html">ti/drivers/I2C.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Define name for an index of an I2C bus.</span></div><div class="line"><span class="preprocessor">#define SENSORS 0</span></div><div class="line"></div><div class="line"><span class="comment">// Define the target address of device on the SENSORS bus.</span></div><div class="line"><span class="preprocessor">#define OPT_ADDR 0x48</span></div><div class="line"></div><div class="line"><span class="comment">// One-time init of I2C driver.</span></div><div class="line"><a class="code" href="group___i2_c.html#ga9ff51ddf1d325776fef90cce0223772b">I2C_init</a>();</div><div class="line"></div><div class="line"><span class="comment">// initialize optional I2C bus parameters.</span></div><div class="line"><a class="code" href="struct_i2_c___params.html">I2C_Params</a> params;</div><div class="line"><a class="code" href="group___i2_c.html#gab11636302074d67180207ab81ceb323c">I2C_Params_init</a>(&amp;params);</div><div class="line">params.<a class="code" href="struct_i2_c___params.html#ad31857f6dbedb77c60c92cc8cd8cde0c">bitRate</a> = <a class="code" href="group___i2_c.html#ggac954e3197f04c50293db466c4abb6fbea966fd2df13b3a9825615c50335cf1987">I2C_100kHz</a>;</div><div class="line"></div><div class="line"><span class="comment">// Open I2C bus for usage.</span></div><div class="line"><a class="code" href="struct_i2_c___config__.html">I2C_Handle</a> i2cHandle = <a class="code" href="group___i2_c.html#ga2db3461e1e956d9b86af414da2fb05f6">I2C_open</a>(SENSORS, &amp;params);</div><div class="line"></div><div class="line"><span class="comment">// Initialize target address of transaction.</span></div><div class="line"><a class="code" href="struct_i2_c___transaction.html">I2C_Transaction</a> transaction = {0};</div><div class="line">transaction.<a class="code" href="struct_i2_c___transaction.html#a951cf16485f3cced8dfe0adb387bd118">targetAddress</a> = OPT_ADDR;</div><div class="line"></div><div class="line"><span class="comment">// Read from I2C target device.</span></div><div class="line">transaction.<a class="code" href="struct_i2_c___transaction.html#a804b918d5cb08bb75a39866d0b89e01e">readBuf</a> = data;</div><div class="line">transaction.<a class="code" href="struct_i2_c___transaction.html#a2085d4c943f0d8617365b7c427e6a0de">readCount</a> = <span class="keyword">sizeof</span>(data);</div><div class="line">transaction.<a class="code" href="struct_i2_c___transaction.html#a08959a9f098163d02d6002e73b3a4606">writeCount</a> = 0;</div><div class="line"><a class="code" href="group___i2_c.html#gac5d827b67fe77d7d179026941cc069d7">I2C_transfer</a>(i2cHandle, &amp;transaction);</div><div class="line"></div><div class="line"><span class="comment">// Write to I2C target device.</span></div><div class="line">transaction.<a class="code" href="struct_i2_c___transaction.html#aa3490c2af4b443a7a4ec13f57aec6d20">writeBuf</a> = command;</div><div class="line">transaction.<a class="code" href="struct_i2_c___transaction.html#a08959a9f098163d02d6002e73b3a4606">writeCount</a> = <span class="keyword">sizeof</span>(command);</div><div class="line">transaction.<a class="code" href="struct_i2_c___transaction.html#a2085d4c943f0d8617365b7c427e6a0de">readCount</a> = 0;</div><div class="line"><a class="code" href="group___i2_c.html#gaaee4f0689acbe5f0596e35b18402abf3">I2C_transferTimeout</a>(i2cHandle, &amp;transaction, 5000);</div><div class="line"></div><div class="line"><span class="comment">// Close I2C.</span></div><div class="line"><a class="code" href="group___i2_c.html#ga12c86d89a687f2ee1eb980d99c32326d">I2C_close</a>(i2cHandle);</div></div><!-- fragment --><p><a class="anchor" id="ti_drivers_I2C_Examples"></a></p><h2>Examples</h2>
<ul>
<li><a class="el" href="group___i2_c.html#ti_drivers_I2C_Example_open">Getting an I2C bus handle</a> </li>
<li><a class="el" href="group___i2_c.html#ti_drivers_I2C_Example_write3bytes">Sending 3 bytes</a> </li>
<li><a class="el" href="group___i2_c.html#ti_drivers_I2C_Example_read5bytes">Reading 5 bytes</a> </li>
<li><a class="el" href="group___i2_c.html#ti_drivers_I2C_Example_writeread">Writing then reading in a single transaction</a> </li>
<li><a class="el" href="group___i2_c.html#ti_drivers_I2C_Example_callback">Using Callback mode</a></li>
</ul>
<p><a class="anchor" id="ti_drivers_I2C_Example_open"></a></p><h2>Opening the I2C Driver</h2>
<p>After calling <a class="el" href="group___i2_c.html#ga9ff51ddf1d325776fef90cce0223772b" title="Function to initialize the I2C driver. ">I2C_init()</a>, the application can open an I2C instance by calling <a class="el" href="group___i2_c.html#ga2db3461e1e956d9b86af414da2fb05f6" title="Open an I2C driver instance. ">I2C_open()</a>.The following code example opens an I2C instance with default parameters by passing <code>NULL</code> for the <a class="el" href="struct_i2_c___params.html" title="I2C parameters used with I2C_open(). ">I2C_Params</a> argument.</p>
<div class="fragment"><div class="line"><a class="code" href="struct_i2_c___config__.html">I2C_Handle</a> i2cHandle;</div><div class="line"></div><div class="line">i2cHandle = <a class="code" href="group___i2_c.html#ga2db3461e1e956d9b86af414da2fb05f6">I2C_open</a>(0, NULL);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (i2cHandle == NULL) {</div><div class="line">    <span class="comment">// Error opening I2C</span></div><div class="line">    <span class="keywordflow">while</span> (1) {}</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ti_drivers_I2C_Example_write3bytes"></a></p><h2>Sending three bytes of data.</h2>
<div class="fragment"><div class="line"><a class="code" href="struct_i2_c___transaction.html">I2C_Transaction</a> i2cTransaction = {0};</div><div class="line">uint8_t writeBuffer[3];</div><div class="line"></div><div class="line">writeBuffer[0] = 0xAB;</div><div class="line">writeBuffer[1] = 0xCD;</div><div class="line">writeBuffer[2] = 0xEF;</div><div class="line"></div><div class="line">i2cTransaction.<a class="code" href="struct_i2_c___transaction.html#a951cf16485f3cced8dfe0adb387bd118">targetAddress</a> = 0x50;</div><div class="line">i2cTransaction.<a class="code" href="struct_i2_c___transaction.html#aa3490c2af4b443a7a4ec13f57aec6d20">writeBuf</a> = writeBuffer;</div><div class="line">i2cTransaction.<a class="code" href="struct_i2_c___transaction.html#a08959a9f098163d02d6002e73b3a4606">writeCount</a> = 3;</div><div class="line">i2cTransaction.<a class="code" href="struct_i2_c___transaction.html#a804b918d5cb08bb75a39866d0b89e01e">readBuf</a> = NULL;</div><div class="line">i2cTransaction.<a class="code" href="struct_i2_c___transaction.html#a2085d4c943f0d8617365b7c427e6a0de">readCount</a> = 0;</div><div class="line"></div><div class="line">status = <a class="code" href="group___i2_c.html#gac5d827b67fe77d7d179026941cc069d7">I2C_transfer</a>(i2cHandle, &amp;i2cTransaction);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (status == <span class="keyword">false</span>) {</div><div class="line">    <span class="comment">// Unsuccessful I2C transfer</span></div><div class="line">    <span class="keywordflow">if</span> (i2cTransaction.<a class="code" href="struct_i2_c___transaction.html#a911f51c3c6fffcb962b225363fdbbb81">status</a> == <a class="code" href="group___i2_c___s_t_a_t_u_s.html#ga75c95f62df35a6769b69904e6cd90181">I2C_STATUS_ADDR_NACK</a>) {</div><div class="line">        <span class="comment">// I2C target address not acknowledged</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ti_drivers_I2C_Example_read5bytes"></a></p><h2>Reading five bytes of data.</h2>
<div class="fragment"><div class="line"><a class="code" href="struct_i2_c___transaction.html">I2C_Transaction</a> i2cTransaction = {0};</div><div class="line">uint8_t readBuffer[5];</div><div class="line"></div><div class="line">i2cTransaction.<a class="code" href="struct_i2_c___transaction.html#a951cf16485f3cced8dfe0adb387bd118">targetAddress</a> = 0x50;</div><div class="line">i2cTransaction.<a class="code" href="struct_i2_c___transaction.html#aa3490c2af4b443a7a4ec13f57aec6d20">writeBuf</a> = NULL;</div><div class="line">i2cTransaction.<a class="code" href="struct_i2_c___transaction.html#a08959a9f098163d02d6002e73b3a4606">writeCount</a> = 0;</div><div class="line">i2cTransaction.<a class="code" href="struct_i2_c___transaction.html#a804b918d5cb08bb75a39866d0b89e01e">readBuf</a> = readBuffer;</div><div class="line">i2cTransaction.<a class="code" href="struct_i2_c___transaction.html#a2085d4c943f0d8617365b7c427e6a0de">readCount</a> = 5;</div><div class="line"></div><div class="line">status = <a class="code" href="group___i2_c.html#gac5d827b67fe77d7d179026941cc069d7">I2C_transfer</a>(i2cHandle, &amp;i2cTransaction);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (status == <span class="keyword">false</span>) {</div><div class="line">    <span class="keywordflow">if</span> (i2cTransaction.<a class="code" href="struct_i2_c___transaction.html#a911f51c3c6fffcb962b225363fdbbb81">status</a> == <a class="code" href="group___i2_c___s_t_a_t_u_s.html#ga75c95f62df35a6769b69904e6cd90181">I2C_STATUS_ADDR_NACK</a>) {</div><div class="line">        <span class="comment">// I2C target address not acknowledged</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ti_drivers_I2C_Example_writeread"></a></p><h2>Writing two bytes and reading four bytes in a single transaction.</h2>
<div class="fragment"><div class="line"><a class="code" href="struct_i2_c___transaction.html">I2C_Transaction</a> i2cTransaction = {0};</div><div class="line">uint8_t readBuffer[4];</div><div class="line">uint8_t writeBuffer[2];</div><div class="line"></div><div class="line">writeBuffer[0] = 0xAB;</div><div class="line">writeBuffer[1] = 0xCD;</div><div class="line"></div><div class="line">i2cTransaction.<a class="code" href="struct_i2_c___transaction.html#a951cf16485f3cced8dfe0adb387bd118">targetAddress</a> = 0x50;</div><div class="line">i2cTransaction.<a class="code" href="struct_i2_c___transaction.html#aa3490c2af4b443a7a4ec13f57aec6d20">writeBuf</a> = writeBuffer;</div><div class="line">i2cTransaction.<a class="code" href="struct_i2_c___transaction.html#a08959a9f098163d02d6002e73b3a4606">writeCount</a> = 2;</div><div class="line">i2cTransaction.<a class="code" href="struct_i2_c___transaction.html#a804b918d5cb08bb75a39866d0b89e01e">readBuf</a> = readBuffer;</div><div class="line">i2cTransaction.<a class="code" href="struct_i2_c___transaction.html#a2085d4c943f0d8617365b7c427e6a0de">readCount</a> = 4;</div><div class="line"></div><div class="line">status = <a class="code" href="group___i2_c.html#gac5d827b67fe77d7d179026941cc069d7">I2C_transfer</a>(i2cHandle, &amp;i2cTransaction);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (status == <span class="keyword">false</span>) {</div><div class="line">     <span class="keywordflow">if</span> (i2cTransaction-&gt;<a class="code" href="struct_i2_c___transaction.html#a911f51c3c6fffcb962b225363fdbbb81">status</a> == <a class="code" href="group___i2_c___s_t_a_t_u_s.html#ga75c95f62df35a6769b69904e6cd90181">I2C_STATUS_ADDR_NACK</a>) {</div><div class="line">         <span class="comment">// target address not acknowledged</span></div><div class="line">     }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ti_drivers_I2C_Example_callback"></a></p><h2>Using callback mode</h2>
<p>This final example shows usage of <a class="el" href="group___i2_c.html#gga39f3b9340fc4ee241b0d2da9b2841c26a129731a7edeb285f43a54b2cf9f5ac72">I2C_MODE_CALLBACK</a>, with queuing of multiple transactions. Because multiple transactions are simultaneously queued, separate <a class="el" href="struct_i2_c___transaction.html" title="Defines a transaction to be used with I2C_transfer() or I2C_transferTimeout(). ">I2C_Transaction</a> structures must be used. Each <a class="el" href="struct_i2_c___transaction.html" title="Defines a transaction to be used with I2C_transfer() or I2C_transferTimeout(). ">I2C_Transaction</a> will contain a custom application argument of a semaphore handle. The <a class="el" href="struct_i2_c___transaction.html#a29ec65addac2d4ef5d1235c2329e2fc1">I2C_Transaction.arg</a> will point to the semaphore handle. When the callback function is called, the <a class="el" href="struct_i2_c___transaction.html#a29ec65addac2d4ef5d1235c2329e2fc1">I2C_Transaction.arg</a> is checked for <code>NULL</code>. If this value is not <code>NULL</code>, then it can be assumed the <code>arg</code> is pointing to a valid semaphore handle. The semaphore handle is then used to call <code>sem_post()</code>. Hypothetically, this can be used to signal transaction completion to the task(s) that queued the transaction(s).</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> callbackFxn(<a class="code" href="struct_i2_c___config__.html">I2C_Handle</a> handle, <a class="code" href="struct_i2_c___transaction.html">I2C_Transaction</a> *msg, <span class="keywordtype">bool</span> status)</div><div class="line">{</div><div class="line">    <span class="comment">// if transaction failed.</span></div><div class="line">    <span class="keywordflow">if</span> (status == <span class="keyword">false</span>) {</div><div class="line">        <span class="keywordflow">if</span> (msg-&gt;<a class="code" href="struct_i2_c___transaction.html#a911f51c3c6fffcb962b225363fdbbb81">status</a> == <a class="code" href="group___i2_c___s_t_a_t_u_s.html#ga75c95f62df35a6769b69904e6cd90181">I2C_STATUS_ADDR_NACK</a>) {</div><div class="line">            <span class="comment">// target address not acknowledged</span></div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (msg-&gt;<a class="code" href="struct_i2_c___transaction.html#a911f51c3c6fffcb962b225363fdbbb81">status</a> == <a class="code" href="group___i2_c___s_t_a_t_u_s.html#ga2cca884b9720ab2ca750ebfdb8614601">I2C_STATUS_CANCEL</a>) {</div><div class="line">            <span class="comment">// transaction canceled by I2C_cancel()</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Check for a custom argument.</span></div><div class="line">    <span class="keywordflow">if</span> (msg-&gt;<a class="code" href="struct_i2_c___transaction.html#a29ec65addac2d4ef5d1235c2329e2fc1">arg</a> != NULL) {</div><div class="line"></div><div class="line">        <span class="comment">// In this example, the custom argument is a semaphore handle.</span></div><div class="line">        <span class="comment">// Perform a semaphore post.</span></div><div class="line">        sem_post((sem_t *) (msg-&gt;<a class="code" href="struct_i2_c___transaction.html#a29ec65addac2d4ef5d1235c2329e2fc1">arg</a>));</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Snippets of the thread code that initiates the transactions are shown below. Note the use of multiple <a class="el" href="struct_i2_c___transaction.html" title="Defines a transaction to be used with I2C_transfer() or I2C_transferTimeout(). ">I2C_Transaction</a> structures. The handle of the semaphore to be posted is specified via <code>i2cTransaction2.arg</code>. <a class="el" href="group___i2_c.html#gac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C target peripheral. ">I2C_transfer()</a> is called three times to initiate each transaction. Since callback mode is used, these functions return immediately. After the transactions have been queued, other work can be done. Eventually, <code>sem_wait()</code> is called causing the thread to block until the transaction completes. When the transaction completes, the application's callback function, <code>callbackFxn</code> will be called. Once <a class="el" href="group___i2_c.html#gadaa5c99b7c23a00bac52d15a2469764e" title="The definition of a callback function. ">I2C_CallbackFxn</a> posts the semaphore, the thread will be unblocked and can resume execution.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> thread(arg0, arg1)</div><div class="line">{</div><div class="line"></div><div class="line">    <a class="code" href="struct_i2_c___transaction.html">I2C_Transaction</a> i2cTransaction0 = {0};</div><div class="line">    <a class="code" href="struct_i2_c___transaction.html">I2C_Transaction</a> i2cTransaction1 = {0};</div><div class="line">    <a class="code" href="struct_i2_c___transaction.html">I2C_Transaction</a> i2cTransaction2 = {0};</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    i2cTransaction0.<a class="code" href="struct_i2_c___transaction.html#a29ec65addac2d4ef5d1235c2329e2fc1">arg</a> = NULL;</div><div class="line">    i2cTransaction1.<a class="code" href="struct_i2_c___transaction.html#a29ec65addac2d4ef5d1235c2329e2fc1">arg</a> = NULL;</div><div class="line">    i2cTransaction2.<a class="code" href="struct_i2_c___transaction.html#a29ec65addac2d4ef5d1235c2329e2fc1">arg</a> = semaphoreHandle;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <a class="code" href="group___i2_c.html#gac5d827b67fe77d7d179026941cc069d7">I2C_transfer</a>(i2c, &amp;i2cTransaction0);</div><div class="line">    <a class="code" href="group___i2_c.html#gac5d827b67fe77d7d179026941cc069d7">I2C_transfer</a>(i2c, &amp;i2cTransaction1);</div><div class="line">    <a class="code" href="group___i2_c.html#gac5d827b67fe77d7d179026941cc069d7">I2C_transfer</a>(i2c, &amp;i2cTransaction2);</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    sem_wait(semaphoreHandle);</div><div class="line">}</div></div><!-- fragment --><hr/>
 <h2 class="groupheader">Typedef Documentation</h2>
<a id="gadaa5c99b7c23a00bac52d15a2469764e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadaa5c99b7c23a00bac52d15a2469764e">&sect;&nbsp;</a></span>I2C_CallbackFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* I2C_CallbackFxn) (<a class="el" href="group___i2_c.html#ga1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a> handle, <a class="el" href="struct_i2_c___transaction.html">I2C_Transaction</a> *transaction, bool transferStatus)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The definition of a callback function. </p>
<p>When operating in <a class="el" href="group___i2_c.html#gga39f3b9340fc4ee241b0d2da9b2841c26a129731a7edeb285f43a54b2cf9f5ac72">I2C_MODE_CALLBACK</a>, the callback function is called when an <a class="el" href="group___i2_c.html#gac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C target peripheral. ">I2C_transfer()</a> completes. The application is responsible for declaring an <a class="el" href="group___i2_c.html#gadaa5c99b7c23a00bac52d15a2469764e" title="The definition of a callback function. ">I2C_CallbackFxn</a> function and providing a pointer in <a class="el" href="struct_i2_c___params.html#a57edf1b900368904779d0c57a73cf047">I2C_Params.transferCallbackFxn</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The callback function is called from an interrupt context.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">handle</td><td><a class="el" href="group___i2_c.html#ga1d8718f847129c7aa61dd1c264d8a13c" title="A handle that is returned from an I2C_open() call. ">I2C_Handle</a> used with the initial call to <a class="el" href="group___i2_c.html#gac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C target peripheral. ">I2C_transfer()</a>.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">transaction</td><td>Pointer to the <a class="el" href="struct_i2_c___transaction.html" title="Defines a transaction to be used with I2C_transfer() or I2C_transferTimeout(). ">I2C_Transaction</a> structure used with the initial call to <a class="el" href="group___i2_c.html#gac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C target peripheral. ">I2C_transfer()</a>. This structure contains the custom argument specified by <code>transaction.arg</code> and the transaction status.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">transferStatus</td><td>Boolean indicating if the I2C transaction was successful. If <code>true</code>, the transaction was successful. If <code>false</code>, the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae43e4c7b224a8cc37764acb792182453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae43e4c7b224a8cc37764acb792182453">&sect;&nbsp;</a></span>I2C_Config</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_i2_c___config__.html">I2C_Config_</a>  <a class="el" href="group___i2_c.html#gae43e4c7b224a8cc37764acb792182453">I2C_Config</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C driver's configuration structure. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#ga9ff51ddf1d325776fef90cce0223772b" title="Function to initialize the I2C driver. ">I2C_init()</a> </dd>
<dd>
<a class="el" href="group___i2_c.html#ga2db3461e1e956d9b86af414da2fb05f6" title="Open an I2C driver instance. ">I2C_open()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga39f3b9340fc4ee241b0d2da9b2841c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39f3b9340fc4ee241b0d2da9b2841c26">&sect;&nbsp;</a></span>I2C_TransferMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#ga39f3b9340fc4ee241b0d2da9b2841c26">I2C_TransferMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return behavior of I2C_Transfer() specified in the <a class="el" href="struct_i2_c___params.html" title="I2C parameters used with I2C_open(). ">I2C_Params</a>. </p>
<p>This enumeration defines the return behaviors for a call to <a class="el" href="group___i2_c.html#gac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C target peripheral. ">I2C_transfer()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_i2_c___params.html" title="I2C parameters used with I2C_open(). ">I2C_Params</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga39f3b9340fc4ee241b0d2da9b2841c26abe065350be2a0ae5c9beb24624626c75"></a>I2C_MODE_BLOCKING&#160;</td><td class="fielddoc"><p>In <a class="el" href="group___i2_c.html#gga39f3b9340fc4ee241b0d2da9b2841c26abe065350be2a0ae5c9beb24624626c75">I2C_MODE_BLOCKING</a>, calls to <a class="el" href="group___i2_c.html#gac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C target peripheral. ">I2C_transfer()</a> block until the <a class="el" href="struct_i2_c___transaction.html" title="Defines a transaction to be used with I2C_transfer() or I2C_transferTimeout(). ">I2C_Transaction</a> completes. Other threads calling <a class="el" href="group___i2_c.html#gac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C target peripheral. ">I2C_transfer()</a> while a transaction is in progress are also placed into a blocked state. If multiple threads are blocked, the thread with the highest priority will be unblocked first. This implies that arbitration will not be executed in chronological order.</p>
<dl class="section note"><dt>Note</dt><dd>When using <a class="el" href="group___i2_c.html#gga39f3b9340fc4ee241b0d2da9b2841c26abe065350be2a0ae5c9beb24624626c75">I2C_MODE_BLOCKING</a>, <a class="el" href="group___i2_c.html#gac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C target peripheral. ">I2C_transfer()</a> must be called from a thread context. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="gga39f3b9340fc4ee241b0d2da9b2841c26a129731a7edeb285f43a54b2cf9f5ac72"></a>I2C_MODE_CALLBACK&#160;</td><td class="fielddoc"><p>In <a class="el" href="group___i2_c.html#gga39f3b9340fc4ee241b0d2da9b2841c26a129731a7edeb285f43a54b2cf9f5ac72">I2C_MODE_CALLBACK</a>, calls to <a class="el" href="group___i2_c.html#gac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C target peripheral. ">I2C_transfer()</a> return immediately. The application's callback function, <a class="el" href="struct_i2_c___params.html#a57edf1b900368904779d0c57a73cf047">I2C_Params.transferCallbackFxn</a>, is called when the transaction is complete. Sequential calls to <a class="el" href="group___i2_c.html#gac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C target peripheral. ">I2C_transfer()</a> will place <a class="el" href="struct_i2_c___transaction.html" title="Defines a transaction to be used with I2C_transfer() or I2C_transferTimeout(). ">I2C_Transaction</a> structures into an internal queue. Queued transactions are automatically started after the previous transaction has completed. This queuing occurs regardless of any error state from previous transactions. The transactions are always executed in chronological order. The <a class="el" href="struct_i2_c___params.html#a57edf1b900368904779d0c57a73cf047">I2C_Params.transferCallbackFxn</a> function will be called asynchronously as each transaction is completed. </p>
</td></tr>
</table>

</div>
</div>
<a id="gac954e3197f04c50293db466c4abb6fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac954e3197f04c50293db466c4abb6fbe">&sect;&nbsp;</a></span>I2C_BitRate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#gac954e3197f04c50293db466c4abb6fbe">I2C_BitRate</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit rate for an I2C driver instance specified in the <a class="el" href="struct_i2_c___params.html" title="I2C parameters used with I2C_open(). ">I2C_Params</a>. </p>
<p>This enumeration defines the bit rates used with an <a class="el" href="group___i2_c.html#gac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C target peripheral. ">I2C_transfer()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>You must check that the device specific implementation supports the desired <a class="el" href="group___i2_c.html#gac954e3197f04c50293db466c4abb6fbe" title="Bit rate for an I2C driver instance specified in the I2C_Params. ">I2C_BitRate</a>. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac954e3197f04c50293db466c4abb6fbea966fd2df13b3a9825615c50335cf1987"></a>I2C_100kHz&#160;</td><td class="fielddoc"><p>I2C Standard-mode. Up to 100 kbit/s. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac954e3197f04c50293db466c4abb6fbea83cc3750242e6ae9194cd7ed94f764d9"></a>I2C_400kHz&#160;</td><td class="fielddoc"><p>I2C Fast-mode. Up to 400 kbit/s. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac954e3197f04c50293db466c4abb6fbea38a2e32ba65eb0f67b928d181242befa"></a>I2C_1000kHz&#160;</td><td class="fielddoc"><p>I2C Fast-mode Plus. Up to 1Mbit/s. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga8cad0c04a9eca0fffc0ffe5586a5179b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8cad0c04a9eca0fffc0ffe5586a5179b">&sect;&nbsp;</a></span>I2C_cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancels all I2C transfers. </p>
<p>This function will cancel asynchronous <a class="el" href="group___i2_c.html#gac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C target peripheral. ">I2C_transfer()</a> operations by generating a STOP condition on the I2C bus.</p>
<p>Calls to <a class="el" href="group___i2_c.html#ga8cad0c04a9eca0fffc0ffe5586a5179b" title="Cancels all I2C transfers. ">I2C_cancel()</a> return immediately; however, the transaction may not yet be canceled.</p>
<p>For <a class="el" href="group___i2_c.html#gga39f3b9340fc4ee241b0d2da9b2841c26abe065350be2a0ae5c9beb24624626c75">I2C_MODE_BLOCKING</a>, the current transaction is canceled.</p>
<p>For <a class="el" href="group___i2_c.html#gga39f3b9340fc4ee241b0d2da9b2841c26a129731a7edeb285f43a54b2cf9f5ac72">I2C_MODE_CALLBACK</a> mode, the in progress transfer, as well as any queued transfers, will be canceled. The individual callback functions for each transfer will be called in chronological order. The callback functions are called in an interrupt context. Additional calls to <a class="el" href="group___i2_c.html#gac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C target peripheral. ">I2C_transfer()</a> invoked from the callback function of a canceled transaction will always fail. In such cases, the <a class="el" href="struct_i2_c___transaction.html#a911f51c3c6fffcb962b225363fdbbb81">I2C_Transaction.status</a> will indicate <a class="el" href="group___i2_c___s_t_a_t_u_s.html#gad92f93f1f1c8ef8fc2be70bb8b0c7aa9" title="I2C transaction is invalid. ">I2C_STATUS_INVALID_TRANS</a>.</p>
<p>A canceled transaction may be identified when the <a class="el" href="struct_i2_c___transaction.html#a911f51c3c6fffcb962b225363fdbbb81">I2C_Transaction.status</a> is set to <a class="el" href="group___i2_c___s_t_a_t_u_s.html#ga2cca884b9720ab2ca750ebfdb8614601" title="I2C transaction canceled by I2C_cancel(). ">I2C_STATUS_CANCEL</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This API may not handle cases where the I2C target holds the clock line indefinitely.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>I2C_Transfer() has been called.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>An <a class="el" href="group___i2_c.html#ga1d8718f847129c7aa61dd1c264d8a13c" title="A handle that is returned from an I2C_open() call. ">I2C_Handle</a> returned from <a class="el" href="group___i2_c.html#ga2db3461e1e956d9b86af414da2fb05f6" title="Open an I2C driver instance. ">I2C_open()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Different I2C target devices will behave differently when an in-progress transfer fails and needs to be canceled. The target may need to be reset, or there may be other target-specific steps that can be used to successfully resume communication.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#gac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C target peripheral. ">I2C_transfer()</a> </dd>
<dd>
<a class="el" href="group___i2_c.html#gga39f3b9340fc4ee241b0d2da9b2841c26a129731a7edeb285f43a54b2cf9f5ac72">I2C_MODE_CALLBACK</a> </dd></dl>

</div>
</div>
<a id="ga12c86d89a687f2ee1eb980d99c32326d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12c86d89a687f2ee1eb980d99c32326d">&sect;&nbsp;</a></span>I2C_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to close an I2C driver instance. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group___i2_c.html#ga2db3461e1e956d9b86af414da2fb05f6" title="Open an I2C driver instance. ">I2C_open()</a> has been called.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>An <a class="el" href="group___i2_c.html#ga1d8718f847129c7aa61dd1c264d8a13c" title="A handle that is returned from an I2C_open() call. ">I2C_Handle</a> returned from <a class="el" href="group___i2_c.html#ga2db3461e1e956d9b86af414da2fb05f6" title="Open an I2C driver instance. ">I2C_open()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4c74b1b9f8e76ac22bec7608491cb223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c74b1b9f8e76ac22bec7608491cb223">&sect;&nbsp;</a></span>I2C_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t I2C_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast16_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>controlArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function performs implementation specific features on a driver instance. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group___i2_c.html#ga2db3461e1e956d9b86af414da2fb05f6" title="Open an I2C driver instance. ">I2C_open()</a> has to be called first.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>An <a class="el" href="group___i2_c.html#ga1d8718f847129c7aa61dd1c264d8a13c" title="A handle that is returned from an I2C_open() call. ">I2C_Handle</a> returned from <a class="el" href="group___i2_c.html#ga2db3461e1e956d9b86af414da2fb05f6" title="Open an I2C driver instance. ">I2C_open()</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>A command value defined by the device specific implementation.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">controlArg</td><td>An optional R/W (read/write) argument that is accompanied with <code>cmd</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Implementation specific return codes. Negative values indicate unsuccessful operations.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group___i2_c___s_t_a_t_u_s.html#gaa0bcf3acd26ac82bd8ff91daba2c78c4" title="Successful status code returned by I2C API. ">I2C_STATUS_SUCCESS</a></td><td>The call was successful. </td></tr>
    <tr><td class="paramname"><a class="el" href="group___i2_c___s_t_a_t_u_s.html#ga11c31c9869ed2441789205d9e5967d66" title="An error status code returned by I2C_control() for undefined command codes. ">I2C_STATUS_UNDEFINEDCMD</a></td><td>The <code>cmd</code> value is not supported by the device specific implementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9ff51ddf1d325776fef90cce0223772b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ff51ddf1d325776fef90cce0223772b">&sect;&nbsp;</a></span>I2C_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize the I2C driver. </p>
<p>This function must also be called before any other I2C driver APIs. </p>

</div>
</div>
<a id="ga2db3461e1e956d9b86af414da2fb05f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2db3461e1e956d9b86af414da2fb05f6">&sect;&nbsp;</a></span>I2C_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___i2_c.html#ga1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a> I2C_open </td>
          <td>(</td>
          <td class="paramtype">uint_least8_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_i2_c___params.html">I2C_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open an I2C driver instance. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group___i2_c.html#ga9ff51ddf1d325776fef90cce0223772b" title="Function to initialize the I2C driver. ">I2C_init()</a> has been called.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index in the <code>I2C_Config</code>[] array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Pointer to an initialized <a class="el" href="struct_i2_c___params.html" title="I2C parameters used with I2C_open(). ">I2C_Params</a> structure. If NULL, the default <a class="el" href="struct_i2_c___params.html" title="I2C parameters used with I2C_open(). ">I2C_Params</a> values are used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="group___i2_c.html#ga1d8718f847129c7aa61dd1c264d8a13c" title="A handle that is returned from an I2C_open() call. ">I2C_Handle</a> on success, or <code>NULL</code> on an error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#ga9ff51ddf1d325776fef90cce0223772b" title="Function to initialize the I2C driver. ">I2C_init()</a> </dd>
<dd>
<a class="el" href="group___i2_c.html#ga12c86d89a687f2ee1eb980d99c32326d" title="Function to close an I2C driver instance. ">I2C_close()</a> </dd></dl>

</div>
</div>
<a id="gab11636302074d67180207ab81ceb323c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab11636302074d67180207ab81ceb323c">&sect;&nbsp;</a></span>I2C_Params_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_Params_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___params.html">I2C_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize an <a class="el" href="struct_i2_c___params.html" title="I2C parameters used with I2C_open(). ">I2C_Params</a> structure to its default values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>A pointer to <a class="el" href="struct_i2_c___params.html" title="I2C parameters used with I2C_open(). ">I2C_Params</a> structure for initialization.</td></tr>
  </table>
  </dd>
</dl>
<p>Defaults values are: </p><ul>
<li><a class="el" href="struct_i2_c___params.html#a79c5c51380ffbdb21df1dff6cb57de0e">I2C_Params.transferMode</a> = <a class="el" href="group___i2_c.html#gga39f3b9340fc4ee241b0d2da9b2841c26abe065350be2a0ae5c9beb24624626c75">I2C_MODE_BLOCKING</a> </li>
<li><a class="el" href="struct_i2_c___params.html#a57edf1b900368904779d0c57a73cf047">I2C_Params.transferCallbackFxn</a> = <code>NULL</code> </li>
<li><a class="el" href="struct_i2_c___params.html#ad31857f6dbedb77c60c92cc8cd8cde0c">I2C_Params.bitRate</a> = <a class="el" href="group___i2_c.html#ggac954e3197f04c50293db466c4abb6fbea966fd2df13b3a9825615c50335cf1987">I2C_100kHz</a> </li>
<li><a class="el" href="struct_i2_c___params.html#a2416cc06d853e6cc24e1f294dfebb194">I2C_Params.custom</a> = <code>NULL</code> </li>
</ul>

</div>
</div>
<a id="ga999fa1c606163ca9bbb4252a27c8eb9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga999fa1c606163ca9bbb4252a27c8eb9d">&sect;&nbsp;</a></span>I2C_setClockTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t I2C_setClockTimeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the I2C SCL clock timeout. </p>
<p>An I2C target can extend a I2C transaction by periodically pulling the clock low to create a slow bit transfer rate. The application can use this API to program a counter in the I2C module. The count is used to force a timeout if an I2C target holds the clock line low for longer than the <code>timeout</code> duration. An <a class="el" href="group___i2_c___s_t_a_t_u_s.html#gae1ce91f866196f18abebfd6aead32cbe" title="I2C serial clock line timeout. ">I2C_STATUS_CLOCK_TIMEOUT</a> status indicates a timeout event occured.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>An <a class="el" href="group___i2_c.html#ga1d8718f847129c7aa61dd1c264d8a13c" title="A handle that is returned from an I2C_open() call. ">I2C_Handle</a> returned from <a class="el" href="group___i2_c.html#ga2db3461e1e956d9b86af414da2fb05f6" title="Open an I2C driver instance. ">I2C_open()</a></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Timeout in units of I2C clock cycles. Refer to the device specifc reference manual to determine how to calculate the timeout value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible return values include: <ul>
<li><a class="el" href="group___i2_c___s_t_a_t_u_s.html#gaa0bcf3acd26ac82bd8ff91daba2c78c4" title="Successful status code returned by I2C API. ">I2C_STATUS_SUCCESS</a> </li>
<li><a class="el" href="group___i2_c___s_t_a_t_u_s.html#ga7323fe57c39c46d0da9910e17f5f0b06" title="Generic error status code returned by I2C API. ">I2C_STATUS_ERROR</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#gac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C target peripheral. ">I2C_transfer()</a> </dd></dl>

</div>
</div>
<a id="gac5d827b67fe77d7d179026941cc069d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5d827b67fe77d7d179026941cc069d7">&sect;&nbsp;</a></span>I2C_transfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool I2C_transfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_i2_c___transaction.html">I2C_Transaction</a> *&#160;</td>
          <td class="paramname"><em>transaction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an I2C transaction with an I2C target peripheral. </p>
<p>This function will perform an I2C transfer, as specified by an <a class="el" href="struct_i2_c___transaction.html" title="Defines a transaction to be used with I2C_transfer() or I2C_transferTimeout(). ">I2C_Transaction</a> structure.</p>
<dl class="section note"><dt>Note</dt><dd>When using <a class="el" href="group___i2_c.html#gga39f3b9340fc4ee241b0d2da9b2841c26abe065350be2a0ae5c9beb24624626c75">I2C_MODE_BLOCKING</a>, this must be called from a thread context.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>An <a class="el" href="group___i2_c.html#ga1d8718f847129c7aa61dd1c264d8a13c" title="A handle that is returned from an I2C_open() call. ">I2C_Handle</a> returned from <a class="el" href="group___i2_c.html#ga2db3461e1e956d9b86af414da2fb05f6" title="Open an I2C driver instance. ">I2C_open()</a></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transaction</td><td>A pointer to an <a class="el" href="struct_i2_c___transaction.html" title="Defines a transaction to be used with I2C_transfer() or I2C_transferTimeout(). ">I2C_Transaction</a>. The application is responsible for allocating and initializing an <a class="el" href="struct_i2_c___transaction.html" title="Defines a transaction to be used with I2C_transfer() or I2C_transferTimeout(). ">I2C_Transaction</a> structure prior to passing it to I2C_Transfer(). This structure must persist in memory unmodified until the transfer is complete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="struct_i2_c___transaction.html" title="Defines a transaction to be used with I2C_transfer() or I2C_transferTimeout(). ">I2C_Transaction</a> structures cannot be re-used until the previous transaction has completed. Upon the completion of a transaction, the <a class="el" href="struct_i2_c___transaction.html#a911f51c3c6fffcb962b225363fdbbb81">I2C_Transaction.status</a> may be used for error handling.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>In <a class="el" href="group___i2_c.html#gga39f3b9340fc4ee241b0d2da9b2841c26abe065350be2a0ae5c9beb24624626c75">I2C_MODE_BLOCKING</a>: <code>true</code> for a successful transfer; <code>false</code> for an error (for example, an I2C bus fault (NACK)).</dd>
<dd>
In <a class="el" href="group___i2_c.html#gga39f3b9340fc4ee241b0d2da9b2841c26a129731a7edeb285f43a54b2cf9f5ac72">I2C_MODE_CALLBACK</a>: always <code>true</code>. The <a class="el" href="group___i2_c.html#gadaa5c99b7c23a00bac52d15a2469764e" title="The definition of a callback function. ">I2C_CallbackFxn</a> <code>bool</code> argument will be <code>true</code> to indicate success, and <code>false</code> to indicate an error.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group___i2_c.html#ga2db3461e1e956d9b86af414da2fb05f6" title="Open an I2C driver instance. ">I2C_open()</a> has been called.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#ga2db3461e1e956d9b86af414da2fb05f6" title="Open an I2C driver instance. ">I2C_open()</a>, <a class="el" href="group___i2_c.html#gaaee4f0689acbe5f0596e35b18402abf3" title="Perform an I2C transaction with an I2C target peripheral. ">I2C_transferTimeout()</a> </dd>
<dd>
<a class="el" href="struct_i2_c___transaction.html" title="Defines a transaction to be used with I2C_transfer() or I2C_transferTimeout(). ">I2C_Transaction</a> </dd></dl>

</div>
</div>
<a id="gaaee4f0689acbe5f0596e35b18402abf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaee4f0689acbe5f0596e35b18402abf3">&sect;&nbsp;</a></span>I2C_transferTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t I2C_transferTimeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_i2_c___transaction.html">I2C_Transaction</a> *&#160;</td>
          <td class="paramname"><em>transaction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an I2C transaction with an I2C target peripheral. </p>
<p>This function will perform an I2C transfer, as specified by an <a class="el" href="struct_i2_c___transaction.html" title="Defines a transaction to be used with I2C_transfer() or I2C_transferTimeout(). ">I2C_Transaction</a> structure. If the timeout is exceeded, then the I2C transaction is canceled.</p>
<dl class="section note"><dt>Note</dt><dd>When using <a class="el" href="group___i2_c.html#gga39f3b9340fc4ee241b0d2da9b2841c26abe065350be2a0ae5c9beb24624626c75">I2C_MODE_BLOCKING</a>, this must be called from a thread context.</dd>
<dd>
The timeout restriction is only applied when using <a class="el" href="group___i2_c.html#gga39f3b9340fc4ee241b0d2da9b2841c26abe065350be2a0ae5c9beb24624626c75">I2C_MODE_BLOCKING</a>. If using <a class="el" href="group___i2_c.html#gga39f3b9340fc4ee241b0d2da9b2841c26a129731a7edeb285f43a54b2cf9f5ac72">I2C_MODE_CALLBACK</a>, the application should manage timeouts using <a class="el" href="group___i2_c.html#ga8cad0c04a9eca0fffc0ffe5586a5179b" title="Cancels all I2C transfers. ">I2C_cancel()</a>. Additionally, this timeout may not handle cases where the I2C target holds the clock line indefinitely.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>An <a class="el" href="group___i2_c.html#ga1d8718f847129c7aa61dd1c264d8a13c" title="A handle that is returned from an I2C_open() call. ">I2C_Handle</a> returned from <a class="el" href="group___i2_c.html#ga2db3461e1e956d9b86af414da2fb05f6" title="Open an I2C driver instance. ">I2C_open()</a></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transaction</td><td>A pointer to an <a class="el" href="struct_i2_c___transaction.html" title="Defines a transaction to be used with I2C_transfer() or I2C_transferTimeout(). ">I2C_Transaction</a>. The application is responsible for allocating and initializing an <a class="el" href="struct_i2_c___transaction.html" title="Defines a transaction to be used with I2C_transfer() or I2C_transferTimeout(). ">I2C_Transaction</a> structure prior to passing it to I2C_TransferTimeout(). This structure must persist in memory unmodified until the transfer is complete.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>The time in system ticks to wait for the transaction to complete. Passing I2C_WAIT_FOREVER into this parameter will cause <a class="el" href="group___i2_c.html#gaaee4f0689acbe5f0596e35b18402abf3" title="Perform an I2C transaction with an I2C target peripheral. ">I2C_transferTimeout()</a> to behave the same as <a class="el" href="group___i2_c.html#gac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C target peripheral. ">I2C_transfer()</a> but with a more detailed return status.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="struct_i2_c___transaction.html" title="Defines a transaction to be used with I2C_transfer() or I2C_transferTimeout(). ">I2C_Transaction</a> structures cannot be re-used until the previous transaction has completed. Upon the completion of a transaction, the <a class="el" href="struct_i2_c___transaction.html#a911f51c3c6fffcb962b225363fdbbb81">I2C_Transaction.status</a> may be used for error handling.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>In <a class="el" href="group___i2_c.html#gga39f3b9340fc4ee241b0d2da9b2841c26a129731a7edeb285f43a54b2cf9f5ac72">I2C_MODE_CALLBACK</a>: always <code>I2C_STATUS_SUCCESS</code>. The <a class="el" href="group___i2_c.html#gadaa5c99b7c23a00bac52d15a2469764e" title="The definition of a callback function. ">I2C_CallbackFxn</a> <code>transferStatus</code> argument will be <code>true</code> to indicate success, and <code>false</code> to indicate an error.</dd>
<dd>
In <a class="el" href="group___i2_c.html#gga39f3b9340fc4ee241b0d2da9b2841c26abe065350be2a0ae5c9beb24624626c75">I2C_MODE_BLOCKING</a>: Possible return values include: <ul>
<li><a class="el" href="group___i2_c___s_t_a_t_u_s.html#gaa0bcf3acd26ac82bd8ff91daba2c78c4" title="Successful status code returned by I2C API. ">I2C_STATUS_SUCCESS</a> </li>
<li><a class="el" href="group___i2_c___s_t_a_t_u_s.html#ga7323fe57c39c46d0da9910e17f5f0b06" title="Generic error status code returned by I2C API. ">I2C_STATUS_ERROR</a> </li>
<li><a class="el" href="group___i2_c___s_t_a_t_u_s.html#gacef5657ae83115da15f49dd76801638b" title="I2C operation timed-out. ">I2C_STATUS_TIMEOUT</a> </li>
<li><a class="el" href="group___i2_c___s_t_a_t_u_s.html#gae1ce91f866196f18abebfd6aead32cbe" title="I2C serial clock line timeout. ">I2C_STATUS_CLOCK_TIMEOUT</a> </li>
<li><a class="el" href="group___i2_c___s_t_a_t_u_s.html#ga75c95f62df35a6769b69904e6cd90181" title="I2C target address not acknowledged. ">I2C_STATUS_ADDR_NACK</a> </li>
<li><a class="el" href="group___i2_c___s_t_a_t_u_s.html#ga3773311442a356cd750e1cf34b85ed5a" title="I2C data byte not acknowledged. ">I2C_STATUS_DATA_NACK</a> </li>
<li><a class="el" href="group___i2_c___s_t_a_t_u_s.html#gadb5718560335315df79d4abe7ddba317" title="I2C multi-controller arbitration lost. ">I2C_STATUS_ARB_LOST</a> </li>
<li><a class="el" href="group___i2_c___s_t_a_t_u_s.html#ga4d4ff3732548047b7c09a1f34ab93d98" title="I2C transaction is in progress or returned without completing. ">I2C_STATUS_INCOMPLETE</a> </li>
<li><a class="el" href="group___i2_c___s_t_a_t_u_s.html#gaf7455cb02ee12dfc513ceb28323b4b8d" title="I2C bus already in use by another controller. The I2C transaction. was therefore unable to start...">I2C_STATUS_BUS_BUSY</a> </li>
<li><a class="el" href="group___i2_c___s_t_a_t_u_s.html#ga2cca884b9720ab2ca750ebfdb8614601" title="I2C transaction canceled by I2C_cancel(). ">I2C_STATUS_CANCEL</a> </li>
<li><a class="el" href="group___i2_c___s_t_a_t_u_s.html#gad92f93f1f1c8ef8fc2be70bb8b0c7aa9" title="I2C transaction is invalid. ">I2C_STATUS_INVALID_TRANS</a></li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group___i2_c.html#ga2db3461e1e956d9b86af414da2fb05f6" title="Open an I2C driver instance. ">I2C_open()</a> has been called.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#ga2db3461e1e956d9b86af414da2fb05f6" title="Open an I2C driver instance. ">I2C_open()</a>, <a class="el" href="group___i2_c.html#gac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C target peripheral. ">I2C_transfer()</a> </dd>
<dd>
<a class="el" href="struct_i2_c___transaction.html" title="Defines a transaction to be used with I2C_transfer() or I2C_transferTimeout(). ">I2C_Transaction</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">© Copyright 1995-2025</a>, Texas Instruments Incorporated. All rights reserved. <br/>
  <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
