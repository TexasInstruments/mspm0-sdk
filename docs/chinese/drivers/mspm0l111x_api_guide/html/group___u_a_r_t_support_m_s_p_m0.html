<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>MSPM0L111X TI-Driver Library: UART driver supporting APIs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MSPM0L111X TI-Driver Library
   &#160;<span id="projectnumber">2.05.01.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">UART driver supporting APIs<div class="ingroups"><a class="el" href="group___u_a_r_t.html">Universal Asynchronous Receiver-Transmitter (UART)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for UART driver supporting APIs:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group___u_a_r_t_support_m_s_p_m0.png" border="0" alt="" usemap="#group______u__a__r__t__support__m__s__p__m0"/>
<map name="group______u__a__r__t__support__m__s__p__m0" id="group______u__a__r__t__support__m__s__p__m0">
<area shape="rect" id="node2" href="group___u_a_r_t.html" title="Universal Asynchronous\l Receiver&#45;Transmitter\l (UART)" alt="" coords="5,5,184,61"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t_support___fxns.html">UARTSupport_Fxns</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pointers to implementation/hardware specific logic.  <a href="struct_u_a_r_t_support___fxns.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___object.html">UART_Object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private Metadata structure for a UART instance.  <a href="struct_u_a_r_t___object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___buffers___object.html">UART_Buffers_Object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private Metadata structure for a UART instance supporting buffers.  <a href="struct_u_a_r_t___buffers___object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___event_callback___object.html">UART_EventCallback_Object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private Metadata structure for a UART instance supporting events.  <a href="struct_u_a_r_t___event_callback___object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___callback___object.html">UART_Callback_Object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private Metadata structure for a UART instance supporting callbacks.  <a href="struct_u_a_r_t___callback___object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___data___object.html">UART_Data_Object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private Metadata structure for a UART instance supporting data structures needed for UART TX/RX execution.  <a href="struct_u_a_r_t___data___object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___config__.html">UART_Config_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART Global configuration.  <a href="struct_u_a_r_t___config__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga68be81b9ce429a5e5c3ac02d285dbd3b"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_u_a_r_t___config__.html">UART_Config_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t_support_m_s_p_m0.html#ga68be81b9ce429a5e5c3ac02d285dbd3b">UART_Config</a></td></tr>
<tr class="memdesc:ga68be81b9ce429a5e5c3ac02d285dbd3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART Global configuration.  <a href="#ga68be81b9ce429a5e5c3ac02d285dbd3b">More...</a><br /></td></tr>
<tr class="separator:ga68be81b9ce429a5e5c3ac02d285dbd3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac631c209670246c126aa881a2ba5b8ff"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t_support_m_s_p_m0.html#gac631c209670246c126aa881a2ba5b8ff">UART_readBuffered</a> (<a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle, void *buf, size_t size, size_t *bytesRead)</td></tr>
<tr class="memdesc:gac631c209670246c126aa881a2ba5b8ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART read that only supports buffered mode.  <a href="#gac631c209670246c126aa881a2ba5b8ff">More...</a><br /></td></tr>
<tr class="separator:gac631c209670246c126aa881a2ba5b8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28d4cd7a17d16035650bd02a602a451a"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t_support_m_s_p_m0.html#ga28d4cd7a17d16035650bd02a602a451a">UART_writeBuffered</a> (<a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle, const void *buf, size_t size, size_t *bytesWritten)</td></tr>
<tr class="memdesc:ga28d4cd7a17d16035650bd02a602a451a"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART write that only supports buffered mode.  <a href="#ga28d4cd7a17d16035650bd02a602a451a">More...</a><br /></td></tr>
<tr class="separator:ga28d4cd7a17d16035650bd02a602a451a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3b2e6e98a344727f4a2dbae53f08d55"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t_support_m_s_p_m0.html#gaf3b2e6e98a344727f4a2dbae53f08d55">UART_readCallback</a> (<a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle, void *buf, size_t size, size_t *bytesRead)</td></tr>
<tr class="memdesc:gaf3b2e6e98a344727f4a2dbae53f08d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART read that only supports callback mode.  <a href="#gaf3b2e6e98a344727f4a2dbae53f08d55">More...</a><br /></td></tr>
<tr class="separator:gaf3b2e6e98a344727f4a2dbae53f08d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b27db3e5e5c673fb119998026f7b381"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t_support_m_s_p_m0.html#ga2b27db3e5e5c673fb119998026f7b381">UART_writeCallback</a> (<a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle, const void *buf, size_t size, size_t *bytesWritten)</td></tr>
<tr class="memdesc:ga2b27db3e5e5c673fb119998026f7b381"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART write that only supports callback mode.  <a href="#ga2b27db3e5e5c673fb119998026f7b381">More...</a><br /></td></tr>
<tr class="separator:ga2b27db3e5e5c673fb119998026f7b381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad38d4b350d3cc945c739fe969c7ece86"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t_support_m_s_p_m0.html#gad38d4b350d3cc945c739fe969c7ece86">UART_readFullFeatured</a> (<a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle, void *buf, size_t size, size_t *bytesRead)</td></tr>
<tr class="memdesc:gad38d4b350d3cc945c739fe969c7ece86"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART read that only supports buffered and callback mode.  <a href="#gad38d4b350d3cc945c739fe969c7ece86">More...</a><br /></td></tr>
<tr class="separator:gad38d4b350d3cc945c739fe969c7ece86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd06c63ea82f6caf04319487253f41e4"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t_support_m_s_p_m0.html#gabd06c63ea82f6caf04319487253f41e4">UART_writeFullFeatured</a> (<a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a> handle, const void *buf, size_t size, size_t *bytesWritten)</td></tr>
<tr class="memdesc:gabd06c63ea82f6caf04319487253f41e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART write that only supports buffered and callback mode.  <a href="#gabd06c63ea82f6caf04319487253f41e4">More...</a><br /></td></tr>
<tr class="separator:gabd06c63ea82f6caf04319487253f41e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gad24e1d95c2d7232d55dc5b1d00a56bb5"><td class="memItemLeft" align="right" valign="top"><a id="gad24e1d95c2d7232d55dc5b1d00a56bb5"></a>
const <a class="el" href="group___u_a_r_t_support_m_s_p_m0.html#ga68be81b9ce429a5e5c3ac02d285dbd3b">UART_Config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t_support_m_s_p_m0.html#gad24e1d95c2d7232d55dc5b1d00a56bb5">UART_config</a> []</td></tr>
<tr class="memdesc:gad24e1d95c2d7232d55dc5b1d00a56bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of <a class="el" href="group___u_a_r_t_support_m_s_p_m0.html#ga68be81b9ce429a5e5c3ac02d285dbd3b">UART_Config</a> structure. <br /></td></tr>
<tr class="separator:gad24e1d95c2d7232d55dc5b1d00a56bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e40006b96c9c55e5ac52d51d094dbac"><td class="memItemLeft" align="right" valign="top"><a id="ga3e40006b96c9c55e5ac52d51d094dbac"></a>
const uint_least8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t_support_m_s_p_m0.html#ga3e40006b96c9c55e5ac52d51d094dbac">UART_count</a></td></tr>
<tr class="memdesc:ga3e40006b96c9c55e5ac52d51d094dbac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of UART instances. <br /></td></tr>
<tr class="separator:ga3e40006b96c9c55e5ac52d51d094dbac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h1>Overview</h1>
<p>Refer to <a class="el" href="group___u_a_r_t.html#ti_drivers_UART_Overview">ti_drivers_UART_Overview</a> for a complete description of APIs and examples of use. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga68be81b9ce429a5e5c3ac02d285dbd3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68be81b9ce429a5e5c3ac02d285dbd3b">&sect;&nbsp;</a></span>UART_Config</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_u_a_r_t___config__.html">UART_Config_</a>  <a class="el" href="group___u_a_r_t_support_m_s_p_m0.html#ga68be81b9ce429a5e5c3ac02d285dbd3b">UART_Config</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART Global configuration. </p>
<p>The <a class="el" href="group___u_a_r_t_support_m_s_p_m0.html#ga68be81b9ce429a5e5c3ac02d285dbd3b">UART_Config</a> structure contains a set of pointers used to characterize the UART driver implementation. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gac631c209670246c126aa881a2ba5b8ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac631c209670246c126aa881a2ba5b8ff">&sect;&nbsp;</a></span>UART_readBuffered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t UART_readBuffered </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>bytesRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART read that only supports buffered mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>UART_Handle instance from <a class="el" href="group___u_a_r_t.html#gab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>location to read data into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>amount of data to read in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bytesRead</td><td>If non-NULL, the location to store the number of bytes actually read into the buffer. If NULL, this parameter will be ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status indicating success or failure of the read.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#ga101b7761f89b3ec49f0c6726669acfed" title="Successful status code returned by UART APIs. ">UART_STATUS_SUCCESS</a></td><td>The call was successful. </td></tr>
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#gaa658b16955ceabc4e33e31cab6444b3e" title="The UART is currently in use. ">UART_STATUS_EINUSE</a></td><td>Another read from the UART is currently ongoing. </td></tr>
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#ga69975d5ab5731732cb732df574ca11e2" title="A UART_write() or UART_read() operation was cancelled. ">UART_STATUS_ECANCELLED</a></td><td>In <a class="el" href="group___u_a_r_t.html#gga2507a620dba95cd20885c52494d19e90a09c2d5349786d1199eb87dc040f3d724">UART_Mode_BLOCKING</a>, the read was canceled by a call to <a class="el" href="group___u_a_r_t.html#ga51ed7e94d5b409ca1fcb2d65c5a25c3c" title="Function that cancels a UART_read() function call. ">UART_readCancel()</a> before any data could be received. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga28d4cd7a17d16035650bd02a602a451a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28d4cd7a17d16035650bd02a602a451a">&sect;&nbsp;</a></span>UART_writeBuffered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t UART_writeBuffered </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>bytesWritten</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART write that only supports buffered mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>UART_Handle instance from <a class="el" href="group___u_a_r_t.html#gab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>location to write data from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>amount of data to write in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bytesWritten</td><td>If non-NULL, the location to store the number of bytes actually written into the buffer. If NULL, this parameter will be ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status indicating success or failure of the write.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#ga101b7761f89b3ec49f0c6726669acfed" title="Successful status code returned by UART APIs. ">UART_STATUS_SUCCESS</a></td><td>The call was successful. </td></tr>
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#gaa658b16955ceabc4e33e31cab6444b3e" title="The UART is currently in use. ">UART_STATUS_EINUSE</a></td><td>Another write to the UART is currently ongoing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf3b2e6e98a344727f4a2dbae53f08d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3b2e6e98a344727f4a2dbae53f08d55">&sect;&nbsp;</a></span>UART_readCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t UART_readCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>bytesRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART read that only supports callback mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>UART_Handle instance from <a class="el" href="group___u_a_r_t.html#gab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>location to read data into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>amount of data to read in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bytesRead</td><td>If non-NULL, the location to store the number of bytes actually read into the buffer. If NULL, this parameter will be ignored. In callback mode, NULL could be passed in for this parameter, since the callback function will be passed the number of bytes read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status indicating success or failure of the read.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#ga101b7761f89b3ec49f0c6726669acfed" title="Successful status code returned by UART APIs. ">UART_STATUS_SUCCESS</a></td><td>The call was successful. </td></tr>
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#gaa658b16955ceabc4e33e31cab6444b3e" title="The UART is currently in use. ">UART_STATUS_EINUSE</a></td><td>Another read from the UART is currently ongoing. </td></tr>
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#ga69975d5ab5731732cb732df574ca11e2" title="A UART_write() or UART_read() operation was cancelled. ">UART_STATUS_ECANCELLED</a></td><td>In <a class="el" href="group___u_a_r_t.html#gga2507a620dba95cd20885c52494d19e90a09c2d5349786d1199eb87dc040f3d724">UART_Mode_BLOCKING</a>, the read was canceled by a call to <a class="el" href="group___u_a_r_t.html#ga51ed7e94d5b409ca1fcb2d65c5a25c3c" title="Function that cancels a UART_read() function call. ">UART_readCancel()</a> before any data could be received. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2b27db3e5e5c673fb119998026f7b381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b27db3e5e5c673fb119998026f7b381">&sect;&nbsp;</a></span>UART_writeCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t UART_writeCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>bytesWritten</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART write that only supports callback mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>UART_Handle instance from <a class="el" href="group___u_a_r_t.html#gab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>location to write data from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>amount of data to write in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bytesWritten</td><td>If non-NULL, the location to store the number of bytes actually written into the buffer. If NULL, this parameter will be ignored. In callback mode, NULL could be passed in for this parameter, since the callback function will be passed the number of bytes written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status indicating success or failure of the write.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#ga101b7761f89b3ec49f0c6726669acfed" title="Successful status code returned by UART APIs. ">UART_STATUS_SUCCESS</a></td><td>The call was successful. </td></tr>
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#gaa658b16955ceabc4e33e31cab6444b3e" title="The UART is currently in use. ">UART_STATUS_EINUSE</a></td><td>Another write to the UART is currently ongoing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad38d4b350d3cc945c739fe969c7ece86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad38d4b350d3cc945c739fe969c7ece86">&sect;&nbsp;</a></span>UART_readFullFeatured()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t UART_readFullFeatured </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>bytesRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART read that only supports buffered and callback mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>UART_Handle instance from <a class="el" href="group___u_a_r_t.html#gab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>location to read data into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>amount of data to read in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bytesRead</td><td>If non-NULL, the location to store the number of bytes actually read into the buffer. If NULL, this parameter will be ignored. In callback mode, NULL could be passed in for this parameter, since the callback function will be passed the number of bytes read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status indicating success or failure of the read.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#ga101b7761f89b3ec49f0c6726669acfed" title="Successful status code returned by UART APIs. ">UART_STATUS_SUCCESS</a></td><td>The call was successful. </td></tr>
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#gaa658b16955ceabc4e33e31cab6444b3e" title="The UART is currently in use. ">UART_STATUS_EINUSE</a></td><td>Another read from the UART is currently ongoing. </td></tr>
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#ga69975d5ab5731732cb732df574ca11e2" title="A UART_write() or UART_read() operation was cancelled. ">UART_STATUS_ECANCELLED</a></td><td>In <a class="el" href="group___u_a_r_t.html#gga2507a620dba95cd20885c52494d19e90a09c2d5349786d1199eb87dc040f3d724">UART_Mode_BLOCKING</a>, the read was canceled by a call to <a class="el" href="group___u_a_r_t.html#ga51ed7e94d5b409ca1fcb2d65c5a25c3c" title="Function that cancels a UART_read() function call. ">UART_readCancel()</a> before any data could be received. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabd06c63ea82f6caf04319487253f41e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd06c63ea82f6caf04319487253f41e4">&sect;&nbsp;</a></span>UART_writeFullFeatured()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t UART_writeFullFeatured </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#gab69886c7119a5054a972d8c735f15928">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>bytesWritten</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART write that only supports buffered and callback mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>UART_Handle instance from <a class="el" href="group___u_a_r_t.html#gab6d1d6b7b1f9922484f9b8a0f78ed030" title="Function to initialize a given UART peripheral. ">UART_open()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>location to write data from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>amount of data to write in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bytesWritten</td><td>If non-NULL, the location to store the number of bytes actually written into the buffer. If NULL, this parameter will be ignored. In callback mode, NULL could be passed in for this parameter, since the callback function will be passed the number of bytes written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status indicating success or failure of the write.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#ga101b7761f89b3ec49f0c6726669acfed" title="Successful status code returned by UART APIs. ">UART_STATUS_SUCCESS</a></td><td>The call was successful. </td></tr>
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t___s_t_a_t_u_s.html#gaa658b16955ceabc4e33e31cab6444b3e" title="The UART is currently in use. ">UART_STATUS_EINUSE</a></td><td>Another write to the UART is currently ongoing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">© Copyright 1995-2025</a>, Texas Instruments Incorporated. All rights reserved. <br/>
  <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
